--- valgrind-3.7.0/include/vki/vki-ppc64-linux.h.jj	2010-10-08 11:14:21.000000000 +0200
+++ valgrind-3.7.0/include/vki/vki-ppc64-linux.h	2012-01-27 16:45:19.418707191 +0100
@@ -386,6 +386,16 @@ struct vki_sigcontext {
 #define VKI_F_SETSIG        10      /*  for sockets. */
 #define VKI_F_GETSIG        11      /*  for sockets. */
 
+#define VKI_F_SETOWN_EX		15
+#define VKI_F_GETOWN_EX		16
+
+struct vki_f_owner_ex
+{
+  enum { VKI_F_OWNER_TID, VKI_F_OWNER_PID, VKI_F_OWNER_PGRP }
+    type;			/* Owner type of ID.  */
+  __vki_kernel_pid_t pid;	/* ID of owner.  */
+};
+
 /* for F_[GET|SET]FL */
 #define VKI_FD_CLOEXEC  1  /* actually anything with low bit set goes */
 
--- valgrind-3.7.0/include/vki/vki-arm-linux.h.jj	2011-03-28 16:09:17.000000000 +0200
+++ valgrind-3.7.0/include/vki/vki-arm-linux.h	2012-01-27 16:44:48.356887209 +0100
@@ -270,6 +270,16 @@ struct vki_sigcontext {
 #define VKI_F_SETLK64		13
 #define VKI_F_SETLKW64		14
 
+#define VKI_F_SETOWN_EX		15
+#define VKI_F_GETOWN_EX		16
+
+struct vki_f_owner_ex
+{
+  enum { VKI_F_OWNER_TID, VKI_F_OWNER_PID, VKI_F_OWNER_PGRP }
+    type;			/* Owner type of ID.  */
+  __vki_kernel_pid_t pid;	/* ID of owner.  */
+};
+
 /* for F_[GET|SET]FL */
 #define VKI_FD_CLOEXEC	1	/* actually anything with low bit set goes */
 
--- valgrind-3.7.0/include/vki/vki-x86-linux.h.jj	2010-10-08 11:14:21.000000000 +0200
+++ valgrind-3.7.0/include/vki/vki-x86-linux.h	2012-01-27 16:43:45.727249836 +0100
@@ -308,6 +308,16 @@ struct vki_sigcontext {
 #define VKI_F_SETLK64		13
 #define VKI_F_SETLKW64		14
 
+#define VKI_F_SETOWN_EX		15
+#define VKI_F_GETOWN_EX		16
+
+struct vki_f_owner_ex
+{
+  enum { VKI_F_OWNER_TID, VKI_F_OWNER_PID, VKI_F_OWNER_PGRP }
+    type;			/* Owner type of ID.  */
+  __vki_kernel_pid_t pid;	/* ID of owner.  */
+};
+
 /* for F_[GET|SET]FL */
 #define VKI_FD_CLOEXEC	1	/* actually anything with low bit set goes */
 
--- valgrind-3.7.0/include/vki/vki-ppc32-linux.h.jj	2010-10-08 11:14:21.000000000 +0200
+++ valgrind-3.7.0/include/vki/vki-ppc32-linux.h	2012-01-27 16:45:11.912752106 +0100
@@ -337,6 +337,16 @@ struct vki_sigcontext {
 #define VKI_F_SETLK64		13
 #define VKI_F_SETLKW64		14
 
+#define VKI_F_SETOWN_EX		15
+#define VKI_F_GETOWN_EX		16
+
+struct vki_f_owner_ex
+{
+  enum { VKI_F_OWNER_TID, VKI_F_OWNER_PID, VKI_F_OWNER_PGRP }
+    type;			/* Owner type of ID.  */
+  __vki_kernel_pid_t pid;	/* ID of owner.  */
+};
+
 /* for F_[GET|SET]FL */
 #define VKI_FD_CLOEXEC	 1		/* actually anything with low bit set goes */
 
--- valgrind-3.7.0/include/vki/vki-s390x-linux.h.jj	2011-06-08 17:26:29.000000000 +0200
+++ valgrind-3.7.0/include/vki/vki-s390x-linux.h	2012-01-27 16:45:31.078639504 +0100
@@ -332,6 +332,16 @@ typedef struct vki_sigaltstack {
 #define VKI_F_SETSIG	10	/* for sockets. */
 #define VKI_F_GETSIG	11	/* for sockets. */
 
+#define VKI_F_SETOWN_EX		15
+#define VKI_F_GETOWN_EX		16
+
+struct vki_f_owner_ex
+{
+  enum { VKI_F_OWNER_TID, VKI_F_OWNER_PID, VKI_F_OWNER_PGRP }
+    type;			/* Owner type of ID.  */
+  __vki_kernel_pid_t pid;	/* ID of owner.  */
+};
+
 #define VKI_FD_CLOEXEC  1  /* actually anything with low bit set goes */
 
 #define VKI_F_LINUX_SPECIFIC_BASE   1024
--- valgrind-3.7.0/include/vki/vki-amd64-linux.h.jj	2010-10-08 11:14:21.000000000 +0200
+++ valgrind-3.7.0/include/vki/vki-amd64-linux.h	2012-01-27 16:44:23.592030914 +0100
@@ -268,6 +268,16 @@ struct vki_sigcontext {
 #define VKI_F_SETSIG		10	/*  for sockets. */
 #define VKI_F_GETSIG		11	/*  for sockets. */
 
+#define VKI_F_SETOWN_EX		15
+#define VKI_F_GETOWN_EX		16
+
+struct vki_f_owner_ex
+{
+  enum { VKI_F_OWNER_TID, VKI_F_OWNER_PID, VKI_F_OWNER_PGRP }
+    type;			/* Owner type of ID.  */
+  __vki_kernel_pid_t pid;	/* ID of owner.  */
+};
+
 #define VKI_FD_CLOEXEC	1	/* actually anything with low bit set goes */
 
 #define VKI_F_LINUX_SPECIFIC_BASE	1024
--- valgrind-3.7.0/coregrind/m_syswrap/syswrap-linux.c.jj	2011-08-02 14:49:29.000000000 +0200
+++ valgrind-3.7.0/coregrind/m_syswrap/syswrap-linux.c	2012-01-27 17:08:11.621732289 +0100
@@ -3778,6 +3778,22 @@ PRE(sys_fcntl)
                     struct flock64 *, lock);
       break;
 
+   case VKI_F_SETOWN_EX:
+      PRINT("sys_fcntl[F_SETOWN_EX] ( %ld, %ld, %ld )", ARG1,ARG2,ARG3);
+      PRE_REG_READ3(long, "fcntl",
+                    unsigned int, fd, unsigned int, cmd,
+                    struct vki_f_owner_ex *, arg);
+      PRE_MEM_READ("fcntl(F_SETOWN_EX)", ARG3, sizeof(struct vki_f_owner_ex));
+      break;
+
+   case VKI_F_GETOWN_EX:
+      PRINT("sys_fcntl[F_GETOWN_EX] ( %ld, %ld, %ld )", ARG1,ARG2,ARG3);
+      PRE_REG_READ3(long, "fcntl",
+                    unsigned int, fd, unsigned int, cmd,
+                    struct vki_f_owner_ex *, arg);
+      PRE_MEM_WRITE("fcntl(F_GETOWN_EX)", ARG3, sizeof(struct vki_f_owner_ex));
+      break;
+
    default:
       PRINT("sys_fcntl[UNKNOWN] ( %ld, %ld, %ld )", ARG1,ARG2,ARG3);
       I_die_here;
@@ -3812,6 +3828,8 @@ POST(sys_fcntl)
          if (VG_(clo_track_fds))
             ML_(record_fd_open_named)(tid, RES);
       }
+   } else if (ARG2 == VKI_F_GETOWN_EX) {
+      POST_MEM_WRITE(ARG3, sizeof(struct vki_f_owner_ex));
    }
 }
 
@@ -3857,6 +3875,22 @@ PRE(sys_fcntl64)
                     unsigned int, fd, unsigned int, cmd,
                     struct flock64 *, lock);
       break;
+
+   case VKI_F_SETOWN_EX:
+      PRINT("sys_fcntl[F_SETOWN_EX] ( %ld, %ld, %ld )", ARG1,ARG2,ARG3);
+      PRE_REG_READ3(long, "fcntl",
+                    unsigned int, fd, unsigned int, cmd,
+                    struct vki_f_owner_ex *, arg);
+      PRE_MEM_READ("fcntl(F_SETOWN_EX)", ARG3, sizeof(struct vki_f_owner_ex));
+      break;
+
+   case VKI_F_GETOWN_EX:
+      PRINT("sys_fcntl[F_GETOWN_EX] ( %ld, %ld, %ld )", ARG1,ARG2,ARG3);
+      PRE_REG_READ3(long, "fcntl",
+                    unsigned int, fd, unsigned int, cmd,
+                    struct vki_f_owner_ex *, arg);
+      PRE_MEM_WRITE("fcntl(F_GETOWN_EX)", ARG3, sizeof(struct vki_f_owner_ex));
+      break;
    }
    
 #  if defined(VGP_x86_linux)
@@ -3887,6 +3921,8 @@ POST(sys_fcntl64)
          if (VG_(clo_track_fds))
             ML_(record_fd_open_named)(tid, RES);
       }
+   } else if (ARG2 == VKI_F_GETOWN_EX) {
+      POST_MEM_WRITE(ARG3, sizeof(struct vki_f_owner_ex));
    }
 }
 
