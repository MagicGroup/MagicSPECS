To: vim_dev@googlegroups.com
Subject: Patch 7.4.212
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.212 (after 7.4.200)
Problem:    Now that the +visual feature is always enabled the #ifdefs for it
	    are not useful.
Solution:   Remove the checks for FEAT_VISUAL.
Files:	    src/buffer.c, src/charset.c, src/edit.c, src/eval.c,
	    src/ex_cmds.c, src/ex_docmd.c, src/fold.c, src/getchar.c,
	    src/gui.c, src/gui_mac.c, src/gui_w48.c, src/main.c, src/mark.c,
	    src/menu.c, src/misc2.c, src/move.c, src/netbeans.c, src/normal.c,
	    src/ops.c, src/option.c, src/os_msdos.c, src/os_qnx.c,
	    src/quickfix.c, src/regexp.c, src/regexp_nfa.c, src/screen.c,
	    src/search.c, src/spell.c, src/syntax.c, src/term.c, src/ui.c,
	    src/undo.c, src/version.c, src/window.c, src/feature.h,
	    src/globals.h, src/option.h, src/os_win32.h, src/structs.h


*** ../vim-7.4.211/src/buffer.c	2014-03-12 18:55:52.100906804 +0100
--- src/buffer.c	2014-03-23 13:01:39.843144050 +0100
***************
*** 1432,1441 ****
  	curwin->w_alt_fnum = curbuf->b_fnum; /* remember alternate file */
      buflist_altfpos(curwin);			 /* remember curpos */
  
- #ifdef FEAT_VISUAL
      /* Don't restart Select mode after switching to another buffer. */
      VIsual_reselect = FALSE;
- #endif
  
      /* close_windows() or apply_autocmds() may change curbuf */
      prevbuf = curbuf;
--- 1432,1439 ----
*** ../vim-7.4.211/src/charset.c	2013-02-06 16:20:01.000000000 +0100
--- src/charset.c	2014-03-23 13:02:19.467144657 +0100
***************
*** 1380,1389 ****
  		&& (State & NORMAL)
  		&& !wp->w_p_list
  		&& !virtual_active()
! #ifdef FEAT_VISUAL
! 		&& !(VIsual_active
! 				   && (*p_sel == 'e' || ltoreq(*pos, VIsual)))
! #endif
  		)
  	    *cursor = vcol + incr - 1;	    /* cursor at end */
  	else
--- 1380,1386 ----
  		&& (State & NORMAL)
  		&& !wp->w_p_list
  		&& !virtual_active()
! 		&& !(VIsual_active && (*p_sel == 'e' || ltoreq(*pos, VIsual)))
  		)
  	    *cursor = vcol + incr - 1;	    /* cursor at end */
  	else
***************
*** 1463,1469 ****
  }
  #endif
  
- #if defined(FEAT_VISUAL) || defined(PROTO)
  /*
   * Get the leftmost and rightmost virtual column of pos1 and pos2.
   * Used for Visual block mode.
--- 1460,1465 ----
***************
*** 1500,1506 ****
      else
  	*right = to1;
  }
- #endif
  
  /*
   * skipwhite: skip over ' ' and '\t'.
--- 1496,1501 ----
*** ../vim-7.4.211/src/edit.c	2014-02-22 23:03:48.712901208 +0100
--- src/edit.c	2014-03-23 13:03:11.951145462 +0100
***************
*** 220,228 ****
  #ifdef FEAT_RIGHTLEFT
  static void ins_ctrl_ __ARGS((void));
  #endif
- #ifdef FEAT_VISUAL
  static int ins_start_select __ARGS((int c));
- #endif
  static void ins_insert __ARGS((int replaceState));
  static void ins_ctrl_o __ARGS((void));
  static void ins_shift __ARGS((int c, int lastc));
--- 220,226 ----
***************
*** 932,938 ****
  	    }
  #endif
  
- #ifdef FEAT_VISUAL
  	/*
  	 * If 'keymodel' contains "startsel", may start selection.  If it
  	 * does, a CTRL-O and c will be stuffed, we need to get these
--- 930,935 ----
***************
*** 940,946 ****
  	 */
  	if (ins_start_select(c))
  	    continue;
- #endif
  
  	/*
  	 * The big switch to handle a character in insert mode.
--- 937,942 ----
***************
*** 6900,6906 ****
  	    else if (cc != NUL)
  		++curwin->w_cursor.col;	/* put cursor back on the NUL */
  
- #ifdef FEAT_VISUAL
  	    /* <C-S-Right> may have started Visual mode, adjust the position for
  	     * deleted characters. */
  	    if (VIsual_active && VIsual.lnum == curwin->w_cursor.lnum)
--- 6896,6901 ----
***************
*** 6910,6921 ****
  		if (VIsual.col > len)
  		{
  		    VIsual.col = len;
! # ifdef FEAT_VIRTUALEDIT
  		    VIsual.coladd = 0;
! # endif
  		}
  	    }
- #endif
  	}
      }
      did_ai = FALSE;
--- 6905,6915 ----
  		if (VIsual.col > len)
  		{
  		    VIsual.col = len;
! #ifdef FEAT_VIRTUALEDIT
  		    VIsual.coladd = 0;
! #endif
  		}
  	    }
  	}
      }
      did_ai = FALSE;
***************
*** 8112,8120 ****
      int		need_redraw = FALSE;
      int		regname;
      int		literally = 0;
- #ifdef FEAT_VISUAL
      int		vis_active = VIsual_active;
- #endif
  
      /*
       * If we are going to wait for a character, show a '"'.
--- 8106,8112 ----
***************
*** 8218,8228 ****
      if (need_redraw || stuff_empty())
  	edit_unputchar();
  
- #ifdef FEAT_VISUAL
      /* Disallow starting Visual mode here, would get a weird mode. */
      if (!vis_active && VIsual_active)
  	end_visual_mode();
- #endif
  }
  
  /*
--- 8210,8218 ----
***************
*** 8419,8429 ****
  #endif
  	       )
  	    && (restart_edit == NUL
! 		   || (gchar_cursor() == NUL
! #ifdef FEAT_VISUAL
! 		       && !VIsual_active
! #endif
! 		      ))
  #ifdef FEAT_RIGHTLEFT
  	    && !revins_on
  #endif
--- 8409,8415 ----
  #endif
  	       )
  	    && (restart_edit == NUL
! 		   || (gchar_cursor() == NUL && !VIsual_active))
  #ifdef FEAT_RIGHTLEFT
  	    && !revins_on
  #endif
***************
*** 8525,8531 ****
  }
  #endif
  
- #ifdef FEAT_VISUAL
  /*
   * If 'keymodel' contains "startsel", may start selection.
   * Returns TRUE when a CTRL-O and other keys stuffed.
--- 8511,8516 ----
***************
*** 8581,8587 ****
  	}
      return FALSE;
  }
- #endif
  
  /*
   * <Insert> key in Insert mode: toggle insert/replace mode.
--- 8566,8571 ----
*** ../vim-7.4.211/src/eval.c	2014-02-24 03:31:55.816738026 +0100
--- src/eval.c	2014-03-23 13:03:56.419146143 +0100
***************
*** 11833,11844 ****
      {
  	case MLINE: buf[0] = 'V'; break;
  	case MCHAR: buf[0] = 'v'; break;
- #ifdef FEAT_VISUAL
  	case MBLOCK:
  		buf[0] = Ctrl_V;
  		sprintf((char *)buf + 1, "%ld", reglen + 1);
  		break;
- #endif
      }
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = vim_strsave(buf);
--- 11833,11842 ----
***************
*** 12552,12560 ****
  #ifdef FEAT_VIRTUALEDIT
  	"virtualedit",
  #endif
- #ifdef FEAT_VISUAL
  	"visual",
- #endif
  #ifdef FEAT_VISUALEXTRA
  	"visualextra",
  #endif
--- 12550,12556 ----
***************
*** 14397,14403 ****
      buf[1] = NUL;
      buf[2] = NUL;
  
- #ifdef FEAT_VISUAL
      if (VIsual_active)
      {
  	if (VIsual_select)
--- 14393,14398 ----
***************
*** 14405,14413 ****
  	else
  	    buf[0] = VIsual_mode;
      }
!     else
! #endif
! 	if (State == HITRETURN || State == ASKMORE || State == SETWSIZE
  		|| State == CONFIRM)
      {
  	buf[0] = 'r';
--- 14400,14406 ----
  	else
  	    buf[0] = VIsual_mode;
      }
!     else if (State == HITRETURN || State == ASKMORE || State == SETWSIZE
  		|| State == CONFIRM)
      {
  	buf[0] = 'r';
***************
*** 16756,16762 ****
  		case 'V': case 'l':	/* line-wise selection */
  		    yank_type = MLINE;
  		    break;
- #ifdef FEAT_VISUAL
  		case 'b': case Ctrl_V:	/* block-wise selection */
  		    yank_type = MBLOCK;
  		    if (VIM_ISDIGIT(stropt[1]))
--- 16749,16754 ----
***************
*** 16766,16772 ****
  			--stropt;
  		    }
  		    break;
- #endif
  	    }
      }
  
--- 16758,16763 ----
***************
*** 18769,18775 ****
      typval_T	*argvars UNUSED;
      typval_T	*rettv UNUSED;
  {
- #ifdef FEAT_VISUAL
      char_u	str[2];
  
      rettv->v_type = VAR_STRING;
--- 18760,18765 ----
***************
*** 18780,18786 ****
      /* A non-zero number or non-empty string argument: reset mode. */
      if (non_zero_arg(&argvars[0]))
  	curbuf->b_visual_mode_eval = NUL;
- #endif
  }
  
  /*
--- 18770,18775 ----
***************
*** 19154,19167 ****
  	return NULL;
      if (name[0] == '.')				/* cursor */
  	return &curwin->w_cursor;
- #ifdef FEAT_VISUAL
      if (name[0] == 'v' && name[1] == NUL)	/* Visual start */
      {
  	if (VIsual_active)
  	    return &VIsual;
  	return &curwin->w_cursor;
      }
- #endif
      if (name[0] == '\'')			/* mark */
      {
  	pp = getmark_buf_fnum(curbuf, name[1], FALSE, fnum);
--- 19143,19154 ----
*** ../vim-7.4.211/src/ex_cmds.c	2014-03-19 17:41:20.390105580 +0100
--- src/ex_cmds.c	2014-03-23 13:04:09.359146341 +0100
***************
*** 3274,3286 ****
  	goto theend;
      }
  
- #ifdef FEAT_VISUAL
      /*
       * End Visual mode before switching to another buffer, so the text can be
       * copied into the GUI selection buffer.
       */
      reset_VIsual();
- #endif
  
  #ifdef FEAT_AUTOCMD
      if ((command != NULL || newlnum > (linenr_T)0)
--- 3274,3284 ----
*** ../vim-7.4.211/src/ex_docmd.c	2014-03-12 21:28:09.481046816 +0100
--- src/ex_docmd.c	2014-03-23 13:04:47.975146933 +0100
***************
*** 8577,8586 ****
  	beginline(BL_SOL | BL_FIX);
      }
  
- #if defined(FEAT_VISUAL)
      if (VIsual_active)
  	end_visual_mode();
- #endif
  
      switch (eap->cmdidx)
      {
--- 8577,8584 ----
***************
*** 8991,9001 ****
      RedrawingDisabled = 0;
      p_lz = FALSE;
      update_topline();
!     update_screen(eap->forceit ? CLEAR :
! #ifdef FEAT_VISUAL
! 	    VIsual_active ? INVERTED :
! #endif
! 	    0);
  #ifdef FEAT_TITLE
      if (need_maketitle)
  	maketitle();
--- 8989,8995 ----
      RedrawingDisabled = 0;
      p_lz = FALSE;
      update_topline();
!     update_screen(eap->forceit ? CLEAR : VIsual_active ? INVERTED : 0);
  #ifdef FEAT_TITLE
      if (need_maketitle)
  	maketitle();
***************
*** 9030,9040 ****
  	status_redraw_all();
      else
  	status_redraw_curbuf();
!     update_screen(
! # ifdef FEAT_VISUAL
! 	    VIsual_active ? INVERTED :
! # endif
! 	    0);
      RedrawingDisabled = r;
      p_lz = p;
      out_flush();
--- 9024,9030 ----
  	status_redraw_all();
      else
  	status_redraw_curbuf();
!     update_screen(VIsual_active ? INVERTED : 0);
      RedrawingDisabled = r;
      p_lz = p;
      out_flush();
*** ../vim-7.4.211/src/fold.c	2013-11-05 07:12:59.000000000 +0100
--- src/fold.c	2014-03-23 13:05:14.775147344 +0100
***************
*** 430,440 ****
      }
      if (done == DONE_NOTHING)
  	EMSG(_(e_nofold));
- #ifdef FEAT_VISUAL
      /* Force a redraw to remove the Visual highlighting. */
      if (had_visual)
  	redraw_curbuf_later(INVERTED);
- #endif
  }
  
  /* openFold() {{{2 */
--- 430,438 ----
***************
*** 807,817 ****
      if (!did_one)
      {
  	EMSG(_(e_nofold));
- #ifdef FEAT_VISUAL
  	/* Force a redraw to remove the Visual highlighting. */
  	if (had_visual)
  	    redraw_curbuf_later(INVERTED);
- #endif
      }
      else
  	/* Deleting markers may make cursor column invalid. */
--- 805,813 ----
***************
*** 1065,1071 ****
  }
  
  /* foldAdjustVisual() {{{2 */
- #ifdef FEAT_VISUAL
  /*
   * Adjust the Visual area to include any fold at the start or end completely.
   */
--- 1061,1066 ----
***************
*** 1103,1109 ****
  #endif
      }
  }
- #endif
  
  /* cursor_foldstart() {{{2 */
  /*
--- 1098,1103 ----
*** ../vim-7.4.211/src/getchar.c	2014-03-12 20:17:47.748982126 +0100
--- src/getchar.c	2014-03-23 13:05:45.383147813 +0100
***************
*** 870,876 ****
  	c = read_redo(FALSE, old_redo);
      }
  
- #ifdef FEAT_VISUAL
      if (c == 'v')   /* redo Visual */
      {
  	VIsual = curwin->w_cursor;
--- 870,875 ----
***************
*** 880,886 ****
  	redo_VIsual_busy = TRUE;
  	c = read_redo(FALSE, old_redo);
      }
- #endif
  
      /* try to enter the count (in place of a previous count) */
      if (count)
--- 879,884 ----
***************
*** 1162,1168 ****
      return typebuf.tb_maplen == 0;
  }
  
- #if defined(FEAT_VISUAL) || defined(PROTO)
  /*
   * Return the number of characters that are mapped (or not typed).
   */
--- 1160,1165 ----
***************
*** 1171,1177 ****
  {
      return typebuf.tb_maplen;
  }
- #endif
  
  /*
   * remove "len" characters from typebuf.tb_buf[typebuf.tb_off + offset]
--- 1168,1173 ----
***************
*** 2443,2449 ****
  				idx = get_menu_index(current_menu, local_State);
  				if (idx != MENU_INDEX_INVALID)
  				{
- # ifdef FEAT_VISUAL
  				    /*
  				     * In Select mode and a Visual mode menu
  				     * is used:  Switch to Visual mode
--- 2439,2444 ----
***************
*** 2457,2463 ****
  					(void)ins_typebuf(K_SELECT_STRING,
  						  REMAP_NONE, 0, TRUE, FALSE);
  				    }
- # endif
  				    ins_typebuf(current_menu->strings[idx],
  						current_menu->noremap[idx],
  						0, TRUE,
--- 2452,2457 ----
***************
*** 2516,2522 ****
  			    break;
  			}
  
- #ifdef FEAT_VISUAL
  			/*
  			 * In Select mode and a Visual mode mapping is used:
  			 * Switch to Visual mode temporarily.  Append K_SELECT
--- 2510,2515 ----
***************
*** 2529,2535 ****
  			    (void)ins_typebuf(K_SELECT_STRING, REMAP_NONE,
  							      0, TRUE, FALSE);
  			}
- #endif
  
  #ifdef FEAT_EVAL
  			/* Copy the values from *mp that are used, because
--- 2522,2527 ----
*** ../vim-7.4.211/src/gui.c	2013-06-30 17:41:48.000000000 +0200
--- src/gui.c	2014-03-23 13:05:57.623148000 +0100
***************
*** 3132,3142 ****
       */
      if (!mouse_has(checkfor) || checkfor == MOUSE_COMMAND)
      {
- #ifdef FEAT_VISUAL
  	/* Don't do modeless selection in Visual mode. */
  	if (checkfor != MOUSE_NONEF && VIsual_active && (State & NORMAL))
  	    return;
- #endif
  
  	/*
  	 * When 'mousemodel' is "popup", shift-left is translated to right.
--- 3132,3140 ----
*** ../vim-7.4.211/src/gui_mac.c	2013-05-06 04:06:04.000000000 +0200
--- src/gui_mac.c	2014-03-23 13:06:30.143148498 +0100
***************
*** 1068,1078 ****
      }
   */
  
- 
- #ifdef FEAT_VISUAL
      reset_VIsual();
- #endif
- 
      fnames = new_fnames_from_AEDesc(&theList, &numFiles, &error);
  
      if (error)
--- 1068,1074 ----
***************
*** 1142,1148 ****
  
      /* Update the screen display */
      update_screen(NOT_VALID);
! #ifdef FEAT_VISUAL
      /* Select the text if possible */
      if (gotPosition)
      {
--- 1138,1144 ----
  
      /* Update the screen display */
      update_screen(NOT_VALID);
! 
      /* Select the text if possible */
      if (gotPosition)
      {
***************
*** 1160,1166 ****
  	    VIsual.col = 0;
  	}
      }
! #endif
      setcursor();
      out_flush();
  
--- 1156,1162 ----
  	    VIsual.col = 0;
  	}
      }
! 
      setcursor();
      out_flush();
  
*** ../vim-7.4.211/src/gui_w48.c	2014-03-19 12:37:18.537826062 +0100
--- src/gui_w48.c	2014-03-23 13:06:44.959148725 +0100
***************
*** 3708,3716 ****
      DragQueryPoint(hDrop, &pt);
      MapWindowPoints(s_hwnd, s_textArea, &pt, 1);
  
- # ifdef FEAT_VISUAL
      reset_VIsual();
- # endif
  
      fnames = (char_u **)alloc(cFiles * sizeof(char_u *));
  
--- 3708,3714 ----
*** ../vim-7.4.211/src/main.c	2014-01-14 12:57:00.000000000 +0100
--- src/main.c	2014-03-23 13:07:21.771149289 +0100
***************
*** 1057,1065 ****
      if (!cmdwin && !noexmode && SETJMP(x_jump_env))
      {
  	State = NORMAL;
- # ifdef FEAT_VISUAL
  	VIsual_active = FALSE;
- # endif
  	got_int = TRUE;
  	need_wait_return = FALSE;
  	global_busy = FALSE;
--- 1057,1063 ----
***************
*** 1096,1106 ****
  		check_timestamps(FALSE);
  	    if (need_wait_return)	/* if wait_return still needed ... */
  		wait_return(FALSE);	/* ... call it now */
! 	    if (need_start_insertmode && goto_im()
! #ifdef FEAT_VISUAL
! 		    && !VIsual_active
! #endif
! 		    )
  	    {
  		need_start_insertmode = FALSE;
  		stuffReadbuff((char_u *)"i");	/* start insert mode next */
--- 1094,1100 ----
  		check_timestamps(FALSE);
  	    if (need_wait_return)	/* if wait_return still needed ... */
  		wait_return(FALSE);	/* ... call it now */
! 	    if (need_start_insertmode && goto_im() && !VIsual_active)
  	    {
  		need_start_insertmode = FALSE;
  		stuffReadbuff((char_u *)"i");	/* start insert mode next */
***************
*** 1202,1208 ****
  		diff_need_scrollbind = FALSE;
  	    }
  #endif
! #if defined(FEAT_FOLDING) && defined(FEAT_VISUAL)
  	    /* Include a closed fold completely in the Visual area. */
  	    foldAdjustVisual();
  #endif
--- 1196,1202 ----
  		diff_need_scrollbind = FALSE;
  	    }
  #endif
! #if defined(FEAT_FOLDING)
  	    /* Include a closed fold completely in the Visual area. */
  	    foldAdjustVisual();
  #endif
***************
*** 1228,1239 ****
  	    update_topline();
  	    validate_cursor();
  
- #ifdef FEAT_VISUAL
  	    if (VIsual_active)
  		update_curbuf(INVERTED);/* update inverted part */
! 	    else
! #endif
! 		if (must_redraw)
  		update_screen(0);
  	    else if (redraw_cmdline || clear_cmdline)
  		showmode();
--- 1222,1230 ----
  	    update_topline();
  	    validate_cursor();
  
  	    if (VIsual_active)
  		update_curbuf(INVERTED);/* update inverted part */
! 	    else if (must_redraw)
  		update_screen(0);
  	    else if (redraw_cmdline || clear_cmdline)
  		showmode();
*** ../vim-7.4.211/src/mark.c	2013-11-03 00:20:46.000000000 +0100
--- src/mark.c	2014-03-23 13:08:03.011149921 +0100
***************
*** 98,104 ****
  	return OK;
      }
  
- #ifdef FEAT_VISUAL
      if (c == '<' || c == '>')
      {
  	if (c == '<')
--- 98,103 ----
***************
*** 110,116 ****
  	    curbuf->b_visual.vi_mode = 'v';
  	return OK;
      }
- #endif
  
  #ifndef EBCDIC
      if (c > 'z')	    /* some islower() and isupper() cannot handle
--- 109,114 ----
***************
*** 340,348 ****
      int		*fnum;
  {
      pos_T		*posp;
- #ifdef FEAT_VISUAL
      pos_T		*startp, *endp;
- #endif
      static pos_T	pos_copy;
  
      posp = NULL;
--- 338,344 ----
***************
*** 403,409 ****
  	curwin->w_cursor = pos;
  	listcmd_busy = slcb;
      }
- #ifdef FEAT_VISUAL
      else if (c == '<' || c == '>')	/* start/end of visual area */
      {
  	startp = &buf->b_visual.vi_start;
--- 399,404 ----
***************
*** 428,434 ****
  #endif
  	}
      }
- #endif
      else if (ASCII_ISLOWER(c))		/* normal named mark */
      {
  	posp = &(buf->b_namedm[c - 'a']);
--- 423,428 ----
***************
*** 757,766 ****
      show_one_mark(']', arg, &curbuf->b_op_end, NULL, TRUE);
      show_one_mark('^', arg, &curbuf->b_last_insert, NULL, TRUE);
      show_one_mark('.', arg, &curbuf->b_last_change, NULL, TRUE);
- #ifdef FEAT_VISUAL
      show_one_mark('<', arg, &curbuf->b_visual.vi_start, NULL, TRUE);
      show_one_mark('>', arg, &curbuf->b_visual.vi_end, NULL, TRUE);
- #endif
      show_one_mark(-1, arg, NULL, NULL, FALSE);
  }
  
--- 751,758 ----
***************
*** 892,901 ****
  		    case '.': curbuf->b_last_change.lnum = 0; break;
  		    case '[': curbuf->b_op_start.lnum    = 0; break;
  		    case ']': curbuf->b_op_end.lnum      = 0; break;
- #ifdef FEAT_VISUAL
  		    case '<': curbuf->b_visual.vi_start.lnum = 0; break;
  		    case '>': curbuf->b_visual.vi_end.lnum   = 0; break;
- #endif
  		    case ' ': break;
  		    default:  EMSG2(_(e_invarg2), p);
  			      return;
--- 884,891 ----
***************
*** 1085,1095 ****
  	    one_adjust_nodel(&(curbuf->b_changelist[i].lnum));
  #endif
  
- #ifdef FEAT_VISUAL
  	/* Visual area */
  	one_adjust_nodel(&(curbuf->b_visual.vi_start.lnum));
  	one_adjust_nodel(&(curbuf->b_visual.vi_end.lnum));
- #endif
  
  #ifdef FEAT_QUICKFIX
  	/* quickfix marks */
--- 1075,1083 ----
***************
*** 1136,1149 ****
  		    if (win->w_tagstack[i].fmark.fnum == fnum)
  			one_adjust_nodel(&(win->w_tagstack[i].fmark.mark.lnum));
  
- #ifdef FEAT_VISUAL
  	    /* the displayed Visual area */
  	    if (win->w_old_cursor_lnum != 0)
  	    {
  		one_adjust_nodel(&(win->w_old_cursor_lnum));
  		one_adjust_nodel(&(win->w_old_visual_lnum));
  	    }
- #endif
  
  	    /* topline and cursor position for windows with the same buffer
  	     * other than the current window */
--- 1124,1135 ----
***************
*** 1260,1270 ****
  	col_adjust(&(curbuf->b_changelist[i]));
  #endif
  
- #ifdef FEAT_VISUAL
      /* Visual area */
      col_adjust(&(curbuf->b_visual.vi_start));
      col_adjust(&(curbuf->b_visual.vi_end));
- #endif
  
      /* previous context mark */
      col_adjust(&(curwin->w_pcmark));
--- 1246,1254 ----
*** ../vim-7.4.211/src/menu.c	2011-04-11 15:17:21.000000000 +0200
--- src/menu.c	2014-03-23 13:08:19.091150168 +0100
***************
*** 1640,1646 ****
  	idx = MENU_INDEX_INSERT;
      else if (state & CMDLINE)
  	idx = MENU_INDEX_CMDLINE;
- #ifdef FEAT_VISUAL
      else if (VIsual_active)
      {
  	if (VIsual_select)
--- 1640,1645 ----
***************
*** 1648,1654 ****
  	else
  	    idx = MENU_INDEX_VISUAL;
      }
- #endif
      else if (state == HITRETURN || state == ASKMORE)
  	idx = MENU_INDEX_CMDLINE;
      else if (finish_op)
--- 1647,1652 ----
***************
*** 1811,1824 ****
      static int
  get_menu_mode()
  {
- #ifdef FEAT_VISUAL
      if (VIsual_active)
      {
  	if (VIsual_select)
  	    return MENU_INDEX_SELECT;
  	return MENU_INDEX_VISUAL;
      }
- #endif
      if (State & INSERT)
  	return MENU_INDEX_INSERT;
      if ((State & CMDLINE) || State == ASKMORE || State == HITRETURN)
--- 1809,1820 ----
*** ../vim-7.4.211/src/misc2.c	2014-02-23 23:38:58.824760280 +0100
--- src/misc2.c	2014-03-23 13:08:56.927150748 +0100
***************
*** 31,39 ****
      if (virtual_op != MAYBE)
  	return virtual_op;
      return (ve_flags == VE_ALL
- # ifdef FEAT_VISUAL
  	    || ((ve_flags & VE_BLOCK) && VIsual_active && VIsual_mode == Ctrl_V)
- # endif
  	    || ((ve_flags & VE_INSERT) && (State & INSERT)));
  }
  
--- 31,37 ----
***************
*** 149,157 ****
  
      one_more = (State & INSERT)
  		    || restart_edit != NUL
- #ifdef FEAT_VISUAL
  		    || (VIsual_active && *p_sel != 'o')
- #endif
  #ifdef FEAT_VIRTUALEDIT
  		    || ((ve_flags & VE_ONEMORE) && wcol < MAXCOL)
  #endif
--- 147,153 ----
***************
*** 570,578 ****
  	 * - in Visual mode and 'selection' isn't "old"
  	 * - 'virtualedit' is set */
  	if ((State & INSERT) || restart_edit
- #ifdef FEAT_VISUAL
  		|| (VIsual_active && *p_sel != 'o')
- #endif
  #ifdef FEAT_VIRTUALEDIT
  		|| (ve_flags & VE_ONEMORE)
  #endif
--- 566,572 ----
***************
*** 627,635 ****
  adjust_cursor_col()
  {
      if (curwin->w_cursor.col > 0
- # ifdef FEAT_VISUAL
  	    && (!VIsual_active || *p_sel == 'o')
- # endif
  	    && gchar_cursor() == NUL)
  	--curwin->w_cursor.col;
  }
--- 621,627 ----
***************
*** 3290,3306 ****
  {
      if (State & NORMAL)
      {
- #ifdef FEAT_VISUAL
  	if (VIsual_active)
  	{
  	    if (VIsual_select)
  		return SELECTMODE;
  	    return VISUAL;
  	}
! 	else
! #endif
! 	    if (finish_op)
! 		return OP_PENDING;
      }
      return State;
  }
--- 3282,3295 ----
  {
      if (State & NORMAL)
      {
  	if (VIsual_active)
  	{
  	    if (VIsual_select)
  		return SELECTMODE;
  	    return VISUAL;
  	}
! 	else if (finish_op)
! 	    return OP_PENDING;
      }
      return State;
  }
***************
*** 3738,3744 ****
      }
      if (finish_op)
  	return SHAPE_IDX_O;
- #ifdef FEAT_VISUAL
      if (VIsual_active)
      {
  	if (*p_sel == 'e')
--- 3727,3732 ----
***************
*** 3746,3752 ****
  	else
  	    return SHAPE_IDX_V;
      }
- #endif
      return SHAPE_IDX_N;
  }
  #endif
--- 3734,3739 ----
*** ../vim-7.4.211/src/move.c	2014-02-11 18:58:05.102320947 +0100
--- src/move.c	2014-03-23 13:09:16.535151048 +0100
***************
*** 2857,2873 ****
      win_T	*old_curwin = curwin;
      buf_T	*old_curbuf = curbuf;
      int		restart_edit_save;
- # ifdef FEAT_VISUAL
      int		old_VIsual_select = VIsual_select;
      int		old_VIsual_active = VIsual_active;
- # endif
  
      /*
       * loop through the cursorbound windows
       */
- # ifdef FEAT_VISUAL
      VIsual_select = VIsual_active = 0;
- # endif
      for (curwin = firstwin; curwin; curwin = curwin->w_next)
      {
  	curbuf = curwin->w_buffer;
--- 2857,2869 ----
***************
*** 2916,2925 ****
      /*
       * reset current-window
       */
- # ifdef FEAT_VISUAL
      VIsual_select = old_VIsual_select;
      VIsual_active = old_VIsual_active;
- # endif
      curwin = old_curwin;
      curbuf = old_curbuf;
  }
--- 2912,2919 ----
*** ../vim-7.4.211/src/netbeans.c	2012-06-20 19:56:18.000000000 +0200
--- src/netbeans.c	2014-03-23 13:09:29.163151241 +0100
***************
*** 2232,2242 ****
  
  	    nb_set_curbuf(buf->bufp);
  
- #ifdef FEAT_VISUAL
  	    /* Don't want Visual mode now. */
  	    if (VIsual_active)
  		end_visual_mode();
- #endif
  #ifdef NBDEBUG
  	    s = args;
  #endif
--- 2232,2240 ----
*** ../vim-7.4.211/src/normal.c	2014-03-12 17:41:59.128838878 +0100
--- src/normal.c	2014-03-23 15:07:40.435259900 +0100
***************
*** 14,20 ****
  
  #include "vim.h"
  
- #ifdef FEAT_VISUAL
  /*
   * The Visual area is remembered for reselection.
   */
--- 14,19 ----
***************
*** 24,30 ****
  static int	VIsual_mode_orig = NUL;		/* saved Visual mode */
  
  static int	restart_VIsual_select = 0;
- #endif
  
  #ifdef FEAT_EVAL
  static void	set_vcount_ca __ARGS((cmdarg_T *cap, int *set_prevcount));
--- 23,28 ----
***************
*** 37,43 ****
  static int	find_command __ARGS((int cmdchar));
  static void	op_colon __ARGS((oparg_T *oap));
  static void	op_function __ARGS((oparg_T *oap));
! #if defined(FEAT_MOUSE) && defined(FEAT_VISUAL)
  static void	find_start_of_word __ARGS((pos_T *));
  static void	find_end_of_word __ARGS((pos_T *));
  static int	get_mouse_class __ARGS((char_u *p));
--- 35,41 ----
  static int	find_command __ARGS((int cmdchar));
  static void	op_colon __ARGS((oparg_T *oap));
  static void	op_function __ARGS((oparg_T *oap));
! #if defined(FEAT_MOUSE)
  static void	find_start_of_word __ARGS((pos_T *));
  static void	find_end_of_word __ARGS((pos_T *));
  static int	get_mouse_class __ARGS((char_u *p));
***************
*** 48,56 ****
  static int	checkclearopq __ARGS((oparg_T *oap));
  static void	clearop __ARGS((oparg_T *oap));
  static void	clearopbeep __ARGS((oparg_T *oap));
- #ifdef FEAT_VISUAL
  static void	unshift_special __ARGS((cmdarg_T *cap));
- #endif
  #ifdef FEAT_CMDL_INFO
  static void	del_from_showcmd __ARGS((int));
  #endif
--- 46,52 ----
***************
*** 117,141 ****
  #ifdef FEAT_VREPLACE
  static void	nv_vreplace __ARGS((cmdarg_T *cap));
  #endif
- #ifdef FEAT_VISUAL
  static void	v_swap_corners __ARGS((int cmdchar));
- #endif
  static void	nv_replace __ARGS((cmdarg_T *cap));
  static void	n_swapchar __ARGS((cmdarg_T *cap));
  static void	nv_cursormark __ARGS((cmdarg_T *cap, int flag, pos_T *pos));
- #ifdef FEAT_VISUAL
  static void	v_visop __ARGS((cmdarg_T *cap));
- #endif
  static void	nv_subst __ARGS((cmdarg_T *cap));
  static void	nv_abbrev __ARGS((cmdarg_T *cap));
  static void	nv_optrans __ARGS((cmdarg_T *cap));
  static void	nv_gomark __ARGS((cmdarg_T *cap));
  static void	nv_pcmark __ARGS((cmdarg_T *cap));
  static void	nv_regname __ARGS((cmdarg_T *cap));
- #ifdef FEAT_VISUAL
  static void	nv_visual __ARGS((cmdarg_T *cap));
  static void	n_start_visual_mode __ARGS((int c));
- #endif
  static void	nv_window __ARGS((cmdarg_T *cap));
  static void	nv_suspend __ARGS((cmdarg_T *cap));
  static void	nv_g_cmd __ARGS((cmdarg_T *cap));
--- 113,131 ----
***************
*** 155,165 ****
  static void	nv_wordcmd __ARGS((cmdarg_T *cap));
  static void	nv_beginline __ARGS((cmdarg_T *cap));
  static void	adjust_cursor __ARGS((oparg_T *oap));
- #ifdef FEAT_VISUAL
  static void	adjust_for_sel __ARGS((cmdarg_T *cap));
  static int	unadjust_for_sel __ARGS((void));
  static void	nv_select __ARGS((cmdarg_T *cap));
- #endif
  static void	nv_goto __ARGS((cmdarg_T *cap));
  static void	nv_normal __ARGS((cmdarg_T *cap));
  static void	nv_esc __ARGS((cmdarg_T *oap));
--- 145,153 ----
***************
*** 248,271 ****
      {Ctrl_N,	nv_down,	NV_STS,			FALSE},
      {Ctrl_O,	nv_ctrlo,	0,			0},
      {Ctrl_P,	nv_up,		NV_STS,			FALSE},
- #ifdef FEAT_VISUAL
      {Ctrl_Q,	nv_visual,	0,			FALSE},
- #else
-     {Ctrl_Q,	nv_ignore,	0,			0},
- #endif
      {Ctrl_R,	nv_redo,	0,			0},
      {Ctrl_S,	nv_ignore,	0,			0},
      {Ctrl_T,	nv_tagpop,	NV_NCW,			0},
      {Ctrl_U,	nv_halfpage,	0,			0},
- #ifdef FEAT_VISUAL
      {Ctrl_V,	nv_visual,	0,			FALSE},
      {'V',	nv_visual,	0,			FALSE},
      {'v',	nv_visual,	0,			FALSE},
- #else
-     {Ctrl_V,	nv_error,	0,			0},
-     {'V',	nv_error,	0,			0},
-     {'v',	nv_error,	0,			0},
- #endif
      {Ctrl_W,	nv_window,	0,			0},
      {Ctrl_X,	nv_addsub,	0,			0},
      {Ctrl_Y,	nv_scroll_line,	0,			FALSE},
--- 236,249 ----
***************
*** 427,435 ****
      {K_HELP,	nv_help,	NV_NCW,			0},
      {K_F1,	nv_help,	NV_NCW,			0},
      {K_XF1,	nv_help,	NV_NCW,			0},
- #ifdef FEAT_VISUAL
      {K_SELECT,	nv_select,	0,			0},
- #endif
  #ifdef FEAT_GUI
      {K_VER_SCROLLBAR, nv_ver_scrollbar, 0,		0},
      {K_HOR_SCROLLBAR, nv_hor_scrollbar, 0,		0},
--- 405,411 ----
***************
*** 579,589 ****
  #ifdef FEAT_CMDL_INFO
      int		need_flushbuf;		/* need to call out_flush() */
  #endif
- #ifdef FEAT_VISUAL
      pos_T	old_pos;		/* cursor position before command */
      int		mapped_len;
      static int	old_mapped_len = 0;
- #endif
      int		idx;
  #ifdef FEAT_EVAL
      int		set_prevcount = FALSE;
--- 555,563 ----
***************
*** 643,651 ****
      }
  #endif
  
- #ifdef FEAT_VISUAL
      mapped_len = typebuf_maplen();
- #endif
  
      State = NORMAL_BUSY;
  #ifdef USE_ON_FLY_SCROLL
--- 617,623 ----
***************
*** 666,672 ****
      c = safe_vgetc();
      LANGMAP_ADJUST(c, TRUE);
  
- #ifdef FEAT_VISUAL
      /*
       * If a mapping was started in Visual or Select mode, remember the length
       * of the mapping.  This is used below to not return to Insert mode for as
--- 638,643 ----
***************
*** 677,688 ****
      else if (old_mapped_len
  		|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))
  	old_mapped_len = typebuf_maplen();
- #endif
  
      if (c == NUL)
  	c = K_ZERO;
  
- #ifdef FEAT_VISUAL
      /*
       * In Select mode, typed text replaces the selection.
       */
--- 648,657 ----
***************
*** 703,718 ****
  	msg_nowait = TRUE;	/* don't delay going to insert mode */
  	old_mapped_len = 0;	/* do go to Insert mode */
      }
- #endif
  
  #ifdef FEAT_CMDL_INFO
      need_flushbuf = add_to_showcmd(c);
  #endif
  
  getcount:
- #ifdef FEAT_VISUAL
      if (!(VIsual_active && VIsual_select))
- #endif
      {
  	/*
  	 * Handle a count before a command and compute ca.count0.
--- 672,684 ----
***************
*** 856,862 ****
  	goto normal_end;
  #endif
  
- #ifdef FEAT_VISUAL
      /*
       * In Visual/Select mode, a few keys are handled in a special way.
       */
--- 822,827 ----
***************
*** 892,898 ****
  	    }
  	}
      }
- #endif
  
  #ifdef FEAT_RIGHTLEFT
      if (curwin->w_p_rl && KeyTyped && !KeyStuffed
--- 857,862 ----
***************
*** 930,940 ****
  		    && !Recording
  		    && !Exec_reg)
  		|| ((ca.cmdchar == 'a' || ca.cmdchar == 'i')
! 		    && (oap->op_type != OP_NOP
! #ifdef FEAT_VISUAL
! 			|| VIsual_active
! #endif
! 		       ))))
      {
  	int	*cp;
  	int	repl = FALSE;	/* get character for replace mode */
--- 894,900 ----
  		    && !Recording
  		    && !Exec_reg)
  		|| ((ca.cmdchar == 'a' || ca.cmdchar == 'i')
! 		    && (oap->op_type != OP_NOP || VIsual_active))))
      {
  	int	*cp;
  	int	repl = FALSE;	/* get character for replace mode */
***************
*** 1168,1174 ****
  	msg_col = 0;
      }
  
- #ifdef FEAT_VISUAL
      old_pos = curwin->w_cursor;		/* remember where cursor was */
  
      /* When 'keymodel' contains "startsel" some keys start Select/Visual
--- 1128,1133 ----
***************
*** 1188,1194 ****
  	    mod_mask &= ~MOD_MASK_SHIFT;
  	}
      }
- #endif
  
      /*
       * Execute the command!
--- 1147,1152 ----
***************
*** 1220,1231 ****
  #endif
      }
  
- #ifdef FEAT_VISUAL
      /* Get the length of mapped chars again after typing a count, second
       * character or "z333<cr>". */
      if (old_mapped_len > 0)
  	old_mapped_len = typebuf_maplen();
- #endif
  
      /*
       * If an operation is pending, handle it...
--- 1178,1187 ----
***************
*** 1247,1257 ****
      if (       ((p_smd
  		    && msg_silent == 0
  		    && (restart_edit != 0
- #ifdef FEAT_VISUAL
  			|| (VIsual_active
  			    && old_pos.lnum == curwin->w_cursor.lnum
  			    && old_pos.col == curwin->w_cursor.col)
- #endif
  		       )
  		    && (clear_cmdline
  			|| redraw_cmdline)
--- 1203,1211 ----
***************
*** 1259,1267 ****
  		    && !msg_nowait
  		    && KeyTyped)
  		|| (restart_edit != 0
- #ifdef FEAT_VISUAL
  		    && !VIsual_active
- #endif
  		    && (msg_scroll
  			|| emsg_on_display)))
  	    && oap->regname == 0
--- 1213,1219 ----
***************
*** 1368,1403 ****
       * May switch from Visual to Select mode after CTRL-O command.
       */
      if (       oap->op_type == OP_NOP
- #ifdef FEAT_VISUAL
  	    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)
  		|| restart_VIsual_select == 1)
- #else
- 	    && restart_edit != 0
- #endif
  	    && !(ca.retval & CA_COMMAND_BUSY)
  	    && stuff_empty()
  	    && oap->regname == 0)
      {
- #ifdef FEAT_VISUAL
  	if (restart_VIsual_select == 1)
  	{
  	    VIsual_select = TRUE;
  	    showmode();
  	    restart_VIsual_select = 0;
  	}
! #endif
! 	if (restart_edit != 0
! #ifdef FEAT_VISUAL
! 		&& !VIsual_active && old_mapped_len == 0
! #endif
! 		)
  	    (void)edit(restart_edit, FALSE, 1L);
      }
  
- #ifdef FEAT_VISUAL
      if (restart_VIsual_select == 2)
  	restart_VIsual_select = 1;
- #endif
  
      /* Save count before an operator for next time. */
      opcount = ca.opcount;
--- 1320,1343 ----
       * May switch from Visual to Select mode after CTRL-O command.
       */
      if (       oap->op_type == OP_NOP
  	    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)
  		|| restart_VIsual_select == 1)
  	    && !(ca.retval & CA_COMMAND_BUSY)
  	    && stuff_empty()
  	    && oap->regname == 0)
      {
  	if (restart_VIsual_select == 1)
  	{
  	    VIsual_select = TRUE;
  	    showmode();
  	    restart_VIsual_select = 0;
  	}
! 	if (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)
  	    (void)edit(restart_edit, FALSE, 1L);
      }
  
      if (restart_VIsual_select == 2)
  	restart_VIsual_select = 1;
  
      /* Save count before an operator for next time. */
      opcount = ca.opcount;
***************
*** 1437,1451 ****
      int		empty_region_error;
      int		restart_edit_save;
  
- #ifdef FEAT_VISUAL
      /* The visual area is remembered for redo */
      static int	    redo_VIsual_mode = NUL; /* 'v', 'V', or Ctrl-V */
      static linenr_T redo_VIsual_line_count; /* number of lines */
      static colnr_T  redo_VIsual_vcol;	    /* number of cols or end column */
      static long	    redo_VIsual_count;	    /* count for Visual operator */
! # ifdef FEAT_VIRTUALEDIT
      int		    include_line_break = FALSE;
- # endif
  #endif
  
  #if defined(FEAT_CLIPBOARD)
--- 1377,1389 ----
      int		empty_region_error;
      int		restart_edit_save;
  
      /* The visual area is remembered for redo */
      static int	    redo_VIsual_mode = NUL; /* 'v', 'V', or Ctrl-V */
      static linenr_T redo_VIsual_line_count; /* number of lines */
      static colnr_T  redo_VIsual_vcol;	    /* number of cols or end column */
      static long	    redo_VIsual_count;	    /* count for Visual operator */
! #ifdef FEAT_VIRTUALEDIT
      int		    include_line_break = FALSE;
  #endif
  
  #if defined(FEAT_CLIPBOARD)
***************
*** 1459,1468 ****
      if ((clip_star.available || clip_plus.available)
  	    && oap->op_type != OP_NOP
  	    && !gui_yank
- # ifdef FEAT_VISUAL
  	    && VIsual_active
  	    && !redo_VIsual_busy
- # endif
  	    && oap->regname == 0)
  	clip_auto_select();
  #endif
--- 1397,1404 ----
***************
*** 1471,1483 ****
      /*
       * If an operation is pending, handle it...
       */
!     if ((finish_op
! #ifdef FEAT_VISUAL
! 		|| VIsual_active
! #endif
! 		) && oap->op_type != OP_NOP)
      {
- #ifdef FEAT_VISUAL
  	oap->is_VIsual = VIsual_active;
  	if (oap->motion_force == 'V')
  	    oap->motion_type = MLINE;
--- 1407,1414 ----
      /*
       * If an operation is pending, handle it...
       */
!     if ((finish_op || VIsual_active) && oap->op_type != OP_NOP)
      {
  	oap->is_VIsual = VIsual_active;
  	if (oap->motion_force == 'V')
  	    oap->motion_type = MLINE;
***************
*** 1501,1517 ****
  	    VIsual_select = FALSE;
  	    VIsual_reselect = FALSE;
  	}
- #endif
  
  	/* Only redo yank when 'y' flag is in 'cpoptions'. */
  	/* Never redo "zf" (define fold). */
  	if ((vim_strchr(p_cpo, CPO_YANK) != NULL || oap->op_type != OP_YANK)
- #ifdef FEAT_VISUAL
  		&& ((!VIsual_active || oap->motion_force)
  		    /* Also redo Operator-pending Visual mode mappings */
  		    || (VIsual_active && cap->cmdchar == ':'
  						 && oap->op_type != OP_COLON))
- #endif
  		&& cap->cmdchar != 'D'
  #ifdef FEAT_FOLDING
  		&& oap->op_type != OP_FOLD
--- 1432,1445 ----
***************
*** 1554,1560 ****
  	    }
  	}
  
- #ifdef FEAT_VISUAL
  	if (redo_VIsual_busy)
  	{
  	    /* Redo of an operation on a Visual area. Use the same size from
--- 1482,1487 ----
***************
*** 1639,1645 ****
  	    if (VIsual_mode == 'V')
  		oap->start.col = 0;
  	}
- #endif /* FEAT_VISUAL */
  
  	/*
  	 * Set oap->start to the first position of the operated text, oap->end
--- 1566,1571 ----
***************
*** 1690,1696 ****
  	virtual_op = virtual_active();
  #endif
  
- #ifdef FEAT_VISUAL
  	if (VIsual_active || redo_VIsual_busy)
  	{
  	    if (VIsual_mode == Ctrl_V)	/* block mode */
--- 1616,1621 ----
***************
*** 1826,1834 ****
  	    {
  		oap->motion_type = MCHAR;
  		if (VIsual_mode != Ctrl_V && *ml_get_pos(&(oap->end)) == NUL
! # ifdef FEAT_VIRTUALEDIT
  			&& (include_line_break || !virtual_op)
! # endif
  			)
  		{
  		    oap->inclusive = FALSE;
--- 1751,1759 ----
  	    {
  		oap->motion_type = MCHAR;
  		if (VIsual_mode != Ctrl_V && *ml_get_pos(&(oap->end)) == NUL
! #ifdef FEAT_VIRTUALEDIT
  			&& (include_line_break || !virtual_op)
! #endif
  			)
  		{
  		    oap->inclusive = FALSE;
***************
*** 1840,1848 ****
  			{
  			    ++oap->end.lnum;
  			    oap->end.col = 0;
! # ifdef FEAT_VIRTUALEDIT
  			    oap->end.coladd = 0;
! # endif
  			    ++oap->line_count;
  			}
  			else
--- 1765,1773 ----
  			{
  			    ++oap->end.lnum;
  			    oap->end.col = 0;
! #ifdef FEAT_VIRTUALEDIT
  			    oap->end.coladd = 0;
! #endif
  			    ++oap->line_count;
  			}
  			else
***************
*** 1868,1877 ****
  	    if (!gui_yank)
  	    {
  		VIsual_active = FALSE;
! # ifdef FEAT_MOUSE
  		setmouse();
  		mouse_dragging = 0;
! # endif
  		if (mode_displayed)
  		    clear_cmdline = TRUE;   /* unshow visual mode later */
  #ifdef FEAT_CMDL_INFO
--- 1793,1802 ----
  	    if (!gui_yank)
  	    {
  		VIsual_active = FALSE;
! #ifdef FEAT_MOUSE
  		setmouse();
  		mouse_dragging = 0;
! #endif
  		if (mode_displayed)
  		    clear_cmdline = TRUE;   /* unshow visual mode later */
  #ifdef FEAT_CMDL_INFO
***************
*** 1886,1892 ****
  		    redraw_curbuf_later(INVERTED);
  	    }
  	}
- #endif
  
  #ifdef FEAT_MBYTE
  	/* Include the trailing byte of a multi-byte char. */
--- 1811,1816 ----
***************
*** 1921,1936 ****
  	empty_region_error = (oap->empty
  				&& vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL);
  
- #ifdef FEAT_VISUAL
  	/* Force a redraw when operating on an empty Visual region, when
  	 * 'modifiable is off or creating a fold. */
  	if (oap->is_VIsual && (oap->empty || !curbuf->b_p_ma
! # ifdef FEAT_FOLDING
  		    || oap->op_type == OP_FOLD
! # endif
  		    ))
  	    redraw_curbuf_later(INVERTED);
- #endif
  
  	/*
  	 * If the end of an operator is in column one while oap->motion_type
--- 1845,1858 ----
  	empty_region_error = (oap->empty
  				&& vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL);
  
  	/* Force a redraw when operating on an empty Visual region, when
  	 * 'modifiable is off or creating a fold. */
  	if (oap->is_VIsual && (oap->empty || !curbuf->b_p_ma
! #ifdef FEAT_FOLDING
  		    || oap->op_type == OP_FOLD
! #endif
  		    ))
  	    redraw_curbuf_later(INVERTED);
  
  	/*
  	 * If the end of an operator is in column one while oap->motion_type
***************
*** 1943,1952 ****
  		&& oap->inclusive == FALSE
  		&& !(cap->retval & CA_NO_ADJ_OP_END)
  		&& oap->end.col == 0
- #ifdef FEAT_VISUAL
  		&& (!oap->is_VIsual || *p_sel == 'o')
  		&& !oap->block_mode
- #endif
  		&& oap->line_count > 1)
  	{
  	    oap->end_adjusted = TRUE;	    /* remember that we did this */
--- 1865,1872 ----
***************
*** 1971,1981 ****
  	{
  	case OP_LSHIFT:
  	case OP_RSHIFT:
! 	    op_shift(oap, TRUE,
! #ifdef FEAT_VISUAL
! 		    oap->is_VIsual ? (int)cap->count1 :
! #endif
! 		    1);
  	    auto_format(FALSE, TRUE);
  	    break;
  
--- 1891,1897 ----
  	{
  	case OP_LSHIFT:
  	case OP_RSHIFT:
! 	    op_shift(oap, TRUE, oap->is_VIsual ? (int)cap->count1 : 1);
  	    auto_format(FALSE, TRUE);
  	    break;
  
***************
*** 1988,2002 ****
  		beep_flush();
  	    else
  	    {
! 		(void)do_join(oap->line_count, oap->op_type == OP_JOIN, TRUE, TRUE);
  		auto_format(FALSE, TRUE);
  	    }
  	    break;
  
  	case OP_DELETE:
- #ifdef FEAT_VISUAL
  	    VIsual_reselect = FALSE;	    /* don't reselect now */
- #endif
  	    if (empty_region_error)
  	    {
  		vim_beep();
--- 1904,1917 ----
  		beep_flush();
  	    else
  	    {
! 		(void)do_join(oap->line_count, oap->op_type == OP_JOIN,
! 								  TRUE, TRUE);
  		auto_format(FALSE, TRUE);
  	    }
  	    break;
  
  	case OP_DELETE:
  	    VIsual_reselect = FALSE;	    /* don't reselect now */
  	    if (empty_region_error)
  	    {
  		vim_beep();
***************
*** 2026,2034 ****
  	    break;
  
  	case OP_CHANGE:
- #ifdef FEAT_VISUAL
  	    VIsual_reselect = FALSE;	    /* don't reselect now */
- #endif
  	    if (empty_region_error)
  	    {
  		vim_beep();
--- 1941,1947 ----
***************
*** 2126,2134 ****
  
  	case OP_INSERT:
  	case OP_APPEND:
- #ifdef FEAT_VISUAL
  	    VIsual_reselect = FALSE;	/* don't reselect now */
- #endif
  #ifdef FEAT_VISUALEXTRA
  	    if (empty_region_error)
  	    {
--- 2039,2045 ----
***************
*** 2158,2166 ****
  	    break;
  
  	case OP_REPLACE:
- #ifdef FEAT_VISUAL
  	    VIsual_reselect = FALSE;	/* don't reselect now */
- #endif
  #ifdef FEAT_VISUALEXTRA
  	    if (empty_region_error)
  #endif
--- 2069,2075 ----
***************
*** 2220,2228 ****
  	{
  	    curwin->w_cursor = old_cursor;
  	}
- #ifdef FEAT_VISUAL
  	oap->block_mode = FALSE;
- #endif
  	clearop(oap);
      }
  }
--- 2129,2135 ----
***************
*** 2235,2245 ****
      oparg_T	*oap;
  {
      stuffcharReadbuff(':');
- #ifdef FEAT_VISUAL
      if (oap->is_VIsual)
  	stuffReadbuff((char_u *)"'<,'>");
      else
- #endif
      {
  	/*
  	 * Make the range look nice, so it can be repeated.
--- 2142,2150 ----
***************
*** 2404,2417 ****
      pos_T	save_cursor;
  #endif
      win_T	*old_curwin = curwin;
- #ifdef FEAT_VISUAL
      static pos_T orig_cursor;
      colnr_T	leftcol, rightcol;
      pos_T	end_visual;
      int		diff;
      int		old_active = VIsual_active;
      int		old_mode = VIsual_mode;
- #endif
      int		regname;
  
  #if defined(FEAT_FOLDING)
--- 2309,2320 ----
***************
*** 2432,2446 ****
  	if (!gui.in_use)
  #endif
  	{
- #ifdef FEAT_VISUAL
  	    if (VIsual_active)
  	    {
  		if (!mouse_has(MOUSE_VISUAL))
  		    return FALSE;
  	    }
! 	    else
! #endif
! 		if (State == NORMAL && !mouse_has(MOUSE_NORMAL))
  		return FALSE;
  	}
  
--- 2335,2346 ----
  	if (!gui.in_use)
  #endif
  	{
  	    if (VIsual_active)
  	    {
  		if (!mouse_has(MOUSE_VISUAL))
  		    return FALSE;
  	    }
! 	    else if (State == NORMAL && !mouse_has(MOUSE_NORMAL))
  		return FALSE;
  	}
  
***************
*** 2509,2522 ****
  	}
      }
  
- #ifndef FEAT_VISUAL
-     /*
-      * ALT is only used for starting/extending Visual mode.
-      */
-     if ((mod_mask & MOD_MASK_ALT))
- 	return FALSE;
- #endif
- 
      /*
       * CTRL right mouse button does CTRL-T
       */
--- 2409,2414 ----
***************
*** 2586,2592 ****
  		return FALSE;
  	    }
  
- #ifdef FEAT_VISUAL
  	    /*
  	     * If visual was active, yank the highlighted text and put it
  	     * before the mouse pointer position.
--- 2478,2483 ----
***************
*** 2607,2613 ****
  		do_always = TRUE;	/* ignore 'mouse' setting next time */
  		return FALSE;
  	    }
- #endif
  	    /*
  	     * The rest is below jump_to_mouse()
  	     */
--- 2498,2503 ----
***************
*** 2761,2767 ****
  		{
  		    /* First set the cursor position before showing the popup
  		     * menu. */
- #ifdef FEAT_VISUAL
  		    if (VIsual_active)
  		    {
  			pos_T    m_pos;
--- 2651,2656 ----
***************
*** 2800,2815 ****
  		    }
  		    else
  			jump_flags = MOUSE_MAY_STOP_VIS;
- #endif
  		}
  		if (jump_flags)
  		{
  		    jump_flags = jump_to_mouse(jump_flags, NULL, which_button);
! 		    update_curbuf(
! #ifdef FEAT_VISUAL
! 			    VIsual_active ? INVERTED :
! #endif
! 			    VALID);
  		    setcursor();
  		    out_flush();    /* Update before showing popup menu */
  		}
--- 2689,2699 ----
  		    }
  		    else
  			jump_flags = MOUSE_MAY_STOP_VIS;
  		}
  		if (jump_flags)
  		{
  		    jump_flags = jump_to_mouse(jump_flags, NULL, which_button);
! 		    update_curbuf(VIsual_active ? INVERTED : VALID);
  		    setcursor();
  		    out_flush();    /* Update before showing popup menu */
  		}
***************
*** 2832,2838 ****
  	}
      }
  
- #ifdef FEAT_VISUAL
      if ((State & (NORMAL | INSERT))
  			    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))
      {
--- 2716,2721 ----
***************
*** 2872,2878 ****
  		jump_flags |= MOUSE_MAY_VIS;
  	}
      }
- #endif
  
      /*
       * If an operator is pending, ignore all drags and releases until the
--- 2755,2760 ----
***************
*** 2941,2947 ****
      }
  #endif
  
- #ifdef FEAT_VISUAL
      /* Set global flag that we are extending the Visual area with mouse
       * dragging; temporarily minimize 'scrolloff'. */
      if (VIsual_active && is_drag && p_so)
--- 2823,2828 ----
***************
*** 3040,3046 ****
       */
      else if ((State & INSERT) && VIsual_active)
  	stuffcharReadbuff(Ctrl_O);
- #endif
  
      /*
       * Middle mouse click: Put text before cursor.
--- 2921,2926 ----
***************
*** 3118,3128 ****
       */
      else if ((mod_mask & MOD_MASK_SHIFT))
      {
! 	if (State & INSERT
! #ifdef FEAT_VISUAL
! 		|| (VIsual_active && VIsual_select)
! #endif
! 		)
  	    stuffcharReadbuff(Ctrl_O);
  	if (which_button == MOUSE_LEFT)
  	    stuffcharReadbuff('*');
--- 2998,3004 ----
       */
      else if ((mod_mask & MOD_MASK_SHIFT))
      {
! 	if ((State & INSERT) || (VIsual_active && VIsual_select))
  	    stuffcharReadbuff(Ctrl_O);
  	if (which_button == MOUSE_LEFT)
  	    stuffcharReadbuff('*');
***************
*** 3153,3159 ****
  # endif
      }
  #endif
- #ifdef FEAT_VISUAL
      else if ((mod_mask & MOD_MASK_MULTI_CLICK) && (State & (NORMAL | INSERT))
  	     && mouse_has(MOUSE_VISUAL))
      {
--- 3029,3034 ----
***************
*** 3267,3278 ****
  	    || (VIsual_active && p_smd && msg_silent == 0
  				 && (!old_active || VIsual_mode != old_mode)))
  	redraw_cmdline = TRUE;
- #endif
  
      return moved;
  }
  
- #ifdef FEAT_VISUAL
  /*
   * Move "pos" back to the start of the word it's in.
   */
--- 3142,3151 ----
***************
*** 3372,3381 ****
  	return 1;
      return c;
  }
- #endif /* FEAT_VISUAL */
  #endif /* FEAT_MOUSE */
  
- #if defined(FEAT_VISUAL) || defined(PROTO)
  /*
   * Check if  highlighting for visual mode is possible, give a warning message
   * if not.
--- 3245,3252 ----
***************
*** 3468,3474 ****
  	VIsual_reselect = FALSE;
      }
  }
- #endif /* FEAT_VISUAL */
  
  #if defined(FEAT_BEVAL)
  static int find_is_eval_item __ARGS((char_u *ptr, int *colp, int *nbp, int dir));
--- 3339,3344 ----
***************
*** 3802,3812 ****
  checkclearopq(oap)
      oparg_T	*oap;
  {
!     if (oap->op_type == OP_NOP
! #ifdef FEAT_VISUAL
! 	    && !VIsual_active
! #endif
! 	    )
  	return FALSE;
      clearopbeep(oap);
      return TRUE;
--- 3672,3678 ----
  checkclearopq(oap)
      oparg_T	*oap;
  {
!     if (oap->op_type == OP_NOP && !VIsual_active)
  	return FALSE;
      clearopbeep(oap);
      return TRUE;
***************
*** 3830,3836 ****
      beep_flush();
  }
  
- #ifdef FEAT_VISUAL
  /*
   * Remove the shift modifier from a special key.
   */
--- 3696,3701 ----
***************
*** 3849,3866 ****
      }
      cap->cmdchar = simplify_key(cap->cmdchar, &mod_mask);
  }
- #endif
  
  #if defined(FEAT_CMDL_INFO) || defined(PROTO)
  /*
   * Routines for displaying a partly typed command
   */
  
! #ifdef FEAT_VISUAL	/* need room for size of Visual area */
! # define SHOWCMD_BUFLEN SHOWCMD_COLS + 1 + 30
! #else
! # define SHOWCMD_BUFLEN SHOWCMD_COLS + 1
! #endif
  static char_u	showcmd_buf[SHOWCMD_BUFLEN];
  static char_u	old_showcmd_buf[SHOWCMD_BUFLEN];  /* For push_showcmd() */
  static int	showcmd_is_clear = TRUE;
--- 3714,3726 ----
      }
      cap->cmdchar = simplify_key(cap->cmdchar, &mod_mask);
  }
  
  #if defined(FEAT_CMDL_INFO) || defined(PROTO)
  /*
   * Routines for displaying a partly typed command
   */
  
! #define SHOWCMD_BUFLEN SHOWCMD_COLS + 1 + 30
  static char_u	showcmd_buf[SHOWCMD_BUFLEN];
  static char_u	old_showcmd_buf[SHOWCMD_BUFLEN];  /* For push_showcmd() */
  static int	showcmd_is_clear = TRUE;
***************
*** 3874,3880 ****
      if (!p_sc)
  	return;
  
- #ifdef FEAT_VISUAL
      if (VIsual_active && !char_avail())
      {
  	int		cursor_bot = lt(VIsual, curwin->w_cursor);
--- 3734,3739 ----
***************
*** 3960,3966 ****
  	showcmd_visual = TRUE;
      }
      else
- #endif
      {
  	showcmd_buf[0] = NUL;
  	showcmd_visual = FALSE;
--- 3819,3824 ----
***************
*** 4203,4212 ****
      int		want_hor;
      win_T	*old_curwin = curwin;
      buf_T	*old_curbuf = curbuf;
- #ifdef FEAT_VISUAL
      int		old_VIsual_select = VIsual_select;
      int		old_VIsual_active = VIsual_active;
- #endif
      colnr_T	tgt_leftcol = curwin->w_leftcol;
      long	topline;
      long	y;
--- 4061,4068 ----
***************
*** 4223,4231 ****
      /*
       * loop through the scrollbound windows and scroll accordingly
       */
- #ifdef FEAT_VISUAL
      VIsual_select = VIsual_active = 0;
- #endif
      for (curwin = firstwin; curwin; curwin = curwin->w_next)
      {
  	curbuf = curwin->w_buffer;
--- 4079,4085 ----
***************
*** 4280,4289 ****
      /*
       * reset current-window
       */
- #ifdef FEAT_VISUAL
      VIsual_select = old_VIsual_select;
      VIsual_active = old_VIsual_active;
- #endif
      curwin = old_curwin;
      curbuf = old_curbuf;
  }
--- 4134,4141 ----
***************
*** 5239,5249 ****
  
  		    if (checkclearop(cap->oap))
  			break;
- # ifdef FEAT_VISUAL
  		    if (VIsual_active && get_visual_text(cap, &ptr, &len)
  								      == FAIL)
  			return;
- # endif
  		    if (ptr == NULL)
  		    {
  			pos_T	pos = curwin->w_cursor;
--- 5091,5099 ----
***************
*** 5411,5422 ****
      /*
       * Ignore 'Q' in Visual mode, just give a beep.
       */
- #ifdef FEAT_VISUAL
      if (VIsual_active)
  	vim_beep();
!     else
! #endif
! 	if (!checkclearop(cap->oap))
  	do_exmode(FALSE);
  }
  
--- 5261,5269 ----
      /*
       * Ignore 'Q' in Visual mode, just give a beep.
       */
      if (VIsual_active)
  	vim_beep();
!     else if (!checkclearop(cap->oap))
  	do_exmode(FALSE);
  }
  
***************
*** 5430,5440 ****
      int	    old_p_im;
      int	    cmd_result;
  
- #ifdef FEAT_VISUAL
      if (VIsual_active)
  	nv_operator(cap);
      else
- #endif
      {
  	if (cap->oap->op_type != OP_NOP)
  	{
--- 5277,5285 ----
***************
*** 5494,5508 ****
  nv_ctrlg(cap)
      cmdarg_T *cap;
  {
- #ifdef FEAT_VISUAL
      if (VIsual_active)	/* toggle Selection/Visual mode */
      {
  	VIsual_select = !VIsual_select;
  	showmode();
      }
!     else
! #endif
! 	if (!checkclearop(cap->oap))
  	/* print full name if count given or :cd used */
  	fileinfo((int)cap->count0, FALSE, TRUE);
  }
--- 5339,5350 ----
  nv_ctrlg(cap)
      cmdarg_T *cap;
  {
      if (VIsual_active)	/* toggle Selection/Visual mode */
      {
  	VIsual_select = !VIsual_select;
  	showmode();
      }
!     else if (!checkclearop(cap->oap))
  	/* print full name if count given or :cd used */
  	fileinfo((int)cap->count0, FALSE, TRUE);
  }
***************
*** 5514,5527 ****
  nv_ctrlh(cap)
      cmdarg_T *cap;
  {
- #ifdef FEAT_VISUAL
      if (VIsual_active && VIsual_select)
      {
  	cap->cmdchar = 'x';	/* BS key behaves like 'x' in Select mode */
  	v_visop(cap);
      }
      else
- #endif
  	nv_left(cap);
  }
  
--- 5356,5367 ----
***************
*** 5558,5564 ****
  nv_ctrlo(cap)
      cmdarg_T	*cap;
  {
- #ifdef FEAT_VISUAL
      if (VIsual_active && VIsual_select)
      {
  	VIsual_select = FALSE;
--- 5398,5403 ----
***************
*** 5566,5572 ****
  	restart_VIsual_select = 2;	/* restart Select mode later */
      }
      else
- #endif
      {
  	cap->count1 = -cap->count1;
  	nv_pcmark(cap);
--- 5405,5410 ----
***************
*** 5675,5684 ****
       */
      if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K')
      {
- #ifdef FEAT_VISUAL
  	if (VIsual_active && get_visual_text(cap, &ptr, &n) == FAIL)
  	    return;
- #endif
  	if (checkclearopq(cap->oap))
  	    return;
      }
--- 5513,5520 ----
***************
*** 5872,5878 ****
      vim_free(buf);
  }
  
- #if defined(FEAT_VISUAL) || defined(PROTO)
  /*
   * Get visually selected text, within one line only.
   * Returns FAIL if more than one line selected.
--- 5708,5713 ----
***************
*** 5917,5923 ****
      reset_VIsual_and_resel();
      return OK;
  }
- #endif
  
  /*
   * CTRL-T: backwards in tag stack
--- 5752,5757 ----
***************
*** 6040,6050 ****
      cmdarg_T	*cap;
  {
      long	n;
! #ifdef FEAT_VISUAL
!     int		PAST_LINE;
! #else
! # define PAST_LINE 0
! #endif
  
      if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))
      {
--- 5874,5880 ----
      cmdarg_T	*cap;
  {
      long	n;
!     int		past_line;
  
      if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))
      {
***************
*** 6057,6081 ****
  
      cap->oap->motion_type = MCHAR;
      cap->oap->inclusive = FALSE;
! #ifdef FEAT_VISUAL
!     PAST_LINE = (VIsual_active && *p_sel != 'o');
  
! # ifdef FEAT_VIRTUALEDIT
      /*
!      * In virtual mode, there's no such thing as "PAST_LINE", as lines are
!      * (theoretically) infinitely long.
       */
      if (virtual_active())
! 	PAST_LINE = 0;
! # endif
  #endif
  
      for (n = cap->count1; n > 0; --n)
      {
! 	if ((!PAST_LINE && oneright() == FAIL)
! #ifdef FEAT_VISUAL
! 		|| (PAST_LINE && *ml_get_cursor() == NUL)
! #endif
  		)
  	{
  	    /*
--- 5887,5907 ----
  
      cap->oap->motion_type = MCHAR;
      cap->oap->inclusive = FALSE;
!     past_line = (VIsual_active && *p_sel != 'o');
  
! #ifdef FEAT_VIRTUALEDIT
      /*
!      * In virtual edit mode, there's no such thing as "past_line", as lines
!      * are (theoretically) infinitely long.
       */
      if (virtual_active())
! 	past_line = 0;
  #endif
  
      for (n = cap->count1; n > 0; --n)
      {
! 	if ((!past_line && oneright() == FAIL)
! 		|| (past_line && *ml_get_cursor() == NUL)
  		)
  	{
  	    /*
***************
*** 6123,6148 ****
  	    }
  	    break;
  	}
! #ifdef FEAT_VISUAL
! 	else if (PAST_LINE)
  	{
  	    curwin->w_set_curswant = TRUE;
! # ifdef FEAT_VIRTUALEDIT
  	    if (virtual_active())
  		oneright();
  	    else
! # endif
  	    {
! # ifdef FEAT_MBYTE
  		if (has_mbyte)
  		    curwin->w_cursor.col +=
  					 (*mb_ptr2len)(ml_get_cursor());
  		else
! # endif
  		    ++curwin->w_cursor.col;
  	    }
  	}
- #endif
      }
  #ifdef FEAT_FOLDING
      if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped
--- 5949,5972 ----
  	    }
  	    break;
  	}
! 	else if (past_line)
  	{
  	    curwin->w_set_curswant = TRUE;
! #ifdef FEAT_VIRTUALEDIT
  	    if (virtual_active())
  		oneright();
  	    else
! #endif
  	    {
! #ifdef FEAT_MBYTE
  		if (has_mbyte)
  		    curwin->w_cursor.col +=
  					 (*mb_ptr2len)(ml_get_cursor());
  		else
! #endif
  		    ++curwin->w_cursor.col;
  	    }
  	}
      }
  #ifdef FEAT_FOLDING
      if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped
***************
*** 6503,6511 ****
  	else
  	    curwin->w_cursor.coladd = 0;
  #endif
- #ifdef FEAT_VISUAL
  	adjust_for_sel(cap);
- #endif
  #ifdef FEAT_FOLDING
  	if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)
  	    foldOpenCursor();
--- 6327,6333 ----
***************
*** 6754,6760 ****
  	    int	    dir = (cap->cmdchar == ']' && cap->nchar == 'p')
  							 ? FORWARD : BACKWARD;
  	    int	    regname = cap->oap->regname;
- #ifdef FEAT_VISUAL
  	    int	    was_visual = VIsual_active;
  	    int	    line_count = curbuf->b_ml.ml_line_count;
  	    pos_T   start, end;
--- 6576,6581 ----
***************
*** 6766,6779 ****
  		end =  equalpos(start,VIsual) ? curwin->w_cursor : VIsual;
  		curwin->w_cursor = (dir == BACKWARD ? start : end);
  	    }
- #endif
  # ifdef FEAT_CLIPBOARD
  	    adjust_clip_reg(&regname);
  # endif
  	    prep_redo_cmd(cap);
  
  	    do_put(regname, dir, cap->count1, PUT_FIXINDENT);
- #ifdef FEAT_VISUAL
  	    if (was_visual)
  	    {
  		VIsual = start;
--- 6587,6598 ----
***************
*** 6802,6808 ****
  		    redraw_later(SOME_VALID);
  		}
  	    }
- #endif
  	}
      }
  
--- 6621,6626 ----
***************
*** 6936,6944 ****
  #ifdef FEAT_VIRTUALEDIT
  	    curwin->w_cursor.coladd = 0;
  #endif
- #ifdef FEAT_VISUAL
  	    adjust_for_sel(cap);
- #endif
  	}
      }
  #ifdef FEAT_FOLDING
--- 6754,6760 ----
***************
*** 7027,7037 ****
  nv_undo(cap)
      cmdarg_T	*cap;
  {
!     if (cap->oap->op_type == OP_LOWER
! #ifdef FEAT_VISUAL
! 	    || VIsual_active
! #endif
! 	    )
      {
  	/* translate "<Visual>u" to "<Visual>gu" and "guu" to "gugu" */
  	cap->cmdchar = 'g';
--- 6843,6849 ----
  nv_undo(cap)
      cmdarg_T	*cap;
  {
!     if (cap->oap->op_type == OP_LOWER || VIsual_active)
      {
  	/* translate "<Visual>u" to "<Visual>gu" and "guu" to "gugu" */
  	cap->cmdchar = 'g';
***************
*** 7089,7095 ****
  	return;
      }
  
- #ifdef FEAT_VISUAL
      /* Visual mode "r" */
      if (VIsual_active)
      {
--- 6901,6906 ----
***************
*** 7105,7111 ****
  	nv_operator(cap);
  	return;
      }
- #endif
  
  #ifdef FEAT_VIRTUALEDIT
      /* Break tabs, etc. */
--- 6916,6921 ----
***************
*** 7273,7279 ****
      }
  }
  
- #ifdef FEAT_VISUAL
  /*
   * 'o': Exchange start and end of Visual area.
   * 'O': same, but in block mode exchange left and right corners.
--- 7083,7088 ----
***************
*** 7326,7332 ****
  	curwin->w_set_curswant = TRUE;
      }
  }
- #endif /* FEAT_VISUAL */
  
  /*
   * "R" (cap->arg is FALSE) and "gR" (cap->arg is TRUE).
--- 7135,7140 ----
***************
*** 7335,7341 ****
  nv_Replace(cap)
      cmdarg_T	    *cap;
  {
- #ifdef FEAT_VISUAL
      if (VIsual_active)		/* "R" is replace lines */
      {
  	cap->cmdchar = 'c';
--- 7143,7148 ----
***************
*** 7344,7352 ****
  	VIsual_mode = 'V';
  	nv_operator(cap);
      }
!     else
! #endif
! 	if (!checkclearopq(cap->oap))
      {
  	if (!curbuf->b_p_ma)
  	    EMSG(_(e_modifiable));
--- 7151,7157 ----
  	VIsual_mode = 'V';
  	nv_operator(cap);
      }
!     else if (!checkclearopq(cap->oap))
      {
  	if (!curbuf->b_p_ma)
  	    EMSG(_(e_modifiable));
***************
*** 7369,7384 ****
  nv_vreplace(cap)
      cmdarg_T	*cap;
  {
- # ifdef FEAT_VISUAL
      if (VIsual_active)
      {
  	cap->cmdchar = 'r';
  	cap->nchar = cap->extra_char;
  	nv_replace(cap);	/* Do same as "r" in Visual mode for now */
      }
!     else
! # endif
! 	if (!checkclearopq(cap->oap))
      {
  	if (!curbuf->b_p_ma)
  	    EMSG(_(e_modifiable));
--- 7174,7186 ----
  nv_vreplace(cap)
      cmdarg_T	*cap;
  {
      if (VIsual_active)
      {
  	cap->cmdchar = 'r';
  	cap->nchar = cap->extra_char;
  	nv_replace(cap);	/* Do same as "r" in Visual mode for now */
      }
!     else if (!checkclearopq(cap->oap))
      {
  	if (!curbuf->b_p_ma)
  	    EMSG(_(e_modifiable));
***************
*** 7525,7531 ****
      curwin->w_set_curswant = TRUE;
  }
  
- #ifdef FEAT_VISUAL
  /*
   * Handle commands that are operators in Visual mode.
   */
--- 7327,7332 ----
***************
*** 7550,7556 ****
      cap->cmdchar = *(vim_strchr(trans, cap->cmdchar) + 1);
      nv_operator(cap);
  }
- #endif
  
  /*
   * "s" and "S" commands.
--- 7351,7356 ----
***************
*** 7559,7565 ****
  nv_subst(cap)
      cmdarg_T	*cap;
  {
- #ifdef FEAT_VISUAL
      if (VIsual_active)	/* "vs" and "vS" are the same as "vc" */
      {
  	if (cap->cmdchar == 'S')
--- 7359,7364 ----
***************
*** 7571,7577 ****
  	nv_operator(cap);
      }
      else
- #endif
  	nv_optrans(cap);
  }
  
--- 7370,7375 ----
***************
*** 7585,7596 ****
      if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)
  	cap->cmdchar = 'x';		/* DEL key behaves like 'x' */
  
- #ifdef FEAT_VISUAL
      /* in Visual mode these commands are operators */
      if (VIsual_active)
  	v_visop(cap);
      else
- #endif
  	nv_optrans(cap);
  }
  
--- 7383,7392 ----
***************
*** 7758,7764 ****
  	clearopbeep(cap->oap);
  }
  
- #ifdef FEAT_VISUAL
  /*
   * Handle "v", "V" and "CTRL-V" commands.
   * Also for "gh", "gH" and "g^H" commands: Always start Select mode, cap->arg
--- 7554,7559 ----
***************
*** 7950,7956 ****
      }
  }
  
- #endif /* FEAT_VISUAL */
  
  /*
   * CTRL-W: Window commands
--- 7745,7750 ----
***************
*** 7975,7984 ****
      cmdarg_T	*cap;
  {
      clearop(cap->oap);
- #ifdef FEAT_VISUAL
      if (VIsual_active)
  	end_visual_mode();		/* stop Visual mode */
- #endif
      do_cmdline_cmd((char_u *)"st");
  }
  
--- 7769,7776 ----
***************
*** 7990,7998 ****
      cmdarg_T	*cap;
  {
      oparg_T	*oap = cap->oap;
- #ifdef FEAT_VISUAL
      pos_T	tpos;
- #endif
      int		i;
      int		flag = FALSE;
  
--- 7782,7788 ----
***************
*** 8025,8031 ****
  	do_cmdline_cmd((char_u *)"%s//~/&");
  	break;
  
- #ifdef FEAT_VISUAL
      /*
       * "gv": Reselect the previous Visual area.  If Visual already active,
       *	     exchange previous and current Visual area.
--- 7815,7820 ----
***************
*** 8126,8132 ****
  	cap->arg = TRUE;
  	nv_visual(cap);
  	break;
- #endif /* FEAT_VISUAL */
  
      /* "gn", "gN" visually select next/previous search match
       * "gn" selects next match
--- 7915,7920 ----
***************
*** 8134,8142 ****
       */
      case 'N':
      case 'n':
- #ifdef FEAT_VISUAL
  	if (!current_search(cap->count1, cap->nchar == 'n'))
- #endif
  	    clearopbeep(oap);
  	break;
  
--- 7922,7928 ----
***************
*** 8258,8266 ****
  				    && vim_iswhite(ptr[curwin->w_cursor.col]))
  		--curwin->w_cursor.col;
  	    curwin->w_set_curswant = TRUE;
- #ifdef FEAT_VISUAL
  	    adjust_for_sel(cap);
- #endif
  	}
  	break;
  
--- 8044,8050 ----
***************
*** 8657,8667 ****
      cmdarg_T	*cap;
  {
      /* In Visual mode and typing "gUU" triggers an operator */
!     if (cap->oap->op_type == OP_UPPER
! #ifdef FEAT_VISUAL
! 	    || VIsual_active
! #endif
! 	    )
      {
  	/* translate "gUU" to "gUgU" */
  	cap->cmdchar = 'g';
--- 8441,8447 ----
      cmdarg_T	*cap;
  {
      /* In Visual mode and typing "gUU" triggers an operator */
!     if (cap->oap->op_type == OP_UPPER || VIsual_active)
      {
  	/* translate "gUU" to "gUgU" */
  	cap->cmdchar = 'g';
***************
*** 8683,8693 ****
  nv_tilde(cap)
      cmdarg_T	*cap;
  {
!     if (!p_to
! #ifdef FEAT_VISUAL
! 	    && !VIsual_active
! #endif
! 	    && cap->oap->op_type != OP_TILDE)
  	n_swapchar(cap);
      else
  	nv_operator(cap);
--- 8463,8469 ----
  nv_tilde(cap)
      cmdarg_T	*cap;
  {
!     if (!p_to && !VIsual_active && cap->oap->op_type != OP_TILDE)
  	n_swapchar(cap);
      else
  	nv_operator(cap);
***************
*** 8906,8914 ****
  	clearopbeep(cap->oap);
      else
      {
- #ifdef FEAT_VISUAL
  	adjust_for_sel(cap);
- #endif
  #ifdef FEAT_FOLDING
  	if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)
  	    foldOpenCursor();
--- 8682,8688 ----
***************
*** 8931,8939 ****
       * - 'virtualedit' is not "all" and not "onemore".
       */
      if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL
- #ifdef FEAT_VISUAL
  		&& (!VIsual_active || *p_sel == 'o')
- #endif
  #ifdef FEAT_VIRTUALEDIT
  		&& !virtual_active() && (ve_flags & VE_ONEMORE) == 0
  #endif
--- 8705,8711 ----
***************
*** 8968,8974 ****
  			       one-character line). */
  }
  
- #ifdef FEAT_VISUAL
  /*
   * In exclusive Visual mode, may include the last character.
   */
--- 8740,8745 ----
***************
*** 8979,8989 ****
      if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'
  	    && gchar_cursor() != NUL && lt(VIsual, curwin->w_cursor))
      {
! # ifdef FEAT_MBYTE
  	if (has_mbyte)
  	    inc_cursor();
  	else
! # endif
  	    ++curwin->w_cursor.col;
  	cap->oap->inclusive = FALSE;
      }
--- 8750,8760 ----
      if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'
  	    && gchar_cursor() != NUL && lt(VIsual, curwin->w_cursor))
      {
! #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	    inc_cursor();
  	else
! #endif
  	    ++curwin->w_cursor.col;
  	cap->oap->inclusive = FALSE;
      }
***************
*** 9044,9050 ****
      }
  }
  
- #endif
  
  /*
   * "G", "gg", CTRL-END, CTRL-HOME.
--- 8815,8820 ----
***************
*** 9095,9107 ****
  	if (cmdwin_type != 0)
  	    cmdwin_result = Ctrl_C;
  #endif
- #ifdef FEAT_VISUAL
  	if (VIsual_active)
  	{
  	    end_visual_mode();		/* stop Visual */
  	    redraw_curbuf_later(INVERTED);
  	}
- #endif
  	/* CTRL-\ CTRL-G restarts Insert mode when 'insertmode' is set. */
  	if (cap->nchar == Ctrl_G && p_im)
  	    restart_edit = 'a';
--- 8865,8875 ----
***************
*** 9132,9140 ****
  #ifdef FEAT_CMDWIN
  		&& cmdwin_type == 0
  #endif
- #ifdef FEAT_VISUAL
  		&& !VIsual_active
- #endif
  		&& no_reason)
  	    MSG(_("Type  :quit<Enter>  to exit Vim"));
  
--- 8900,8906 ----
***************
*** 9152,9158 ****
  #endif
      }
  
- #ifdef FEAT_VISUAL
      if (VIsual_active)
      {
  	end_visual_mode();	/* stop Visual */
--- 8918,8923 ----
***************
*** 9160,9169 ****
  	curwin->w_set_curswant = TRUE;
  	redraw_curbuf_later(INVERTED);
      }
!     else
! #endif
! 	if (no_reason)
! 	    vim_beep();
      clearop(cap->oap);
  
      /* A CTRL-C is often used at the start of a menu.  When 'insertmode' is
--- 8925,8932 ----
  	curwin->w_set_curswant = TRUE;
  	redraw_curbuf_later(INVERTED);
      }
!     else if (no_reason)
! 	vim_beep();
      clearop(cap->oap);
  
      /* A CTRL-C is often used at the start of a menu.  When 'insertmode' is
***************
*** 9187,9206 ****
      if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS)
  	cap->cmdchar = 'i';
  
- #ifdef FEAT_VISUAL
      /* in Visual mode "A" and "I" are an operator */
      if (VIsual_active && (cap->cmdchar == 'A' || cap->cmdchar == 'I'))
  	v_visop(cap);
  
      /* in Visual mode and after an operator "a" and "i" are for text objects */
!     else
! #endif
! 	if ((cap->cmdchar == 'a' || cap->cmdchar == 'i')
! 	    && (cap->oap->op_type != OP_NOP
! #ifdef FEAT_VISUAL
! 		|| VIsual_active
! #endif
! 		))
      {
  #ifdef FEAT_TEXTOBJ
  	nv_object(cap);
--- 8950,8962 ----
      if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS)
  	cap->cmdchar = 'i';
  
      /* in Visual mode "A" and "I" are an operator */
      if (VIsual_active && (cap->cmdchar == 'A' || cap->cmdchar == 'I'))
  	v_visop(cap);
  
      /* in Visual mode and after an operator "a" and "i" are for text objects */
!     else if ((cap->cmdchar == 'a' || cap->cmdchar == 'i')
! 	    && (cap->oap->op_type != OP_NOP || VIsual_active))
      {
  #ifdef FEAT_TEXTOBJ
  	nv_object(cap);
***************
*** 9467,9478 ****
  nv_join(cap)
      cmdarg_T *cap;
  {
- #ifdef FEAT_VISUAL
      if (VIsual_active)	/* join the visual lines */
  	nv_operator(cap);
!     else
! #endif
! 	if (!checkclearop(cap->oap))
      {
  	if (cap->count0 <= 1)
  	    cap->count0 = 2;	    /* default for join is two lines! */
--- 9223,9231 ----
  nv_join(cap)
      cmdarg_T *cap;
  {
      if (VIsual_active)	/* join the visual lines */
  	nv_operator(cap);
!     else if (!checkclearop(cap->oap))
      {
  	if (cap->count0 <= 1)
  	    cap->count0 = 2;	    /* default for join is two lines! */
***************
*** 9495,9506 ****
  nv_put(cap)
      cmdarg_T  *cap;
  {
- #ifdef FEAT_VISUAL
      int		regname = 0;
      void	*reg1 = NULL, *reg2 = NULL;
      int		empty = FALSE;
      int		was_visual = FALSE;
- #endif
      int		dir;
      int		flags = 0;
  
--- 9248,9257 ----
***************
*** 9526,9532 ****
  	if (cap->cmdchar == 'g')
  	    flags |= PUT_CURSEND;
  
- #ifdef FEAT_VISUAL
  	if (VIsual_active)
  	{
  	    /* Putting in Visual mode: The put text replaces the selected
--- 9277,9282 ----
***************
*** 9536,9549 ****
  	     */
  	    was_visual = TRUE;
  	    regname = cap->oap->regname;
! # ifdef FEAT_CLIPBOARD
  	    adjust_clip_reg(&regname);
! # endif
  	   if (regname == 0 || regname == '"'
  				     || VIM_ISDIGIT(regname) || regname == '-'
! # ifdef FEAT_CLIPBOARD
  		    || (clip_unnamed && (regname == '*' || regname == '+'))
! # endif
  
  		    )
  	    {
--- 9286,9299 ----
  	     */
  	    was_visual = TRUE;
  	    regname = cap->oap->regname;
! #ifdef FEAT_CLIPBOARD
  	    adjust_clip_reg(&regname);
! #endif
  	   if (regname == 0 || regname == '"'
  				     || VIM_ISDIGIT(regname) || regname == '-'
! #ifdef FEAT_CLIPBOARD
  		    || (clip_unnamed && (regname == '*' || regname == '+'))
! #endif
  
  		    )
  	    {
***************
*** 9591,9600 ****
  	    /* May have been reset in do_put(). */
  	    VIsual_active = TRUE;
  	}
- #endif
  	do_put(cap->oap->regname, dir, cap->count1, flags);
  
- #ifdef FEAT_VISUAL
  	/* If a register was saved, put it back now. */
  	if (reg2 != NULL)
  	    put_register(regname, reg2);
--- 9341,9348 ----
***************
*** 9621,9627 ****
  		coladvance((colnr_T)MAXCOL);
  	    }
  	}
- #endif
  	auto_format(FALSE, TRUE);
      }
  }
--- 9369,9374 ----
***************
*** 9642,9652 ****
      }
      else
  #endif
- #ifdef FEAT_VISUAL
      if (VIsual_active)  /* switch start and end of visual */
  	v_swap_corners(cap->cmdchar);
      else
- #endif
  	n_opencmd(cap);
  }
  
--- 9389,9397 ----
*** ../vim-7.4.211/src/ops.c	2014-03-19 18:57:27.730175565 +0100
--- src/ops.c	2014-03-23 15:08:16.095260447 +0100
***************
*** 57,65 ****
      char_u	**y_array;	/* pointer to array of line pointers */
      linenr_T	y_size;		/* number of lines in y_array */
      char_u	y_type;		/* MLINE, MCHAR or MBLOCK */
- #ifdef FEAT_VISUAL
      colnr_T	y_width;	/* only set if y_type == MBLOCK */
- #endif
  } y_regs[NUM_REGISTERS];
  
  static struct yankreg	*y_current;	    /* ptr to current yankreg */
--- 57,63 ----
***************
*** 107,123 ****
  static int	yank_copy_line __ARGS((struct block_def *bd, long y_idx));
  #ifdef FEAT_CLIPBOARD
  static void	copy_yank_reg __ARGS((struct yankreg *reg));
- # if defined(FEAT_VISUAL) || defined(FEAT_EVAL)
  static void	may_set_selection __ARGS((void));
- # endif
  #endif
  static void	dis_msg __ARGS((char_u *p, int skip_esc));
  #if defined(FEAT_COMMENTS) || defined(PROTO)
  static char_u	*skip_comment __ARGS((char_u *line, int process, int include_space, int *is_comment));
  #endif
- #ifdef FEAT_VISUAL
  static void	block_prep __ARGS((oparg_T *oap, struct block_def *, linenr_T, int));
- #endif
  #if defined(FEAT_CLIPBOARD) || defined(FEAT_EVAL)
  static void	str_to_reg __ARGS((struct yankreg *y_ptr, int type, char_u *str, long len, long blocklen));
  #endif
--- 105,117 ----
***************
*** 187,193 ****
      return i;
  }
  
- #if defined(FEAT_VISUAL) || defined(PROTO)
  /*
   * Return TRUE if operator "op" always works on whole lines.
   */
--- 181,186 ----
***************
*** 197,203 ****
  {
      return opchars[op][2];
  }
- #endif
  
  /*
   * Get first operator command character.
--- 190,195 ----
***************
*** 232,249 ****
      long	    i;
      int		    first_char;
      char_u	    *s;
- #ifdef FEAT_VISUAL
      int		    block_col = 0;
- #endif
  
      if (u_save((linenr_T)(oap->start.lnum - 1),
  				       (linenr_T)(oap->end.lnum + 1)) == FAIL)
  	return;
  
- #ifdef FEAT_VISUAL
      if (oap->block_mode)
  	block_col = curwin->w_cursor.col;
- #endif
  
      for (i = oap->line_count; --i >= 0; )
      {
--- 224,237 ----
***************
*** 272,286 ****
      foldOpenCursor();
  #endif
  
- #ifdef FEAT_VISUAL
      if (oap->block_mode)
      {
  	curwin->w_cursor.lnum = oap->start.lnum;
  	curwin->w_cursor.col = block_col;
      }
!     else
! #endif
! 	if (curs_top)	    /* put cursor on first line, for ">>" */
      {
  	curwin->w_cursor.lnum = oap->start.lnum;
  	beginline(BL_SOL | BL_FIX);   /* shift_line() may have set cursor.col */
--- 260,271 ----
      foldOpenCursor();
  #endif
  
      if (oap->block_mode)
      {
  	curwin->w_cursor.lnum = oap->start.lnum;
  	curwin->w_cursor.col = block_col;
      }
!     else if (curs_top)	    /* put cursor on first line, for ">>" */
      {
  	curwin->w_cursor.lnum = oap->start.lnum;
  	beginline(BL_SOL | BL_FIX);   /* shift_line() may have set cursor.col */
***************
*** 733,746 ****
       * there is no change still need to remove the Visual highlighting. */
      if (last_changed != 0)
  	changed_lines(first_changed, 0,
- #ifdef FEAT_VISUAL
  		oap->is_VIsual ? start_lnum + oap->line_count :
- #endif
  		last_changed + 1, 0L);
- #ifdef FEAT_VISUAL
      else if (oap->is_VIsual)
  	redraw_curbuf_later(INVERTED);
- #endif
  
      if (oap->line_count > p_report)
      {
--- 718,727 ----
***************
*** 948,954 ****
  }
  #endif
  
- #if defined(FEAT_VISUAL) || defined(PROTO)
  /*
   * Obtain the contents of a "normal" register. The register is made empty.
   * The returned pointer has allocated memory, use put_register() later.
--- 929,934 ----
***************
*** 1016,1025 ****
      *y_current = *(struct yankreg *)reg;
      vim_free(reg);
  
! # ifdef FEAT_CLIPBOARD
      /* Send text written to clipboard register to the clipboard. */
      may_set_selection();
! # endif
  }
  
      void
--- 996,1005 ----
      *y_current = *(struct yankreg *)reg;
      vim_free(reg);
  
! #ifdef FEAT_CLIPBOARD
      /* Send text written to clipboard register to the clipboard. */
      may_set_selection();
! #endif
  }
  
      void
***************
*** 1034,1040 ****
      vim_free(reg);
      *y_current = tmp;
  }
- #endif
  
  #if defined(FEAT_MOUSE) || defined(PROTO)
  /*
--- 1014,1019 ----
***************
*** 1634,1643 ****
      int			n;
      linenr_T		lnum;
      char_u		*ptr;
- #ifdef FEAT_VISUAL
      char_u		*newp, *oldp;
      struct block_def	bd;
- #endif
      linenr_T		old_lcount = curbuf->b_ml.ml_line_count;
      int			did_yank = FALSE;
      int			orig_regname = oap->regname;
--- 1613,1620 ----
***************
*** 1670,1679 ****
       * delete linewise.  Don't do this for the change command or Visual mode.
       */
      if (       oap->motion_type == MCHAR
- #ifdef FEAT_VISUAL
  	    && !oap->is_VIsual
  	    && !oap->block_mode
- #endif
  	    && oap->line_count > 1
  	    && oap->motion_force == NUL
  	    && oap->op_type == OP_DELETE)
--- 1647,1654 ----
***************
*** 1787,1793 ****
  	}
      }
  
- #ifdef FEAT_VISUAL
      /*
       * block mode delete
       */
--- 1762,1767 ----
***************
*** 1838,1846 ****
  						       oap->end.lnum + 1, 0L);
  	oap->line_count = 0;	    /* no lines deleted */
      }
!     else
! #endif
! 	if (oap->motion_type == MLINE)
      {
  	if (oap->op_type == OP_CHANGE)
  	{
--- 1812,1818 ----
  						       oap->end.lnum + 1, 0L);
  	oap->line_count = 0;	    /* no lines deleted */
      }
!     else if (oap->motion_type == MLINE)
      {
  	if (oap->op_type == OP_CHANGE)
  	{
***************
*** 1924,1936 ****
  		return FAIL;
  
  	    /* if 'cpoptions' contains '$', display '$' at end of change */
! 	    if (	   vim_strchr(p_cpo, CPO_DOLLAR) != NULL
  		    && oap->op_type == OP_CHANGE
  		    && oap->end.lnum == curwin->w_cursor.lnum
! #ifdef FEAT_VISUAL
! 		    && !oap->is_VIsual
! #endif
! 		    )
  		display_dollar(oap->end.col - !oap->inclusive);
  
  	    n = oap->end.col - oap->start.col + 1 - !oap->inclusive;
--- 1896,1905 ----
  		return FAIL;
  
  	    /* if 'cpoptions' contains '$', display '$' at end of change */
! 	    if (       vim_strchr(p_cpo, CPO_DOLLAR) != NULL
  		    && oap->op_type == OP_CHANGE
  		    && oap->end.lnum == curwin->w_cursor.lnum
! 		    && !oap->is_VIsual)
  		display_dollar(oap->end.col - !oap->inclusive);
  
  	    n = oap->end.col - oap->start.col + 1 - !oap->inclusive;
***************
*** 1967,1977 ****
  	    }
  	    else
  	    {
! 		(void)del_bytes((long)n, !virtual_op, oap->op_type == OP_DELETE
! #ifdef FEAT_VISUAL
! 				    && !oap->is_VIsual
! #endif
! 							);
  	    }
  	}
  	else				/* delete characters between lines */
--- 1936,1943 ----
  	    }
  	    else
  	    {
! 		(void)del_bytes((long)n, !virtual_op,
! 				oap->op_type == OP_DELETE && !oap->is_VIsual);
  	    }
  	}
  	else				/* delete characters between lines */
***************
*** 2008,2018 ****
  	    {
  		/* delete from start of line until op_end */
  		curwin->w_cursor.col = 0;
! 		(void)del_bytes((long)n, !virtual_op, oap->op_type == OP_DELETE
! #ifdef FEAT_VISUAL
! 					&& !oap->is_VIsual
! #endif
! 							    );
  		curwin->w_cursor = curpos;	/* restore curwin->w_cursor */
  	    }
  	    if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
--- 1974,1981 ----
  	    {
  		/* delete from start of line until op_end */
  		curwin->w_cursor.col = 0;
! 		(void)del_bytes((long)n, !virtual_op,
! 				oap->op_type == OP_DELETE && !oap->is_VIsual);
  		curwin->w_cursor = curpos;	/* restore curwin->w_cursor */
  	    }
  	    if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
***************
*** 2025,2038 ****
  #ifdef FEAT_VIRTUALEDIT
  setmarks:
  #endif
- #ifdef FEAT_VISUAL
      if (oap->block_mode)
      {
  	curbuf->b_op_end.lnum = oap->end.lnum;
  	curbuf->b_op_end.col = oap->start.col;
      }
      else
- #endif
  	curbuf->b_op_end = oap->start;
      curbuf->b_op_start = oap->start;
  
--- 1988,1999 ----
***************
*** 2318,2326 ****
      oparg_T	*oap;
  {
      pos_T		pos;
- #ifdef FEAT_VISUAL
      struct block_def	bd;
- #endif
      int			did_change = FALSE;
  
      if (u_save((linenr_T)(oap->start.lnum - 1),
--- 2279,2285 ----
***************
*** 2328,2334 ****
  	return;
  
      pos = oap->start;
- #ifdef FEAT_VISUAL
      if (oap->block_mode)		    /* Visual block mode */
      {
  	for (; pos.lnum <= oap->end.lnum; ++pos.lnum)
--- 2287,2292 ----
***************
*** 2340,2346 ****
  	    one_change = swapchars(oap->op_type, &pos, bd.textlen);
  	    did_change |= one_change;
  
! # ifdef FEAT_NETBEANS_INTG
  	    if (netbeans_active() && one_change)
  	    {
  		char_u *ptr = ml_get_buf(curbuf, pos.lnum, FALSE);
--- 2298,2304 ----
  	    one_change = swapchars(oap->op_type, &pos, bd.textlen);
  	    did_change |= one_change;
  
! #ifdef FEAT_NETBEANS_INTG
  	    if (netbeans_active() && one_change)
  	    {
  		char_u *ptr = ml_get_buf(curbuf, pos.lnum, FALSE);
***************
*** 2350,2362 ****
  		netbeans_inserted(curbuf, pos.lnum, bd.textcol,
  						&ptr[bd.textcol], bd.textlen);
  	    }
! # endif
  	}
  	if (did_change)
  	    changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L);
      }
      else				    /* not block mode */
- #endif
      {
  	if (oap->motion_type == MLINE)
  	{
--- 2308,2319 ----
  		netbeans_inserted(curbuf, pos.lnum, bd.textcol,
  						&ptr[bd.textcol], bd.textlen);
  	    }
! #endif
  	}
  	if (did_change)
  	    changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L);
      }
      else				    /* not block mode */
      {
  	if (oap->motion_type == MLINE)
  	{
***************
*** 2412,2422 ****
  	}
      }
  
- #ifdef FEAT_VISUAL
      if (!did_change && oap->is_VIsual)
  	/* No change: need to remove the Visual selection */
  	redraw_curbuf_later(INVERTED);
- #endif
  
      /*
       * Set '[ and '] marks.
--- 2369,2377 ----
***************
*** 3018,3027 ****
      if (       oap->motion_type == MCHAR
  	    && oap->start.col == 0
  	    && !oap->inclusive
- #ifdef FEAT_VISUAL
  	    && (!oap->is_VIsual || *p_sel == 'o')
  	    && !oap->block_mode
- #endif
  	    && oap->end.col == 0
  	    && yanklines > 1)
      {
--- 2973,2980 ----
***************
*** 3032,3040 ****
  
      y_current->y_size = yanklines;
      y_current->y_type = yanktype;   /* set the yank register type */
- #ifdef FEAT_VISUAL
      y_current->y_width = 0;
- #endif
      y_current->y_array = (char_u **)lalloc_clear((long_u)(sizeof(char_u *) *
  							    yanklines), TRUE);
  
--- 2985,2991 ----
***************
*** 3047,3053 ****
      y_idx = 0;
      lnum = oap->start.lnum;
  
- #ifdef FEAT_VISUAL
      if (oap->block_mode)
      {
  	/* Visual block mode */
--- 2998,3003 ----
***************
*** 3057,3075 ****
  	if (curwin->w_curswant == MAXCOL && y_current->y_width > 0)
  	    y_current->y_width--;
      }
- #endif
  
      for ( ; lnum <= yankendlnum; lnum++, y_idx++)
      {
  	switch (y_current->y_type)
  	{
- #ifdef FEAT_VISUAL
  	    case MBLOCK:
  		block_prep(oap, &bd, lnum, FALSE);
  		if (yank_copy_line(&bd, y_idx) == FAIL)
  		    goto fail;
  		break;
- #endif
  
  	    case MLINE:
  		if ((y_current->y_array[y_idx] =
--- 3007,3022 ----
***************
*** 3206,3214 ****
      if (mess)			/* Display message about yank? */
      {
  	if (yanktype == MCHAR
- #ifdef FEAT_VISUAL
  		&& !oap->block_mode
- #endif
  		&& yanklines == 1)
  	    yanklines = 0;
  	/* Some versions of Vi use ">=" here, some don't...  */
--- 3153,3159 ----
***************
*** 3218,3234 ****
  	    update_topline_redraw();
  	    if (yanklines == 1)
  	    {
- #ifdef FEAT_VISUAL
  		if (oap->block_mode)
  		    MSG(_("block of 1 line yanked"));
  		else
- #endif
  		    MSG(_("1 line yanked"));
  	    }
- #ifdef FEAT_VISUAL
  	    else if (oap->block_mode)
  		smsg((char_u *)_("block of %ld lines yanked"), yanklines);
- #endif
  	    else
  		smsg((char_u *)_("%ld lines yanked"), yanklines);
  	}
--- 3163,3175 ----
***************
*** 3239,3249 ****
       */
      curbuf->b_op_start = oap->start;
      curbuf->b_op_end = oap->end;
!     if (yanktype == MLINE
! #ifdef FEAT_VISUAL
! 		&& !oap->block_mode
! #endif
!        )
      {
  	curbuf->b_op_start.col = 0;
  	curbuf->b_op_end.col = MAXCOL;
--- 3180,3186 ----
       */
      curbuf->b_op_start = oap->start;
      curbuf->b_op_end = oap->end;
!     if (yanktype == MLINE && !oap->block_mode)
      {
  	curbuf->b_op_start.col = 0;
  	curbuf->b_op_end.col = MAXCOL;
***************
*** 3380,3386 ****
      long	i;			/* index in y_array[] */
      int		y_type;
      long	y_size;
- #ifdef FEAT_VISUAL
      int		oldlen;
      long	y_width = 0;
      colnr_T	vcol;
--- 3317,3322 ----
***************
*** 3388,3394 ****
      int		incr = 0;
      long	j;
      struct block_def bd;
- #endif
      char_u	**y_array = NULL;
      long	nr_lines = 0;
      pos_T	new_cursor;
--- 3324,3329 ----
***************
*** 3497,3510 ****
  	get_yank_register(regname, FALSE);
  
  	y_type = y_current->y_type;
- #ifdef FEAT_VISUAL
  	y_width = y_current->y_width;
- #endif
  	y_size = y_current->y_size;
  	y_array = y_current->y_array;
      }
  
- #ifdef FEAT_VISUAL
      if (y_type == MLINE)
      {
  	if (flags & PUT_LINE_SPLIT)
--- 3432,3442 ----
***************
*** 3535,3541 ****
  	curbuf->b_op_start = curwin->w_cursor;	/* default for '[ mark */
  	curbuf->b_op_end = curwin->w_cursor;	/* default for '] mark */
      }
- #endif
  
      if (flags & PUT_LINE)	/* :put command or "p" in Visual line mode. */
  	y_type = MLINE;
--- 3467,3472 ----
***************
*** 3547,3553 ****
  	goto end;
      }
  
- #ifdef FEAT_VISUAL
      if (y_type == MBLOCK)
      {
  	lnum = curwin->w_cursor.lnum + y_size + 1;
--- 3478,3483 ----
***************
*** 3556,3564 ****
  	if (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)
  	    goto end;
      }
!     else
! #endif
! 	if (y_type == MLINE)
      {
  	lnum = curwin->w_cursor.lnum;
  #ifdef FEAT_FOLDING
--- 3486,3492 ----
  	if (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)
  	    goto end;
      }
!     else if (y_type == MLINE)
      {
  	lnum = curwin->w_cursor.lnum;
  #ifdef FEAT_FOLDING
***************
*** 3610,3616 ****
      lnum = curwin->w_cursor.lnum;
      col = curwin->w_cursor.col;
  
- #ifdef FEAT_VISUAL
      /*
       * Block mode
       */
--- 3538,3543 ----
***************
*** 3792,3798 ****
  	    curwin->w_cursor.lnum = lnum;
      }
      else
- #endif
      {
  	/*
  	 * Character or Line mode
--- 3719,3724 ----
***************
*** 3866,3882 ****
  			curwin->w_cursor.col += (colnr_T)(totlen - 1);
  		    }
  		}
- #ifdef FEAT_VISUAL
  		if (VIsual_active)
  		    lnum++;
! #endif
! 	    } while (
! #ifdef FEAT_VISUAL
! 		    VIsual_active && lnum <= curbuf->b_visual.vi_end.lnum
! #else
! 		    FALSE /* stop after 1 paste */
! #endif
! 		    );
  
  	    curbuf->b_op_end = curwin->w_cursor;
  	    /* For "CTRL-O p" in Insert mode, put cursor after last char */
--- 3792,3800 ----
  			curwin->w_cursor.col += (colnr_T)(totlen - 1);
  		    }
  		}
  		if (VIsual_active)
  		    lnum++;
! 	    } while (VIsual_active && lnum <= curbuf->b_visual.vi_end.lnum);
  
  	    curbuf->b_op_end = curwin->w_cursor;
  	    /* For "CTRL-O p" in Insert mode, put cursor after last char */
***************
*** 4038,4046 ****
      if (regname == '=')
  	vim_free(y_array);
  
- #ifdef FEAT_VISUAL
      VIsual_active = FALSE;
- #endif
  
      /* If the cursor is past the end of the line put it at the end. */
      adjust_cursor_eol();
--- 3956,3962 ----
***************
*** 4729,4739 ****
  	return;
      curwin->w_cursor = oap->start;
  
- #ifdef FEAT_VISUAL
      if (oap->is_VIsual)
  	/* When there is no change: need to remove the Visual selection */
  	redraw_curbuf_later(INVERTED);
- #endif
  
      /* Set '[ mark at the start of the formatted area */
      curbuf->b_op_start = oap->start;
--- 4645,4653 ----
***************
*** 4765,4771 ****
  	saved_cursor.lnum = 0;
      }
  
- #ifdef FEAT_VISUAL
      if (oap->is_VIsual)
      {
  	win_T	*wp;
--- 4679,4684 ----
***************
*** 4783,4789 ****
  	    }
  	}
      }
- #endif
  }
  
  #if defined(FEAT_EVAL) || defined(PROTO)
--- 4696,4701 ----
***************
*** 4794,4804 ****
  op_formatexpr(oap)
      oparg_T	*oap;
  {
- # ifdef FEAT_VISUAL
      if (oap->is_VIsual)
  	/* When there is no change: need to remove the Visual selection */
  	redraw_curbuf_later(INVERTED);
- # endif
  
      if (fex_format(oap->start.lnum, oap->line_count, NUL) != 0)
  	/* As documented: when 'formatexpr' returns non-zero fall back to
--- 4706,4714 ----
***************
*** 5238,5244 ****
      return FALSE;
  }
  
- #ifdef FEAT_VISUAL
  /*
   * prepare a few things for block mode yank/delete/tilde
   *
--- 5148,5153 ----
***************
*** 5397,5403 ****
      bdp->textcol = (colnr_T) (pstart - line);
      bdp->textstart = pstart;
  }
- #endif /* FEAT_VISUAL */
  
  #ifdef FEAT_RIGHTLEFT
  static void reverse_line __ARGS((char_u *s));
--- 5306,5311 ----
***************
*** 5748,5766 ****
  	str = skipwhite(skiptowhite(str));
  	if (STRNCMP(str, "CHAR", 4) == 0)
  	    y_current->y_type = MCHAR;
- #ifdef FEAT_VISUAL
  	else if (STRNCMP(str, "BLOCK", 5) == 0)
  	    y_current->y_type = MBLOCK;
- #endif
  	else
  	    y_current->y_type = MLINE;
  	/* get the block width; if it's missing we get a zero, which is OK */
  	str = skipwhite(skiptowhite(str));
- #ifdef FEAT_VISUAL
  	y_current->y_width = getdigits(&str);
- #else
- 	(void)getdigits(&str);
- #endif
      }
  
      while (!(eof = viminfo_readline(virp))
--- 5656,5668 ----
***************
*** 5868,5878 ****
  	    case MCHAR:
  		type = (char_u *)"CHAR";
  		break;
- #ifdef FEAT_VISUAL
  	    case MBLOCK:
  		type = (char_u *)"BLOCK";
  		break;
- #endif
  	    default:
  		sprintf((char *)IObuff, _("E574: Unknown register type %d"),
  							    y_regs[i].y_type);
--- 5770,5778 ----
***************
*** 5886,5898 ****
  	fprintf(fp, "\"%c", c);
  	if (c == execreg_lastc)
  	    fprintf(fp, "@");
! 	fprintf(fp, "\t%s\t%d\n", type,
! #ifdef FEAT_VISUAL
! 		    (int)y_regs[i].y_width
! #else
! 		    0
! #endif
! 		    );
  
  	/* If max_num_lines < 0, then we save ALL the lines in the register */
  	if (max_num_lines > 0 && num_lines > max_num_lines)
--- 5786,5792 ----
  	fprintf(fp, "\"%c", c);
  	if (c == execreg_lastc)
  	    fprintf(fp, "@");
! 	fprintf(fp, "\t%s\t%d\n", type, (int)y_regs[i].y_width);
  
  	/* If max_num_lines < 0, then we save ALL the lines in the register */
  	if (max_num_lines > 0 && num_lines > max_num_lines)
***************
*** 6039,6048 ****
  {
      struct yankreg *old_y_previous, *old_y_current;
      pos_T	old_cursor;
- #ifdef FEAT_VISUAL
      pos_T	old_visual;
      int		old_visual_mode;
- #endif
      colnr_T	old_curswant;
      int		old_set_curswant;
      pos_T	old_op_start, old_op_end;
--- 5933,5940 ----
***************
*** 6063,6072 ****
  	old_set_curswant = curwin->w_set_curswant;
  	old_op_start = curbuf->b_op_start;
  	old_op_end = curbuf->b_op_end;
- #ifdef FEAT_VISUAL
  	old_visual = VIsual;
  	old_visual_mode = VIsual_mode;
- #endif
  	clear_oparg(&oa);
  	oa.regname = (cbd == &clip_plus ? '+' : '*');
  	oa.op_type = OP_YANK;
--- 5955,5962 ----
***************
*** 6084,6093 ****
  	curwin->w_set_curswant = old_set_curswant;
  	curbuf->b_op_start = old_op_start;
  	curbuf->b_op_end = old_op_end;
- #ifdef FEAT_VISUAL
  	VIsual = old_visual;
  	VIsual_mode = old_visual_mode;
- #endif
      }
      else
      {
--- 5974,5981 ----
***************
*** 6190,6196 ****
  }
  
  
- # if defined(FEAT_VISUAL) || defined(FEAT_EVAL)
  /*
   * If we have written to a clipboard register, send the text to the clipboard.
   */
--- 6078,6083 ----
***************
*** 6208,6214 ****
  	clip_gen_set_selection(&clip_plus);
      }
  }
- # endif
  
  #endif /* FEAT_CLIPBOARD || PROTO */
  
--- 6095,6100 ----
***************
*** 6273,6282 ****
  
      if (y_current->y_array != NULL)
      {
- #ifdef FEAT_VISUAL
  	if (reglen != NULL && y_current->y_type == MBLOCK)
  	    *reglen = y_current->y_width;
- #endif
  	return y_current->y_type;
      }
      return MAUTO;
--- 6159,6166 ----
***************
*** 6454,6464 ****
      get_yank_register(name, TRUE);
      if (!y_append && !must_append)
  	free_yank_all();
- #ifndef FEAT_VISUAL
-     /* Just in case - make sure we don't use MBLOCK */
-     if (yank_type == MBLOCK)
- 	yank_type = MAUTO;
- #endif
      str_to_reg(y_current, yank_type, str, len, block_len);
  
  # ifdef FEAT_CLIPBOARD
--- 6338,6343 ----
***************
*** 6496,6504 ****
      int		append = FALSE;		/* append to last line in register */
      char_u	*s;
      char_u	**pp;
- #ifdef FEAT_VISUAL
      long	maxlen;
- #endif
  
      if (y_ptr->y_array == NULL)		/* NULL means empty register */
  	y_ptr->y_size = 0;
--- 6375,6381 ----
***************
*** 6539,6547 ****
  	pp[lnum] = y_ptr->y_array[lnum];
      vim_free(y_ptr->y_array);
      y_ptr->y_array = pp;
- #ifdef FEAT_VISUAL
      maxlen = 0;
- #endif
  
      /*
       * Find the end of each line and save it into the array.
--- 6416,6422 ----
***************
*** 6552,6561 ****
  	    if (str[i] == '\n')
  		break;
  	i -= start;			/* i is now length of line */
- #ifdef FEAT_VISUAL
  	if (i > maxlen)
  	    maxlen = i;
- #endif
  	if (append)
  	{
  	    --lnum;
--- 6427,6434 ----
***************
*** 6585,6596 ****
      }
      y_ptr->y_type = type;
      y_ptr->y_size = lnum;
- # ifdef FEAT_VISUAL
      if (type == MBLOCK)
  	y_ptr->y_width = (blocklen < 0 ? maxlen - 1 : blocklen);
      else
  	y_ptr->y_width = 0;
- # endif
  }
  #endif /* FEAT_CLIPBOARD || FEAT_EVAL || PROTO */
  
--- 6458,6467 ----
***************
*** 6684,6695 ****
      long	word_count_cursor = 0;
      int		eol_size;
      long	last_check = 100000L;
- #ifdef FEAT_VISUAL
      long	line_count_selected = 0;
      pos_T	min_pos, max_pos;
      oparg_T	oparg;
      struct block_def	bd;
- #endif
  
      /*
       * Compute the length of the file in characters.
--- 6555,6564 ----
***************
*** 6705,6711 ****
  	else
  	    eol_size = 1;
  
- #ifdef FEAT_VISUAL
  	if (VIsual_active)
  	{
  	    if (lt(VIsual, curwin->w_cursor))
--- 6574,6579 ----
***************
*** 6749,6755 ****
  	    }
  	    line_count_selected = max_pos.lnum - min_pos.lnum + 1;
  	}
- #endif
  
  	for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)
  	{
--- 6617,6622 ----
***************
*** 6762,6768 ****
  		last_check = byte_count + 100000L;
  	    }
  
- #ifdef FEAT_VISUAL
  	    /* Do extra processing for VIsual mode. */
  	    if (VIsual_active
  		    && lnum >= min_pos.lnum && lnum <= max_pos.lnum)
--- 6629,6634 ----
***************
*** 6773,6785 ****
  		switch (VIsual_mode)
  		{
  		    case Ctrl_V:
! # ifdef FEAT_VIRTUALEDIT
  			virtual_op = virtual_active();
! # endif
  			block_prep(&oparg, &bd, lnum, 0);
! # ifdef FEAT_VIRTUALEDIT
  			virtual_op = MAYBE;
! # endif
  			s = bd.textstart;
  			len = (long)bd.textlen;
  			break;
--- 6639,6651 ----
  		switch (VIsual_mode)
  		{
  		    case Ctrl_V:
! #ifdef FEAT_VIRTUALEDIT
  			virtual_op = virtual_active();
! #endif
  			block_prep(&oparg, &bd, lnum, 0);
! #ifdef FEAT_VIRTUALEDIT
  			virtual_op = MAYBE;
! #endif
  			s = bd.textstart;
  			len = (long)bd.textlen;
  			break;
***************
*** 6811,6817 ****
  		}
  	    }
  	    else
- #endif
  	    {
  		/* In non-visual mode, check for the line the cursor is on */
  		if (lnum == curwin->w_cursor.lnum)
--- 6677,6682 ----
***************
*** 6833,6839 ****
  	if (!curbuf->b_p_eol && curbuf->b_p_bin)
  	    byte_count -= eol_size;
  
- #ifdef FEAT_VISUAL
  	if (VIsual_active)
  	{
  	    if (VIsual_mode == Ctrl_V && curwin->w_curswant < MAXCOL)
--- 6698,6703 ----
***************
*** 6864,6870 ****
  			byte_count_cursor, byte_count);
  	}
  	else
- #endif
  	{
  	    p = ml_get_curline();
  	    validate_virtcol();
--- 6728,6733 ----
*** ../vim-7.4.211/src/option.c	2014-03-12 18:55:52.100906804 +0100
--- src/option.c	2014-03-23 13:28:12.359168452 +0100
***************
*** 1629,1639 ****
  #endif
  			    SCRIPTID_INIT},
      {"keymodel",    "km",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
- #ifdef FEAT_VISUAL
  			    (char_u *)&p_km, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"keywordprg",  "kp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_kp, PV_KP,
--- 1629,1635 ----
***************
*** 2190,2208 ****
  			    (char_u *)&p_secure, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"selection",   "sel",  P_STRING|P_VI_DEF,
- #ifdef FEAT_VISUAL
  			    (char_u *)&p_sel, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)"inclusive", (char_u *)0L}
  			    SCRIPTID_INIT},
      {"selectmode",  "slm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
- #ifdef FEAT_VISUAL
  			    (char_u *)&p_slm, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"sessionoptions", "ssop", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_SESSION
--- 2186,2196 ----
***************
*** 2979,2991 ****
  static char *(p_wak_values[]) = {"yes", "menu", "no", NULL};
  #endif
  static char *(p_mousem_values[]) = {"extend", "popup", "popup_setpos", "mac", NULL};
- #ifdef FEAT_VISUAL
  static char *(p_sel_values[]) = {"inclusive", "exclusive", "old", NULL};
  static char *(p_slm_values[]) = {"mouse", "key", "cmd", NULL};
- #endif
- #ifdef FEAT_VISUAL
  static char *(p_km_values[]) = {"startsel", "stopsel", NULL};
- #endif
  #ifdef FEAT_BROWSE
  static char *(p_bsdir_values[]) = {"current", "last", "buffer", NULL};
  #endif
--- 2967,2975 ----
***************
*** 6578,6584 ****
      }
  #endif
  
- #ifdef FEAT_VISUAL
      /* 'selection' */
      else if (varp == &p_sel)
      {
--- 6562,6567 ----
***************
*** 6593,6599 ****
  	if (check_opt_strings(p_slm, p_slm_values, TRUE) != OK)
  	    errmsg = e_invarg;
      }
- #endif
  
  #ifdef FEAT_BROWSE
      /* 'browsedir' */
--- 6576,6581 ----
***************
*** 6605,6611 ****
      }
  #endif
  
- #ifdef FEAT_VISUAL
      /* 'keymodel' */
      else if (varp == &p_km)
      {
--- 6587,6592 ----
***************
*** 6617,6623 ****
  	    km_startsel = (vim_strchr(p_km, 'a') != NULL);
  	}
      }
- #endif
  
      /* 'mousemodel' */
      else if (varp == &p_mousem)
--- 6598,6603 ----
*** ../vim-7.4.211/src/os_msdos.c	2013-05-06 04:06:04.000000000 +0200
--- src/os_msdos.c	2014-03-23 13:28:24.855168644 +0100
***************
*** 2270,2278 ****
  		default:
  		case 'L':	type = MLINE;	break;
  		case 'C':	type = MCHAR;	break;
- #ifdef FEAT_VISUAL
  		case 'B':	type = MBLOCK;	break;
- #endif
  	    }
  	}
  
--- 2270,2276 ----
***************
*** 2799,2807 ****
  	    default:
  	    case MLINE:	    clip_sel_type = "L";	break;
  	    case MCHAR:	    clip_sel_type = "C";	break;
- #ifdef FEAT_VISUAL
  	    case MBLOCK:    clip_sel_type = "B";	break;
- #endif
  	}
  
  	movedata(
--- 2797,2803 ----
*** ../vim-7.4.211/src/os_qnx.c	2011-09-21 19:48:08.000000000 +0200
--- src/os_qnx.c	2014-03-23 13:28:38.815168858 +0100
***************
*** 78,86 ****
  		default: /* fallthrough to line type */
  		case 'L': type = MLINE; break;
  		case 'C': type = MCHAR; break;
- #ifdef FEAT_VISUAL
  		case 'B': type = MBLOCK; break;
- #endif
  	    }
  	    is_type_set = TRUE;
  	}
--- 78,84 ----
***************
*** 143,151 ****
  		default: /* fallthrough to MLINE */
  		case MLINE:	*vim_clip = 'L'; break;
  		case MCHAR:	*vim_clip = 'C'; break;
- #ifdef FEAT_VISUAL
  		case MBLOCK:	*vim_clip = 'B'; break;
- #endif
  	    }
  
  	    vim_strncpy(text_clip, str, len);
--- 141,147 ----
*** ../vim-7.4.211/src/quickfix.c	2014-03-12 19:41:37.096948866 +0100
--- src/quickfix.c	2014-03-23 13:28:50.907169043 +0100
***************
*** 2347,2355 ****
      else
  	height = QF_WINHEIGHT;
  
- #ifdef FEAT_VISUAL
      reset_VIsual_and_resel();			/* stop Visual mode */
- #endif
  #ifdef FEAT_GUI
      need_mouse_correct = TRUE;
  #endif
--- 2347,2353 ----
*** ../vim-7.4.211/src/regexp.c	2013-11-21 17:12:55.000000000 +0100
--- src/regexp.c	2014-03-23 13:29:14.495169404 +0100
***************
*** 4179,4187 ****
  			    - (*mb_head_off)(regline, reginput - 1), reg_buf);
      return -1;
  }
- 
  #endif
! #ifdef FEAT_VISUAL
  static int reg_match_visual __ARGS((void));
  
  /*
--- 4179,4186 ----
  			    - (*mb_head_off)(regline, reginput - 1), reg_buf);
      return -1;
  }
  #endif
! 
  static int reg_match_visual __ARGS((void));
  
  /*
***************
*** 4258,4264 ****
      }
      return TRUE;
  }
- #endif
  
  #define ADVANCE_REGINPUT() mb_ptr_adv(reginput)
  
--- 4257,4262 ----
***************
*** 4440,4448 ****
  	    break;
  
  	  case RE_VISUAL:
- #ifdef FEAT_VISUAL
  	    if (!reg_match_visual())
- #endif
  		status = RA_NOMATCH;
  	    break;
  
--- 4438,4444 ----
*** ../vim-7.4.211/src/regexp_nfa.c	2013-11-28 14:20:11.000000000 +0100
--- src/regexp_nfa.c	2014-03-23 13:29:31.367169663 +0100
***************
*** 6403,6416 ****
  		break;
  
  	    case NFA_VISUAL:
- #ifdef FEAT_VISUAL
  		result = reg_match_visual();
  		if (result)
  		{
  		    add_here = TRUE;
  		    add_state = t->state->out;
  		}
- #endif
  		break;
  
  	    case NFA_MOPEN1:
--- 6403,6414 ----
*** ../vim-7.4.211/src/screen.c	2013-12-11 15:51:54.000000000 +0100
--- src/screen.c	2014-03-23 13:32:10.787172106 +0100
***************
*** 446,453 ****
  #endif
  }
  
- #if defined(FEAT_RUBY) || defined(FEAT_PERL) || defined(FEAT_VISUAL) || \
-     (defined(FEAT_CLIPBOARD) && defined(FEAT_X11)) || defined(PROTO)
  /*
   * update all windows that are editing the current buffer
   */
--- 446,451 ----
***************
*** 458,464 ****
      redraw_curbuf_later(type);
      update_screen(type);
  }
- #endif
  
  /*
   * update_screen()
--- 456,461 ----
***************
*** 596,609 ****
  		    && curwin->w_botfill == curwin->w_old_botfill
  #endif
  		    && curwin->w_topline == curwin->w_lines[0].wl_lnum)
- #ifdef FEAT_VISUAL
  		|| (type == INVERTED
  		    && VIsual_active
  		    && curwin->w_old_cursor_lnum == curwin->w_cursor.lnum
  		    && curwin->w_old_visual_mode == VIsual_mode
  		    && (curwin->w_valid & VALID_VIRTCOL)
  		    && curwin->w_old_curswant == curwin->w_curswant)
- #endif
  		))
  	curwin->w_redr_type = type;
  
--- 593,604 ----
***************
*** 1030,1039 ****
  				   updating.  0 when no mid area updating. */
      int		bot_start = 999;/* first row of the bot area that needs
  				   updating.  999 when no bot area updating */
- #ifdef FEAT_VISUAL
      int		scrolled_down = FALSE;	/* TRUE when scrolled down when
  					   w_topline got smaller a bit */
- #endif
  #ifdef FEAT_SEARCH_EXTRA
      matchitem_T *cur;		/* points to the match list */
      int		top_to_mod = FALSE;    /* redraw above mod_top */
--- 1025,1032 ----
***************
*** 1354,1362 ****
  			    /* Need to update rows that are new, stop at the
  			     * first one that scrolled down. */
  			    top_end = i;
- #ifdef FEAT_VISUAL
  			    scrolled_down = TRUE;
- #endif
  
  			    /* Move the entries that were scrolled, disable
  			     * the entries for the lines to be redrawn. */
--- 1347,1353 ----
***************
*** 1513,1519 ****
  	type = NOT_VALID;
      }
  
- #ifdef FEAT_VISUAL
      /* check if we are updating or removing the inverted part */
      if ((VIsual_active && buf == curwin->w_buffer)
  	    || (wp->w_old_cursor_lnum != 0 && type != NOT_VALID))
--- 1504,1509 ----
***************
*** 1708,1714 ****
  	wp->w_old_visual_lnum = 0;
  	wp->w_old_visual_col = 0;
      }
- #endif /* FEAT_VISUAL */
  
  #if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)
      /* reset got_int, otherwise regexp won't work */
--- 1698,1703 ----
***************
*** 2670,2676 ****
       * 6. set highlighting for the Visual area an other text.
       * If all folded lines are in the Visual area, highlight the line.
       */
- #ifdef FEAT_VISUAL
      if (VIsual_active && wp->w_buffer == curwin->w_buffer)
      {
  	if (ltoreq(curwin->w_cursor, VIsual))
--- 2659,2664 ----
***************
*** 2718,2724 ****
  	    }
  	}
      }
- #endif
  
  #ifdef FEAT_SYN_HL
      /* Show 'cursorcolumn' in the fold line. */
--- 2706,2711 ----
***************
*** 2876,2885 ****
      int		fromcol, tocol;		/* start/end of inverting */
      int		fromcol_prev = -2;	/* start of inverting after cursor */
      int		noinvcur = FALSE;	/* don't invert the cursor */
- #ifdef FEAT_VISUAL
      pos_T	*top, *bot;
      int		lnum_in_visual_area = FALSE;
- #endif
      pos_T	pos;
      long	v;
  
--- 2863,2870 ----
***************
*** 3090,3096 ****
       */
      fromcol = -10;
      tocol = MAXCOL;
- #ifdef FEAT_VISUAL
      if (VIsual_active && wp->w_buffer == curwin->w_buffer)
      {
  					/* Visual is after curwin->w_cursor */
--- 3075,3080 ----
***************
*** 3183,3191 ****
      /*
       * handle 'incsearch' and ":s///c" highlighting
       */
!     else
! #endif /* FEAT_VISUAL */
! 	if (highlight_match
  	    && wp == curwin
  	    && lnum >= curwin->w_cursor.lnum
  	    && lnum <= curwin->w_cursor.lnum + search_match_lines)
--- 3167,3173 ----
      /*
       * handle 'incsearch' and ":s///c" highlighting
       */
!     else if (highlight_match
  	    && wp == curwin
  	    && lnum >= curwin->w_cursor.lnum
  	    && lnum <= curwin->w_cursor.lnum + search_match_lines)
***************
*** 3324,3330 ****
  	    mb_ptr_adv(ptr);
  	}
  
- #if defined(FEAT_SYN_HL) || defined(FEAT_VIRTUALEDIT) || defined(FEAT_VISUAL)
  	/* When:
  	 * - 'cuc' is set, or
  	 * - 'colorcolumn' is set, or
--- 3306,3311 ----
***************
*** 3333,3359 ****
  	 * the end of the line may be before the start of the displayed part.
  	 */
  	if (vcol < v && (
! # ifdef FEAT_SYN_HL
! 	     wp->w_p_cuc
! 	     || draw_color_col
! #  if defined(FEAT_VIRTUALEDIT) || defined(FEAT_VISUAL)
! 	     ||
! #  endif
! # endif
! # ifdef FEAT_VIRTUALEDIT
! 	     virtual_active()
! #  ifdef FEAT_VISUAL
! 	     ||
! #  endif
! # endif
! # ifdef FEAT_VISUAL
! 	     (VIsual_active && wp->w_buffer == curwin->w_buffer)
! # endif
! 	     ))
  	{
  	    vcol = v;
  	}
- #endif
  
  	/* Handle a character that's not completely on the screen: Put ptr at
  	 * that character but skip the first few screen characters. */
--- 3314,3329 ----
  	 * the end of the line may be before the start of the displayed part.
  	 */
  	if (vcol < v && (
! #ifdef FEAT_SYN_HL
! 	     wp->w_p_cuc || draw_color_col ||
! #endif
! #ifdef FEAT_VIRTUALEDIT
! 	     virtual_active() ||
! #endif
! 	     (VIsual_active && wp->w_buffer == curwin->w_buffer)))
  	{
  	    vcol = v;
  	}
  
  	/* Handle a character that's not completely on the screen: Put ptr at
  	 * that character but skip the first few screen characters. */
***************
*** 4500,4508 ****
  			&& ((wp->w_p_list && lcs_eol > 0)
  			    || ((fromcol >= 0 || fromcol_prev >= 0)
  				&& tocol > vcol
- #ifdef FEAT_VISUAL
  				&& VIsual_mode != Ctrl_V
- #endif
  				&& (
  # ifdef FEAT_RIGHTLEFT
  				    wp->w_p_rl ? (col >= 0) :
--- 4470,4476 ----
***************
*** 4854,4864 ****
  #endif
  	    if (lcs_eol == lcs_eol_one
  		    && ((area_attr != 0 && vcol == fromcol
- #ifdef FEAT_VISUAL
  			    && (VIsual_mode != Ctrl_V
  				|| lnum == VIsual.lnum
  				|| lnum == curwin->w_cursor.lnum)
- #endif
  			    && c == NUL)
  #ifdef FEAT_SEARCH_EXTRA
  			/* highlight 'hlsearch' match at end of line */
--- 4822,4830 ----
***************
*** 9659,9668 ****
      do_mode = ((p_smd && msg_silent == 0)
  	    && ((State & INSERT)
  		|| restart_edit
! #ifdef FEAT_VISUAL
! 		|| VIsual_active
! #endif
! 		));
      if (do_mode || Recording)
      {
  	/*
--- 9625,9631 ----
      do_mode = ((p_smd && msg_silent == 0)
  	    && ((State & INSERT)
  		|| restart_edit
! 		|| VIsual_active));
      if (do_mode || Recording)
      {
  	/*
***************
*** 9790,9796 ****
  		if ((State & INSERT) && p_paste)
  		    MSG_PUTS_ATTR(_(" (paste)"), attr);
  
- #ifdef FEAT_VISUAL
  		if (VIsual_active)
  		{
  		    char *p;
--- 9753,9758 ----
***************
*** 9810,9816 ****
  		    }
  		    MSG_PUTS_ATTR(_(p), attr);
  		}
- #endif
  		MSG_PUTS_ATTR(" --", attr);
  	    }
  
--- 9772,9777 ----
***************
*** 9839,9849 ****
  	msg_clr_cmdline();
  
  #ifdef FEAT_CMDL_INFO
- # ifdef FEAT_VISUAL
      /* In Visual mode the size of the selected area must be redrawn. */
      if (VIsual_active)
  	clear_showcmd();
- # endif
  
      /* If the last window has no status line, the ruler is after the mode
       * message and must be redrawn */
--- 9800,9808 ----
*** ../vim-7.4.211/src/search.c	2014-01-14 21:31:30.000000000 +0100
--- src/search.c	2014-03-23 13:34:46.351174489 +0100
***************
*** 506,512 ****
  #endif
  
  /*
!  * lowest level search function.
   * Search for 'count'th occurrence of pattern 'pat' in direction 'dir'.
   * Start at position 'pos' and return the found position in 'pos'.
   *
--- 506,512 ----
  #endif
  
  /*
!  * Lowest level search function.
   * Search for 'count'th occurrence of pattern 'pat' in direction 'dir'.
   * Start at position 'pos' and return the found position in 'pos'.
   *
***************
*** 3198,3204 ****
      cls_bigword = bigword;
      clearpos(&start_pos);
  
- #ifdef FEAT_VISUAL
      /* Correct cursor when 'selection' is exclusive */
      if (VIsual_active && *p_sel == 'e' && lt(VIsual, curwin->w_cursor))
  	dec_cursor();
--- 3198,3203 ----
***************
*** 3208,3214 ****
       * character, select the word and/or white space under the cursor.
       */
      if (!VIsual_active || equalpos(curwin->w_cursor, VIsual))
- #endif
      {
  	/*
  	 * Go to start of current word or white space.
--- 3207,3212 ----
***************
*** 3245,3251 ****
  		include_white = TRUE;
  	}
  
- #ifdef FEAT_VISUAL
  	if (VIsual_active)
  	{
  	    /* should do something when inclusive == FALSE ! */
--- 3243,3248 ----
***************
*** 3253,3259 ****
  	    redraw_curbuf_later(INVERTED);	/* update the inversion */
  	}
  	else
- #endif
  	{
  	    oap->start = start_pos;
  	    oap->motion_type = MCHAR;
--- 3250,3255 ----
***************
*** 3267,3273 ****
      while (count > 0)
      {
  	inclusive = TRUE;
- #ifdef FEAT_VISUAL
  	if (VIsual_active && lt(curwin->w_cursor, VIsual))
  	{
  	    /*
--- 3263,3268 ----
***************
*** 3288,3294 ****
  	    }
  	}
  	else
- #endif
  	{
  	    /*
  	     * Move cursor forward one word and/or white area.
--- 3283,3288 ----
***************
*** 3334,3351 ****
  	    back_in_line();
  	    if (cls() == 0 && curwin->w_cursor.col > 0)
  	    {
- #ifdef FEAT_VISUAL
  		if (VIsual_active)
  		    VIsual = curwin->w_cursor;
  		else
- #endif
  		    oap->start = curwin->w_cursor;
  	    }
  	}
  	curwin->w_cursor = pos;	/* put cursor back at end */
      }
  
- #ifdef FEAT_VISUAL
      if (VIsual_active)
      {
  	if (*p_sel == 'e' && inclusive && ltoreq(VIsual, curwin->w_cursor))
--- 3328,3342 ----
***************
*** 3357,3363 ****
  	}
      }
      else
- #endif
  	oap->inclusive = inclusive;
  
      return OK;
--- 3348,3353 ----
***************
*** 3384,3390 ****
      pos = start_pos;
      findsent(FORWARD, 1L);	/* Find start of next sentence. */
  
- #ifdef FEAT_VISUAL
      /*
       * When the Visual area is bigger than one character: Extend it.
       */
--- 3374,3379 ----
***************
*** 3471,3477 ****
  	}
  	return OK;
      }
- #endif
  
      /*
       * If the cursor started on a blank, check if it is just before the start
--- 3460,3465 ----
***************
*** 3521,3527 ****
  	    find_first_blank(&start_pos);
      }
  
- #ifdef FEAT_VISUAL
      if (VIsual_active)
      {
  	/* Avoid getting stuck with "is" on a single space before a sentence. */
--- 3509,3514 ----
***************
*** 3534,3540 ****
  	redraw_curbuf_later(INVERTED);	/* update the inversion */
      }
      else
- #endif
      {
  	/* include a newline after the sentence, if there is one */
  	if (incl(&curwin->w_cursor) == -1)
--- 3521,3526 ----
***************
*** 3574,3582 ****
      /*
       * If we start on '(', '{', ')', '}', etc., use the whole block inclusive.
       */
- #ifdef FEAT_VISUAL
      if (!VIsual_active || equalpos(VIsual, curwin->w_cursor))
- #endif
      {
  	setpcmark();
  	if (what == '{')		/* ignore indent */
--- 3560,3566 ----
***************
*** 3587,3593 ****
  	    /* cursor on '(' or '{', move cursor just after it */
  	    ++curwin->w_cursor.col;
      }
- #ifdef FEAT_VISUAL
      else if (lt(VIsual, curwin->w_cursor))
      {
  	old_start = VIsual;
--- 3571,3576 ----
***************
*** 3595,3601 ****
      }
      else
  	old_end = VIsual;
- #endif
  
      /*
       * Search backwards for unclosed '(', '{', etc..
--- 3578,3583 ----
***************
*** 3641,3647 ****
  		if (decl(&curwin->w_cursor) != 0)
  		    break;
  	    }
- #ifdef FEAT_VISUAL
  	/*
  	 * In Visual mode, when the resulting area is not bigger than what we
  	 * started with, extend it to the next block, and then exclude again.
--- 3623,3628 ----
***************
*** 3666,3676 ****
  	    curwin->w_cursor = *end_pos;
  	}
  	else
- #endif
  	    break;
      }
  
- #ifdef FEAT_VISUAL
      if (VIsual_active)
      {
  	if (*p_sel == 'e')
--- 3647,3655 ----
***************
*** 3683,3689 ****
  	showmode();
      }
      else
- #endif
      {
  	oap->start = start_pos;
  	oap->motion_type = MCHAR;
--- 3662,3667 ----
***************
*** 3807,3823 ****
      old_pos = curwin->w_cursor;
      old_end = curwin->w_cursor;		    /* remember where we started */
      old_start = old_end;
- #ifdef FEAT_VISUAL
      if (!VIsual_active || *p_sel == 'e')
- #endif
  	decl(&old_end);			    /* old_end is inclusive */
  
      /*
       * If we start on "<aaa>" select that block.
       */
- #ifdef FEAT_VISUAL
      if (!VIsual_active || equalpos(VIsual, curwin->w_cursor))
- #endif
      {
  	setpcmark();
  
--- 3785,3797 ----
***************
*** 3843,3849 ****
  	    old_end = curwin->w_cursor;
  	}
      }
- #ifdef FEAT_VISUAL
      else if (lt(VIsual, curwin->w_cursor))
      {
  	old_start = VIsual;
--- 3817,3822 ----
***************
*** 3851,3857 ****
      }
      else
  	old_end = VIsual;
- #endif
  
  again:
      /*
--- 3824,3829 ----
***************
*** 3951,3957 ****
  	}
      }
  
- #ifdef FEAT_VISUAL
      if (VIsual_active)
      {
  	/* If the end is before the start there is no text between tags, select
--- 3923,3928 ----
***************
*** 3966,3972 ****
  	showmode();
      }
      else
- #endif
      {
  	oap->start = start_pos;
  	oap->motion_type = MCHAR;
--- 3937,3942 ----
***************
*** 4010,4016 ****
  
      start_lnum = curwin->w_cursor.lnum;
  
- #ifdef FEAT_VISUAL
      /*
       * When visual area is more than one line: extend it.
       */
--- 3980,3985 ----
***************
*** 4064,4070 ****
  	curwin->w_cursor.col = 0;
  	return retval;
      }
- #endif
  
      /*
       * First move back to the start_lnum of the paragraph or white lines
--- 4033,4038 ----
***************
*** 4136,4142 ****
  	while (start_lnum > 1 && linewhite(start_lnum - 1))
  	    --start_lnum;
  
- #ifdef FEAT_VISUAL
      if (VIsual_active)
      {
  	/* Problem: when doing "Vipipip" nothing happens in a single white
--- 4104,4109 ----
***************
*** 4149,4155 ****
  	showmode();
      }
      else
- #endif
      {
  	oap->start.lnum = start_lnum;
  	oap->start.col = 0;
--- 4116,4121 ----
***************
*** 4247,4253 ****
      int		col_end;
      int		col_start = curwin->w_cursor.col;
      int		inclusive = FALSE;
- #ifdef FEAT_VISUAL
      int		vis_empty = TRUE;	/* Visual selection <= 1 char */
      int		vis_bef_curs = FALSE;	/* Visual starts before cursor */
      int		inside_quotes = FALSE;	/* Looks like "i'" done before */
--- 4213,4218 ----
***************
*** 4331,4347 ****
  	}
      }
      else
- #endif
  
!     if (line[col_start] == quotechar
! #ifdef FEAT_VISUAL
! 	    || !vis_empty
! #endif
! 	    )
      {
  	int	first_col = col_start;
  
- #ifdef FEAT_VISUAL
  	if (!vis_empty)
  	{
  	    if (vis_bef_curs)
--- 4296,4306 ----
  	}
      }
      else
  
!     if (line[col_start] == quotechar || !vis_empty)
      {
  	int	first_col = col_start;
  
  	if (!vis_empty)
  	{
  	    if (vis_bef_curs)
***************
*** 4349,4355 ****
  	    else
  		first_col = find_prev_quote(line, col_start, quotechar, NULL);
  	}
! #endif
  	/* The cursor is on a quote, we don't know if it's the opening or
  	 * closing quote.  Search from the start of the line to find out.
  	 * Also do this when there is a Visual area, a' may leave the cursor
--- 4308,4314 ----
  	    else
  		first_col = find_prev_quote(line, col_start, quotechar, NULL);
  	}
! 
  	/* The cursor is on a quote, we don't know if it's the opening or
  	 * closing quote.  Search from the start of the line to find out.
  	 * Also do this when there is a Visual area, a' may leave the cursor
***************
*** 4406,4419 ****
  
      /* Set start position.  After vi" another i" must include the ".
       * For v2i" include the quotes. */
!     if (!include && count < 2
! #ifdef FEAT_VISUAL
! 	    && (vis_empty || !inside_quotes)
! #endif
! 	    )
  	++col_start;
      curwin->w_cursor.col = col_start;
- #ifdef FEAT_VISUAL
      if (VIsual_active)
      {
  	/* Set the start of the Visual area when the Visual area was empty, we
--- 4365,4373 ----
  
      /* Set start position.  After vi" another i" must include the ".
       * For v2i" include the quotes. */
!     if (!include && count < 2 && (vis_empty || !inside_quotes))
  	++col_start;
      curwin->w_cursor.col = col_start;
      if (VIsual_active)
      {
  	/* Set the start of the Visual area when the Visual area was empty, we
***************
*** 4433,4439 ****
  	}
      }
      else
- #endif
      {
  	oap->start = curwin->w_cursor;
  	oap->motion_type = MCHAR;
--- 4387,4392 ----
***************
*** 4441,4454 ****
  
      /* Set end position. */
      curwin->w_cursor.col = col_end;
!     if ((include || count > 1
! #ifdef FEAT_VISUAL
! 		/* After vi" another i" must include the ". */
  		|| (!vis_empty && inside_quotes)
- #endif
  	) && inc_cursor() == 2)
  	inclusive = TRUE;
- #ifdef FEAT_VISUAL
      if (VIsual_active)
      {
  	if (vis_empty || vis_bef_curs)
--- 4394,4403 ----
  
      /* Set end position. */
      curwin->w_cursor.col = col_end;
!     if ((include || count > 1 /* After vi" another i" must include the ". */
  		|| (!vis_empty && inside_quotes)
  	) && inc_cursor() == 2)
  	inclusive = TRUE;
      if (VIsual_active)
      {
  	if (vis_empty || vis_bef_curs)
***************
*** 4480,4486 ****
  	}
      }
      else
- #endif
      {
  	/* Set inclusive and other oap's flags. */
  	oap->inclusive = inclusive;
--- 4429,4434 ----
***************
*** 4491,4497 ****
  
  #endif /* FEAT_TEXTOBJ */
  
- #if defined(FEAT_VISUAL) || defined(PROTO)
  static int is_one_char __ARGS((char_u *pattern));
  
  /*
--- 4439,4444 ----
***************
*** 4690,4696 ****
      vim_regfree(regmatch.regprog);
      return result;
  }
- #endif /* FEAT_VISUAL */
  
  #if defined(FEAT_LISP) || defined(FEAT_CINDENT) || defined(FEAT_TEXTOBJ) \
  	|| defined(PROTO)
--- 4637,4642 ----
*** ../vim-7.4.211/src/spell.c	2014-03-08 16:13:39.123462070 +0100
--- src/spell.c	2014-03-23 13:35:15.195174931 +0100
***************
*** 10191,10197 ****
      if (no_spell_checking(curwin))
  	return;
  
- #ifdef FEAT_VISUAL
      if (VIsual_active)
      {
  	/* Use the Visually selected text as the bad word.  But reject
--- 10191,10196 ----
***************
*** 10209,10218 ****
  	++badlen;
  	end_visual_mode();
      }
!     else
! #endif
! 	/* Find the start of the badly spelled word. */
! 	if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0
  	    || curwin->w_cursor.col > prev_cursor.col)
      {
  	/* No bad word or it starts after the cursor: use the word under the
--- 10208,10215 ----
  	++badlen;
  	end_visual_mode();
      }
!     /* Find the start of the badly spelled word. */
!     else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0
  	    || curwin->w_cursor.col > prev_cursor.col)
      {
  	/* No bad word or it starts after the cursor: use the word under the
*** ../vim-7.4.211/src/syntax.c	2013-11-28 18:53:47.000000000 +0100
--- src/syntax.c	2014-03-23 13:35:30.379175164 +0100
***************
*** 6837,6846 ****
  	CENT("SignColumn term=standout ctermbg=Grey ctermfg=DarkBlue",
  	     "SignColumn term=standout ctermbg=Grey ctermfg=DarkBlue guibg=Grey guifg=DarkBlue"),
  #endif
- #ifdef FEAT_VISUAL
  	CENT("Visual term=reverse",
  	     "Visual term=reverse guibg=LightGrey"),
- #endif
  #ifdef FEAT_DIFF
  	CENT("DiffAdd term=bold ctermbg=LightBlue",
  	     "DiffAdd term=bold ctermbg=LightBlue guibg=LightBlue"),
--- 6837,6844 ----
***************
*** 6927,6936 ****
  	CENT("SignColumn term=standout ctermbg=DarkGrey ctermfg=Cyan",
  	     "SignColumn term=standout ctermbg=DarkGrey ctermfg=Cyan guibg=Grey guifg=Cyan"),
  #endif
- #ifdef FEAT_VISUAL
  	CENT("Visual term=reverse",
  	     "Visual term=reverse guibg=DarkGrey"),
- #endif
  #ifdef FEAT_DIFF
  	CENT("DiffAdd term=bold ctermbg=DarkBlue",
  	     "DiffAdd term=bold ctermbg=DarkBlue guibg=DarkBlue"),
--- 6925,6932 ----
*** ../vim-7.4.211/src/term.c	2014-03-19 14:01:53.153903819 +0100
--- src/term.c	2014-03-23 13:35:43.519175365 +0100
***************
*** 3456,3467 ****
  	return;
      }
  
- #  ifdef FEAT_VISUAL
      if (VIsual_active)
  	checkfor = MOUSE_VISUAL;
!     else
! #  endif
! 	if (State == HITRETURN || State == ASKMORE || State == SETWSIZE)
  	checkfor = MOUSE_RETURN;
      else if (State & INSERT)
  	checkfor = MOUSE_INSERT;
--- 3456,3464 ----
  	return;
      }
  
      if (VIsual_active)
  	checkfor = MOUSE_VISUAL;
!     else if (State == HITRETURN || State == ASKMORE || State == SETWSIZE)
  	checkfor = MOUSE_RETURN;
      else if (State & INSERT)
  	checkfor = MOUSE_INSERT;
*** ../vim-7.4.211/src/ui.c	2013-07-13 20:57:08.000000000 +0200
--- src/ui.c	2014-03-23 13:36:15.459175855 +0100
***************
*** 2610,2622 ****
  	if (on_sep_line)
  	    return IN_SEP_LINE;
  #endif
- #ifdef FEAT_VISUAL
  	if (flags & MOUSE_MAY_STOP_VIS)
  	{
  	    end_visual_mode();
  	    redraw_curbuf_later(INVERTED);	/* delete the inversion */
  	}
- #endif
  #if defined(FEAT_CMDWIN) && defined(FEAT_CLIPBOARD)
  	/* Continue a modeless selection in another window. */
  	if (cmdwin_type != 0 && row < W_WINROW(curwin))
--- 2610,2620 ----
***************
*** 2686,2717 ****
  	}
  #endif
  
- #ifdef FEAT_VISUAL
  	/* Before jumping to another buffer, or moving the cursor for a left
  	 * click, stop Visual mode. */
  	if (VIsual_active
  		&& (wp->w_buffer != curwin->w_buffer
  		    || (!on_status_line
! # ifdef FEAT_VERTSPLIT
  			&& !on_sep_line
! # endif
! # ifdef FEAT_FOLDING
  			&& (
! #  ifdef FEAT_RIGHTLEFT
  			    wp->w_p_rl ? col < W_WIDTH(wp) - wp->w_p_fdc :
! #  endif
  			    col >= wp->w_p_fdc
! #  ifdef FEAT_CMDWIN
  				  + (cmdwin_type == 0 && wp == curwin ? 0 : 1)
- #  endif
- 			    )
  # endif
  			&& (flags & MOUSE_MAY_STOP_VIS))))
  	{
  	    end_visual_mode();
  	    redraw_curbuf_later(INVERTED);	/* delete the inversion */
  	}
- #endif
  #ifdef FEAT_CMDWIN
  	if (cmdwin_type != 0 && wp != curwin)
  	{
--- 2684,2713 ----
  	}
  #endif
  
  	/* Before jumping to another buffer, or moving the cursor for a left
  	 * click, stop Visual mode. */
  	if (VIsual_active
  		&& (wp->w_buffer != curwin->w_buffer
  		    || (!on_status_line
! #ifdef FEAT_VERTSPLIT
  			&& !on_sep_line
! #endif
! #ifdef FEAT_FOLDING
  			&& (
! # ifdef FEAT_RIGHTLEFT
  			    wp->w_p_rl ? col < W_WIDTH(wp) - wp->w_p_fdc :
! # endif
  			    col >= wp->w_p_fdc
! # ifdef FEAT_CMDWIN
  				  + (cmdwin_type == 0 && wp == curwin ? 0 : 1)
  # endif
+ 			    )
+ #endif
  			&& (flags & MOUSE_MAY_STOP_VIS))))
  	{
  	    end_visual_mode();
  	    redraw_curbuf_later(INVERTED);	/* delete the inversion */
  	}
  #ifdef FEAT_CMDWIN
  	if (cmdwin_type != 0 && wp != curwin)
  	{
***************
*** 2801,2814 ****
  #endif
      else /* keep_window_focus must be TRUE */
      {
- #ifdef FEAT_VISUAL
  	/* before moving the cursor for a left click, stop Visual mode */
  	if (flags & MOUSE_MAY_STOP_VIS)
  	{
  	    end_visual_mode();
  	    redraw_curbuf_later(INVERTED);	/* delete the inversion */
  	}
- #endif
  
  #if defined(FEAT_CMDWIN) && defined(FEAT_CLIPBOARD)
  	/* Continue a modeless selection in another window. */
--- 2797,2808 ----
***************
*** 2933,2939 ****
      if (mouse_comp_pos(curwin, &row, &col, &curwin->w_cursor.lnum))
  	mouse_past_bottom = TRUE;
  
- #ifdef FEAT_VISUAL
      /* Start Visual mode before coladvance(), for when 'sel' != "old" */
      if ((flags & MOUSE_MAY_VIS) && !VIsual_active)
      {
--- 2927,2932 ----
***************
*** 2947,2953 ****
  	if (p_smd && msg_silent == 0)
  	    redraw_cmdline = TRUE;	/* show visual mode later */
      }
- #endif
  
      curwin->w_curswant = col;
      curwin->w_set_curswant = FALSE;	/* May still have been TRUE */
--- 2940,2945 ----
*** ../vim-7.4.211/src/undo.c	2014-03-12 16:51:35.060792541 +0100
--- src/undo.c	2014-03-23 13:37:05.435176620 +0100
***************
*** 532,540 ****
  
  	/* save named marks and Visual marks for undo */
  	mch_memmove(uhp->uh_namedm, curbuf->b_namedm, sizeof(pos_T) * NMARKS);
- #ifdef FEAT_VISUAL
  	uhp->uh_visual = curbuf->b_visual;
- #endif
  
  	curbuf->b_u_newhead = uhp;
  	if (curbuf->b_u_oldhead == NULL)
--- 532,538 ----
***************
*** 1014,1029 ****
      /* Assume NMARKS will stay the same. */
      for (i = 0; i < NMARKS; ++i)
  	serialize_pos(uhp->uh_namedm[i], fp);
- #ifdef FEAT_VISUAL
      serialize_visualinfo(&uhp->uh_visual, fp);
- #else
-     {
- 	visualinfo_T info;
- 
- 	memset(&info, 0, sizeof(visualinfo_T));
- 	serialize_visualinfo(&info, fp);
-     }
- #endif
      put_time(fp, uhp->uh_time);
  
      /* Optional fields. */
--- 1012,1018 ----
***************
*** 1082,1095 ****
      uhp->uh_flags = get2c(fp);
      for (i = 0; i < NMARKS; ++i)
  	unserialize_pos(&uhp->uh_namedm[i], fp);
- #ifdef FEAT_VISUAL
      unserialize_visualinfo(&uhp->uh_visual, fp);
- #else
-     {
- 	visualinfo_T info;
- 	unserialize_visualinfo(&info, fp);
-     }
- #endif
      uhp->uh_time = get8ctime(fp);
  
      /* Optional fields. */
--- 1071,1077 ----
***************
*** 2406,2414 ****
      int		old_flags;
      int		new_flags;
      pos_T	namedm[NMARKS];
- #ifdef FEAT_VISUAL
      visualinfo_T visualinfo;
- #endif
      int		empty_buffer;		    /* buffer became empty */
      u_header_T	*curhead = curbuf->b_u_curhead;
  
--- 2388,2394 ----
***************
*** 2430,2438 ****
       * save marks before undo/redo
       */
      mch_memmove(namedm, curbuf->b_namedm, sizeof(pos_T) * NMARKS);
- #ifdef FEAT_VISUAL
      visualinfo = curbuf->b_visual;
- #endif
      curbuf->b_op_start.lnum = curbuf->b_ml.ml_line_count;
      curbuf->b_op_start.col = 0;
      curbuf->b_op_end.lnum = 0;
--- 2410,2416 ----
***************
*** 2602,2614 ****
  	    curbuf->b_namedm[i] = curhead->uh_namedm[i];
  	    curhead->uh_namedm[i] = namedm[i];
  	}
- #ifdef FEAT_VISUAL
      if (curhead->uh_visual.vi_start.lnum != 0)
      {
  	curbuf->b_visual = curhead->uh_visual;
  	curhead->uh_visual = visualinfo;
      }
- #endif
  
      /*
       * If the cursor is only off by one line, put it at the same position as
--- 2580,2590 ----
*** ../vim-7.4.211/src/version.c	2014-03-22 13:29:57.693846167 +0100
--- src/version.c	2014-03-23 15:01:49.719254526 +0100
***************
*** 642,656 ****
  #else
  	"-virtualedit",
  #endif
- #ifdef FEAT_VISUAL
  	"+visual",
! # ifdef FEAT_VISUALEXTRA
  	"+visualextra",
- # else
- 	"-visualextra",
- # endif
  #else
! 	"-visual",
  #endif
  #ifdef FEAT_VIMINFO
  	"+viminfo",
--- 642,652 ----
  #else
  	"-virtualedit",
  #endif
  	"+visual",
! #ifdef FEAT_VISUALEXTRA
  	"+visualextra",
  #else
! 	"-visualextra",
  #endif
  #ifdef FEAT_VIMINFO
  	"+viminfo",
*** ../vim-7.4.211/src/window.c	2014-01-10 15:53:09.000000000 +0100
--- src/window.c	2014-03-23 13:38:17.767177729 +0100
***************
*** 130,138 ****
      case Ctrl_S:
      case 's':
  		CHECK_CMDWIN
- #ifdef FEAT_VISUAL
  		reset_VIsual_and_resel();	/* stop Visual mode */
- #endif
  #ifdef FEAT_QUICKFIX
  		/* When splitting the quickfix window open a new buffer in it,
  		 * don't replicate the quickfix buffer. */
--- 130,136 ----
***************
*** 150,158 ****
      case Ctrl_V:
      case 'v':
  		CHECK_CMDWIN
- # ifdef FEAT_VISUAL
  		reset_VIsual_and_resel();	/* stop Visual mode */
- # endif
  # ifdef FEAT_QUICKFIX
  		/* When splitting the quickfix window open a new buffer in it,
  		 * don't replicate the quickfix buffer. */
--- 148,154 ----
***************
*** 170,178 ****
      case Ctrl_HAT:
      case '^':
  		CHECK_CMDWIN
- #ifdef FEAT_VISUAL
  		reset_VIsual_and_resel();	/* stop Visual mode */
- #endif
  		STRCPY(cbuf, "split #");
  		if (Prenum)
  		    vim_snprintf((char *)cbuf + 7, sizeof(cbuf) - 7,
--- 166,172 ----
***************
*** 184,192 ****
      case Ctrl_N:
      case 'n':
  		CHECK_CMDWIN
- #ifdef FEAT_VISUAL
  		reset_VIsual_and_resel();	/* stop Visual mode */
- #endif
  #ifdef FEAT_QUICKFIX
  newwindow:
  #endif
--- 178,184 ----
***************
*** 206,223 ****
  /* quit current window */
      case Ctrl_Q:
      case 'q':
- #ifdef FEAT_VISUAL
  		reset_VIsual_and_resel();	/* stop Visual mode */
- #endif
  		do_cmdline_cmd((char_u *)"quit");
  		break;
  
  /* close current window */
      case Ctrl_C:
      case 'c':
- #ifdef FEAT_VISUAL
  		reset_VIsual_and_resel();	/* stop Visual mode */
- #endif
  		do_cmdline_cmd((char_u *)"close");
  		break;
  
--- 198,211 ----
***************
*** 226,234 ****
      case Ctrl_Z:
      case 'z':
  		CHECK_CMDWIN
- #ifdef FEAT_VISUAL
  		reset_VIsual_and_resel();	/* stop Visual mode */
- #endif
  		do_cmdline_cmd((char_u *)"pclose");
  		break;
  
--- 214,220 ----
***************
*** 248,256 ****
      case Ctrl_O:
      case 'o':
  		CHECK_CMDWIN
- #ifdef FEAT_VISUAL
  		reset_VIsual_and_resel();	/* stop Visual mode */
- #endif
  		do_cmdline_cmd((char_u *)"only");
  		break;
  
--- 234,240 ----
***************
*** 399,416 ****
      case Ctrl_R:
      case 'r':
  		CHECK_CMDWIN
- #ifdef FEAT_VISUAL
  		reset_VIsual_and_resel();	/* stop Visual mode */
- #endif
  		win_rotate(FALSE, (int)Prenum1);    /* downwards */
  		break;
  
  /* rotate windows upwards */
      case 'R':
  		CHECK_CMDWIN
- #ifdef FEAT_VISUAL
  		reset_VIsual_and_resel();	/* stop Visual mode */
- #endif
  		win_rotate(TRUE, (int)Prenum1);	    /* upwards */
  		break;
  
--- 383,396 ----
***************
*** 499,507 ****
      case ']':
      case Ctrl_RSB:
  		CHECK_CMDWIN
- #ifdef FEAT_VISUAL
  		reset_VIsual_and_resel();	/* stop Visual mode */
- #endif
  		if (Prenum)
  		    postponed_split = Prenum;
  		else
--- 479,485 ----
***************
*** 612,620 ****
  #endif
  		    case ']':
  		    case Ctrl_RSB:
- #ifdef FEAT_VISUAL
  			reset_VIsual_and_resel();	/* stop Visual mode */
- #endif
  			if (Prenum)
  			    postponed_split = Prenum;
  			else
--- 590,596 ----
***************
*** 3726,3734 ****
  {
      tabpage_T	*tp = curtab;
  
- #ifdef FEAT_VISUAL
      reset_VIsual_and_resel();	/* stop Visual mode */
- #endif
  #ifdef FEAT_AUTOCMD
      if (trigger_leave_autocmds)
      {
--- 3702,3708 ----
***************
*** 4029,4040 ****
  	return;
  #endif
  
- #ifdef FEAT_VISUAL
      if (wp->w_buffer != curbuf)
  	reset_VIsual_and_resel();
      else if (VIsual_active)
  	wp->w_cursor = curwin->w_cursor;
- #endif
  
  #ifdef FEAT_GUI
      need_mouse_correct = TRUE;
--- 4003,4012 ----
***************
*** 6037,6043 ****
      long	count;
      linenr_T	*file_lnum;
  {
- # ifdef FEAT_VISUAL
      if (VIsual_active)
      {
  	int	len;
--- 6009,6014 ----
***************
*** 6048,6054 ****
  	return find_file_name_in_path(ptr, len,
  		     FNAME_MESS|FNAME_EXP|FNAME_REL, count, curbuf->b_ffname);
      }
- # endif
      return file_name_at_cursor(FNAME_MESS|FNAME_HYP|FNAME_EXP|FNAME_REL, count,
  			       file_lnum);
  
--- 6019,6024 ----
*** ../vim-7.4.211/src/feature.h	2014-03-12 17:56:42.960852421 +0100
--- src/feature.h	2014-03-23 13:39:02.003178407 +0100
***************
*** 214,220 ****
   * +visual		Visual mode - now always included.
   * +visualextra		Extra features for Visual mode (mostly block operators).
   */
- #define FEAT_VISUAL
  #ifdef FEAT_NORMAL
  # define FEAT_VISUALEXTRA
  #endif
--- 214,219 ----
***************
*** 1138,1150 ****
  #ifdef FEAT_GUI
  # ifndef FEAT_CLIPBOARD
  #  define FEAT_CLIPBOARD
- #  ifndef FEAT_VISUAL
- #   define FEAT_VISUAL
- #  endif
  # endif
  #endif
  
! #if defined(FEAT_NORMAL) && defined(FEAT_VISUAL) \
  	&& (defined(UNIX) || defined(VMS)) \
  	&& defined(WANT_X11) && defined(HAVE_X11)
  # define FEAT_XCLIPBOARD
--- 1137,1146 ----
  #ifdef FEAT_GUI
  # ifndef FEAT_CLIPBOARD
  #  define FEAT_CLIPBOARD
  # endif
  #endif
  
! #if defined(FEAT_NORMAL) \
  	&& (defined(UNIX) || defined(VMS)) \
  	&& defined(WANT_X11) && defined(HAVE_X11)
  # define FEAT_XCLIPBOARD
*** ../vim-7.4.211/src/globals.h	2014-02-22 23:03:48.712901208 +0100
--- src/globals.h	2014-03-23 13:39:17.407178643 +0100
***************
*** 662,668 ****
  				/* set to TRUE when "-s" commandline argument
  				 * used for ex */
  
- #ifdef FEAT_VISUAL
  EXTERN pos_T	VIsual;		/* start position of active Visual selection */
  EXTERN int	VIsual_active INIT(= FALSE);
  				/* whether Visual mode is active */
--- 662,667 ----
***************
*** 677,683 ****
  
  EXTERN int	redo_VIsual_busy INIT(= FALSE);
  				/* TRUE when redoing Visual */
- #endif
  
  #ifdef FEAT_MOUSE
  /*
--- 676,681 ----
***************
*** 1178,1188 ****
  EXTERN int	fill_diff INIT(= '-');
  #endif
  
- #ifdef FEAT_VISUAL
  /* Whether 'keymodel' contains "stopsel" and "startsel". */
  EXTERN int	km_stopsel INIT(= FALSE);
  EXTERN int	km_startsel INIT(= FALSE);
- #endif
  
  #ifdef FEAT_CMDWIN
  EXTERN int	cedit_key INIT(= -1);	/* key value of 'cedit' option */
--- 1176,1184 ----
*** ../vim-7.4.211/src/option.h	2014-03-12 18:55:52.104906804 +0100
--- src/option.h	2014-03-23 13:39:30.991178851 +0100
***************
*** 572,580 ****
  EXTERN char_u	*p_isp;		/* 'isprint' */
  EXTERN int	p_js;		/* 'joinspaces' */
  EXTERN char_u	*p_kp;		/* 'keywordprg' */
- #ifdef FEAT_VISUAL
  EXTERN char_u	*p_km;		/* 'keymodel' */
- #endif
  #ifdef FEAT_LANGMAP
  EXTERN char_u	*p_langmap;	/* 'langmap'*/
  #endif
--- 572,578 ----
***************
*** 681,690 ****
  #endif
  EXTERN char_u	*p_sections;	/* 'sections' */
  EXTERN int	p_secure;	/* 'secure' */
- #ifdef FEAT_VISUAL
  EXTERN char_u	*p_sel;		/* 'selection' */
  EXTERN char_u	*p_slm;		/* 'selectmode' */
- #endif
  #ifdef FEAT_SESSION
  EXTERN char_u	*p_ssop;	/* 'sessionoptions' */
  EXTERN unsigned	ssop_flags;
--- 679,686 ----
*** ../vim-7.4.211/src/os_win32.h	2013-09-25 19:13:32.000000000 +0200
--- src/os_win32.h	2014-03-23 13:39:49.819179139 +0100
***************
*** 68,74 ****
  #endif
  
  #define USE_FNAME_CASE		/* adjust case of file names */
! #if !defined(FEAT_CLIPBOARD) && defined(FEAT_VISUAL) && defined(FEAT_MOUSE)
  # define FEAT_CLIPBOARD		/* include clipboard support */
  #endif
  #if defined(__DATE__) && defined(__TIME__)
--- 68,74 ----
  #endif
  
  #define USE_FNAME_CASE		/* adjust case of file names */
! #if !defined(FEAT_CLIPBOARD) && defined(FEAT_MOUSE)
  # define FEAT_CLIPBOARD		/* include clipboard support */
  #endif
  #if defined(__DATE__) && defined(__TIME__)
*** ../vim-7.4.211/src/structs.h	2014-03-12 18:55:52.104906804 +0100
--- src/structs.h	2014-03-23 13:40:19.175179589 +0100
***************
*** 346,354 ****
  #endif
      int		uh_flags;	/* see below */
      pos_T	uh_namedm[NMARKS];	/* marks before undo/after redo */
- #ifdef FEAT_VISUAL
      visualinfo_T uh_visual;	/* Visual areas before undo/after redo */
- #endif
      time_t	uh_time;	/* timestamp when the change was made */
      long	uh_save_nr;	/* set when the file was saved after the
  				   changes in this block */
--- 346,352 ----
***************
*** 1406,1417 ****
  
      pos_T	b_namedm[NMARKS]; /* current named marks (mark.c) */
  
- #ifdef FEAT_VISUAL
      /* These variables are set when VIsual_active becomes FALSE */
      visualinfo_T b_visual;
! # ifdef FEAT_EVAL
      int		b_visual_mode_eval;  /* b_visual.vi_mode for visualmode() */
- # endif
  #endif
  
      pos_T	b_last_cursor;	/* cursor position when last unloading this
--- 1404,1413 ----
  
      pos_T	b_namedm[NMARKS]; /* current named marks (mark.c) */
  
      /* These variables are set when VIsual_active becomes FALSE */
      visualinfo_T b_visual;
! #ifdef FEAT_EVAL
      int		b_visual_mode_eval;  /* b_visual.vi_mode for visualmode() */
  #endif
  
      pos_T	b_last_cursor;	/* cursor position when last unloading this
***************
*** 1980,1986 ****
  				       time through cursupdate() to the
  				       current virtual column */
  
- #ifdef FEAT_VISUAL
      /*
       * the next six are used to update the visual part
       */
--- 1976,1981 ----
***************
*** 1991,1997 ****
      linenr_T	w_old_visual_lnum;  /* last known start of visual part */
      colnr_T	w_old_visual_col;   /* last known start of visual part */
      colnr_T	w_old_curswant;	    /* last known value of Curswant */
- #endif
  
      /*
       * "w_topline", "w_leftcol" and "w_skipcol" specify the offsets for
--- 1986,1991 ----
***************
*** 2293,2302 ****
  				   (inclusive) */
      int		empty;		/* op_start and op_end the same (only used by
  				   do_change()) */
- #ifdef FEAT_VISUAL
      int		is_VIsual;	/* operator on Visual area */
      int		block_mode;	/* current operator is Visual block mode */
- #endif
      colnr_T	start_vcol;	/* start col for block mode operator */
      colnr_T	end_vcol;	/* end col for block mode operator */
  #ifdef FEAT_AUTOCMD
--- 2287,2294 ----
*** ../vim-7.4.211/src/version.c	2014-03-22 13:29:57.693846167 +0100
--- src/version.c	2014-03-23 15:01:49.719254526 +0100
***************
*** 740,741 ****
--- 736,739 ----
  {   /* Add new patch number below this line */
+ /**/
+     212,
  /**/

-- 
If all you have is a hammer, everything looks like a nail.
When your hammer is C++, everything begins to look like a thumb.
			-- Steve Hoflich, comp.lang.c++

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
