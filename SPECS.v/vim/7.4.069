To: vim_dev@googlegroups.com
Subject: Patch 7.4.069
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.069
Problem:    Cannot right shift lines starting with #.
Solution:   Allow the right shift when 'cino' contains #N with N > 0.
            (Christian Brabandt)
            Refactor parsing 'cino', store the values in the buffer.
Files:      runtime/doc/indent.txt, src/buffer.c, src/edit.c, src/eval.c,
            src/ex_getln.c, src/fold.c, src/misc1.c, src/ops.c,
            src/proto/misc1.pro, src/proto/option.pro, src/structs.h,
            src/option.c


*** ../vim-7.4.068/runtime/doc/indent.txt	2013-08-10 13:24:56.000000000 +0200
--- runtime/doc/indent.txt	2013-11-05 07:10:56.000000000 +0100
***************
*** 545,554 ****
  	      (default 70 lines).
  
  								*cino-#*
! 	#N    When N is non-zero recognize shell/Perl comments, starting with
! 	      '#'.  Default N is zero: don't recognize '#' comments.  Note
! 	      that lines starting with # will still be seen as preprocessor
! 	      lines.
  
  
  The defaults, spelled out in full, are:
--- 545,556 ----
  	      (default 70 lines).
  
  								*cino-#*
! 	#N    When N is non-zero recognize shell/Perl comments starting with
! 	      '#', do not recognize preprocessor lines; allow right-shifting
! 	      lines that start with "#".
! 	      When N is zero (default): don't recognize '#' comments, do
! 	      recognize preprocessor lines; right-shifting lines that start
! 	      with "#" does not work.
  
  
  The defaults, spelled out in full, are:
***************
*** 556,562 ****
  			c3,C0,/0,(2s,us,U0,w0,W0,k0,m0,j0,J0,)20,*70,#0
  
  Vim puts a line in column 1 if:
! - It starts with '#' (preprocessor directives), if 'cinkeys' contains '#'.
  - It starts with a label (a keyword followed by ':', other than "case" and
    "default") and 'cinoptions' does not contain an 'L' entry with a positive
    value.
--- 558,564 ----
  			c3,C0,/0,(2s,us,U0,w0,W0,k0,m0,j0,J0,)20,*70,#0
  
  Vim puts a line in column 1 if:
! - It starts with '#' (preprocessor directives), if 'cinkeys' contains '#0'.
  - It starts with a label (a keyword followed by ':', other than "case" and
    "default") and 'cinoptions' does not contain an 'L' entry with a positive
    value.
***************
*** 581,588 ****
  
  Clojure indentation differs somewhat from traditional Lisps, due in part to
  the use of square and curly brackets, and otherwise by community convention.
! These conventions are not always universally followed, so the Clojure indent
! script offers a few configurable options, listed below.
  
  If the current vim does not include searchpairpos(), the indent script falls
  back to normal 'lisp' indenting, and the following options are ignored.
--- 583,590 ----
  
  Clojure indentation differs somewhat from traditional Lisps, due in part to
  the use of square and curly brackets, and otherwise by community convention.
! These conventions are not universally followed, so the Clojure indent script
! offers a few configurable options, listed below.
  
  If the current vim does not include searchpairpos(), the indent script falls
  back to normal 'lisp' indenting, and the following options are ignored.
*** ../vim-7.4.068/src/buffer.c	2013-11-02 04:39:34.000000000 +0100
--- src/buffer.c	2013-11-05 06:18:54.000000000 +0100
***************
*** 211,217 ****
--- 211,220 ----
  
      /* if first time loading this buffer, init b_chartab[] */
      if (curbuf->b_flags & BF_NEVERLOADED)
+     {
  	(void)buf_init_chartab(curbuf, FALSE);
+ 	parse_cino(curbuf);
+     }
  
      /*
       * Set/reset the Changed flag first, autocmds may change the buffer.
*** ../vim-7.4.068/src/edit.c	2013-11-04 04:20:28.000000000 +0100
--- src/edit.c	2013-11-05 06:12:45.000000000 +0100
***************
*** 8958,8964 ****
  
  	    *inserted_space_p = FALSE;
  	    if (p_sta && in_indent)
! 		ts = (int)get_sw_value();
  	    else
  		ts = (int)get_sts_value();
  	    /* Compute the virtual column where we want to be.  Since
--- 8958,8964 ----
  
  	    *inserted_space_p = FALSE;
  	    if (p_sta && in_indent)
! 		ts = (int)get_sw_value(curbuf);
  	    else
  		ts = (int)get_sts_value();
  	    /* Compute the virtual column where we want to be.  Since
***************
*** 9647,9653 ****
       * When nothing special, insert TAB like a normal character
       */
      if (!curbuf->b_p_et
! 	    && !(p_sta && ind && curbuf->b_p_ts != get_sw_value())
  	    && get_sts_value() == 0)
  	return TRUE;
  
--- 9647,9653 ----
       * When nothing special, insert TAB like a normal character
       */
      if (!curbuf->b_p_et
! 	    && !(p_sta && ind && curbuf->b_p_ts != get_sw_value(curbuf))
  	    && get_sts_value() == 0)
  	return TRUE;
  
***************
*** 9663,9669 ****
      AppendToRedobuff((char_u *)"\t");
  
      if (p_sta && ind)		/* insert tab in indent, use 'shiftwidth' */
! 	temp = (int)get_sw_value();
      else if (curbuf->b_p_sts != 0) /* use 'softtabstop' when set */
  	temp = (int)get_sts_value();
      else			/* otherwise use 'tabstop' */
--- 9663,9669 ----
      AppendToRedobuff((char_u *)"\t");
  
      if (p_sta && ind)		/* insert tab in indent, use 'shiftwidth' */
! 	temp = (int)get_sw_value(curbuf);
      else if (curbuf->b_p_sts != 0) /* use 'softtabstop' when set */
  	temp = (int)get_sts_value();
      else			/* otherwise use 'tabstop' */
*** ../vim-7.4.068/src/eval.c	2013-11-02 23:29:17.000000000 +0100
--- src/eval.c	2013-11-05 06:12:49.000000000 +0100
***************
*** 16934,16940 ****
      typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
!     rettv->vval.v_number = get_sw_value();
  }
  
  /*
--- 16934,16940 ----
      typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
!     rettv->vval.v_number = get_sw_value(curbuf);
  }
  
  /*
*** ../vim-7.4.068/src/ex_getln.c	2013-07-05 19:44:21.000000000 +0200
--- src/ex_getln.c	2013-11-05 06:12:57.000000000 +0100
***************
*** 2280,2286 ****
  
  	    if (c1 == Ctrl_T)
  	    {
! 		long        sw = get_sw_value();
  
  		p = (char_u *)line_ga.ga_data;
  		p[line_ga.ga_len] = NUL;
--- 2280,2286 ----
  
  	    if (c1 == Ctrl_T)
  	    {
! 		long        sw = get_sw_value(curbuf);
  
  		p = (char_u *)line_ga.ga_data;
  		p[line_ga.ga_len] = NUL;
***************
*** 2337,2343 ****
  		    p[line_ga.ga_len] = NUL;
  		    indent = get_indent_str(p, 8);
  		    --indent;
! 		    indent -= indent % get_sw_value();
  		}
  		while (get_indent_str(p, 8) > indent)
  		{
--- 2337,2343 ----
  		    p[line_ga.ga_len] = NUL;
  		    indent = get_indent_str(p, 8);
  		    --indent;
! 		    indent -= indent % get_sw_value(curbuf);
  		}
  		while (get_indent_str(p, 8) > indent)
  		{
***************
*** 4178,4184 ****
  /*
   * Prepare a string for expansion.
   * When expanding file names: The string will be used with expand_wildcards().
!  * Copy the file name into allocated memory and add a '*' at the end.
   * When expanding other names: The string will be used with regcomp().  Copy
   * the name into allocated memory and prepend "^".
   */
--- 4178,4184 ----
  /*
   * Prepare a string for expansion.
   * When expanding file names: The string will be used with expand_wildcards().
!  * Copy "fname[len]" into allocated memory and add a '*' at the end.
   * When expanding other names: The string will be used with regcomp().  Copy
   * the name into allocated memory and prepend "^".
   */
*** ../vim-7.4.068/src/fold.c	2013-06-15 16:57:24.000000000 +0200
--- src/fold.c	2013-11-05 06:13:03.000000000 +0100
***************
*** 3052,3058 ****
  	    flp->lvl = -1;
      }
      else
! 	flp->lvl = get_indent_buf(buf, lnum) / get_sw_value();
      if (flp->lvl > flp->wp->w_p_fdn)
      {
  	flp->lvl = flp->wp->w_p_fdn;
--- 3052,3058 ----
  	    flp->lvl = -1;
      }
      else
! 	flp->lvl = get_indent_buf(buf, lnum) / get_sw_value(curbuf);
      if (flp->lvl > flp->wp->w_p_fdn)
      {
  	flp->lvl = flp->wp->w_p_fdn;
*** ../vim-7.4.068/src/misc1.c	2013-11-04 02:53:46.000000000 +0100
--- src/misc1.c	2013-11-05 06:45:15.000000000 +0100
***************
*** 1405,1411 ****
  #ifdef FEAT_SMARTINDENT
  	if (did_si)
  	{
! 	    int        sw = (int)get_sw_value();
  
  	    if (p_sr)
  		newindent -= newindent % sw;
--- 1405,1411 ----
  #ifdef FEAT_SMARTINDENT
  	if (did_si)
  	{
! 	    int        sw = (int)get_sw_value(curbuf);
  
  	    if (p_sr)
  		newindent -= newindent % sw;
***************
*** 5342,5349 ****
  static int	find_match __ARGS((int lookfor, linenr_T ourscope, int ind_maxparen, int ind_maxcomment));
  static int	cin_is_cpp_namespace __ARGS((char_u *));
  
- static int	ind_hash_comment = 0;   /* # starts a comment */
- 
  /*
   * Skip over white space and C comments within the line.
   * Also skip over Perl/shell comments if desired.
--- 5342,5347 ----
***************
*** 5360,5366 ****
  
  	/* Perl/shell # comment comment continues until eol.  Require a space
  	 * before # to avoid recognizing $#array. */
! 	if (ind_hash_comment != 0 && s != prev_s && *s == '#')
  	{
  	    s += STRLEN(s);
  	    break;
--- 5358,5364 ----
  
  	/* Perl/shell # comment comment continues until eol.  Require a space
  	 * before # to avoid recognizing $#array. */
! 	if (curbuf->b_ind_hash_comment != 0 && s != prev_s && *s == '#')
  	{
  	    s += STRLEN(s);
  	    break;
***************
*** 6639,6839 ****
      return retval;
  }
  
!     int
! get_c_indent()
  {
!     int sw = (int)get_sw_value();
  
      /*
!      * spaces from a block's opening brace the prevailing indent for that
!      * block should be
       */
  
!     int ind_level = sw;
  
!     /*
!      * spaces from the edge of the line an open brace that's at the end of a
!      * line is imagined to be.
!      */
!     int ind_open_imag = 0;
  
!     /*
!      * spaces from the prevailing indent for a line that is not preceded by
!      * an opening brace.
!      */
!     int ind_no_brace = 0;
! 
!     /*
!      * column where the first { of a function should be located }
!      */
!     int ind_first_open = 0;
  
!     /*
!      * spaces from the prevailing indent a leftmost open brace should be
!      * located
!      */
!     int ind_open_extra = 0;
  
!     /*
!      * spaces from the matching open brace (real location for one at the left
       * edge; imaginary location from one that ends a line) the matching close
!      * brace should be located
!      */
!     int ind_close_extra = 0;
  
!     /*
!      * spaces from the edge of the line an open brace sitting in the leftmost
!      * column is imagined to be
!      */
!     int ind_open_left_imag = 0;
  
!     /*
!      * Spaces jump labels should be shifted to the left if N is non-negative,
!      * otherwise the jump label will be put to column 1.
!      */
!     int ind_jump_label = -1;
  
!     /*
!      * spaces from the switch() indent a "case xx" label should be located
!      */
!     int ind_case = sw;
  
!     /*
!      * spaces from the "case xx:" code after a switch() should be located
!      */
!     int ind_case_code = sw;
  
!     /*
!      * lineup break at end of case in switch() with case label
!      */
!     int ind_case_break = 0;
  
!     /*
!      * spaces from the class declaration indent a scope declaration label
!      * should be located
!      */
!     int ind_scopedecl = sw;
  
!     /*
!      * spaces from the scope declaration label code should be located
!      */
!     int ind_scopedecl_code = sw;
  
!     /*
!      * amount K&R-style parameters should be indented
!      */
!     int ind_param = sw;
  
!     /*
!      * amount a function type spec should be indented
!      */
!     int ind_func_type = sw;
  
!     /*
!      * amount a cpp base class declaration or constructor initialization
!      * should be indented
!      */
!     int ind_cpp_baseclass = sw;
  
!     /*
!      * additional spaces beyond the prevailing indent a continuation line
!      * should be located
!      */
!     int ind_continuation = sw;
  
!     /*
!      * spaces from the indent of the line with an unclosed parentheses
!      */
!     int ind_unclosed = sw * 2;
  
!     /*
!      * spaces from the indent of the line with an unclosed parentheses, which
!      * itself is also unclosed
!      */
!     int ind_unclosed2 = sw;
  
!     /*
!      * suppress ignoring spaces from the indent of a line starting with an
!      * unclosed parentheses.
!      */
!     int ind_unclosed_noignore = 0;
  
!     /*
!      * If the opening paren is the last nonwhite character on the line, and
!      * ind_unclosed_wrapped is nonzero, use this indent relative to the outer
!      * context (for very long lines).
!      */
!     int ind_unclosed_wrapped = 0;
  
!     /*
!      * suppress ignoring white space when lining up with the character after
!      * an unclosed parentheses.
!      */
!     int ind_unclosed_whiteok = 0;
  
!     /*
!      * indent a closing parentheses under the line start of the matching
!      * opening parentheses.
!      */
!     int ind_matching_paren = 0;
  
!     /*
!      * indent a closing parentheses under the previous line.
!      */
!     int ind_paren_prev = 0;
  
!     /*
!      * Extra indent for comments.
!      */
!     int ind_comment = 0;
  
!     /*
!      * spaces from the comment opener when there is nothing after it.
!      */
!     int ind_in_comment = 3;
  
!     /*
!      * boolean: if non-zero, use ind_in_comment even if there is something
!      * after the comment opener.
!      */
!     int ind_in_comment2 = 0;
  
!     /*
!      * max lines to search for an open paren
!      */
!     int ind_maxparen = 20;
  
!     /*
!      * max lines to search for an open comment
!      */
!     int ind_maxcomment = 70;
  
!     /*
!      * handle braces for java code
!      */
!     int	ind_java = 0;
  
!     /*
!      * not to confuse JS object properties with labels
!      */
!     int ind_js = 0;
  
!     /*
!      * handle blocked cases correctly
!      */
!     int ind_keep_case_label = 0;
  
!     /*
!      * handle C++ namespace
!      */
!     int ind_cpp_namespace = 0;
  
!     /*
!      * handle continuation lines containing conditions of if(), for() and
!      * while()
!      */
!     int ind_if_for_while = 0;
  
      pos_T	cur_curpos;
      int		amount;
      int		scope_amount;
--- 6637,6865 ----
      return retval;
  }
  
! /*
!  * Parse 'cinoptions' and set the values in "curbuf".
!  * Must be called when 'cinoptions', 'shiftwidth' and/or 'tabstop' changes.
!  */
!     void
! parse_cino(buf)
!     buf_T	*buf;
  {
!     char_u	*p;
!     char_u	*l;
!     char_u	*digits;
!     int		n;
!     int		divider;
!     int		fraction = 0;
!     int		sw = (int)get_sw_value(buf);
  
      /*
!      * Set the default values.
       */
+     /* Spaces from a block's opening brace the prevailing indent for that
+      * block should be. */
+     buf->b_ind_level = sw;
  
!     /* Spaces from the edge of the line an open brace that's at the end of a
!      * line is imagined to be. */
!     buf->b_ind_open_imag = 0;
  
!     /* Spaces from the prevailing indent for a line that is not preceded by
!      * an opening brace. */
!     buf->b_ind_no_brace = 0;
  
!     /* Column where the first { of a function should be located }. */
!     buf->b_ind_first_open = 0;
  
!     /* Spaces from the prevailing indent a leftmost open brace should be
!      * located. */
!     buf->b_ind_open_extra = 0;
  
!     /* Spaces from the matching open brace (real location for one at the left
       * edge; imaginary location from one that ends a line) the matching close
!      * brace should be located. */
!     buf->b_ind_close_extra = 0;
  
!     /* Spaces from the edge of the line an open brace sitting in the leftmost
!      * column is imagined to be. */
!     buf->b_ind_open_left_imag = 0;
  
!     /* Spaces jump labels should be shifted to the left if N is non-negative,
!      * otherwise the jump label will be put to column 1. */
!     buf->b_ind_jump_label = -1;
  
!     /* Spaces from the switch() indent a "case xx" label should be located. */
!     buf->b_ind_case = sw;
  
!     /* Spaces from the "case xx:" code after a switch() should be located. */
!     buf->b_ind_case_code = sw;
  
!     /* Lineup break at end of case in switch() with case label. */
!     buf->b_ind_case_break = 0;
  
!     /* Spaces from the class declaration indent a scope declaration label
!      * should be located. */
!     buf->b_ind_scopedecl = sw;
  
!     /* Spaces from the scope declaration label code should be located. */
!     buf->b_ind_scopedecl_code = sw;
  
!     /* Amount K&R-style parameters should be indented. */
!     buf->b_ind_param = sw;
  
!     /* Amount a function type spec should be indented. */
!     buf->b_ind_func_type = sw;
  
!     /* Amount a cpp base class declaration or constructor initialization
!      * should be indented. */
!     buf->b_ind_cpp_baseclass = sw;
  
!     /* additional spaces beyond the prevailing indent a continuation line
!      * should be located. */
!     buf->b_ind_continuation = sw;
  
!     /* Spaces from the indent of the line with an unclosed parentheses. */
!     buf->b_ind_unclosed = sw * 2;
  
!     /* Spaces from the indent of the line with an unclosed parentheses, which
!      * itself is also unclosed. */
!     buf->b_ind_unclosed2 = sw;
  
!     /* Suppress ignoring spaces from the indent of a line starting with an
!      * unclosed parentheses. */
!     buf->b_ind_unclosed_noignore = 0;
  
!     /* If the opening paren is the last nonwhite character on the line, and
!      * b_ind_unclosed_wrapped is nonzero, use this indent relative to the outer
!      * context (for very long lines). */
!     buf->b_ind_unclosed_wrapped = 0;
  
!     /* Suppress ignoring white space when lining up with the character after
!      * an unclosed parentheses. */
!     buf->b_ind_unclosed_whiteok = 0;
  
!     /* Indent a closing parentheses under the line start of the matching
!      * opening parentheses. */
!     buf->b_ind_matching_paren = 0;
  
!     /* Indent a closing parentheses under the previous line. */
!     buf->b_ind_paren_prev = 0;
  
!     /* Extra indent for comments. */
!     buf->b_ind_comment = 0;
  
!     /* Spaces from the comment opener when there is nothing after it. */
!     buf->b_ind_in_comment = 3;
  
!     /* Boolean: if non-zero, use b_ind_in_comment even if there is something
!      * after the comment opener. */
!     buf->b_ind_in_comment2 = 0;
  
!     /* Max lines to search for an open paren. */
!     buf->b_ind_maxparen = 20;
  
!     /* Max lines to search for an open comment. */
!     buf->b_ind_maxcomment = 70;
  
!     /* Handle braces for java code. */
!     buf->b_ind_java = 0;
  
!     /* Not to confuse JS object properties with labels. */
!     buf->b_ind_js = 0;
  
!     /* Handle blocked cases correctly. */
!     buf->b_ind_keep_case_label = 0;
  
!     /* Handle C++ namespace. */
!     buf->b_ind_cpp_namespace = 0;
  
!     /* Handle continuation lines containing conditions of if(), for() and
!      * while(). */
!     buf->b_ind_if_for_while = 0;
! 
!     for (p = buf->b_p_cino; *p; )
!     {
! 	l = p++;
! 	if (*p == '-')
! 	    ++p;
! 	digits = p;	    /* remember where the digits start */
! 	n = getdigits(&p);
! 	divider = 0;
! 	if (*p == '.')	    /* ".5s" means a fraction */
! 	{
! 	    fraction = atol((char *)++p);
! 	    while (VIM_ISDIGIT(*p))
! 	    {
! 		++p;
! 		if (divider)
! 		    divider *= 10;
! 		else
! 		    divider = 10;
! 	    }
! 	}
! 	if (*p == 's')	    /* "2s" means two times 'shiftwidth' */
! 	{
! 	    if (p == digits)
! 		n = sw;	/* just "s" is one 'shiftwidth' */
! 	    else
! 	    {
! 		n *= sw;
! 		if (divider)
! 		    n += (sw * fraction + divider / 2) / divider;
! 	    }
! 	    ++p;
! 	}
! 	if (l[1] == '-')
! 	    n = -n;
  
+ 	/* When adding an entry here, also update the default 'cinoptions' in
+ 	 * doc/indent.txt, and add explanation for it! */
+ 	switch (*l)
+ 	{
+ 	    case '>': buf->b_ind_level = n; break;
+ 	    case 'e': buf->b_ind_open_imag = n; break;
+ 	    case 'n': buf->b_ind_no_brace = n; break;
+ 	    case 'f': buf->b_ind_first_open = n; break;
+ 	    case '{': buf->b_ind_open_extra = n; break;
+ 	    case '}': buf->b_ind_close_extra = n; break;
+ 	    case '^': buf->b_ind_open_left_imag = n; break;
+ 	    case 'L': buf->b_ind_jump_label = n; break;
+ 	    case ':': buf->b_ind_case = n; break;
+ 	    case '=': buf->b_ind_case_code = n; break;
+ 	    case 'b': buf->b_ind_case_break = n; break;
+ 	    case 'p': buf->b_ind_param = n; break;
+ 	    case 't': buf->b_ind_func_type = n; break;
+ 	    case '/': buf->b_ind_comment = n; break;
+ 	    case 'c': buf->b_ind_in_comment = n; break;
+ 	    case 'C': buf->b_ind_in_comment2 = n; break;
+ 	    case 'i': buf->b_ind_cpp_baseclass = n; break;
+ 	    case '+': buf->b_ind_continuation = n; break;
+ 	    case '(': buf->b_ind_unclosed = n; break;
+ 	    case 'u': buf->b_ind_unclosed2 = n; break;
+ 	    case 'U': buf->b_ind_unclosed_noignore = n; break;
+ 	    case 'W': buf->b_ind_unclosed_wrapped = n; break;
+ 	    case 'w': buf->b_ind_unclosed_whiteok = n; break;
+ 	    case 'm': buf->b_ind_matching_paren = n; break;
+ 	    case 'M': buf->b_ind_paren_prev = n; break;
+ 	    case ')': buf->b_ind_maxparen = n; break;
+ 	    case '*': buf->b_ind_maxcomment = n; break;
+ 	    case 'g': buf->b_ind_scopedecl = n; break;
+ 	    case 'h': buf->b_ind_scopedecl_code = n; break;
+ 	    case 'j': buf->b_ind_java = n; break;
+ 	    case 'J': buf->b_ind_js = n; break;
+ 	    case 'l': buf->b_ind_keep_case_label = n; break;
+ 	    case '#': buf->b_ind_hash_comment = n; break;
+ 	    case 'N': buf->b_ind_cpp_namespace = n; break;
+ 	    case 'k': buf->b_ind_if_for_while = n; break;
+ 	}
+ 	if (*p == ',')
+ 	    ++p;
+     }
+ }
+ 
+     int
+ get_c_indent()
+ {
      pos_T	cur_curpos;
      int		amount;
      int		scope_amount;
***************
*** 6868,6877 ****
  
      int		whilelevel;
      linenr_T	lnum;
-     char_u	*options;
-     char_u	*digits;
-     int		fraction = 0;	    /* init for GCC */
-     int		divider;
      int		n;
      int		iscase;
      int		lookfor_break;
--- 6894,6899 ----
***************
*** 6880,6962 ****
      int		original_line_islabel;
      int		added_to_amount = 0;
  
!     for (options = curbuf->b_p_cino; *options; )
!     {
! 	l = options++;
! 	if (*options == '-')
! 	    ++options;
! 	digits = options;	    /* remember where the digits start */
! 	n = getdigits(&options);
! 	divider = 0;
! 	if (*options == '.')	    /* ".5s" means a fraction */
! 	{
! 	    fraction = atol((char *)++options);
! 	    while (VIM_ISDIGIT(*options))
! 	    {
! 		++options;
! 		if (divider)
! 		    divider *= 10;
! 		else
! 		    divider = 10;
! 	    }
! 	}
! 	if (*options == 's')	    /* "2s" means two times 'shiftwidth' */
! 	{
! 	    if (options == digits)
! 		n = sw;	/* just "s" is one 'shiftwidth' */
! 	    else
! 	    {
! 		n *= sw;
! 		if (divider)
! 		    n += (sw * fraction + divider / 2) / divider;
! 	    }
! 	    ++options;
! 	}
! 	if (l[1] == '-')
! 	    n = -n;
! 	/* When adding an entry here, also update the default 'cinoptions' in
! 	 * doc/indent.txt, and add explanation for it! */
! 	switch (*l)
! 	{
! 	    case '>': ind_level = n; break;
! 	    case 'e': ind_open_imag = n; break;
! 	    case 'n': ind_no_brace = n; break;
! 	    case 'f': ind_first_open = n; break;
! 	    case '{': ind_open_extra = n; break;
! 	    case '}': ind_close_extra = n; break;
! 	    case '^': ind_open_left_imag = n; break;
! 	    case 'L': ind_jump_label = n; break;
! 	    case ':': ind_case = n; break;
! 	    case '=': ind_case_code = n; break;
! 	    case 'b': ind_case_break = n; break;
! 	    case 'p': ind_param = n; break;
! 	    case 't': ind_func_type = n; break;
! 	    case '/': ind_comment = n; break;
! 	    case 'c': ind_in_comment = n; break;
! 	    case 'C': ind_in_comment2 = n; break;
! 	    case 'i': ind_cpp_baseclass = n; break;
! 	    case '+': ind_continuation = n; break;
! 	    case '(': ind_unclosed = n; break;
! 	    case 'u': ind_unclosed2 = n; break;
! 	    case 'U': ind_unclosed_noignore = n; break;
! 	    case 'W': ind_unclosed_wrapped = n; break;
! 	    case 'w': ind_unclosed_whiteok = n; break;
! 	    case 'm': ind_matching_paren = n; break;
! 	    case 'M': ind_paren_prev = n; break;
! 	    case ')': ind_maxparen = n; break;
! 	    case '*': ind_maxcomment = n; break;
! 	    case 'g': ind_scopedecl = n; break;
! 	    case 'h': ind_scopedecl_code = n; break;
! 	    case 'j': ind_java = n; break;
! 	    case 'J': ind_js = n; break;
! 	    case 'l': ind_keep_case_label = n; break;
! 	    case '#': ind_hash_comment = n; break;
! 	    case 'N': ind_cpp_namespace = n; break;
! 	    case 'k': ind_if_for_while = n; break;
! 	}
! 	if (*options == ',')
! 	    ++options;
!     }
  
      /* remember where the cursor was when we started */
      cur_curpos = curwin->w_cursor;
--- 6902,6909 ----
      int		original_line_islabel;
      int		added_to_amount = 0;
  
!     /* make a copy, value is changed below */
!     int		ind_continuation = curbuf->b_ind_continuation;
  
      /* remember where the cursor was when we started */
      cur_curpos = curwin->w_cursor;
***************
*** 6990,7011 ****
  
      curwin->w_cursor.col = 0;
  
!     original_line_islabel = cin_islabel(ind_maxcomment);  /* XXX */
  
      /*
       * #defines and so on always go at the left when included in 'cinkeys'.
       */
      if (*theline == '#' && (*linecopy == '#' || in_cinkeys('#', ' ', TRUE)))
!     {
! 	amount = 0;
!     }
  
      /*
       * Is it a non-case label?	Then that goes at the left margin too unless:
       *  - JS flag is set.
       *  - 'L' item has a positive value.
       */
!     else if (original_line_islabel && !ind_js && ind_jump_label < 0)
      {
  	amount = 0;
      }
--- 6937,6957 ----
  
      curwin->w_cursor.col = 0;
  
!     original_line_islabel = cin_islabel(curbuf->b_ind_maxcomment);  /* XXX */
  
      /*
       * #defines and so on always go at the left when included in 'cinkeys'.
       */
      if (*theline == '#' && (*linecopy == '#' || in_cinkeys('#', ' ', TRUE)))
! 	amount = curbuf->b_ind_hash_comment;
  
      /*
       * Is it a non-case label?	Then that goes at the left margin too unless:
       *  - JS flag is set.
       *  - 'L' item has a positive value.
       */
!     else if (original_line_islabel && !curbuf->b_ind_js
! 					      && curbuf->b_ind_jump_label < 0)
      {
  	amount = 0;
      }
***************
*** 7027,7033 ****
       * comment, try using the 'comments' option.
       */
      else if (!cin_iscomment(theline)
! 	    && (trypos = find_start_comment(ind_maxcomment)) != NULL) /* XXX */
      {
  	int	lead_start_len = 2;
  	int	lead_middle_len = 1;
--- 6973,6980 ----
       * comment, try using the 'comments' option.
       */
      else if (!cin_iscomment(theline)
! 	    && (trypos = find_start_comment(curbuf->b_ind_maxcomment)) != NULL)
! 	/* XXX */
      {
  	int	lead_start_len = 2;
  	int	lead_middle_len = 1;
***************
*** 7161,7167 ****
  	    }
  	    if (amount == -1)			    /* use the comment opener */
  	    {
! 		if (!ind_in_comment2)
  		{
  		    start = ml_get(trypos->lnum);
  		    look = start + trypos->col + 2; /* skip / and * */
--- 7108,7114 ----
  	    }
  	    if (amount == -1)			    /* use the comment opener */
  	    {
! 		if (!curbuf->b_ind_in_comment2)
  		{
  		    start = ml_get(trypos->lnum);
  		    look = start + trypos->col + 2; /* skip / and * */
***************
*** 7170,7177 ****
  		}
  		getvcol(curwin, trypos, &col, NULL, NULL);
  		amount = col;
! 		if (ind_in_comment2 || *look == NUL)
! 		    amount += ind_in_comment;
  	    }
  	}
      }
--- 7117,7124 ----
  		}
  		getvcol(curwin, trypos, &col, NULL, NULL);
  		amount = col;
! 		if (curbuf->b_ind_in_comment2 || *look == NUL)
! 		    amount += curbuf->b_ind_in_comment;
  	    }
  	}
      }
***************
*** 7179,7187 ****
      /*
       * Are we inside parentheses or braces?
       */						    /* XXX */
!     else if (((trypos = find_match_paren(ind_maxparen, ind_maxcomment)) != NULL
! 		&& ind_java == 0)
! 	    || (tryposBrace = find_start_brace(ind_maxcomment)) != NULL
  	    || trypos != NULL)
      {
        if (trypos != NULL && tryposBrace != NULL)
--- 7126,7136 ----
      /*
       * Are we inside parentheses or braces?
       */						    /* XXX */
!     else if (((trypos = find_match_paren(curbuf->b_ind_maxparen,
! 					    curbuf->b_ind_maxcomment)) != NULL
! 		&& curbuf->b_ind_java == 0)
! 	    || (tryposBrace =
! 			   find_start_brace(curbuf->b_ind_maxcomment)) != NULL
  	    || trypos != NULL)
      {
        if (trypos != NULL && tryposBrace != NULL)
***************
*** 7202,7208 ****
  	 * If the matching paren is more than one line away, use the indent of
  	 * a previous non-empty line that matches the same paren.
  	 */
! 	if (theline[0] == ')' && ind_paren_prev)
  	{
  	    /* Line up with the start of the matching paren line. */
  	    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);  /* XXX */
--- 7151,7157 ----
  	 * If the matching paren is more than one line away, use the indent of
  	 * a previous non-empty line that matches the same paren.
  	 */
! 	if (theline[0] == ')' && curbuf->b_ind_paren_prev)
  	{
  	    /* Line up with the start of the matching paren line. */
  	    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);  /* XXX */
***************
*** 7221,7227 ****
  		curwin->w_cursor.lnum = lnum;
  
  		/* Skip a comment. XXX */
! 		if ((trypos = find_start_comment(ind_maxcomment)) != NULL)
  		{
  		    lnum = trypos->lnum + 1;
  		    continue;
--- 7170,7177 ----
  		curwin->w_cursor.lnum = lnum;
  
  		/* Skip a comment. XXX */
! 		if ((trypos = find_start_comment(curbuf->b_ind_maxcomment))
! 								      != NULL)
  		{
  		    lnum = trypos->lnum + 1;
  		    continue;
***************
*** 7229,7236 ****
  
  		/* XXX */
  		if ((trypos = find_match_paren(
! 				corr_ind_maxparen(ind_maxparen, &cur_curpos),
! 						      ind_maxcomment)) != NULL
  			&& trypos->lnum == our_paren_pos.lnum
  			&& trypos->col == our_paren_pos.col)
  		{
--- 7179,7186 ----
  
  		/* XXX */
  		if ((trypos = find_match_paren(
! 		       corr_ind_maxparen(curbuf->b_ind_maxparen, &cur_curpos),
! 					    curbuf->b_ind_maxcomment)) != NULL
  			&& trypos->lnum == our_paren_pos.lnum
  			&& trypos->col == our_paren_pos.col)
  		{
***************
*** 7258,7264 ****
  	    int	    ignore_paren_col = 0;
  	    int	    is_if_for_while = 0;
  
! 	    if (ind_if_for_while)
  	    {
  		/* Look for the outermost opening parenthesis on this line
  		 * and check whether it belongs to an "if", "for" or "while". */
--- 7208,7214 ----
  	    int	    ignore_paren_col = 0;
  	    int	    is_if_for_while = 0;
  
! 	    if (curbuf->b_ind_if_for_while)
  	    {
  		/* Look for the outermost opening parenthesis on this line
  		 * and check whether it belongs to an "if", "for" or "while". */
***************
*** 7273,7279 ****
  		    curwin->w_cursor.lnum = outermost.lnum;
  		    curwin->w_cursor.col = outermost.col;
  
! 		    trypos = find_match_paren(ind_maxparen, ind_maxcomment);
  		} while (trypos && trypos->lnum == outermost.lnum);
  
  		curwin->w_cursor = cursor_save;
--- 7223,7230 ----
  		    curwin->w_cursor.lnum = outermost.lnum;
  		    curwin->w_cursor.col = outermost.col;
  
! 		    trypos = find_match_paren(curbuf->b_ind_maxparen,
! 						    curbuf->b_ind_maxcomment);
  		} while (trypos && trypos->lnum == outermost.lnum);
  
  		curwin->w_cursor = cursor_save;
***************
*** 7284,7290 ****
  		    cin_is_if_for_while_before_offset(line, &outermost.col);
  	    }
  
! 	    amount = skip_label(our_paren_pos.lnum, &look, ind_maxcomment);
  	    look = skipwhite(look);
  	    if (*look == '(')
  	    {
--- 7235,7242 ----
  		    cin_is_if_for_while_before_offset(line, &outermost.col);
  	    }
  
! 	    amount = skip_label(our_paren_pos.lnum, &look,
! 						    curbuf->b_ind_maxcomment);
  	    look = skipwhite(look);
  	    if (*look == '(')
  	    {
***************
*** 7298,7304 ****
  		line = ml_get_curline();
  		look_col = (int)(look - line);
  		curwin->w_cursor.col = look_col + 1;
! 		if ((trypos = findmatchlimit(NULL, ')', 0, ind_maxparen))
  								      != NULL
  			  && trypos->lnum == our_paren_pos.lnum
  			  && trypos->col < our_paren_pos.col)
--- 7250,7257 ----
  		line = ml_get_curline();
  		look_col = (int)(look - line);
  		curwin->w_cursor.col = look_col + 1;
! 		if ((trypos = findmatchlimit(NULL, ')', 0,
! 						      curbuf->b_ind_maxparen))
  								      != NULL
  			  && trypos->lnum == our_paren_pos.lnum
  			  && trypos->col < our_paren_pos.col)
***************
*** 7307,7330 ****
  		curwin->w_cursor.lnum = save_lnum;
  		look = ml_get(our_paren_pos.lnum) + look_col;
  	    }
! 	    if (theline[0] == ')' || (ind_unclosed == 0 && is_if_for_while == 0)
! 		    || (!ind_unclosed_noignore && *look == '('
  						    && ignore_paren_col == 0))
  	    {
  		/*
  		 * If we're looking at a close paren, line up right there;
  		 * otherwise, line up with the next (non-white) character.
! 		 * When ind_unclosed_wrapped is set and the matching paren is
  		 * the last nonwhite character of the line, use either the
  		 * indent of the current line or the indentation of the next
! 		 * outer paren and add ind_unclosed_wrapped (for very long
  		 * lines).
  		 */
  		if (theline[0] != ')')
  		{
  		    cur_amount = MAXCOL;
  		    l = ml_get(our_paren_pos.lnum);
! 		    if (ind_unclosed_wrapped
  				       && cin_ends_in(l, (char_u *)"(", NULL))
  		    {
  			/* look for opening unmatched paren, indent one level
--- 7260,7284 ----
  		curwin->w_cursor.lnum = save_lnum;
  		look = ml_get(our_paren_pos.lnum) + look_col;
  	    }
! 	    if (theline[0] == ')' || (curbuf->b_ind_unclosed == 0
! 						      && is_if_for_while == 0)
! 		    || (!curbuf->b_ind_unclosed_noignore && *look == '('
  						    && ignore_paren_col == 0))
  	    {
  		/*
  		 * If we're looking at a close paren, line up right there;
  		 * otherwise, line up with the next (non-white) character.
! 		 * When b_ind_unclosed_wrapped is set and the matching paren is
  		 * the last nonwhite character of the line, use either the
  		 * indent of the current line or the indentation of the next
! 		 * outer paren and add b_ind_unclosed_wrapped (for very long
  		 * lines).
  		 */
  		if (theline[0] != ')')
  		{
  		    cur_amount = MAXCOL;
  		    l = ml_get(our_paren_pos.lnum);
! 		    if (curbuf->b_ind_unclosed_wrapped
  				       && cin_ends_in(l, (char_u *)"(", NULL))
  		    {
  			/* look for opening unmatched paren, indent one level
***************
*** 7346,7354 ****
  			}
  
  			our_paren_pos.col = 0;
! 			amount += n * ind_unclosed_wrapped;
  		    }
! 		    else if (ind_unclosed_whiteok)
  			our_paren_pos.col++;
  		    else
  		    {
--- 7300,7308 ----
  			}
  
  			our_paren_pos.col = 0;
! 			amount += n * curbuf->b_ind_unclosed_wrapped;
  		    }
! 		    else if (curbuf->b_ind_unclosed_whiteok)
  			our_paren_pos.col++;
  		    else
  		    {
***************
*** 7374,7385 ****
  		}
  	    }
  
! 	    if (theline[0] == ')' && ind_matching_paren)
  	    {
  		/* Line up with the start of the matching paren line. */
  	    }
! 	    else if ((ind_unclosed == 0 && is_if_for_while == 0)
! 		     || (!ind_unclosed_noignore
  				    && *look == '(' && ignore_paren_col == 0))
  	    {
  		if (cur_amount != MAXCOL)
--- 7328,7339 ----
  		}
  	    }
  
! 	    if (theline[0] == ')' && curbuf->b_ind_matching_paren)
  	    {
  		/* Line up with the start of the matching paren line. */
  	    }
! 	    else if ((curbuf->b_ind_unclosed == 0 && is_if_for_while == 0)
! 		     || (!curbuf->b_ind_unclosed_noignore
  				    && *look == '(' && ignore_paren_col == 0))
  	    {
  		if (cur_amount != MAXCOL)
***************
*** 7387,7425 ****
  	    }
  	    else
  	    {
! 		/* Add ind_unclosed2 for each '(' before our matching one, but
! 		 * ignore (void) before the line (ignore_paren_col). */
  		col = our_paren_pos.col;
  		while ((int)our_paren_pos.col > ignore_paren_col)
  		{
  		    --our_paren_pos.col;
  		    switch (*ml_get_pos(&our_paren_pos))
  		    {
! 			case '(': amount += ind_unclosed2;
  				  col = our_paren_pos.col;
  				  break;
! 			case ')': amount -= ind_unclosed2;
  				  col = MAXCOL;
  				  break;
  		    }
  		}
  
! 		/* Use ind_unclosed once, when the first '(' is not inside
  		 * braces */
  		if (col == MAXCOL)
! 		    amount += ind_unclosed;
  		else
  		{
  		    curwin->w_cursor.lnum = our_paren_pos.lnum;
  		    curwin->w_cursor.col = col;
! 		    if (find_match_paren(ind_maxparen, ind_maxcomment) != NULL)
! 			amount += ind_unclosed2;
  		    else
  		    {
  			if (is_if_for_while)
! 			    amount += ind_if_for_while;
  			else
! 			    amount += ind_unclosed;
  		    }
  		}
  		/*
--- 7341,7380 ----
  	    }
  	    else
  	    {
! 		/* Add b_ind_unclosed2 for each '(' before our matching one,
! 		 * but ignore (void) before the line (ignore_paren_col). */
  		col = our_paren_pos.col;
  		while ((int)our_paren_pos.col > ignore_paren_col)
  		{
  		    --our_paren_pos.col;
  		    switch (*ml_get_pos(&our_paren_pos))
  		    {
! 			case '(': amount += curbuf->b_ind_unclosed2;
  				  col = our_paren_pos.col;
  				  break;
! 			case ')': amount -= curbuf->b_ind_unclosed2;
  				  col = MAXCOL;
  				  break;
  		    }
  		}
  
! 		/* Use b_ind_unclosed once, when the first '(' is not inside
  		 * braces */
  		if (col == MAXCOL)
! 		    amount += curbuf->b_ind_unclosed;
  		else
  		{
  		    curwin->w_cursor.lnum = our_paren_pos.lnum;
  		    curwin->w_cursor.col = col;
! 		    if (find_match_paren(curbuf->b_ind_maxparen,
! 					    curbuf->b_ind_maxcomment) != NULL)
! 			amount += curbuf->b_ind_unclosed2;
  		    else
  		    {
  			if (is_if_for_while)
! 			    amount += curbuf->b_ind_if_for_while;
  			else
! 			    amount += curbuf->b_ind_unclosed;
  		    }
  		}
  		/*
***************
*** 7437,7443 ****
  
  	/* add extra indent for a comment */
  	if (cin_iscomment(theline))
! 	    amount += ind_comment;
        }
  
        /*
--- 7392,7398 ----
  
  	/* add extra indent for a comment */
  	if (cin_iscomment(theline))
! 	    amount += curbuf->b_ind_comment;
        }
  
        /*
***************
*** 7480,7487 ****
  	     */
  	    lnum = ourscope;
  	    if (find_last_paren(start, '(', ')')
! 		    && (trypos = find_match_paren(ind_maxparen,
! 						     ind_maxcomment)) != NULL)
  		lnum = trypos->lnum;
  
  	    /*
--- 7435,7442 ----
  	     */
  	    lnum = ourscope;
  	    if (find_last_paren(start, '(', ')')
! 		    && (trypos = find_match_paren(curbuf->b_ind_maxparen,
! 					   curbuf->b_ind_maxcomment)) != NULL)
  		lnum = trypos->lnum;
  
  	    /*
***************
*** 7490,7500 ****
  	     *			ldfd) {
  	     *		    }
  	     */
! 	    if (ind_js || (ind_keep_case_label
  			   && cin_iscase(skipwhite(ml_get_curline()), FALSE)))
  		amount = get_indent();
  	    else
! 		amount = skip_label(lnum, &l, ind_maxcomment);
  
  	    start_brace = BRACE_AT_END;
  	}
--- 7445,7455 ----
  	     *			ldfd) {
  	     *		    }
  	     */
! 	    if (curbuf->b_ind_js || (curbuf->b_ind_keep_case_label
  			   && cin_iscase(skipwhite(ml_get_curline()), FALSE)))
  		amount = get_indent();
  	    else
! 		amount = skip_label(lnum, &l, curbuf->b_ind_maxcomment);
  
  	    start_brace = BRACE_AT_END;
  	}
***************
*** 7510,7516 ****
  	     * they may want closing braces to line up with something
  	     * other than the open brace.  indulge them, if so.
  	     */
! 	    amount += ind_close_extra;
  	}
  	else
  	{
--- 7465,7471 ----
  	     * they may want closing braces to line up with something
  	     * other than the open brace.  indulge them, if so.
  	     */
! 	    amount += curbuf->b_ind_close_extra;
  	}
  	else
  	{
***************
*** 7523,7536 ****
  	    lookfor = LOOKFOR_INITIAL;
  	    if (cin_iselse(theline))
  		lookfor = LOOKFOR_IF;
! 	    else if (cin_iswhileofdo(theline, cur_curpos.lnum, ind_maxparen))
! 								    /* XXX */
  		lookfor = LOOKFOR_DO;
  	    if (lookfor != LOOKFOR_INITIAL)
  	    {
  		curwin->w_cursor.lnum = cur_curpos.lnum;
! 		if (find_match(lookfor, ourscope, ind_maxparen,
! 							ind_maxcomment) == OK)
  		{
  		    amount = get_indent();	/* XXX */
  		    goto theend;
--- 7478,7491 ----
  	    lookfor = LOOKFOR_INITIAL;
  	    if (cin_iselse(theline))
  		lookfor = LOOKFOR_IF;
! 	    else if (cin_iswhileofdo(theline, cur_curpos.lnum,
! 					    curbuf->b_ind_maxparen)) /* XXX */
  		lookfor = LOOKFOR_DO;
  	    if (lookfor != LOOKFOR_INITIAL)
  	    {
  		curwin->w_cursor.lnum = cur_curpos.lnum;
! 		if (find_match(lookfor, ourscope, curbuf->b_ind_maxparen,
! 					      curbuf->b_ind_maxcomment) == OK)
  		{
  		    amount = get_indent();	/* XXX */
  		    goto theend;
***************
*** 7547,7558 ****
  	    /*
  	     * if the '{' is  _really_ at the left margin, use the imaginary
  	     * location of a left-margin brace.  Otherwise, correct the
! 	     * location for ind_open_extra.
  	     */
  
  	    if (start_brace == BRACE_IN_COL0)	    /* '{' is in column 0 */
  	    {
! 		amount = ind_open_left_imag;
  		lookfor_cpp_namespace = TRUE;
  	    }
  	    else if (start_brace == BRACE_AT_START &&
--- 7502,7513 ----
  	    /*
  	     * if the '{' is  _really_ at the left margin, use the imaginary
  	     * location of a left-margin brace.  Otherwise, correct the
! 	     * location for b_ind_open_extra.
  	     */
  
  	    if (start_brace == BRACE_IN_COL0)	    /* '{' is in column 0 */
  	    {
! 		amount = curbuf->b_ind_open_left_imag;
  		lookfor_cpp_namespace = TRUE;
  	    }
  	    else if (start_brace == BRACE_AT_START &&
***************
*** 7565,7580 ****
  	    {
  		if (start_brace == BRACE_AT_END)    /* '{' is at end of line */
  		{
! 		    amount += ind_open_imag;
  
  		    l = skipwhite(ml_get_curline());
  		    if (cin_is_cpp_namespace(l))
! 			amount += ind_cpp_namespace;
  		}
  		else
  		{
! 		    /* Compensate for adding ind_open_extra later. */
! 		    amount -= ind_open_extra;
  		    if (amount < 0)
  			amount = 0;
  		}
--- 7520,7535 ----
  	    {
  		if (start_brace == BRACE_AT_END)    /* '{' is at end of line */
  		{
! 		    amount += curbuf->b_ind_open_imag;
  
  		    l = skipwhite(ml_get_curline());
  		    if (cin_is_cpp_namespace(l))
! 			amount += curbuf->b_ind_cpp_namespace;
  		}
  		else
  		{
! 		    /* Compensate for adding b_ind_open_extra later. */
! 		    amount -= curbuf->b_ind_open_extra;
  		    if (amount < 0)
  			amount = 0;
  		}
***************
*** 7585,7604 ****
  	    if (cin_iscase(theline, FALSE))	/* it's a switch() label */
  	    {
  		lookfor = LOOKFOR_CASE;	/* find a previous switch() label */
! 		amount += ind_case;
  	    }
  	    else if (cin_isscopedecl(theline))	/* private:, ... */
  	    {
  		lookfor = LOOKFOR_SCOPEDECL;	/* class decl is this block */
! 		amount += ind_scopedecl;
  	    }
  	    else
  	    {
! 		if (ind_case_break && cin_isbreak(theline))	/* break; ... */
  		    lookfor_break = TRUE;
  
  		lookfor = LOOKFOR_INITIAL;
! 		amount += ind_level;	/* ind_level from start of block */
  	    }
  	    scope_amount = amount;
  	    whilelevel = 0;
--- 7540,7561 ----
  	    if (cin_iscase(theline, FALSE))	/* it's a switch() label */
  	    {
  		lookfor = LOOKFOR_CASE;	/* find a previous switch() label */
! 		amount += curbuf->b_ind_case;
  	    }
  	    else if (cin_isscopedecl(theline))	/* private:, ... */
  	    {
  		lookfor = LOOKFOR_SCOPEDECL;	/* class decl is this block */
! 		amount += curbuf->b_ind_scopedecl;
  	    }
  	    else
  	    {
! 		if (curbuf->b_ind_case_break && cin_isbreak(theline))
! 		    /* break; ... */
  		    lookfor_break = TRUE;
  
  		lookfor = LOOKFOR_INITIAL;
! 		/* b_ind_level from start of block */
! 		amount += curbuf->b_ind_level;
  	    }
  	    scope_amount = amount;
  	    whilelevel = 0;
***************
*** 7636,7649 ****
  		    {
  			if (curwin->w_cursor.lnum == 0
  				|| curwin->w_cursor.lnum
! 						    < ourscope - ind_maxparen)
  			{
! 			    /* nothing found (abuse ind_maxparen as limit)
! 			     * assume terminated line (i.e. a variable
  			     * initialization) */
  			    if (cont_amount > 0)
  				amount = cont_amount;
! 			    else if (!ind_js)
  				amount += ind_continuation;
  			    break;
  			}
--- 7593,7606 ----
  		    {
  			if (curwin->w_cursor.lnum == 0
  				|| curwin->w_cursor.lnum
! 					  < ourscope - curbuf->b_ind_maxparen)
  			{
! 			    /* nothing found (abuse curbuf->b_ind_maxparen as
! 			     * limit) assume terminated line (i.e. a variable
  			     * initialization) */
  			    if (cont_amount > 0)
  				amount = cont_amount;
! 			    else if (!curbuf->b_ind_js)
  				amount += ind_continuation;
  			    break;
  			}
***************
*** 7654,7660 ****
  			 * If we're in a comment now, skip to the start of the
  			 * comment.
  			 */
! 			trypos = find_start_comment(ind_maxcomment);
  			if (trypos != NULL)
  			{
  			    curwin->w_cursor.lnum = trypos->lnum + 1;
--- 7611,7617 ----
  			 * If we're in a comment now, skip to the start of the
  			 * comment.
  			 */
! 			trypos = find_start_comment(curbuf->b_ind_maxcomment);
  			if (trypos != NULL)
  			{
  			    curwin->w_cursor.lnum = trypos->lnum + 1;
***************
*** 7680,7686 ****
  			 */
  			if (start_brace != BRACE_IN_COL0
  				|| !cin_isfuncdecl(&l, curwin->w_cursor.lnum,
! 					     0, ind_maxparen, ind_maxcomment))
  			{
  			    /* if the line is terminated with another ','
  			     * it is a continued variable initialization.
--- 7637,7644 ----
  			 */
  			if (start_brace != BRACE_IN_COL0
  				|| !cin_isfuncdecl(&l, curwin->w_cursor.lnum,
! 					     0, curbuf->b_ind_maxparen,
! 						    curbuf->b_ind_maxcomment))
  			{
  			    /* if the line is terminated with another ','
  			     * it is a continued variable initialization.
***************
*** 7711,7721 ****
  			     */					/* XXX */
  			    trypos = NULL;
  			    if (find_last_paren(l, '(', ')'))
! 				trypos = find_match_paren(ind_maxparen,
! 					ind_maxcomment);
  
  			    if (trypos == NULL && find_last_paren(l, '{', '}'))
! 				trypos = find_start_brace(ind_maxcomment);
  
  			    if (trypos != NULL)
  			    {
--- 7669,7681 ----
  			     */					/* XXX */
  			    trypos = NULL;
  			    if (find_last_paren(l, '(', ')'))
! 				trypos = find_match_paren(
! 						curbuf->b_ind_maxparen,
! 						curbuf->b_ind_maxcomment);
  
  			    if (trypos == NULL && find_last_paren(l, '{', '}'))
! 				trypos = find_start_brace(
! 						    curbuf->b_ind_maxcomment);
  
  			    if (trypos != NULL)
  			    {
***************
*** 7750,7757 ****
  			    amount = scope_amount;
  			    if (theline[0] == '{')
  			    {
! 				amount += ind_open_extra;
! 				added_to_amount = ind_open_extra;
  			    }
  			}
  
--- 7710,7717 ----
  			    amount = scope_amount;
  			    if (theline[0] == '{')
  			    {
! 				amount += curbuf->b_ind_open_extra;
! 				added_to_amount = curbuf->b_ind_open_extra;
  			    }
  			}
  
***************
*** 7773,7779 ****
  
  			    /* If we're in a comment now, skip to the start of
  			     * the comment. */
! 			    trypos = find_start_comment(ind_maxcomment);
  			    if (trypos != NULL)
  			    {
  				curwin->w_cursor.lnum = trypos->lnum + 1;
--- 7733,7740 ----
  
  			    /* If we're in a comment now, skip to the start of
  			     * the comment. */
! 			    trypos = find_start_comment(
! 						    curbuf->b_ind_maxcomment);
  			    if (trypos != NULL)
  			    {
  				curwin->w_cursor.lnum = trypos->lnum + 1;
***************
*** 7788,7794 ****
  			    /* Finally the actual check for "namespace". */
  			    if (cin_is_cpp_namespace(l))
  			    {
! 				amount += ind_cpp_namespace - added_to_amount;
  				break;
  			    }
  
--- 7749,7756 ----
  			    /* Finally the actual check for "namespace". */
  			    if (cin_is_cpp_namespace(l))
  			    {
! 				amount += curbuf->b_ind_cpp_namespace
! 							    - added_to_amount;
  				break;
  			    }
  
***************
*** 7802,7808 ****
  		/*
  		 * If we're in a comment now, skip to the start of the comment.
  		 */					    /* XXX */
! 		if ((trypos = find_start_comment(ind_maxcomment)) != NULL)
  		{
  		    curwin->w_cursor.lnum = trypos->lnum + 1;
  		    curwin->w_cursor.col = 0;
--- 7764,7771 ----
  		/*
  		 * If we're in a comment now, skip to the start of the comment.
  		 */					    /* XXX */
! 		if ((trypos = find_start_comment(curbuf->b_ind_maxcomment))
! 								      != NULL)
  		{
  		    curwin->w_cursor.lnum = trypos->lnum + 1;
  		    curwin->w_cursor.col = 0;
***************
*** 7856,7863 ****
  			 * Check that this case label is not for another
  			 * switch()
  			 */				    /* XXX */
! 			if ((trypos = find_start_brace(ind_maxcomment)) ==
! 					     NULL || trypos->lnum == ourscope)
  			{
  			    amount = get_indent();	/* XXX */
  			    break;
--- 7819,7827 ----
  			 * Check that this case label is not for another
  			 * switch()
  			 */				    /* XXX */
! 			if ((trypos = find_start_brace(
! 					    curbuf->b_ind_maxcomment)) == NULL
! 						  || trypos->lnum == ourscope)
  			{
  			    amount = get_indent();	/* XXX */
  			    break;
***************
*** 7900,7908 ****
  			if (l != NULL && cin_is_cinword(l))
  			{
  			    if (theline[0] == '{')
! 				amount += ind_open_extra;
  			    else
! 				amount += ind_level + ind_no_brace;
  			}
  			break;
  		    }
--- 7864,7873 ----
  			if (l != NULL && cin_is_cinword(l))
  			{
  			    if (theline[0] == '{')
! 				amount += curbuf->b_ind_open_extra;
  			    else
! 				amount += curbuf->b_ind_level
! 						     + curbuf->b_ind_no_brace;
  			}
  			break;
  		    }
***************
*** 7916,7923 ****
  		     * ->   y = 1;
  		     */
  		    scope_amount = get_indent() + (iscase    /* XXX */
! 					? ind_case_code : ind_scopedecl_code);
! 		    lookfor = ind_case_break ? LOOKFOR_NOBREAK : LOOKFOR_ANY;
  		    continue;
  		}
  
--- 7881,7890 ----
  		     * ->   y = 1;
  		     */
  		    scope_amount = get_indent() + (iscase    /* XXX */
! 					? curbuf->b_ind_case_code
! 					: curbuf->b_ind_scopedecl_code);
! 		    lookfor = curbuf->b_ind_case_break
! 					      ? LOOKFOR_NOBREAK : LOOKFOR_ANY;
  		    continue;
  		}
  
***************
*** 7928,7934 ****
  		if (lookfor == LOOKFOR_CASE || lookfor == LOOKFOR_SCOPEDECL)
  		{
  		    if (find_last_paren(l, '{', '}') && (trypos =
! 				    find_start_brace(ind_maxcomment)) != NULL)
  		    {
  			curwin->w_cursor.lnum = trypos->lnum + 1;
  			curwin->w_cursor.col = 0;
--- 7895,7901 ----
  		if (lookfor == LOOKFOR_CASE || lookfor == LOOKFOR_SCOPEDECL)
  		{
  		    if (find_last_paren(l, '{', '}') && (trypos =
! 			  find_start_brace(curbuf->b_ind_maxcomment)) != NULL)
  		    {
  			curwin->w_cursor.lnum = trypos->lnum + 1;
  			curwin->w_cursor.col = 0;
***************
*** 7939,7945 ****
  		/*
  		 * Ignore jump labels with nothing after them.
  		 */
! 		if (!ind_js && cin_islabel(ind_maxcomment))
  		{
  		    l = after_label(ml_get_curline());
  		    if (l == NULL || cin_nocode(l))
--- 7906,7912 ----
  		/*
  		 * Ignore jump labels with nothing after them.
  		 */
! 		if (!curbuf->b_ind_js && cin_islabel(curbuf->b_ind_maxcomment))
  		{
  		    l = after_label(ml_get_curline());
  		    if (l == NULL || cin_nocode(l))
***************
*** 7962,7968 ****
  		 * constructor initialization?
  		 */						    /* XXX */
  		n = FALSE;
! 		if (lookfor != LOOKFOR_TERM && ind_cpp_baseclass > 0)
  		{
  		    n = cin_is_cpp_baseclass(&col);
  		    l = ml_get_curline();
--- 7929,7935 ----
  		 * constructor initialization?
  		 */						    /* XXX */
  		n = FALSE;
! 		if (lookfor != LOOKFOR_TERM && curbuf->b_ind_cpp_baseclass > 0)
  		{
  		    n = cin_is_cpp_baseclass(&col);
  		    l = ml_get_curline();
***************
*** 7985,7992 ****
  		    }
  		    else
  								     /* XXX */
! 			amount = get_baseclass_amount(col, ind_maxparen,
! 					   ind_maxcomment, ind_cpp_baseclass);
  		    break;
  		}
  		else if (lookfor == LOOKFOR_CPP_BASECLASS)
--- 7952,7961 ----
  		    }
  		    else
  								     /* XXX */
! 			amount = get_baseclass_amount(col,
! 						   curbuf->b_ind_maxparen,
! 						   curbuf->b_ind_maxcomment,
! 						   curbuf->b_ind_cpp_baseclass);
  		    break;
  		}
  		else if (lookfor == LOOKFOR_CPP_BASECLASS)
***************
*** 8029,8036 ****
  		     */
  		    (void)find_last_paren(l, '(', ')');
  		    trypos = find_match_paren(
! 				 corr_ind_maxparen(ind_maxparen, &cur_curpos),
! 							      ind_maxcomment);
  
  		    /*
  		     * If we are looking for ',', we also look for matching
--- 7998,8005 ----
  		     */
  		    (void)find_last_paren(l, '(', ')');
  		    trypos = find_match_paren(
! 				 corr_ind_maxparen(curbuf->b_ind_maxparen,
! 				      &cur_curpos), curbuf->b_ind_maxcomment);
  
  		    /*
  		     * If we are looking for ',', we also look for matching
***************
*** 8038,8044 ****
  		     */
  		    if (trypos == NULL && terminated == ','
  					      && find_last_paren(l, '{', '}'))
! 			trypos = find_start_brace(ind_maxcomment);
  
  		    if (trypos != NULL)
  		    {
--- 8007,8013 ----
  		     */
  		    if (trypos == NULL && terminated == ','
  					      && find_last_paren(l, '{', '}'))
! 			trypos = find_start_brace(curbuf->b_ind_maxcomment);
  
  		    if (trypos != NULL)
  		    {
***************
*** 8081,8089 ****
  		     * Get indent and pointer to text for current line,
  		     * ignoring any jump label.	    XXX
  		     */
! 		    if (!ind_js)
  			cur_amount = skip_label(curwin->w_cursor.lnum,
! 							  &l, ind_maxcomment);
  		    else
  			cur_amount = get_indent();
  		    /*
--- 8050,8058 ----
  		     * Get indent and pointer to text for current line,
  		     * ignoring any jump label.	    XXX
  		     */
! 		    if (!curbuf->b_ind_js)
  			cur_amount = skip_label(curwin->w_cursor.lnum,
! 						&l, curbuf->b_ind_maxcomment);
  		    else
  			cur_amount = get_indent();
  		    /*
***************
*** 8098,8113 ****
  		    {
  			amount = cur_amount;
  			/*
! 			 * Only add ind_open_extra when the current line
  			 * doesn't start with a '{', which must have a match
  			 * in the same line (scope is the same).  Probably:
  			 *	{ 1, 2 },
  			 * ->	{ 3, 4 }
  			 */
  			if (*skipwhite(l) != '{')
! 			    amount += ind_open_extra;
  
! 			if (ind_cpp_baseclass)
  			{
  			    /* have to look back, whether it is a cpp base
  			     * class declaration or initialization */
--- 8067,8082 ----
  		    {
  			amount = cur_amount;
  			/*
! 			 * Only add b_ind_open_extra when the current line
  			 * doesn't start with a '{', which must have a match
  			 * in the same line (scope is the same).  Probably:
  			 *	{ 1, 2 },
  			 * ->	{ 3, 4 }
  			 */
  			if (*skipwhite(l) != '{')
! 			    amount += curbuf->b_ind_open_extra;
  
! 			if (curbuf->b_ind_cpp_baseclass)
  			{
  			    /* have to look back, whether it is a cpp base
  			     * class declaration or initialization */
***************
*** 8155,8164 ****
  			 */
  			amount = cur_amount;
  			if (theline[0] == '{')
! 			    amount += ind_open_extra;
  			if (lookfor != LOOKFOR_TERM)
  			{
! 			    amount += ind_level + ind_no_brace;
  			    break;
  			}
  
--- 8124,8134 ----
  			 */
  			amount = cur_amount;
  			if (theline[0] == '{')
! 			    amount += curbuf->b_ind_open_extra;
  			if (lookfor != LOOKFOR_TERM)
  			{
! 			    amount += curbuf->b_ind_level
! 						     + curbuf->b_ind_no_brace;
  			    break;
  			}
  
***************
*** 8192,8201 ****
  				curwin->w_cursor.col =
  					  (colnr_T)(l - ml_get_curline()) + 1;
  
! 			    if ((trypos = find_start_brace(ind_maxcomment))
! 								       == NULL
  				    || find_match(LOOKFOR_IF, trypos->lnum,
! 					ind_maxparen, ind_maxcomment) == FAIL)
  				break;
  			}
  		    }
--- 8162,8172 ----
  				curwin->w_cursor.col =
  					  (colnr_T)(l - ml_get_curline()) + 1;
  
! 			    if ((trypos = find_start_brace(
! 					    curbuf->b_ind_maxcomment)) == NULL
  				    || find_match(LOOKFOR_IF, trypos->lnum,
! 					    curbuf->b_ind_maxparen,
! 					    curbuf->b_ind_maxcomment) == FAIL)
  				break;
  			}
  		    }
***************
*** 8232,8238 ****
  			     * enumerations/initializations. */
  			    if (terminated == ',')
  			    {
! 				if (ind_cpp_baseclass == 0)
  				    break;
  
  				lookfor = LOOKFOR_CPP_BASECLASS;
--- 8203,8209 ----
  			     * enumerations/initializations. */
  			    if (terminated == ',')
  			    {
! 				if (curbuf->b_ind_cpp_baseclass == 0)
  				    break;
  
  				lookfor = LOOKFOR_CPP_BASECLASS;
***************
*** 8290,8297 ****
  		 * If so: Ignore until the matching "do".
  		 */
  							/* XXX */
! 		else if (cin_iswhileofdo_end(terminated, ind_maxparen,
! 							      ind_maxcomment))
  		{
  		    /*
  		     * Found an unterminated line after a while ();, line up
--- 8261,8268 ----
  		 * If so: Ignore until the matching "do".
  		 */
  							/* XXX */
! 		else if (cin_iswhileofdo_end(terminated, curbuf->b_ind_maxparen,
! 						    curbuf->b_ind_maxcomment))
  		{
  		    /*
  		     * Found an unterminated line after a while ();, line up
***************
*** 8315,8321 ****
  			lookfor = LOOKFOR_TERM;
  			amount = get_indent();	    /* XXX */
  			if (theline[0] == '{')
! 			    amount += ind_open_extra;
  		    }
  		    ++whilelevel;
  		}
--- 8286,8292 ----
  			lookfor = LOOKFOR_TERM;
  			amount = get_indent();	    /* XXX */
  			if (theline[0] == '{')
! 			    amount += curbuf->b_ind_open_extra;
  		    }
  		    ++whilelevel;
  		}
***************
*** 8408,8415 ****
  term_again:
  			l = ml_get_curline();
  			if (find_last_paren(l, '(', ')')
! 				&& (trypos = find_match_paren(ind_maxparen,
! 						     ind_maxcomment)) != NULL)
  			{
  			    /*
  			     * Check if we are on a case label now.  This is
--- 8379,8387 ----
  term_again:
  			l = ml_get_curline();
  			if (find_last_paren(l, '(', ')')
! 				&& (trypos = find_match_paren(
! 					   curbuf->b_ind_maxparen,
! 					   curbuf->b_ind_maxcomment)) != NULL)
  			{
  			    /*
  			     * Check if we are on a case label now.  This is
***************
*** 8436,8456 ****
  			 *	stat;
  			 * }
  			 */
! 			iscase = (ind_keep_case_label && cin_iscase(l, FALSE));
  
  			/*
  			 * Get indent and pointer to text for current line,
  			 * ignoring any jump label.
  			 */
  			amount = skip_label(curwin->w_cursor.lnum,
! 							  &l, ind_maxcomment);
  
  			if (theline[0] == '{')
! 			    amount += ind_open_extra;
! 			/* See remark above: "Only add ind_open_extra.." */
  			l = skipwhite(l);
  			if (*l == '{')
! 			    amount -= ind_open_extra;
  			lookfor = iscase ? LOOKFOR_ANY : LOOKFOR_TERM;
  
  			/*
--- 8408,8429 ----
  			 *	stat;
  			 * }
  			 */
! 			iscase = (curbuf->b_ind_keep_case_label
! 						     && cin_iscase(l, FALSE));
  
  			/*
  			 * Get indent and pointer to text for current line,
  			 * ignoring any jump label.
  			 */
  			amount = skip_label(curwin->w_cursor.lnum,
! 						&l, curbuf->b_ind_maxcomment);
  
  			if (theline[0] == '{')
! 			    amount += curbuf->b_ind_open_extra;
! 			/* See remark above: "Only add b_ind_open_extra.." */
  			l = skipwhite(l);
  			if (*l == '{')
! 			    amount -= curbuf->b_ind_open_extra;
  			lookfor = iscase ? LOOKFOR_ANY : LOOKFOR_TERM;
  
  			/*
***************
*** 8466,8475 ****
  				&& cin_iselse(l)
  				&& whilelevel == 0)
  			{
! 			    if ((trypos = find_start_brace(ind_maxcomment))
! 								       == NULL
  				    || find_match(LOOKFOR_IF, trypos->lnum,
! 					ind_maxparen, ind_maxcomment) == FAIL)
  				break;
  			    continue;
  			}
--- 8439,8449 ----
  				&& cin_iselse(l)
  				&& whilelevel == 0)
  			{
! 			    if ((trypos = find_start_brace(
! 					    curbuf->b_ind_maxcomment)) == NULL
  				    || find_match(LOOKFOR_IF, trypos->lnum,
! 					    curbuf->b_ind_maxparen,
! 					    curbuf->b_ind_maxcomment) == FAIL)
  				break;
  			    continue;
  			}
***************
*** 8480,8487 ****
  			 */
  			l = ml_get_curline();
  			if (find_last_paren(l, '{', '}')
! 				&& (trypos = find_start_brace(ind_maxcomment))
! 							    != NULL) /* XXX */
  			{
  			    curwin->w_cursor = *trypos;
  			    /* if not "else {" check for terminated again */
--- 8454,8461 ----
  			 */
  			l = ml_get_curline();
  			if (find_last_paren(l, '{', '}')
! 				&& (trypos = find_start_brace(
! 				 curbuf->b_ind_maxcomment)) != NULL) /* XXX */
  			{
  			    curwin->w_cursor = *trypos;
  			    /* if not "else {" check for terminated again */
***************
*** 8500,8510 ****
  
        /* add extra indent for a comment */
        if (cin_iscomment(theline))
! 	  amount += ind_comment;
  
        /* subtract extra left-shift for jump labels */
!       if (ind_jump_label > 0 && original_line_islabel)
! 	  amount -= ind_jump_label;
      }
  
      /*
--- 8474,8484 ----
  
        /* add extra indent for a comment */
        if (cin_iscomment(theline))
! 	  amount += curbuf->b_ind_comment;
  
        /* subtract extra left-shift for jump labels */
!       if (curbuf->b_ind_jump_label > 0 && original_line_islabel)
! 	  amount -= curbuf->b_ind_jump_label;
      }
  
      /*
***************
*** 8525,8531 ****
  
  	if (theline[0] == '{')
  	{
! 	    amount = ind_first_open;
  	}
  
  	/*
--- 8499,8505 ----
  
  	if (theline[0] == '{')
  	{
! 	    amount = curbuf->b_ind_first_open;
  	}
  
  	/*
***************
*** 8543,8552 ****
  		&& !cin_ends_in(theline, (char_u *)",", NULL)
  		&& cin_isfuncdecl(NULL, cur_curpos.lnum + 1,
  				  cur_curpos.lnum + 1,
! 				  ind_maxparen, ind_maxcomment)
  		&& !cin_isterminated(theline, FALSE, TRUE))
  	{
! 	    amount = ind_func_type;
  	}
  	else
  	{
--- 8517,8527 ----
  		&& !cin_ends_in(theline, (char_u *)",", NULL)
  		&& cin_isfuncdecl(NULL, cur_curpos.lnum + 1,
  				  cur_curpos.lnum + 1,
! 				  curbuf->b_ind_maxparen,
! 				  curbuf->b_ind_maxcomment)
  		&& !cin_isterminated(theline, FALSE, TRUE))
  	{
! 	    amount = curbuf->b_ind_func_type;
  	}
  	else
  	{
***************
*** 8565,8571 ****
  		/*
  		 * If we're in a comment now, skip to the start of the comment.
  		 */						/* XXX */
! 		if ((trypos = find_start_comment(ind_maxcomment)) != NULL)
  		{
  		    curwin->w_cursor.lnum = trypos->lnum + 1;
  		    curwin->w_cursor.col = 0;
--- 8540,8547 ----
  		/*
  		 * If we're in a comment now, skip to the start of the comment.
  		 */						/* XXX */
! 		if ((trypos = find_start_comment(
! 					   curbuf->b_ind_maxcomment)) != NULL)
  		{
  		    curwin->w_cursor.lnum = trypos->lnum + 1;
  		    curwin->w_cursor.col = 0;
***************
*** 8577,8583 ****
  		 * constructor initialization?
  		 */						    /* XXX */
  		n = FALSE;
! 		if (ind_cpp_baseclass != 0 && theline[0] != '{')
  		{
  		    n = cin_is_cpp_baseclass(&col);
  		    l = ml_get_curline();
--- 8553,8559 ----
  		 * constructor initialization?
  		 */						    /* XXX */
  		n = FALSE;
! 		if (curbuf->b_ind_cpp_baseclass != 0 && theline[0] != '{')
  		{
  		    n = cin_is_cpp_baseclass(&col);
  		    l = ml_get_curline();
***************
*** 8585,8592 ****
  		if (n)
  		{
  								     /* XXX */
! 		    amount = get_baseclass_amount(col, ind_maxparen,
! 					   ind_maxcomment, ind_cpp_baseclass);
  		    break;
  		}
  
--- 8561,8569 ----
  		if (n)
  		{
  								     /* XXX */
! 		    amount = get_baseclass_amount(col, curbuf->b_ind_maxparen,
! 					   curbuf->b_ind_maxcomment,
! 					   curbuf->b_ind_cpp_baseclass);
  		    break;
  		}
  
***************
*** 8617,8624 ****
  		{
  		    /* take us back to opening paren */
  		    if (find_last_paren(l, '(', ')')
! 			    && (trypos = find_match_paren(ind_maxparen,
! 						     ind_maxcomment)) != NULL)
  			curwin->w_cursor = *trypos;
  
  		    /* For a line ending in ',' that is a continuation line go
--- 8594,8602 ----
  		{
  		    /* take us back to opening paren */
  		    if (find_last_paren(l, '(', ')')
! 			    && (trypos = find_match_paren(
! 					   curbuf->b_ind_maxparen,
! 					   curbuf->b_ind_maxcomment)) != NULL)
  			curwin->w_cursor = *trypos;
  
  		    /* For a line ending in ',' that is a continuation line go
***************
*** 8650,8656 ****
  		 * not in a comment, put it the left margin.
  		 */
  		if (cin_isfuncdecl(NULL, cur_curpos.lnum, 0,
! 				   ind_maxparen, ind_maxcomment))  /* XXX */
  		    break;
  		l = ml_get_curline();
  
--- 8628,8635 ----
  		 * not in a comment, put it the left margin.
  		 */
  		if (cin_isfuncdecl(NULL, cur_curpos.lnum, 0,
! 				   curbuf->b_ind_maxparen,
! 				   curbuf->b_ind_maxcomment))  /* XXX */
  		    break;
  		l = ml_get_curline();
  
***************
*** 8699,8707 ****
  		 * parameters.
  		 */
  		if (cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0,
! 				   ind_maxparen, ind_maxcomment))
  		{
! 		    amount = ind_param;
  		    break;
  		}
  
--- 8678,8687 ----
  		 * parameters.
  		 */
  		if (cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0,
! 				   curbuf->b_ind_maxparen,
! 				   curbuf->b_ind_maxcomment))
  		{
! 		    amount = curbuf->b_ind_param;
  		    break;
  		}
  
***************
*** 8730,8737 ****
  		 */
  		find_last_paren(l, '(', ')');
  
! 		if ((trypos = find_match_paren(ind_maxparen,
! 						     ind_maxcomment)) != NULL)
  		    curwin->w_cursor = *trypos;
  		amount = get_indent();	    /* XXX */
  		break;
--- 8710,8717 ----
  		 */
  		find_last_paren(l, '(', ')');
  
! 		if ((trypos = find_match_paren(curbuf->b_ind_maxparen,
! 					   curbuf->b_ind_maxcomment)) != NULL)
  		    curwin->w_cursor = *trypos;
  		amount = get_indent();	    /* XXX */
  		break;
***************
*** 8739,8745 ****
  
  	    /* add extra indent for a comment */
  	    if (cin_iscomment(theline))
! 		amount += ind_comment;
  
  	    /* add extra indent if the previous line ended in a backslash:
  	     *	      "asdfasdf\
--- 8719,8725 ----
  
  	    /* add extra indent for a comment */
  	    if (cin_iscomment(theline))
! 		amount += curbuf->b_ind_comment;
  
  	    /* add extra indent if the previous line ended in a backslash:
  	     *	      "asdfasdf\
*** ../vim-7.4.068/src/ops.c	2013-11-04 01:41:11.000000000 +0100
--- src/ops.c	2013-11-05 06:13:27.000000000 +0100
***************
*** 336,342 ****
  {
      int		count;
      int		i, j;
!     int		p_sw = (int)get_sw_value();
  
      count = get_indent();	/* get current indent */
  
--- 336,342 ----
  {
      int		count;
      int		i, j;
!     int		p_sw = (int)get_sw_value(curbuf);
  
      count = get_indent();	/* get current indent */
  
***************
*** 392,398 ****
      int			total;
      char_u		*newp, *oldp;
      int			oldcol = curwin->w_cursor.col;
!     int			p_sw = (int)get_sw_value();
      int			p_ts = (int)curbuf->b_p_ts;
      struct block_def	bd;
      int			incr;
--- 392,398 ----
      int			total;
      char_u		*newp, *oldp;
      int			oldcol = curwin->w_cursor.col;
!     int			p_sw = (int)get_sw_value(curbuf);
      int			p_ts = (int)curbuf->b_p_ts;
      struct block_def	bd;
      int			incr;
***************
*** 4046,4052 ****
  #  endif
  # endif
  # ifdef FEAT_CINDENT
! 	(curbuf->b_p_cin && in_cinkeys('#', ' ', TRUE))
  # endif
  	;
  }
--- 4046,4053 ----
  #  endif
  # endif
  # ifdef FEAT_CINDENT
! 	(curbuf->b_p_cin && in_cinkeys('#', ' ', TRUE)
! 					   && curbuf->b_ind_hash_comment == 0)
  # endif
  	;
  }
*** ../vim-7.4.068/src/proto/misc1.pro	2013-11-04 02:53:46.000000000 +0100
--- src/proto/misc1.pro	2013-11-05 06:08:46.000000000 +0100
***************
*** 84,89 ****
--- 84,90 ----
  int cin_islabel __ARGS((int ind_maxcomment));
  int cin_iscase __ARGS((char_u *s, int strict));
  int cin_isscopedecl __ARGS((char_u *s));
+ void parse_cino __ARGS((buf_T *buf));
  int get_c_indent __ARGS((void));
  int get_expr_indent __ARGS((void));
  int get_lisp_indent __ARGS((void));
*** ../vim-7.4.068/src/proto/option.pro	2013-08-10 13:37:22.000000000 +0200
--- src/proto/option.pro	2013-11-05 06:14:46.000000000 +0100
***************
*** 59,65 ****
  void save_file_ff __ARGS((buf_T *buf));
  int file_ff_differs __ARGS((buf_T *buf, int ignore_empty));
  int check_ff_value __ARGS((char_u *p));
! long get_sw_value __ARGS((void));
  long get_sts_value __ARGS((void));
  void find_mps_values __ARGS((int *initc, int *findc, int *backwards, int switchit));
  /* vim: set ft=c : */
--- 59,65 ----
  void save_file_ff __ARGS((buf_T *buf));
  int file_ff_differs __ARGS((buf_T *buf, int ignore_empty));
  int check_ff_value __ARGS((char_u *p));
! long get_sw_value __ARGS((buf_T *buf));
  long get_sts_value __ARGS((void));
  void find_mps_values __ARGS((int *initc, int *findc, int *backwards, int switchit));
  /* vim: set ft=c : */
*** ../vim-7.4.068/src/structs.h	2013-07-03 15:35:59.000000000 +0200
--- src/structs.h	2013-11-05 05:08:26.000000000 +0100
***************
*** 1633,1638 ****
--- 1633,1677 ----
  
      /* end of buffer options */
  
+ #ifdef FEAT_CINDENT
+     /* values set from b_p_cino */
+     int		b_ind_level;
+     int		b_ind_open_imag;
+     int		b_ind_no_brace;
+     int		b_ind_first_open;
+     int		b_ind_open_extra;
+     int		b_ind_close_extra;
+     int		b_ind_open_left_imag;
+     int		b_ind_jump_label;
+     int		b_ind_case;
+     int		b_ind_case_code;
+     int		b_ind_case_break;
+     int		b_ind_param;
+     int		b_ind_func_type;
+     int		b_ind_comment;
+     int		b_ind_in_comment;
+     int		b_ind_in_comment2;
+     int		b_ind_cpp_baseclass;
+     int		b_ind_continuation;
+     int		b_ind_unclosed;
+     int		b_ind_unclosed2;
+     int		b_ind_unclosed_noignore;
+     int		b_ind_unclosed_wrapped;
+     int		b_ind_unclosed_whiteok;
+     int		b_ind_matching_paren;
+     int		b_ind_paren_prev;
+     int		b_ind_maxparen;
+     int		b_ind_maxcomment;
+     int		b_ind_scopedecl;
+     int		b_ind_scopedecl_code;
+     int		b_ind_java;
+     int		b_ind_js;
+     int		b_ind_keep_case_label;
+     int		b_ind_hash_comment;
+     int		b_ind_cpp_namespace;
+     int		b_ind_if_for_while;
+ #endif
+ 
      linenr_T	b_no_eol_lnum;	/* non-zero lnum when last line of next binary
  				 * write should not have an end-of-line */
  
*** ../vim-7.4.068/src/option.c	2013-07-17 21:39:13.000000000 +0200
--- src/option.c	2013-11-05 06:58:04.000000000 +0100
***************
*** 5372,5377 ****
--- 5372,5378 ----
  #ifdef FEAT_CINDENT
      check_string_option(&buf->b_p_cink);
      check_string_option(&buf->b_p_cino);
+     parse_cino(buf);
  #endif
  #ifdef FEAT_AUTOCMD
      check_string_option(&buf->b_p_ft);
***************
*** 6990,6995 ****
--- 6991,7005 ----
      }
  #endif
  
+ #ifdef FEAT_CINDENT
+     /* 'cinoptions' */
+     else if (gvarp == &p_cino)
+     {
+ 	/* TODO: recognize errors */
+ 	parse_cino(curbuf);
+     }
+ #endif
+ 
      /* Options that are a list of flags. */
      else
      {
***************
*** 8338,8351 ****
  	    curwin->w_p_fdc = 12;
  	}
      }
  
      /* 'shiftwidth' or 'tabstop' */
      else if (pp == &curbuf->b_p_sw || pp == &curbuf->b_p_ts)
      {
  	if (foldmethodIsIndent(curwin))
  	    foldUpdateAll(curwin);
      }
! #endif /* FEAT_FOLDING */
  
  #ifdef FEAT_MBYTE
      /* 'maxcombine' */
--- 8348,8371 ----
  	    curwin->w_p_fdc = 12;
  	}
      }
+ #endif /* FEAT_FOLDING */
  
+ #if defined(FEAT_FOLDING) || defined(FEAT_CINDENT)
      /* 'shiftwidth' or 'tabstop' */
      else if (pp == &curbuf->b_p_sw || pp == &curbuf->b_p_ts)
      {
+ # ifdef FEAT_FOLDING
  	if (foldmethodIsIndent(curwin))
  	    foldUpdateAll(curwin);
+ # endif
+ # ifdef FEAT_CINDENT
+ 	/* When 'shiftwidth' changes, or it's zero and 'tabstop' changes:
+ 	 * parse 'cinoptions'. */
+ 	if (pp == &curbuf->b_p_sw || curbuf->b_p_sw == 0)
+ 	    parse_cino(curbuf);
+ # endif
      }
! #endif
  
  #ifdef FEAT_MBYTE
      /* 'maxcombine' */
***************
*** 11729,11737 ****
   * 'tabstop' value when 'shiftwidth' is zero.
   */
      long
! get_sw_value()
  {
!     return curbuf->b_p_sw ? curbuf->b_p_sw : curbuf->b_p_ts;
  }
  
  /*
--- 11749,11758 ----
   * 'tabstop' value when 'shiftwidth' is zero.
   */
      long
! get_sw_value(buf)
!     buf_T *buf;
  {
!     return buf->b_p_sw ? buf->b_p_sw : buf->b_p_ts;
  }
  
  /*
***************
*** 11741,11747 ****
      long
  get_sts_value()
  {
!     return curbuf->b_p_sts < 0 ? get_sw_value() : curbuf->b_p_sts;
  }
  
  /*
--- 11762,11768 ----
      long
  get_sts_value()
  {
!     return curbuf->b_p_sts < 0 ? get_sw_value(curbuf) : curbuf->b_p_sts;
  }
  
  /*
*** ../vim-7.4.068/src/version.c	2013-11-04 04:57:46.000000000 +0100
--- src/version.c	2013-11-05 04:55:36.000000000 +0100
***************
*** 740,741 ****
--- 740,743 ----
  {   /* Add new patch number below this line */
+ /**/
+     69,
  /**/

-- 
A special cleaning ordinance bans housewives from hiding dirt and dust under a
rug in a dwelling.
		[real standing law in Pennsylvania, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
