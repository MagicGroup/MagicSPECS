diff -up OpenGTL-0.9.15.2/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/CMakeLists.txt
--- OpenGTL-0.9.15.2/CMakeLists.txt.95a8c6853b97	2012-01-10 11:12:02.103249511 -0500
+++ OpenGTL-0.9.15.2/CMakeLists.txt	2012-01-10 11:13:27.871518253 -0500
@@ -6,6 +6,7 @@ set(LIB_SUFFIX "" CACHE STRING "Define s
 
 option(OPENGTL_BUILD_TESTS "Build tests" OFF)
 option(OPENGTL_ENABLE_DEBUG_OUTPUT "Enable (heavy) debug output (only do that for debugging OpenGTL" OFF)
+option(OPENGTL_ENABLE_DEBUG_THREAD "Test if functions are accessed by different thread" OFF)
 option(OPENGTL_FULL_WARNINGS "Build OpenGTL with all warnings" OFF)
 option(OPENGTL_CODE_COVERAGE "Activate code coverage for tests" OFF)
 option(OVERIDE_LLVM_ASSERT "Use this only for debug purposes, this break thread safety." OFF)
@@ -46,22 +47,16 @@ configure_file(config-endian.h.cmake ${C
 
 find_package(LLVM REQUIRED)
 
-if( NOT MSVC AND NOT LLVM_VERSION STREQUAL "2.8" AND NOT LLVM_VERSION STREQUAL "2.7" AND NOT LLVM_VERSION STREQUAL "2.9"  ) # There is no way with MSVC to know the llvm version
-  message(FATAL_ERROR "LLVM 2.7 or 2.8 or 2.9 is required.")
-endif()
-
-if(NOT LLVM_SHARED_LIB AND LLVM_VERSION STREQUAL "2.9")
-  message(FATAL_ERROR "LLVM 2.9 needs to be build with dynamic library support.")
-endif()
-
-if(LLVM_VERSION STREQUAL "2.7" OR LLVM_VERSION STREQUAL "2.8" )
-  add_definitions(-DLLVM_27_OR_28)
+if( NOT MSVC AND NOT LLVM_VERSION STREQUAL "3.0" ) # There is no way with MSVC to know the llvm version
+  message(FATAL_ERROR "LLVM 3.0 is required.")
 endif()
 
 if(MSVC)
   add_definitions(/FIiso646.h)
   include_directories(${CMAKE_CURRENT_SOURCE_DIR}/msvc/build)
   install( FILES msvc/inst/stdint.h DESTINATION ${INCLUDE_INSTALL_DIR} )
+  set(LLVM_COMPILED_WITHOUT_ASSERTS true)
+  add_definitions(/W0)
 endif(MSVC)
 
 find_package(Threads)
@@ -85,6 +80,10 @@ if(OPENGTL_ENABLE_DEBUG_OUTPUT)
   add_definitions(-DOPENGTL_ENABLE_DEBUG_OUTPUT)
 endif(OPENGTL_ENABLE_DEBUG_OUTPUT)
 
+if(OPENGTL_ENABLE_DEBUG_THREAD)
+  add_definitions(-DOPENGTL_ENABLE_DEBUG_THREAD)
+endif(OPENGTL_ENABLE_DEBUG_THREAD)
+
 if(NOT LLVM_COMPILED_WITHOUT_ASSERTS)
   if(OVERIDE_LLVM_ASSERT)
     message(STATUS "llvm was build with asserts, this is not supported by OpenGTL but you have enable the overide")
@@ -94,7 +93,7 @@ if(NOT LLVM_COMPILED_WITHOUT_ASSERTS)
 endif(NOT LLVM_COMPILED_WITHOUT_ASSERTS)
 
 if(OPENGTL_FULL_WARNINGS)
-  set(OPENGTL_BUILD_DEFINITION "-Wall -Werror")
+  set(OPENGTL_BUILD_DEFINITION "-Waddress -Warray-bounds -Wc++0x-compat -Wchar-subscripts -Wcomment -Wformat -Wmissing-braces -Wparentheses -Wreorder -Wreturn-type -Wsequence-point -Wsign-compare -Wstrict-aliasing -Wstrict-overflow=1 -Wswitch -Wtrigraphs -Wuninitialized -Wunknown-pragmas -Wunused-function -Wunused-label -Wunused-value -Wvolatile-register-var -Werror -Wno-deprecated-declarations") # -Wall without -Wunused-variable  since it is buggy in gcc 4.6
 endif(OPENGTL_FULL_WARNINGS)
 
 if(CMAKE_SIZEOF_VOID_P EQUAL 4)
@@ -195,8 +194,13 @@ endif(OPENGTL_CODE_COVERAGE)
 
 # Add subdirectories
 
+option(OPENGTL_BUILD_OPENRIJN "Build OpenRijn" OFF)
+
 add_subdirectory(OpenGTL)
 add_subdirectory(OpenCTL)
 add_subdirectory(OpenShiva)
 add_subdirectory(Extensions)
 
+if(OPENGTL_BUILD_OPENRIJN)
+  add_subdirectory(OpenRijn)
+endif(OPENGTL_BUILD_OPENRIJN)
diff -up OpenGTL-0.9.15.2/Extensions/PngDC/PngDC.cpp.95a8c6853b97 OpenGTL-0.9.15.2/Extensions/PngDC/PngDC.cpp
--- OpenGTL-0.9.15.2/Extensions/PngDC/PngDC.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/Extensions/PngDC/PngDC.cpp	2012-01-10 11:12:02.107249479 -0500
@@ -30,6 +30,7 @@
 #include <GTLCore/Region.h>
 #include <GTLCore/Debug.h>
 #include <GTLCore/PixelDescription.h>
+#include <GTLCore/ColorConverters.h>
 
 STATIC_INITIALISATION( PngDC )
 {
@@ -115,21 +116,46 @@ GTLCore::AbstractImage* PngDC::decode( c
   GTL_ASSERT( channelType );
   int channelsCount = 0;
   int alphaPos = -1;
+  const GTLCore::AbstractColorConverter* converter = 0;
   switch( color_type )
   {
     case PNG_COLOR_TYPE_GRAY:
       channelsCount = 1;
+      if(channelType == GTLCore::Type::UnsignedInteger8)
+      {
+          converter = GTLCore::ColorConverters::instance()->sGrayU8();
+      } else {
+          converter = GTLCore::ColorConverters::instance()->sGrayU16();
+      }
       break;
     case PNG_COLOR_TYPE_GRAY_ALPHA:
       channelsCount = 2;
       alphaPos = 1;
+      if(channelType == GTLCore::Type::UnsignedInteger8)
+      {
+          converter = GTLCore::ColorConverters::instance()->sGrayaU8();
+      } else {
+          converter = GTLCore::ColorConverters::instance()->sGrayaU16();
+      }
       break;
     case PNG_COLOR_TYPE_RGB:
       channelsCount = 3;
+      if(channelType == GTLCore::Type::UnsignedInteger8)
+      {
+          converter = GTLCore::ColorConverters::instance()->sRgbU8();
+      } else {
+          converter = GTLCore::ColorConverters::instance()->sRgbU16();
+      }
       break;
     case PNG_COLOR_TYPE_RGB_ALPHA:
       channelsCount = 4;
       alphaPos = 3;
+      if(channelType == GTLCore::Type::UnsignedInteger8)
+      {
+          converter = GTLCore::ColorConverters::instance()->sRgbaU8();
+      } else {
+          converter = GTLCore::ColorConverters::instance()->sRgbaU16();
+      }
       break;
     default:
       png_destroy_read_struct(&png_ptr, &info_ptr, &end_info);
@@ -138,9 +164,9 @@ GTLCore::AbstractImage* PngDC::decode( c
   }
   GTL_ASSERT( channelsCount != 0);
   GTLCore::PixelDescription pixelDescription( channelType, channelsCount, alphaPos );
-  
+  GTL_ASSERT(converter);
   // Allocate buffer image
-  GTLCore::Image* image = new GTLCore::Image( width, height, pixelDescription );
+  GTLCore::Image* image = new GTLCore::Image( width, height, pixelDescription, converter );
   if( _region )
   {
     _region->setCols( width );
diff -up OpenGTL-0.9.15.2/OpenCTL/OpenCTL/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/OpenCTL/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenCTL/OpenCTL/CMakeLists.txt.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenCTL/OpenCTL/CMakeLists.txt	2012-01-10 11:12:02.107249479 -0500
@@ -31,7 +31,7 @@ add_definitions( "-D__STDC_LIMIT_MACROS"
 add_definitions( "-D__STDC_CONSTANT_MACROS" )
 add_definitions( -DCOUMPONENT_NAME="OpenCTL" )
 
-add_definitions( -D_OPENCTL_LIB_="${CMAKE_INSTALL_PREFIX}/lib/libOpenCTL.so.${OPENGTL_LIB_SOVERSION}")
+add_definitions( -D_OPENCTL_LIB_="libOpenCTL.so.${OPENGTL_LIB_SOVERSION}")
 add_definitions( -D_OPENCTL_CTL_STD_LIB_SRC_DIR_="${CMAKE_CURRENT_SOURCE_DIR}")
 add_definitions( -D_OPENCTL_CTL_SHARE_DIR_="${SHARE_INSTALL_DIR}/ctl" )
 
diff -up OpenGTL-0.9.15.2/OpenCTL/OpenCTL/compiler/ParserNG.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/OpenCTL/compiler/ParserNG.cpp
--- OpenGTL-0.9.15.2/OpenCTL/OpenCTL/compiler/ParserNG.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenCTL/OpenCTL/compiler/ParserNG.cpp	2012-01-10 11:12:02.107249479 -0500
@@ -50,12 +50,14 @@ using namespace OpenCTL;
 struct ParserNG::Private {
   Compiler* compiler;
   AST::Tree* tree;
+  bool parsingStarted;
 };
 
 ParserNG::ParserNG(Compiler* _compiler, LexerNG* _lexer) : ParserBase(_compiler, _lexer), d(new Private)
 {
   d->compiler = _compiler;
-  d->tree = 0;
+  d->tree = new AST::Tree;
+  d->parsingStarted = false;
 }
 
 ParserNG::~ParserNG()
@@ -66,8 +68,10 @@ ParserNG::~ParserNG()
 AST::Tree* ParserNG::parse()
 {
   OCTL_DEBUG("Parsing with ParserNG");
-  OCTL_ASSERT( not d->tree );
-  d->tree = new AST::Tree;
+  OCTL_ASSERT( d->tree );
+  OCTL_ASSERT( not d->parsingStarted );
+
+  d->parsingStarted = true;
   variablesManager()->startContext();
   // parse module header
   parseModuleHeader();
diff -up OpenGTL-0.9.15.2/OpenCTL/OpenCTL.doxy.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/OpenCTL.doxy
--- OpenGTL-0.9.15.2/OpenCTL/OpenCTL.doxy.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenCTL/OpenCTL.doxy	2012-01-10 11:12:02.109249461 -0500
@@ -1,6 +1,6 @@
 /**
  * @addtogroup OpenCTL OpenCTL Library
- * @version 0.9.15
+ * @version 0.9.16
  * @author Cyrille Berger
  * 
  * This library allow to use the Color Transformation Language inside your
@@ -8,4 +8,4 @@
  * 
  * More information about the language can be found at
  * <a href="http://ampasctl.sourceforge.net/">the A.M.P.A.S. CTL website</a>.
- */
\ No newline at end of file
+ */
diff -up OpenGTL-0.9.15.2/OpenCTL/OpenCTL/ModulesManager.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/OpenCTL/ModulesManager.cpp
--- OpenGTL-0.9.15.2/OpenCTL/OpenCTL/ModulesManager.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenCTL/OpenCTL/ModulesManager.cpp	2012-01-10 11:12:02.107249479 -0500
@@ -23,10 +23,13 @@
 #include "Module.h"
 
 // LLVM
+#include <llvm/Support/MutexGuard.h>
 #ifdef LLVM_27_OR_28
 #include <llvm/System/Path.h>
+#include <llvm/System/Mutex.h>
 #else
 #include <llvm/Support/Path.h>
+#include <llvm/Support/Mutex.h>
 #endif
 
 #include <GTLCore/Macros_p.h>
@@ -39,6 +42,7 @@ using namespace OpenCTL;
 struct ModulesManager::Private {
   std::map<GTLCore::String, Module*> modules;
   std::list<GTLCore::String> directories;
+  llvm::sys::Mutex mutex;
 };
 
 STATIC_POINTER(ModulesManager, s_instance);
@@ -70,6 +74,7 @@ Module* ModulesManager::module(const GTL
 
 Module* ModulesManager::loadModule(const GTLCore::String& name)
 {
+  llvm::MutexGuard mg(d->mutex);
   Module* m = module( name );
   if( m )
   { // The module is already loaded and in the registry, return it
@@ -96,6 +101,7 @@ Module* ModulesManager::loadModule(const
 
 void ModulesManager::registerModule(const GTLCore::String& name, Module* m )
 {
+  llvm::MutexGuard mg(d->mutex);
   d->modules[ name ] = m;
 }
 
diff -up OpenGTL-0.9.15.2/OpenCTL/OpenCTL/ModulesManager.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/OpenCTL/ModulesManager.h
--- OpenGTL-0.9.15.2/OpenCTL/OpenCTL/ModulesManager.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenCTL/OpenCTL/ModulesManager.h	2012-01-10 11:12:02.107249479 -0500
@@ -74,6 +74,7 @@ namespace OpenCTL {
       void registerModule(const GTLCore::String& name, Module* );
       /**
        * Add a directory to the list of directory that get searched for modules.
+       * This function is not thread-safe.
        */
       void addDirectory(const GTLCore::String& directory);
     public:
diff -up OpenGTL-0.9.15.2/OpenCTL/OpenCTL/Program.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/OpenCTL/Program.cpp
--- OpenGTL-0.9.15.2/OpenCTL/OpenCTL/Program.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenCTL/OpenCTL/Program.cpp	2012-01-10 11:12:02.108249470 -0500
@@ -30,12 +30,12 @@
 #include <llvm/Analysis/LoopPass.h>
 #include <llvm/Analysis/Verifier.h>
 #include <llvm/Target/TargetData.h>
-#include <llvm/ExecutionEngine/ExecutionEngine.h>
 #include <llvm/GlobalVariable.h>
 
 // GTLCore
 #include "GTLCore/Buffer.h"
 #include "GTLCore/BufferImage.h"
+#include "GTLCore/Debug_thread_p.h"
 #include "GTLCore/LLVMBackend/CodeGenerator_p.h"
 #include "GTLCore/LLVMBackend/GenerationContext_p.h"
 #include "GTLCore/PixelDescription.h"
@@ -48,6 +48,7 @@
 #include "GTLCore/Type.h"
 #include "GTLCore/Type_p.h"
 #include "GTLCore/Value.h"
+#include "GTLCore/Value_p.h"
 #include "GTLCore/VariableNG_p.h"
 #include "GTLCore/Utils_p.h"
 
@@ -68,15 +69,16 @@ struct Program::Private {
   {
     GTL_ASSERT(srcPixelDescriptions.size() > 0);
   }
-  llvm::Module* module;
   GTLCore::ModuleData* moduleData;
   void (*func)( const char**, char*, int, GTLCore::ProgressReport*, gtl_uint64);
   std::list<GTLCore::PixelDescription> srcPixelDescriptions;
   GTLCore::PixelDescription dstPixelDescription;
   static int s_id;
-  std::map< GTLCore::String, llvm::GlobalVariable*> varyings;
-  std::map< GTLCore::String, void*> varyingsPtr;
+  std::vector< llvm::GlobalVariable*> varyings;
+  std::vector< void*> varyingsPtr;
+  std::map< GTLCore::String, int > varyingsId;
   std::list<GTLCore::String> varyingsName;
+  TEST_GUARD_VARIABLE
 };
 
 int Program::Private::s_id = 0;
@@ -146,15 +148,16 @@ struct InputGenInfo {
     InputGenInfo& operator=(const InputGenInfo&) { return *this; }
 };
 
-void Program::init(const GTLCore::String& functionName, const Module* module)
+void Program::init(const GTLCore::String& functionName, const Module* _module)
 {
+  TEST_GUARD_WRITE(d)
   d->func = 0;
   d->moduleData = 0;
   // Clone the module
-  if( module->data())
+  if( _module->data())
   {
-    d->module = llvm::CloneModule(module->data()->llvmLinkedModule());
-    d->moduleData = new GTLCore::ModuleData( d->module );
+    llvm::Module* module = llvm::CloneModule(_module->data()->llvmLinkedModule());
+    d->moduleData = new GTLCore::ModuleData( module );
     // Select the function
     std::vector<GTLCore::Parameter> arguments;
     foreach(const GTLCore::PixelDescription& pd, d->srcPixelDescriptions)
@@ -168,10 +171,10 @@ void Program::init(const GTLCore::String
     {
       arguments.push_back(GTLCore::Parameter("", type, true, false, GTLCore::Value()));
     }
-    const GTLCore::Function* functionDef = module->function( functionName, arguments );
+    const GTLCore::Function* functionDef = _module->function( functionName, arguments );
     if( not functionDef ) return;
     
-    llvm::Function* function = d->module->getFunction( (const std::string&)GTLCore::Function::Data::symbolName( GTLCore::ScopedName( "", functionName), functionDef->returnType(),functionDef->parameters() ) );
+    llvm::Function* function = module->getFunction( (const std::string&)GTLCore::Function::Data::symbolName( GTLCore::ScopedName( "", functionName), functionDef->returnType(),functionDef->parameters() ) );
     if(function)
     {
       LLVMBackend::CodeGenerator cg( d->moduleData );
@@ -181,13 +184,13 @@ void Program::init(const GTLCore::String
       for( std::list<GTLCore::PixelDescription>::iterator it = d->srcPixelDescriptions.begin();
            it != d->srcPixelDescriptions.end(); ++it )
       {
-        InputGenInfo* src = new InputGenInfo(*it, d->module->getContext());
+        InputGenInfo* src = new InputGenInfo(*it, module->getContext());
         srcs.push_back( src);
-        configureBuffer( cg, src->channelsTypes, src->indexes, src->needConversion, src->countChannels, d->module->getContext());
+        configureBuffer( cg, src->channelsTypes, src->indexes, src->needConversion, src->countChannels, module->getContext());
       }
       // Initialise pixel information and Configure output buffers
-      InputGenInfo dst( d->dstPixelDescription, d->module->getContext());
-      configureBuffer( cg, dst.channelsTypes, dst.indexes, dst.needConversion, dst.countChannels, d->module->getContext());
+      InputGenInfo dst( d->dstPixelDescription, module->getContext());
+      configureBuffer( cg, dst.channelsTypes, dst.indexes, dst.needConversion, dst.countChannels, module->getContext());
       
       //---------- Program-Pseudo-code ----------//
       // This just a rough explanation of the function that get generated here.
@@ -211,21 +214,24 @@ void Program::init(const GTLCore::String
       //   return;
       // }
       OCTL_DEBUG("Initialize the function type");
-      std::vector<const llvm::Type*> params;
-      params.push_back( llvm::PointerType::get( llvm::PointerType::get( llvm::Type::getInt8Ty(d->module->getContext()), 0 ), 0 ) ); // const char** int8
-      params.push_back( llvm::PointerType::get( llvm::Type::getInt8Ty(d->module->getContext()), 0 )); // char* out8
-      params.push_back( llvm::Type::getInt32Ty(d->module->getContext()) ); // int size
-      params.push_back( GTLCore::Type::Pointer->d->type(d->module->getContext()) ); // ProgressReport* _report
-      params.push_back( llvm::Type::getInt64Ty(d->module->getContext()) );
+      std::list<GTLCore::String> keepVisible;
+      std::vector<llvm::Type*> params;
+      params.push_back( llvm::PointerType::get( llvm::PointerType::get( llvm::Type::getInt8Ty(module->getContext()), 0 ), 0 ) ); // const char** int8
+      params.push_back( llvm::PointerType::get( llvm::Type::getInt8Ty(module->getContext()), 0 )); // char* out8
+      params.push_back( llvm::Type::getInt32Ty(module->getContext()) ); // int size
+      params.push_back( GTLCore::Type::Pointer->d->type(module->getContext()) ); // ProgressReport* _report
+      params.push_back( llvm::Type::getInt64Ty(module->getContext()) );
       // void program(const char* in8, char* out8, int size)
-      llvm::FunctionType* definitionType = llvm::FunctionType::get( llvm::Type::getVoidTy(d->module->getContext()), params, false );
+      llvm::FunctionType* definitionType = llvm::FunctionType::get( llvm::Type::getVoidTy(module->getContext()), params, false );
       int programNb = ++Program::Private::s_id;
-      llvm::Function* func = cg.createFunction( d->module, definitionType, "CTLProgram" + GTLCore::String::number(programNb));
+      GTLCore::String programFunctionName = "CTLProgram" + GTLCore::String::number(programNb);
+      keepVisible.push_back(programFunctionName);
+      llvm::Function* func = cg.createFunction( module, definitionType, programFunctionName);
       // Initialise a generation context
-      LLVMBackend::GenerationContext gc( &cg, &d->module->getContext(), func, 0, d->moduleData, d->module );
+      LLVMBackend::GenerationContext gc( &cg, &module->getContext(), func, 0, d->moduleData, module );
       // {
       OCTL_DEBUG("Initial block");
-      llvm::BasicBlock* initialBlock = llvm::BasicBlock::Create(d->module->getContext());
+      llvm::BasicBlock* initialBlock = llvm::BasicBlock::Create(module->getContext());
       func->getBasicBlockList().push_back( initialBlock );
       // Initialise the buffer, as needed
       OCTL_DEBUG("Initialise buffer");
@@ -255,7 +261,7 @@ void Program::init(const GTLCore::String
       
       for(std::size_t k = 0; k < srcs.size(); ++k)
       {
-        srcs[k]->addr = new llvm::LoadInst( llvm::GetElementPtrInst::Create( ins, cg.integerToConstant(d->module->getContext(), gtl_uint32(k)), "", initialBlock ), "", initialBlock );
+        srcs[k]->addr = new llvm::LoadInst( llvm::GetElementPtrInst::Create( ins, cg.integerToConstant(module->getContext(), gtl_uint32(k)), "", initialBlock ), "", initialBlock );
       }
       //   char* out8 = second arg;
       ++arg_it;
@@ -278,20 +284,20 @@ void Program::init(const GTLCore::String
       for(std::size_t k = 0; k < srcs.size(); ++k)
       {
         srcs[k]->pos = new GTLCore::VariableNG( GTLCore::Type::Integer32, false, false );
-        srcs[k]->pos->initialise( gc, initialBlock, LLVMBackend::ExpressionResult(cg.integerToConstant(d->module->getContext(), INT32_C(0)), GTLCore::Type::Integer32), std::list<llvm::Value*>());
+        srcs[k]->pos->initialise( gc, initialBlock, LLVMBackend::ExpressionResult(cg.integerToConstant(module->getContext(), INT32_C(0)), GTLCore::Type::Integer32), std::list<llvm::Value*>());
       }
       dst.pos = new GTLCore::VariableNG( GTLCore::Type::Integer32, false, false );
-      dst.pos->initialise( gc, initialBlock, LLVMBackend::ExpressionResult(cg.integerToConstant(d->module->getContext(), INT32_C(0)), GTLCore::Type::Integer32), std::list<llvm::Value*>());
+      dst.pos->initialise( gc, initialBlock, LLVMBackend::ExpressionResult(cg.integerToConstant(module->getContext(), INT32_C(0)), GTLCore::Type::Integer32), std::list<llvm::Value*>());
       
       // i < size
       OCTL_DEBUG("i < size");
-      llvm::BasicBlock* forTestBlock = llvm::BasicBlock::Create(d->module->getContext(), "forTestBlock");
+      llvm::BasicBlock* forTestBlock = llvm::BasicBlock::Create(module->getContext(), "forTestBlock");
       func->getBasicBlockList().push_back( forTestBlock);
       llvm::Value* forTest = cg.createStrictInferiorExpression(forTestBlock, srcs[0]->pos->get( gc, forTestBlock ), srcs[0]->pos->type(), size, GTLCore::Type::Integer32 );
       
       // i += pixelSize
       OCTL_DEBUG("i += pixelSize");
-      llvm::BasicBlock* updateBlock = llvm::BasicBlock::Create(d->module->getContext(), "updateBlock");
+      llvm::BasicBlock* updateBlock = llvm::BasicBlock::Create(module->getContext(), "updateBlock");
       func->getBasicBlockList().push_back( updateBlock);
       for(std::size_t k = 0; k < srcs.size(); ++k)
       {
@@ -301,7 +307,7 @@ void Program::init(const GTLCore::String
       
       // Construct the body of the for loop
       OCTL_DEBUG("bodyBlock");
-      llvm::BasicBlock* bodyBlock = llvm::BasicBlock::Create(d->module->getContext(), "bodyBlock");
+      llvm::BasicBlock* bodyBlock = llvm::BasicBlock::Create(module->getContext(), "bodyBlock");
       llvm::BasicBlock* startBodyBlock = bodyBlock;
       func->getBasicBlockList().push_back( bodyBlock);
       
@@ -319,7 +325,7 @@ void Program::init(const GTLCore::String
           OCTL_DEBUG("Load the value from the input buffer");
           llvm::Value* convertedIn = new llvm::LoadInst(
                         cg.convertPointerTo( bodyBlock,
-                                  llvm::GetElementPtrInst::Create( srcs[k]->addr, cg.createAdditionExpression( bodyBlock, srcIndex, srcs[k]->pos->type(), srcs[k]->indexes[i], GTLCore::Type::Integer32), "", bodyBlock), srcs[k]->channelsTypes[i]->d->type(d->module->getContext())),
+                                  llvm::GetElementPtrInst::Create( srcs[k]->addr, cg.createAdditionExpression( bodyBlock, srcIndex, srcs[k]->pos->type(), srcs[k]->indexes[i], GTLCore::Type::Integer32), "", bodyBlock), srcs[k]->channelsTypes[i]->d->type(module->getContext())),
                         "", bodyBlock);
           if( srcs[k]->needConversion[i])
           { // if a buffer is needed that means that the value must be converted
@@ -351,13 +357,15 @@ void Program::init(const GTLCore::String
         {
           llvm::GlobalVariable* globalVar =
               new llvm::GlobalVariable(
-                    *d->module,
-                    parameters[i].type()->d->type(d->module->getContext()),
+                    *module,
+                    parameters[i].type()->d->type(module->getContext()),
                     false, llvm::GlobalValue::ExternalLinkage,
-                    LLVMBackend::CodeGenerator::valueToConstant( gc, parameters[i].defaultValue() ), "" );
+                    LLVMBackend::CodeGenerator::valueToConstant( gc, parameters[i].defaultValue() ), (const std::string&)parameters[i].name() );
           arguments.push_back( new llvm::LoadInst( globalVar, "", bodyBlock ) );
-          d->varyings[ parameters[i].name() ] = globalVar;
+          d->varyingsId[ parameters[i].name() ] = d->varyings.size();
+          d->varyings.push_back(globalVar);
           d->varyingsName.push_back( parameters[i].name() );
+          keepVisible.push_back(parameters[i].name());
         }
       }
       // Some debug
@@ -369,7 +377,7 @@ void Program::init(const GTLCore::String
       }
       OCTL_DEBUG( *function->getFunctionType());
 #endif
-      llvm::CallInst *CallFunc = llvm::CallInst::Create(function, arguments.begin(), arguments.end(), "", bodyBlock);
+      llvm::CallInst *CallFunc = llvm::CallInst::Create(function, arguments, "", bodyBlock);
       CallFunc->setTailCall(false);
       // If there was buffering, save to output
       OCTL_DEBUG("If there was buffering, save to output");
@@ -379,7 +387,7 @@ void Program::init(const GTLCore::String
         llvm::BasicBlock* ifBlock = llvm::BasicBlock::Create(gc.llvmContext());
         func->getBasicBlockList().push_back( ifBlock );
         
-        const llvm::Type* channelType = dst.channelsTypes[i]->d->type(d->module->getContext());
+        llvm::Type* channelType = dst.channelsTypes[i]->d->type(module->getContext());
         llvm::Value* pointer = cg.convertPointerTo( ifBlock, llvm::GetElementPtrInst::Create( out, cg.createAdditionExpression( ifBlock, dstIndex, GTLCore::Type::Integer32, dst.indexes[i], GTLCore::Type::Integer32), "", ifBlock), channelType);
         llvm::Value* result = buffer[i]->get( gc, ifBlock );
         if( dst.needConversion[i])
@@ -422,23 +430,24 @@ void Program::init(const GTLCore::String
       OCTL_DEBUG("Put the for loop together");
       // for(int i = 0; i < size; ++i)
       OCTL_DEBUG("for(int i = 0; i < size; ++i)");
-      llvm::BasicBlock* finBlock = llvm::BasicBlock::Create(d->module->getContext(), "finBlock");
+      llvm::BasicBlock* finBlock = llvm::BasicBlock::Create(module->getContext(), "finBlock");
       func->getBasicBlockList().push_back( finBlock);
       cg.createForStatement(initialBlock, forTestBlock, forTestBlock, forTest, GTLCore::Type::Boolean, updateBlock, startBodyBlock, bodyBlock, finBlock);
       // return;
       OCTL_DEBUG("return;");
-      llvm::ReturnInst::Create(d->module->getContext(), finBlock);
-      OCTL_DEBUG(*d->module);
+      llvm::ReturnInst::Create(module->getContext(), finBlock);
+      OCTL_DEBUG(*module);
       // Optimize
       OCTL_DEBUG("Optimize");
-      
+      module = 0;
+      d->moduleData->doLink();
+      d->moduleData->hideAllSymbolsBut(keepVisible);
       // Register module in the VM
-      GTLCore::VirtualMachine::instance()->registerModule( d->module );
-      GTLCore::VirtualMachine::instance()->executionEngine()->clearAllGlobalMappings();
+      GTLCore::VirtualMachine::instance()->registerModule( d->moduleData->llvmLinkedModule());
       d->func = ( void(*)(const char**, char*,int,GTLCore::ProgressReport*, gtl_uint64)) GTLCore::VirtualMachine::instance()->getPointerToFunction( func );
-      for( std::map< GTLCore::String, llvm::GlobalVariable*>::iterator it = d->varyings.begin(); it != d->varyings.end(); ++it)
+      for( std::vector< llvm::GlobalVariable*>::iterator it = d->varyings.begin(); it != d->varyings.end(); ++it)
       {
-          d->varyingsPtr[ it->first ] = GTLCore::VirtualMachine::instance()->getGlobalVariablePointer( it->second );
+          d->varyingsPtr.push_back(GTLCore::VirtualMachine::instance()->getGlobalVariablePointer( *it ) );
       }
 //       OCTL_DEBUG( ((void*)d->func) << " ==== " << func << "  " << func->isDeclaration() << *func);
       // Cleanup
@@ -450,22 +459,24 @@ void Program::init(const GTLCore::String
       delete[] buffer;
     } else {
       OCTL_DEBUG("Function: " << functionName << " not found in module");
-      delete d->module;
-      d->module = 0;
+      delete module;
+      module = 0;
     }
   } else {
     OCTL_DEBUG("No module was supplied");
-    d->module = 0;
   }
 }
 
 Program::~Program()
 {
-  if(d->module)
   {
-    GTLCore::VirtualMachine::instance()->unregisterModule( d->module);
+    TEST_GUARD_WRITE(d)
+    if(d->moduleData and d->moduleData->llvmLinkedModule())
+    {
+      GTLCore::VirtualMachine::instance()->unregisterModule( d->moduleData->llvmLinkedModule());
+    }
+    delete d->moduleData;
   }
-  delete d->moduleData;
   delete d;
 }
 
@@ -476,6 +487,7 @@ bool Program::isInitialised() const
 
 void Program::apply(const GTLCore::Buffer& input, GTLCore::Buffer& output, GTLCore::ProgressReport* _report, const GTLCore::ChannelsFlags& flags ) const
 {
+  TEST_GUARD_READ(d)
   GTL_ASSERT(d->srcPixelDescriptions.size() == 1);
   OCTL_ASSERT( (input.size() / (d->srcPixelDescriptions.begin()->bitsSize() / 8) ) == (output.size() / (d->dstPixelDescription.bitsSize() / 8) ) );
   OCTL_ASSERT( d->func );
@@ -490,6 +502,7 @@ void Program::apply(const GTLCore::Buffe
 
 void Program::apply(const std::list<GTLCore::Buffer*>& inputs, GTLCore::Buffer& output, GTLCore::ProgressReport* _report, const GTLCore::ChannelsFlags& flags ) const
 {
+  TEST_GUARD_READ(d)
   GTL_ASSERT(d->srcPixelDescriptions.size() == inputs.size());
   OCTL_ASSERT( (output.size() % (d->dstPixelDescription.bitsSize() / 8)) == 0 );
   OCTL_ASSERT( d->func );
@@ -506,6 +519,7 @@ void Program::apply(const std::list<GTLC
 
 void Program::apply(const GTLCore::AbstractImage& input, GTLCore::AbstractImage& output, GTLCore::ProgressReport* report, const GTLCore::ChannelsFlags& flags ) const
 {
+  TEST_GUARD_READ(d)
   GTLCore::AbstractImage::ConstIterator* itSrc = input.createIterator();
   GTLCore::AbstractImage::Iterator* itDst = output.createIterator();
   
@@ -520,54 +534,70 @@ void Program::apply(const GTLCore::Abstr
 
 void Program::setVarying( const GTLCore::String& _name, const GTLCore::Value& _value )
 {
-  std::map< GTLCore::String, void*>::iterator it = d->varyingsPtr.find( _name );
-  std::map< GTLCore::String, llvm::GlobalVariable*>::iterator it2 = d->varyings.find( _name );
-  if( it != d->varyingsPtr.end() )
-  {
-    void* ptr = it->second;
-    if( it2->second->getType()->getElementType() == llvm::Type::getInt32Ty(d->module->getContext()) )
-    {
-        *(int*)ptr =_value.asInt32();
-    } else if( it2->second->getType()->getElementType() == llvm::Type::getInt1Ty(d->module->getContext()) )
-    {
-        *(bool*)ptr = _value.asBoolean();
-    } else if( it2->second->getType()->getElementType() == llvm::Type::getFloatTy(d->module->getContext()) )
-    {
-        GTL_DEBUG("Set " << _value.asFloat32() << " on ptr " << ptr << " from value = " << *(float*)ptr);
-        *(float*)ptr = _value.asFloat32();
-        GTL_DEBUG( *(float*)ptr );
-    }
+  std::size_t id = varyingId(_name);
+  GTL_ASSERT(id != std::size_t(-1));
+  if( id != std::size_t(-1)) {
+    setVarying(id, _value);
   } else {
     OCTL_DEBUG(" No varying named: " << _name);
   }
 }
 
+void Program::setVarying( std::size_t _id, const GTLCore::Value& _value )
+{
+  TEST_GUARD_WRITE(d)
+  GTL_ASSERT( _id < d->varyings.size());
+  if(_id >= d->varyings.size()) return;
+  void* it = d->varyingsPtr[ _id ];
+  llvm::GlobalVariable* it2 = d->varyings[ _id ];
+  GTLCore::copyValueToPtr(_value, it2->getType()->getElementType(), d->moduleData->llvmLinkedModule()->getContext(), it);
+}
+
 GTLCore::Value Program::varying( const GTLCore::String& _name ) const
 {
-  std::map< GTLCore::String, void*>::iterator it = d->varyingsPtr.find( _name );
-  std::map< GTLCore::String, llvm::GlobalVariable*>::iterator it2 = d->varyings.find( _name );
-  if( it != d->varyingsPtr.end() )
-  {
-    void* ptr = it->second;
-    if( it2->second->getType()->getElementType() == llvm::Type::getInt32Ty(d->module->getContext()) )
-    {
-        return GTLCore::Value( *(gtl_int32*)ptr);
-    }
-    if( it2->second->getType()->getElementType() == llvm::Type::getInt1Ty(d->module->getContext()) )
-    {
-        return GTLCore::Value( *(bool*)ptr);
-    }
-    if( it2->second->getType()->getElementType() == llvm::Type::getFloatTy(d->module->getContext()) )
-    {
-        return GTLCore::Value( *(float*)ptr);
-    }
-    OCTL_DEBUG("Invalid type");
+  std::size_t id = varyingId(_name);
+  GTL_ASSERT(id != std::size_t(-1));
+  if( id == std::size_t(-1)) {
+    OCTL_DEBUG(" No varying named: " << _name);
     return GTLCore::Value();
+  } else {
+    return varying(id);
+  }
+}
+
+GTLCore::Value Program::varying( std::size_t _id ) const
+{
+  TEST_GUARD_READ(d)
+  GTL_ASSERT( _id < d->varyings.size());
+  if(_id >= d->varyings.size()) return GTLCore::Value();
+  void* ptr = d->varyingsPtr[_id];
+  llvm::GlobalVariable* it2 = d->varyings[_id];
+  if( it2->getType()->getElementType() == llvm::Type::getInt32Ty(d->moduleData->llvmLinkedModule()->getContext()) )
+  {
+      return GTLCore::Value( *(gtl_int32*)ptr);
+  }
+  if( it2->getType()->getElementType() == llvm::Type::getInt1Ty(d->moduleData->llvmLinkedModule()->getContext()) )
+  {
+      return GTLCore::Value( *(bool*)ptr);
   }
-  OCTL_DEBUG(" No varying named: '" << _name << "'");
+  if( it2->getType()->getElementType() == llvm::Type::getFloatTy(d->moduleData->llvmLinkedModule()->getContext()) )
+  {
+      return GTLCore::Value( *(float*)ptr);
+  }
+  OCTL_DEBUG("Invalid type");
   return GTLCore::Value();
 }
 
+std::size_t Program::varyingId( const GTLCore::String& _name ) const
+{
+  if(d->varyingsId.find(_name) != d->varyingsId.end())
+  {
+    return d->varyingsId[_name];
+  }
+  return -1;
+}
+
+
 #if 0
 
 void Program::setVarying( const GTLCore::String& _name, const GTLCore::Value& _value )
diff -up OpenGTL-0.9.15.2/OpenCTL/OpenCTL/Program.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/OpenCTL/Program.h
--- OpenGTL-0.9.15.2/OpenCTL/OpenCTL/Program.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenCTL/OpenCTL/Program.h	2012-01-10 11:12:02.109249461 -0500
@@ -110,10 +110,25 @@ namespace OpenCTL {
        */
       void setVarying( const GTLCore::String& _name, const GTLCore::Value& _value );
       /**
+       * Set a varying argument of the function used by the program.
+       * For instance the following CTL code gives access to exposure as a <em>varying</em>
+       * argument.
+       *
+       */
+      void setVarying( std::size_t _id, const GTLCore::Value& _value );
+      /**
        * @return a varying argument of a function.
        */
       GTLCore::Value varying( const GTLCore::String& _name ) const;
       /**
+       * @return a varying argument of a function.
+       */
+      GTLCore::Value varying( std::size_t _id ) const;
+      /**
+       * @return the id varying argument of a function. To be used with setVarying and varying
+      */
+      std::size_t varyingId( const GTLCore::String& _name ) const;
+      /**
        * @return the list of varying parameters for this program
        */
       const std::list<GTLCore::String>& varyings() const;
diff -up OpenGTL-0.9.15.2/OpenCTL/tests/arithmetic/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/tests/arithmetic/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenCTL/tests/arithmetic/CMakeLists.txt.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenCTL/tests/arithmetic/CMakeLists.txt	2012-01-10 11:12:02.110249452 -0500
@@ -11,6 +11,8 @@ set( TESTS_FILES
   comparisons.ctl
   division.ctl
   modulo.ctl
+  unary.ctl
+  unsigned.ctl
   )
 
 FOREACH( TEST_FILE ${TESTS_FILES} )
diff -up OpenGTL-0.9.15.2/OpenCTL/tests/arithmetic/unary.ctl.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/tests/arithmetic/unary.ctl
--- OpenGTL-0.9.15.2/OpenCTL/tests/arithmetic/unary.ctl.95a8c6853b97	2012-01-10 11:12:02.110249452 -0500
+++ OpenGTL-0.9.15.2/OpenCTL/tests/arithmetic/unary.ctl	2012-01-10 11:12:02.110249452 -0500
@@ -0,0 +1,9 @@
+import "TestFramework";
+
+int main()
+{
+  int errorcount = 0;
+  -(2);
+//   Test::checkIntEqual( -(2*3), -6, errorcount);
+  return errorcount;
+}
diff -up OpenGTL-0.9.15.2/OpenCTL/tests/arithmetic/unsigned.ctl.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/tests/arithmetic/unsigned.ctl
--- OpenGTL-0.9.15.2/OpenCTL/tests/arithmetic/unsigned.ctl.95a8c6853b97	2012-01-10 11:12:02.110249452 -0500
+++ OpenGTL-0.9.15.2/OpenCTL/tests/arithmetic/unsigned.ctl	2012-01-10 11:12:02.110249452 -0500
@@ -0,0 +1,11 @@
+import "TestFramework";
+
+int main()
+{
+  int errorcount = 0;
+  unsigned int a = 2636245652;
+  unsigned int b = 16777215;
+  unsigned int c = 2222897;
+  Test::check( a % b == c, errorcount);
+  return errorcount;  
+}
diff -up OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/CMakeLists.txt.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/CMakeLists.txt	2012-01-10 11:12:02.110249452 -0500
@@ -16,8 +16,11 @@ set( TESTS_FILES
   structfunctioncoumpoundinitialisation.ctl
   copystruct.ctl
   copyarray.ctl
+  returnstructinit.ctl
   returnstruct.ctl
+  returnstructifelse.ctl
   returnarray.ctl
+  returncomposite.ctl
   constarraynosize.ctl
   returnarrayarray.ctl
   arrayoverflow.ctl
diff -up OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/returncomposite.ctl.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/returncomposite.ctl
--- OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/returncomposite.ctl.95a8c6853b97	2012-01-10 11:12:02.111249443 -0500
+++ OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/returncomposite.ctl	2012-01-10 11:12:02.111249443 -0500
@@ -0,0 +1,24 @@
+
+import "TestFramework";
+
+struct MyStruct {
+  int i;
+  bool b;
+  float f;
+};
+
+MyStruct returnStruct()
+{
+  return { -1, true, 12.42};
+}
+
+int main()
+{
+  int errorcount = 0;
+  MyStruct ms;
+  ms = returnStruct();
+  Test::checkIntEqual( ms.i, -1, errorcount );
+  Test::checkIntEqual( ms.b, true, errorcount );
+  Test::checkIntEqual( ms.f, 12.42, errorcount );
+  return errorcount;
+}
diff -up OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/returnstruct.ctl.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/returnstruct.ctl
--- OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/returnstruct.ctl.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/returnstruct.ctl	2012-01-10 11:12:02.111249443 -0500
@@ -19,7 +19,8 @@ MyStruct returnStruct()
 int main()
 {
   int errorcount = 0;
-  MyStruct ms = returnStruct();
+  MyStruct ms;
+  ms = returnStruct();
   Test::checkIntEqual( ms.i, -1, errorcount );
   Test::checkIntEqual( ms.b, true, errorcount );
   Test::checkIntEqual( ms.f, 12.42, errorcount );
diff -up OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/returnstructifelse.ctl.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/returnstructifelse.ctl
--- OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/returnstructifelse.ctl.95a8c6853b97	2012-01-10 11:12:02.112249434 -0500
+++ OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/returnstructifelse.ctl	2012-01-10 11:12:02.111249443 -0500
@@ -0,0 +1,36 @@
+
+import "TestFramework";
+
+struct MyStruct {
+  int i;
+  bool b;
+  float f;
+};
+
+MyStruct returnStruct()
+{
+  MyStruct a;
+  a.i = -1;
+  a.b = true;
+  a.f = 12.42;
+  return a;
+}
+
+int main()
+{
+  int errorcount = 0;
+  MyStruct ms = { 1, false, 42.12 };
+  if(false) {
+    ms = returnStruct();
+  }
+  Test::checkIntEqual( ms.i, 1, errorcount );
+  Test::checkIntEqual( ms.b, false, errorcount );
+  Test::checkNearEqual( ms.f, 42.12, errorcount );
+  if(true) {
+    ms = returnStruct();
+  }
+  Test::checkIntEqual( ms.i, -1, errorcount );
+  Test::checkIntEqual( ms.b, true, errorcount );
+  Test::checkNearEqual( ms.f, 12.42, errorcount );
+  return errorcount;
+}
diff -up OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/returnstructinit.ctl.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/returnstructinit.ctl
--- OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/returnstructinit.ctl.95a8c6853b97	2012-01-10 11:12:02.112249434 -0500
+++ OpenGTL-0.9.15.2/OpenCTL/tests/complextypes/returnstructinit.ctl	2012-01-10 11:12:02.112249434 -0500
@@ -0,0 +1,27 @@
+
+import "TestFramework";
+
+struct MyStruct {
+  int i;
+  bool b;
+  float f;
+};
+
+MyStruct returnStruct()
+{
+  MyStruct a;
+  a.i = -1;
+  a.b = true;
+  a.f = 12.42;
+  return a;
+}
+
+int main()
+{
+  int errorcount = 0;
+  MyStruct ms = returnStruct();
+  Test::checkIntEqual( ms.i, -1, errorcount );
+  Test::checkIntEqual( ms.b, true, errorcount );
+  Test::checkIntEqual( ms.f, 12.42, errorcount );
+  return errorcount;
+}
diff -up OpenGTL-0.9.15.2/OpenCTL/tests/parse/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/tests/parse/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenCTL/tests/parse/CMakeLists.txt.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenCTL/tests/parse/CMakeLists.txt	2012-01-10 11:12:02.112249434 -0500
@@ -37,6 +37,7 @@ set( TESTS_FILES
   variable_scope.ctl
   varying.ctl
   function_scope.ctl
+  recursive_function.ctl
   )
 
 FOREACH( TEST_FILE ${TESTS_FILES} )
@@ -58,6 +59,7 @@ set( TESTS_FAIL_FILES
   function_out_of_scope.ctl
   affect_constant.ctl
   convert_to_void.ctl
+  const_divide_0.ctl
   )
 
 FOREACH( TEST_FILE ${TESTS_FAIL_FILES} )
diff -up OpenGTL-0.9.15.2/OpenCTL/tests/parse/const_divide_0.ctl.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/tests/parse/const_divide_0.ctl
--- OpenGTL-0.9.15.2/OpenCTL/tests/parse/const_divide_0.ctl.95a8c6853b97	2012-01-10 11:12:02.112249434 -0500
+++ OpenGTL-0.9.15.2/OpenCTL/tests/parse/const_divide_0.ctl	2012-01-10 11:12:02.112249434 -0500
@@ -0,0 +1,2 @@
+
+const int var11 = 1 / 0;
diff -up OpenGTL-0.9.15.2/OpenCTL/tests/parse/expression_complex.ctl.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/tests/parse/expression_complex.ctl
--- OpenGTL-0.9.15.2/OpenCTL/tests/parse/expression_complex.ctl.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenCTL/tests/parse/expression_complex.ctl	2012-01-10 11:12:02.113249426 -0500
@@ -5,5 +5,5 @@ struct MyStruct {
 
 const bool vrai = true;
 const MyStruct myStruct = { { 10 <= (4+5 % 4), 3 < 5, 4 == 2 *4 +4, vrai, vrai || false, 10 / 10 == 1 } };
-const int var1 = 1 + ( 5 / 10 *4 % ( 3 & 4 + 8 ) );
+const int var1 = 1 + ( 5 / 10 *4 % ( 4 & 4 + 8 ) );
 const int var2 = myStruct.array[0] + myStruct.array[1] + myStruct.array[2] + myStruct.array[3];
diff -up OpenGTL-0.9.15.2/OpenCTL/tests/parse/expression_simple.ctl.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/tests/parse/expression_simple.ctl
--- OpenGTL-0.9.15.2/OpenCTL/tests/parse/expression_simple.ctl.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenCTL/tests/parse/expression_simple.ctl	2012-01-10 11:12:02.113249426 -0500
@@ -11,7 +11,7 @@ const int var7 = 1 - 1.0;
 const int var8 = 1 + -1.0 / 4;
 const int var9 = 1 + (-1.0 * 2 );
 const int var10 = 1 % ( 10 * 2 );
-const int var11 = 1 / 0;
+const int var11 = 2 / 1;
 const int var12 = 1 & 0;
 const int var13 = 1 ^ 0;
 const bool var14 = true && false;
diff -up OpenGTL-0.9.15.2/OpenCTL/tests/parse/recursive_function.ctl.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/tests/parse/recursive_function.ctl
--- OpenGTL-0.9.15.2/OpenCTL/tests/parse/recursive_function.ctl.95a8c6853b97	2012-01-10 11:12:02.114249418 -0500
+++ OpenGTL-0.9.15.2/OpenCTL/tests/parse/recursive_function.ctl	2012-01-10 11:12:02.113249426 -0500
@@ -0,0 +1,4 @@
+void recursiveFunction(float f)
+{
+  recursiveFunction(f);
+}
diff -up OpenGTL-0.9.15.2/OpenCTL/tools/benchmark/CtlBenchmark.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenCTL/tools/benchmark/CtlBenchmark.cpp
--- OpenGTL-0.9.15.2/OpenCTL/tools/benchmark/CtlBenchmark.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenCTL/tools/benchmark/CtlBenchmark.cpp	2012-01-10 11:12:02.114249418 -0500
@@ -399,8 +399,8 @@ int main(int argc, char** argv)
   
   GTLCore::PixelDescription pd( GTLCore::Type::Float32, 4);
   
-  int runs = 100;
-  int arraySize = 1000000;
+  int runs = 20;
+  int arraySize = 10000;
   
   GTLCore::Array array( arraySize * pd.bitsSize() / 8 );
   GTLCore::Array refArray( arraySize * pd.bitsSize() / 8 );
diff -up OpenGTL-0.9.15.2/OpenGTL/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenGTL/CMakeLists.txt.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/CMakeLists.txt	2012-01-10 11:12:02.114249418 -0500
@@ -8,3 +8,4 @@ if(OPENGTL_BUILD_TESTS)
 endif(OPENGTL_BUILD_TESTS)
 add_subdirectory(GTLImageIO)
 add_subdirectory(tools)
+add_subdirectory(GTLFragment)
diff -up OpenGTL-0.9.15.2/OpenGTL.doxy.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL.doxy
--- OpenGTL-0.9.15.2/OpenGTL.doxy.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL.doxy	2012-01-10 11:12:02.140249196 -0500
@@ -1,6 +1,6 @@
 /**
  * @mainpage OpenGTL - Open Graphics Transformation Languages
- * @version 0.9.15
+ * @version 0.9.16
  * @author Cyrille Berger
  * 
  * <a href='http://www.opengtl.org/'>OpenGTL</a> is a set of libraries providing Graphics
@@ -20,4 +20,4 @@
  * <li> \ref GTLTest the library that provide unit tests
  * <li> \ref GTLCore_AST the abstract syntaxic tree
 * </ul>
- */
\ No newline at end of file
+ */
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractColorConverter.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractColorConverter.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractColorConverter.cpp.95a8c6853b97	2012-01-10 11:12:02.115249410 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractColorConverter.cpp	2012-01-10 11:12:02.115249410 -0500
@@ -0,0 +1,170 @@
+/*
+ *  Copyright (c) 2009,2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "AbstractColorConverter.h"
+#include "StdTypes.h"
+#include "FloatHalfConverter_p.h"
+#include "Utils_p.h"
+#include "PixelDescription.h"
+#include "Type.h"
+#include "Debug.h"
+#include "Macros_p.h"
+
+#include "AbstractColorConverter_p.h"
+
+using namespace GTLCore;
+
+class GTLCore::Channel
+{
+public:
+    virtual ~Channel() { }
+    virtual float scaleToF32(const char* srcPixel) const = 0;
+    virtual void scaleFromF32(char* dstPixel, float value) const = 0;
+};
+
+template<typename _ChannelType_>
+class ChannelImpl : public Channel
+{
+public:
+    ChannelImpl(std::size_t _pos) : m_pos(_pos) { }
+    virtual ~ChannelImpl() {}
+    virtual float scaleToF32(const char* srcPixel) const;
+    virtual void scaleFromF32(char* dstPixel, float value) const;
+private:
+    inline const _ChannelType_* channel(const char* pixel) const {
+        return reinterpret_cast<const _ChannelType_*>(pixel + m_pos);
+    }
+    inline _ChannelType_* channel(char* pixel) const {
+        return reinterpret_cast<_ChannelType_*>(pixel + m_pos);
+    }
+private:
+    std::size_t m_pos;
+};
+
+template<>
+float ChannelImpl<gtl_uint8>::scaleToF32(const char* srcPixel) const {
+  return gtl_uint8(*channel(srcPixel) / 255.0);
+}
+
+template<>
+void ChannelImpl<gtl_uint8>::scaleFromF32(char* dstPixel, float value) const {
+  *channel(dstPixel) = gtl_uint8(value * 255);
+}
+
+template<>
+float ChannelImpl<gtl_uint16>::scaleToF32(const char* srcPixel) const {
+  return gtl_uint16(*channel(srcPixel) / float(UINT16_MAX));
+}
+
+template<>
+void ChannelImpl<gtl_uint16>::scaleFromF32(char* dstPixel, float value) const {
+  *channel(dstPixel) = gtl_uint16(value * UINT16_MAX);
+}
+
+template<>
+float ChannelImpl<float>::scaleToF32(const char* srcPixel) const {
+  return *channel(srcPixel);
+}
+
+template<>
+void ChannelImpl<float>::scaleFromF32(char* dstPixel, float value) const {
+  *channel(dstPixel) = value;
+}
+
+
+class ChannelHalf : public Channel
+{
+public:
+    ChannelHalf(std::size_t _pos) : m_pos(_pos) { }
+    virtual ~ChannelHalf() {}
+    virtual float scaleToF32(const char* srcPixel) const { return half2float(*channel(srcPixel)); }
+    virtual void scaleFromF32(char* dstPixel, float value) const { *channel(dstPixel) = float2half(value); }
+private:
+    inline const half* channel(const char* pixel) const {
+        return reinterpret_cast<const half*>(pixel + m_pos);
+    }
+    inline half* channel(char* pixel) const {
+        return reinterpret_cast<half*>(pixel + m_pos);
+    }
+private:
+    std::size_t m_pos;
+};
+
+AbstractColorConverter::AbstractColorConverter(const GTLCore::PixelDescription& _pixelDescription) : d(new Private(_pixelDescription))
+{
+  int currentPos = 0;
+  for(std::size_t i = 0; i < _pixelDescription.channels(); ++i)
+  {
+    switch(_pixelDescription.channelTypes()[i]->dataType())
+    {
+      case Type::UNSIGNED_INTEGER8:
+        d->channels.push_back(new ChannelImpl<gtl_uint8>(currentPos));
+        currentPos += 1;
+        break;
+      case Type::UNSIGNED_INTEGER16:
+        d->channels.push_back(new ChannelImpl<gtl_uint16>(currentPos));
+        currentPos += 2;
+        break;
+      case Type::FLOAT16:
+        d->channels.push_back(new ChannelHalf(currentPos));
+        currentPos += 2;
+        break;
+      case Type::FLOAT32:
+        d->channels.push_back(new ChannelImpl<float>(currentPos));
+        currentPos += 4;
+        break;
+      default:
+        GTL_ABORT("Unimplemnted");
+    }
+  }
+}
+
+AbstractColorConverter::~AbstractColorConverter()
+{
+  deleteAll(d->channels);
+  delete d;
+}
+
+void AbstractColorConverter::release(const GTLCore::AbstractColorConverter* _acc)
+{
+  if(_acc and _acc->d->deletable)
+  {
+    delete _acc;
+  }
+}
+
+void AbstractColorConverter::vectorToRgba(const float* _data, RgbaF* _rgba) const
+{
+  char* buffer = new char[d->pixelDescription.bitsSize() / 8];
+  for(std::size_t i = 0; i < d->pixelDescription.channels(); ++i)
+  {
+    d->channels[i]->scaleFromF32(buffer, _data[i]);
+  }
+  pixelToRgba(buffer, _rgba);
+}
+
+void AbstractColorConverter::rgbaToVector(const RgbaF* _rgba, float* _data) const
+{
+  char* buffer = new char[d->pixelDescription.bitsSize() / 8];
+  rgbaToPixel(_rgba, buffer);
+  for(std::size_t i = 0; i < d->pixelDescription.channels(); ++i)
+  {
+    _data[i] = d->channels[i]->scaleToF32(buffer);
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractColorConverter.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractColorConverter.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractColorConverter.h.95a8c6853b97	2012-01-10 11:12:02.115249410 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractColorConverter.h	2012-01-10 11:12:02.115249410 -0500
@@ -0,0 +1,57 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENGTL_COLOR_CONVERTER_H_
+#define _OPENGTL_COLOR_CONVERTER_H_
+
+#include <GTLCore/Export.h>
+
+namespace GTLCore {
+  struct RgbaF;
+  class PixelDescription;
+  class GTLCORE_EXPORT AbstractColorConverter
+  {
+    friend class ColorConverters;
+    GTL_NO_COPY(AbstractColorConverter)
+  protected:
+    AbstractColorConverter(const GTLCore::PixelDescription& _pixelDescription);
+    virtual ~AbstractColorConverter();
+  public:
+    static void release(const GTLCore::AbstractColorConverter* _acc);
+    virtual void pixelToRgba(const char* _data, RgbaF* _rgba) const = 0;
+    virtual void rgbaToPixel(const RgbaF* _rgba, char* _data) const = 0;
+    virtual void vectorToRgba(const float* _data, RgbaF* _rgba) const;
+    virtual void rgbaToVector(const RgbaF* _rgba, float* _data) const;
+  private:
+    // Those are placeholders for the future conversion to/from HSV and to/from LAB
+    virtual void placeholder1() {}
+    virtual void placeholder2() {}
+    virtual void placeholder3() {}
+    virtual void placeholder4() {}
+    virtual void placeholder5() {}
+    virtual void placeholder6() {}
+    virtual void placeholder7() {}
+    virtual void placeholder8() {}
+  private:
+    struct Private;
+    Private* const d;
+  };
+};
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractColorConverter_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractColorConverter_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractColorConverter_p.h.95a8c6853b97	2012-01-10 11:12:02.115249410 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractColorConverter_p.h	2012-01-10 11:12:02.115249410 -0500
@@ -0,0 +1,38 @@
+/*
+ *  Copyright (c) 2009,2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "AbstractColorConverter.h"
+
+#include <vector>
+
+namespace GTLCore {
+
+  class Channel;
+
+  struct AbstractColorConverter::Private
+  {
+    Private(const GTLCore::PixelDescription& _pixelDescription) : pixelDescription(_pixelDescription)
+    {
+    }
+    GTLCore::PixelDescription pixelDescription;
+    std::vector<Channel*> channels;
+    bool deletable;
+  };
+
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractImage.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractImage.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractImage.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractImage.cpp	2012-01-10 11:12:02.116249402 -0500
@@ -24,6 +24,7 @@
 #include "Debug.h"
 #include "PixelDescription.h"
 #include "Region.h"
+#include "AbstractColorConverter.h"
 
 using namespace GTLCore;
 
@@ -32,6 +33,7 @@ struct AbstractImage::Private {
   {
   }
   GTLCore::PixelDescription pixelDescription;
+  const GTLCore::AbstractColorConverter* colorConverter;
   int pixelSize;
 };
 
@@ -51,14 +53,16 @@ AbstractImage::Iterator::~Iterator()
 {
 }
 
-AbstractImage::AbstractImage( const GTLCore::PixelDescription& _pixelDescription ) : d(new Private(_pixelDescription))
+AbstractImage::AbstractImage( const GTLCore::PixelDescription& _pixelDescription, const AbstractColorConverter* _colorConverter ) : d(new Private(_pixelDescription))
 {
   GTL_ASSERT(d->pixelDescription.bitsSize() % 8 == 0);
   d->pixelSize = d->pixelDescription.bitsSize() / 8;
+  d->colorConverter = _colorConverter;
 }
 
 AbstractImage::~AbstractImage()
 {
+  AbstractColorConverter::release(d->colorConverter);
   delete d;
 }
 
@@ -72,6 +76,11 @@ int AbstractImage::pixelSize() const
   return d->pixelSize;
 }
 
+const GTLCore::AbstractColorConverter* AbstractImage::colorConverter() const
+{
+  return d->colorConverter;
+}
+
 int AbstractImage::compare( const AbstractImage* _image, const GTLCore::RegionI& _region) const
 {
   // Test pixelDescription
@@ -97,14 +106,14 @@ int AbstractImage::compare( const Abstra
         if( errorCount < 100 )
         {
           String val1, val2;
-          const char* px1 = rawData( x, y);
-          const char* px2 = _image->rawData( x, y);
+          const unsigned char* px1 = reinterpret_cast<const unsigned char*>(rawData( x, y));
+          const unsigned char* px2 = reinterpret_cast<const unsigned char*>(_image->rawData( x, y));
           for( int i = 0; i < _pixelSize; ++i)
           {
-            val1 += String::number(static_cast<unsigned int>(px1[i]));
-            val2 += String::number(static_cast<unsigned int>(px2[i]));
+            val1 += String::number(static_cast<unsigned int>(px1[i])) + " ";
+            val2 += String::number(static_cast<unsigned int>(px2[i])) + " ";
           }
-          GTL_ERROR( "Pixel (" << x << ", " << y << ") is different. " << val1 << " != " << val2 );
+          GTL_ERROR( "Pixel (" << x << ", " << y << ") is different. " << val1 << "!= " << val2 );
         } else if( errorCount == 100 )
         {
           GTL_ERROR( "and more...");
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractImage.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractImage.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractImage.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AbstractImage.h	2012-01-10 11:12:02.116249402 -0500
@@ -24,6 +24,9 @@
 #include "Region.h"
 
 namespace GTLCore {
+
+class AbstractColorConverter;
+
   class Buffer;
   class PixelDescription;
   class RegionI;
@@ -92,7 +95,7 @@ namespace GTLCore {
           virtual Buffer* current() = 0;
       };
     public:
-      AbstractImage( const GTLCore::PixelDescription& _pixelDescription );
+      AbstractImage( const GTLCore::PixelDescription& _pixelDescription, const AbstractColorConverter* _colorConverter = 0 );
       virtual ~AbstractImage();
     public:
       /**
@@ -142,6 +145,10 @@ namespace GTLCore {
        * Create an iterator on the buffer of the image
        */
       virtual Iterator* createIterator() = 0;
+      /**
+       * @return the color converter associated with this image
+       */
+      const GTLCore::AbstractColorConverter* colorConverter() const;
     protected:
       int pixelSize() const;
     private:
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/AccessorExpression.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/AccessorExpression.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/AccessorExpression.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/AccessorExpression.cpp	2012-01-10 11:12:02.117249393 -0500
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *  Copyright (c) 2008,2010 Cyrille Berger <cberger@cberger.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -19,12 +19,15 @@
 
 #include "AccessorExpression.h"
 
+#include <llvm/ADT/ArrayRef.h>
 #include <llvm/Constants.h>
+#include <llvm/Function.h>
 #include <llvm/Instructions.h>
 
 #include "../LLVMBackend/CodeGenerator_p.h"
 #include "../LLVMBackend/ExpressionResult_p.h"
 #include "../Function.h"
+#include "../Function_p.h"
 #include "../Debug.h"
 #include "../VariableNG_p.h"
 #include "../LLVMBackend/Visitor_p.h"
@@ -65,7 +68,7 @@ llvm::BasicBlock* AccessorExpression::af
 {
   llvm::Value* ptr_ = pointer( _gc, _egc );
   const LLVMBackend::Visitor* visitor = LLVMBackend::Visitor::getVisitorFor( type() );
-  return visitor->set( _gc, _egc.currentBasicBlock(), ptr_, type(), _value.value(), _value.type(), allocatedInMemory());
+  return visitor->set( _gc, _egc.currentBasicBlock(), ptr_, type(), _value.value(), _value.type());
 }
 
 //------------------- ArraySizeAccessorExpression -------------------//
@@ -123,7 +126,7 @@ llvm::Value* StructAccessorExpression::p
   indexes.push_back( _gc.codeGenerator()->integerToConstant(_gc.llvmContext(), INT32_C(0)));
   indexes.push_back( _gc.codeGenerator()->integerToConstant(_gc.llvmContext(), gtl_int32(m_index + STRUCT_FIRST_ELEMENT)));
   llvm::Value* ptr = m_parent->pointer( _gc, _egc);
-  llvm::Value* val = llvm::GetElementPtrInst::Create( ptr, indexes.begin(), indexes.end(), "", _egc.currentBasicBlock());
+  llvm::Value* val = llvm::GetElementPtrInst::Create( ptr, indexes, "", _egc.currentBasicBlock());
   GTL_DEBUG( val );
   return val;
 }
@@ -143,6 +146,25 @@ void StructAccessorExpression::markAsRet
   m_parent->markAsReturnExpression();
 }
 
+llvm::BasicBlock* StructAccessorExpression::affect( LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc, const LLVMBackend::ExpressionResult& _value )
+{
+  const Type::StructDataMember::Information* info = m_parent->type()->structDataMember(m_index).information();
+  if(info and info->setter())
+  {
+    llvm::Function* llvmFunction = info->setter()->d->data->function( );
+    
+    std::vector<llvm::Value*> convertedParams;
+    convertedParams.push_back(m_parent->pointer( _gc, _egc));
+    convertedParams.push_back(_value.value());
+    
+    llvm::CallInst *CallInst = llvm::CallInst::Create(llvmFunction, convertedParams, "", _egc.currentBasicBlock());
+    CallInst->setTailCall(false);
+    return _egc.currentBasicBlock();
+  } else {
+    return AccessorExpression::affect(_gc, _egc, _value);
+  }
+}
+
 //------------------- ArrayAccessorExpression -------------------//
 
 ArrayAccessorExpression::ArrayAccessorExpression(AccessorExpression * _parent, Expression* _index) : m_parent(_parent), m_index(_index)
@@ -162,6 +184,7 @@ llvm::Value* ArrayAccessorExpression::po
   GTL_ASSERT(ptr_);
   const LLVMBackend::Visitor* visitor = LLVMBackend::Visitor::getVisitorFor( m_parent->type() );
   llvm::Value* index = m_index->generateValue(_gc, _egc).value();
+  GTL_DEBUG(*ptr_ << *ptr_->getType());
   llvm::Value* val = visitor->pointerToIndex(_gc, _egc, ptr_, m_parent->type(), index );
   GTL_DEBUG( *val );
   return val;
@@ -195,7 +218,7 @@ llvm::Value* VariableAccessorExpression:
 {
   GTL_DEBUG("VariableAccessorExpression::pointer");
   llvm::Value* val = m_variable->pointer(_egc.currentBasicBlock());
-  GTL_DEBUG(*val);
+  GTL_DEBUG(*val << *val->getType());
   return val;
 }
 
@@ -209,16 +232,6 @@ const GTLCore::Type* VariableAccessorExp
   return m_variable->type();
 }
 
-void VariableAccessorExpression::markAsReturnExpression()
-{
-  m_variable->setAllocatedInMemory( true );
-}
-
-bool VariableAccessorExpression::allocatedInMemory() const
-{
-  return m_variable->allocatedInMemory();
-}
-
 llvm::BasicBlock* VariableAccessorExpression::affect( LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc, const LLVMBackend::ExpressionResult& _value )
 {
   if( _value.functionResult() and (type()->dataType() == Type::ARRAY or type()->dataType() == Type::STRUCTURE ) and not m_variable->constantPointer() )
@@ -229,6 +242,10 @@ llvm::BasicBlock* VariableAccessorExpres
   }
 }
 
+void VariableAccessorExpression::markAsReturnExpression()
+{
+}
+
 //------------------- FunctionMemberAccessorExpression -------------------//
 
 FunctionMemberAccessorExpression::FunctionMemberAccessorExpression( AccessorExpression * _parent, 
@@ -271,12 +288,6 @@ llvm::Value* FunctionMemberAccessorExpre
   return 0;
 }
 
-bool FunctionMemberAccessorExpression::allocatedInMemory() const
-{
-  GTL_ABORT("No memory is allocated for a function member accessor.");
-  return false;
-}
-
 void FunctionMemberAccessorExpression::markAsReturnExpression()
 {
   // There is no easy way to know if an Array/Structure given as argument of a function
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/AccessorExpression.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/AccessorExpression.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/AccessorExpression.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/AccessorExpression.h	2012-01-10 11:12:02.118249384 -0500
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *  Copyright (c) 2008,2010 Cyrille Berger <cberger@cberger.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -36,7 +36,6 @@ namespace GTLCore {
         virtual ExpressionResultSP generateValue( GenerationVisitor* _generationVisitor) const;
       public:
         virtual llvm::Value* pointer(LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc) const = 0;
-        virtual bool allocatedInMemory() const = 0;
         virtual llvm::BasicBlock* affect( LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc, const LLVMBackend::ExpressionResult& _value );
     };
     /**
@@ -52,7 +51,6 @@ namespace GTLCore {
         virtual const GTLCore::Type* type() const;
         virtual llvm::Value* pointer(LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc) const;
         virtual void markAsReturnExpression();
-        virtual bool allocatedInMemory() const { return m_parent->allocatedInMemory(); }
       private:
         AccessorExpression * m_parent;
     };
@@ -70,7 +68,7 @@ namespace GTLCore {
       public:
         virtual llvm::Value* pointer(LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc) const;
         virtual void markAsReturnExpression();
-        virtual bool allocatedInMemory() const { return m_parent->allocatedInMemory(); }
+        virtual llvm::BasicBlock* affect( LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc, const LLVMBackend::ExpressionResult& _value );
       private:
         AccessorExpression * m_parent;
         unsigned int m_index;
@@ -89,7 +87,6 @@ namespace GTLCore {
       public:
         virtual llvm::Value* pointer(LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc) const;
         virtual void markAsReturnExpression();
-        virtual bool allocatedInMemory() const { return m_parent->allocatedInMemory(); }
       private:
         AccessorExpression * m_parent;
         Expression* m_index;
@@ -99,16 +96,15 @@ namespace GTLCore {
      * Access the content of a variable.
      * @ingroup GTLCore_AST
      */
-    class VariableAccessorExpression : public AccessorExpression {
+    class GTLCORE_EXPORT VariableAccessorExpression : public AccessorExpression {
       public:
         VariableAccessorExpression(GTLCore::VariableNG* _variable );
         virtual bool isConstant() const;
         virtual const GTLCore::Type* type() const;
       public:
         virtual llvm::Value* pointer(LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc) const;
-        virtual void markAsReturnExpression();
-        virtual bool allocatedInMemory() const;
         virtual llvm::BasicBlock* affect( LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc, const LLVMBackend::ExpressionResult& _value );
+        virtual void markAsReturnExpression();
       private:
         GTLCore::VariableNG* m_variable;
     };
@@ -129,7 +125,6 @@ namespace GTLCore {
         virtual LLVMBackend::ExpressionResult generateValue( LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc ) const;
         virtual llvm::Value* pointer(LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc) const;
         virtual void markAsReturnExpression();
-        virtual bool allocatedInMemory() const;
       private:
         AccessorExpression* m_parent;
         const Type::StructFunctionMember* m_member;
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/AST.doxy.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/AST.doxy
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/AST.doxy.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/AST.doxy	2012-01-10 11:12:02.118249384 -0500
@@ -1,7 +1,7 @@
 /**
  * @internal
  * @addtogroup GTLCore_AST GTLCore AST Library
- * @version 0.9.15
+ * @version 0.9.16
  * @author Cyrille Berger
  * @ingroup GTLCore
  * 
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/ASTBackend/GenerationVisitor.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/ASTBackend/GenerationVisitor.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/ASTBackend/GenerationVisitor.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/ASTBackend/GenerationVisitor.cpp	2012-01-10 11:12:02.121249359 -0500
@@ -100,7 +100,17 @@ MAKE_INTEGER_BINARY_EXPRESSION(generateB
 MAKE_INTEGER_BINARY_EXPRESSION(generateBitAndExpresion, &)
 MAKE_INTEGER_BINARY_EXPRESSION(generateRightShiftExpresion, >>)
 MAKE_INTEGER_BINARY_EXPRESSION(generateLeftShiftExpresion, <<)
-MAKE_INTEGER_BINARY_EXPRESSION(generateModuloExpresion, %)
+
+AST::ExpressionResultSP GenerationVisitor::generateModuloExpresion( AST::ExpressionResultSP arg1, AST::ExpressionResultSP arg2, const AST::Annotation& _annotation)
+{
+  GET_VALUE( 1)
+  GET_VALUE( 2)
+  if(val2.asInt32() == 0) {
+    reportError( "Modulo by 0.", _annotation);
+    return new ExpressionResult( INT32_C(0) );
+  }
+  return new ExpressionResult( val1.asInt32() % val2.asInt32() );
+}
 
 #define MAKE_BINARY_EXPRESSION( _EXPR_NAME_, _EXPR_OP_ ) \
   AST::ExpressionResultSP GenerationVisitor::_EXPR_NAME_( AST::ExpressionResultSP arg1, AST::ExpressionResultSP arg2, const AST::Annotation&) \
@@ -124,7 +134,21 @@ MAKE_BINARY_EXPRESSION(generateSupperior
 MAKE_BINARY_EXPRESSION(generateAdditionExpresion, +);
 MAKE_BINARY_EXPRESSION(generateSubtractionExpresion, -);
 MAKE_BINARY_EXPRESSION(generateMultiplicationExpresion, *);
-MAKE_BINARY_EXPRESSION(generateDivisionExpresion, /);
+
+AST::ExpressionResultSP GenerationVisitor::generateDivisionExpresion( AST::ExpressionResultSP arg1, AST::ExpressionResultSP arg2, const AST::Annotation& _annotation)
+{
+  GET_VALUE( 1)
+  GET_VALUE( 2)
+  if( val1.type() == Type::Float32 or val2.type() == Type::Float32 )
+  {
+    return new ExpressionResult( val1.asFloat32() / val2.asFloat32() );
+  } else if(val2.asInt32() == 0) {
+    reportError( "Division by 0.", _annotation);
+    return new ExpressionResult( INT32_C(1) );
+  } else {
+    return new ExpressionResult( val1.asInt32() / val2.asInt32() );
+  }
+}
 
 AST::ExpressionResultSP GenerationVisitor::generateTildExpression(AST::ExpressionResultSP arg1, const AST::Annotation& _annotation)
 {
@@ -184,8 +208,7 @@ AST::ExpressionResultSP GenerationVisito
   return new ExpressionResult( Value(values, type) );
 }
 
-AST::ExpressionResultSP GenerationVisitor::createCompoundValue(std::vector< AST::ExpressionResultSP> arg1, const Type*, const AST::Annotation& _annotation)
+AST::ExpressionResultSP GenerationVisitor::createCompoundValue(std::vector< AST::ExpressionResultSP> arg1, const Type* type, const AST::Annotation& _annotation)
 {
-  GTL_ABORT("Unimplemented");
-  return 0;
+  return createCompoundConstant(arg1, type, _annotation);
 }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/ASTBackend/GenerationVisitor.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/ASTBackend/GenerationVisitor.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/ASTBackend/GenerationVisitor.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/ASTBackend/GenerationVisitor.h	2012-01-10 11:12:02.122249350 -0500
@@ -70,7 +70,7 @@ namespace ASTBackend {
         virtual GTLCore::AST::ExpressionResultSP convertExpressionTo(GTLCore::AST::ExpressionResultSP arg1, const GTLCore::Type* _type, const GTLCore::AST::Annotation& _annotation);
         virtual GTLCore::AST::ExpressionResultSP convertArrayToVector(GTLCore::AST::ExpressionResultSP arg1, const GTLCore::Type* type, const GTLCore::AST::Annotation& _annotation);
         virtual GTLCore::AST::ExpressionResultSP createCompoundConstant(std::vector< GTLCore::AST::ExpressionResultSP> arg1, const GTLCore::Type*, const GTLCore::AST::Annotation& arg2);
-        virtual GTLCore::AST::ExpressionResultSP createCompoundValue(std::vector< GTLCore::AST::ExpressionResultSP > arg1, const GTLCore::Type*, const GTLCore::AST::Annotation& _annotation);
+        virtual GTLCore::AST::ExpressionResultSP createCompoundValue(std::vector< GTLCore::AST::ExpressionResultSP > arg1, const GTLCore::Type* type, const GTLCore::AST::Annotation& _annotation);
   };
 }
 
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/BinaryExpression.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/BinaryExpression.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/BinaryExpression.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/BinaryExpression.cpp	2012-01-10 11:12:02.119249375 -0500
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2008-2009 Cyrille Berger <cberger@cberger.net>
+ *  Copyright (c) 2008,2009 Cyrille Berger <cberger@cberger.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/BinaryExpression.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/BinaryExpression.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/BinaryExpression.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/BinaryExpression.h	2012-01-10 11:12:02.119249375 -0500
@@ -32,7 +32,7 @@ namespace GTLCore {
      * This is the base class of binary expressions ( '<', '==', '+', '%'...).
      * @ingroup GTLCore_AST
      */
-    class BinaryExpression : public Expression {
+    class GTLCORE_EXPORT BinaryExpression : public Expression {
       public:
         BinaryExpression( Expression* lhs, Expression* rhs) : m_lhs(lhs), m_rhs(rhs) {}
         ~BinaryExpression();
@@ -281,7 +281,7 @@ namespace GTLCore {
      * expression must be a @ref VariableExpression.
      * @ingroup GTLCore_AST
      */
-    class AssignementBinaryExpression : public BinaryExpression {
+    class GTLCORE_EXPORT AssignementBinaryExpression : public BinaryExpression {
       public:
         AssignementBinaryExpression( AccessorExpression* lhs, Expression* rhs );
         virtual llvm::BasicBlock* generateStatement( LLVMBackend::GenerationContext&, llvm::BasicBlock* ) const;
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/CompoundExpression.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/CompoundExpression.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/CompoundExpression.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/CompoundExpression.cpp	2012-01-10 11:12:02.119249375 -0500
@@ -32,6 +32,8 @@
 #include "../LLVMBackend/ExpressionResult_p.h"
 #include "../LLVMBackend/ExpressionGenerationContext_p.h"
 #include "GenerationVisitor.h"
+#include "../LLVMBackend/Visitor_p.h"
+#include "GarbageCollectionStatement.h"
 
 using namespace GTLCore::AST;
 
@@ -80,11 +82,54 @@ LLVMBackend::ExpressionResult CompoundEx
       }
       return LLVMBackend::ExpressionResult( resultLoad, m_type );
     }
-      break;
     case Type::ARRAY:
-      GTL_ABORT("Unimplemented");
+    {
+      // Allocate memory for an array
+      llvm::Value* ptr = LLVMBackend::CodeGenerator::allocateMemory(_gc, type()->d->type(_gc.llvmContext()), LLVMBackend::CodeGenerator::integerToConstant(_gc.llvmContext(), INT32_C(1)), _egc.currentBasicBlock());
+      
+      // The initial size is equal to the number of elements in the compound
+      std::list<llvm::Value*> sizes;
+      sizes.push_back(LLVMBackend::CodeGenerator::integerToConstant(_gc.llvmContext(), gtl_uint32(m_expressions.size())));
+      
+      // Initialize the array's memory
+      const LLVMBackend::Visitor* visitor = LLVMBackend::Visitor::getVisitorFor(type());
+      _egc.setCurrentBasicBlock(visitor->initialise( _gc, _egc.currentBasicBlock(), ptr, type(), sizes ));
+      
+      // Set the values
+      const Type* mtype = type()->embeddedType();
+      const LLVMBackend::Visitor* mvisitor = LLVMBackend::Visitor::getVisitorFor( mtype );
+      for(std::size_t i = 0; i < m_expressions.size(); ++i)
+      {
+        llvm::Value* nptrToOwnMember = visitor->pointerToIndex(_gc, _egc, ptr, type(),  LLVMBackend::CodeGenerator::integerToConstant(_gc.llvmContext(), gtl_uint32(i)));
+        
+        llvm::Value* val = m_expressions[i]->generateValue( _gc, _egc ).value();
+        
+        _egc.setCurrentBasicBlock(mvisitor->set( _gc, _egc.currentBasicBlock(), nptrToOwnMember, mtype, val, mtype));
+      }
+      _egc.setCurrentBasicBlock(visitor->mark(_gc, _egc.currentBasicBlock(), ptr, type(), LLVMBackend::CodeGenerator::integerToConstant(_gc.llvmContext(), INT32_C(-1))));
+      
+      return LLVMBackend::ExpressionResult(ptr, m_type, true);
+    }
     case Type::STRUCTURE:
-      GTL_ABORT("Unimplemented");
+    {
+      GTL_ASSERT(m_expressions.size() == type()->countStructDataMembers());
+      llvm::Value* ptr = LLVMBackend::CodeGenerator::allocateMemory(_gc, type()->d->type(_gc.llvmContext()), LLVMBackend::CodeGenerator::integerToConstant(_gc.llvmContext(), INT32_C(1)), _egc.currentBasicBlock());
+      
+      const LLVMBackend::Visitor* visitor = LLVMBackend::Visitor::getVisitorFor(type());
+      _egc.setCurrentBasicBlock(visitor->initialise( _gc, _egc.currentBasicBlock(), ptr, type(), std::list<llvm::Value*>()));
+
+      for(std::size_t i = 0; i < type()->countStructDataMembers(); ++i)
+      {
+        const Type* mtype = type()->structDataMember(i).type();
+        llvm::Value* nptrToOwnMember = LLVMBackend::StructureVisitor::pointerToValue(_gc, _egc.currentBasicBlock(), ptr, i);
+        llvm::Value* val = m_expressions[i]->generateValue( _gc, _egc ).value();
+        
+        const LLVMBackend::Visitor* visitor = LLVMBackend::Visitor::getVisitorFor( mtype );
+        _egc.setCurrentBasicBlock(visitor->set( _gc, _egc.currentBasicBlock(), nptrToOwnMember, mtype, val, mtype));
+      }
+      _egc.setCurrentBasicBlock(visitor->mark(_gc, _egc.currentBasicBlock(), ptr, type(), LLVMBackend::CodeGenerator::integerToConstant(_gc.llvmContext(), INT32_C(-1))));
+      return LLVMBackend::ExpressionResult(ptr, m_type, true);
+    }
     default:
       GTL_ABORT("Unsupported");
   }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/ConstantCompoundExpression.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/ConstantCompoundExpression.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/ConstantCompoundExpression.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/ConstantCompoundExpression.cpp	2012-01-10 11:12:02.119249375 -0500
@@ -31,11 +31,12 @@
 #include "../Type_p.h"
 #include "../LLVMBackend/ExpressionResult_p.h"
 #include "../LLVMBackend/ExpressionGenerationContext_p.h"
+#include "../LLVMBackend/Visitor_p.h"
 #include "GenerationVisitor.h"
 
 using namespace GTLCore::AST;
 
-ConstantCompoundExpression::ConstantCompoundExpression( const GTLCore::Type* _type, const std::vector<Expression*>& _expressions) : m_expressions(_expressions), m_type(_type)
+ConstantCompoundExpression::ConstantCompoundExpression( const GTLCore::Type* _type, const std::vector<Expression*>& _expressions) : m_expressions(_expressions), m_type(_type), m_returnExpression(false)
 {
   GTL_ASSERT(_type);
   GTL_ASSERT(not m_expressions.empty());
@@ -65,6 +66,7 @@ bool ConstantCompoundExpression::isConst
 LLVMBackend::ExpressionResult ConstantCompoundExpression::generateValue( LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc ) const
 {
   GTL_DEBUG( m_type->dataType() << " " << Type::ARRAY << " " << Type::STRUCTURE );
+  llvm::Constant* result = 0;
   if( m_type->dataType() == Type::ARRAY or m_type->dataType() == Type::VECTOR)
   {
     const GTLCore::Type* arrayType = m_type->embeddedType();
@@ -77,12 +79,10 @@ LLVMBackend::ExpressionResult ConstantCo
     GTL_ASSERT(members.size() == m_expressions.size());
     if( m_type->dataType() == Type::ARRAY )
     {
-      return LLVMBackend::ExpressionResult( LLVMBackend::CodeGenerator::constantsToArray(_gc, members, m_type) , type() );
+      result = LLVMBackend::CodeGenerator::constantsToArray(_gc, members, m_type);
     } else if( m_type->dataType() == Type::VECTOR )
     {
-      llvm::Constant* constant = LLVMBackend::CodeGenerator::constantsToVector(_gc, members, m_type);
-      GTL_DEBUG( "Coumpound constant = " << *constant << " type = " << *m_type );
-      return LLVMBackend::ExpressionResult( constant, m_type );
+      result = LLVMBackend::CodeGenerator::constantsToVector(_gc, members, m_type);
     }
   } else if( m_type->dataType() == Type::STRUCTURE )
   {
@@ -92,10 +92,23 @@ LLVMBackend::ExpressionResult ConstantCo
     {
       members.push_back( _gc.codeGenerator()->convertConstantTo( m_expressions[i]->generateValue( _gc, _egc).constant(), m_expressions[i]->type(), m_type->structDataMember(i).type() ) );
     }
-    return LLVMBackend::ExpressionResult( LLVMBackend::CodeGenerator::constantsToStructure(_gc, members, m_type), type() );
+    result = LLVMBackend::CodeGenerator::constantsToStructure(_gc, members, m_type);
+  }
+  GTL_ASSERT_X(result, "Can't generate coumpound value, neither array, neither vector.");
+  GTL_DEBUG( "Coumpound constant = " << *result << " type = " << *m_type );
+  if(m_returnExpression and type()->dataType() != Type::VECTOR)
+  {
+    GTL_ASSERT(type()->isStructure() or type()->dataType() == Type::ARRAY);
+    const LLVMBackend::Visitor* visitor = LLVMBackend::Visitor::getVisitorFor( type() );
+    
+    llvm::Value* value = LLVMBackend::CodeGenerator::allocateMemory(_gc, type()->d->type(_gc.llvmContext()), LLVMBackend::CodeGenerator::integerToConstant(_gc.llvmContext(), INT32_C(1)), _egc.currentBasicBlock());
+
+    _egc.setCurrentBasicBlock( visitor->set( _gc, _egc.currentBasicBlock(), value, type(), 
+            new llvm::GlobalVariable( *_gc.llvmModule(), result->getType(), true, llvm::GlobalValue::InternalLinkage, result, "" ), type()) );
+    return LLVMBackend::ExpressionResult(value, type());
+  } else {
+    return LLVMBackend::ExpressionResult(result, type());
   }
-  GTL_ABORT("Can't generate coumpound value, neither array, neither vector.");
-  return LLVMBackend::ExpressionResult();
 }
 
 ExpressionResultSP ConstantCompoundExpression::generateValue( GenerationVisitor* _generationVisitor) const
@@ -111,7 +124,7 @@ ExpressionResultSP ConstantCompoundExpre
 
 void ConstantCompoundExpression::markAsReturnExpression()
 {
-  GTL_ABORT("ConstantCompoundExpression can't be in a return statement");
+  m_returnExpression = true;
 }
 
 Expression* ConstantCompoundExpression::expressionAt(unsigned int _idx )
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/ConstantCompoundExpression.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/ConstantCompoundExpression.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/ConstantCompoundExpression.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/ConstantCompoundExpression.h	2012-01-10 11:12:02.119249375 -0500
@@ -44,6 +44,7 @@ namespace GTLCore {
         std::vector<Expression*> m_expressions;
         const GTLCore::Type* m_type;
         bool m_constant;
+        bool m_returnExpression;
     };
   }
 }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Expression.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Expression.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Expression.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Expression.cpp	2012-01-10 11:12:02.120249367 -0500
@@ -48,6 +48,7 @@
 #include "../Color.h"
 #include "../TypesManager.h"
 
+using namespace GTLCore;
 using namespace GTLCore::AST;
 
 //------------------------------------------//
@@ -61,7 +62,7 @@ llvm::BasicBlock* Expression::generateSt
   return egc.currentBasicBlock();
 }
 
-Expression* Expression::fromValue( const GTLCore::Value& _val)
+Expression* Expression::fromValue( const GTLCore::Value& _val, const GTLCore::Type* _declarationType)
 {
   switch( _val.type()->dataType() )
   {
@@ -86,17 +87,28 @@ Expression* Expression::fromValue( const
     {
       if (_val.type() == Type::Color)
       {
+        GTL_ASSERT(_declarationType);
+        GTL_ASSERT(_declarationType->structName() == "color");
         std::vector<Expression*> expressions;
         GTLCore::Color c = _val.asColor();
         expressions.push_back(new AST::NumberExpression<float>(c.red()));
         expressions.push_back(new AST::NumberExpression<float>(c.green()));
         expressions.push_back(new AST::NumberExpression<float>(c.blue()));
         expressions.push_back(new AST::NumberExpression<float>(c.alpha()));
-        return new AST::ConstantCompoundExpression( GTLCore::TypesManager::getVector(Type::Float32, 4), expressions );
+        return new AST::ConstantCompoundExpression( _declarationType, expressions );
+      } else {
+        std::vector<Expression*> expressions;
+        foreach(const Value& val, *_val.asArray())
+        {
+          expressions.push_back(fromValue(val));
+        }
+        
+        return new AST::ConstantCompoundExpression( _val.type(), expressions );
+        
       }
     }
     default:
-      GTL_ABORT("Unimplmeneted");
+      GTL_ABORT("Unimplmeneted: type is " << _val.type()->dataType() << _val);
   }
 }
 
@@ -104,6 +116,11 @@ Expression* Expression::fromValue( const
 //------------- ProxyExpression ------------//
 //------------------------------------------//
 
+ProxyExpression::ProxyExpression( Expression* expr ) : m_clone( expr)
+{
+  GTL_ASSERT(expr);
+}
+
 LLVMBackend::ExpressionResult ProxyExpression::generateValue( LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc) const
 {
   return m_clone->generateValue( _gc, _egc);
@@ -118,7 +135,7 @@ ExpressionResultSP ProxyExpression::gene
 //------------- GlobalDataExpression ------------//
 //------------------------------------------//
 
-GlobalDataExpression::GlobalDataExpression( Expression* expression ) : m_expression( expression )
+GlobalDataExpression::GlobalDataExpression( Expression* expression ) : m_expression( expression ), m_isreturn(false)
 { }
 
 GlobalDataExpression::~GlobalDataExpression()
@@ -129,11 +146,12 @@ GlobalDataExpression::~GlobalDataExpress
 LLVMBackend::ExpressionResult GlobalDataExpression::generateValue( LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc) const
 {
   LLVMBackend::ExpressionResult value = m_expression->generateValue( _gc, _egc );
-  if( type()->dataType() == Type::VECTOR )
+  if( m_isreturn) return value;
+  if( value.isConstant() )
   {
-    return value;
-  } else {
     return LLVMBackend::ExpressionResult( new llvm::GlobalVariable( *_gc.llvmModule(), value.constant()->getType(), true, llvm::GlobalValue::InternalLinkage, value.constant(), "" ), type() );
+  } else {
+    return value;
   }
 }
 
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Expression.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Expression.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Expression.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Expression.h	2012-01-10 11:12:02.120249367 -0500
@@ -59,9 +59,10 @@ namespace GTLCore {
         virtual void markAsReturnExpression() = 0;
       public:
         /**
+         * @param _declarationType is used for structure whose Value's type is different from their actual type
          * @return an \ref AST::Expression corresponding to the value @p _val given in parameter.
          */
-        static AST::Expression* fromValue( const GTLCore::Value& _val);
+        static AST::Expression* fromValue( const GTLCore::Value& _val, const GTLCore::Type* _declarationType = 0);
     };
 
     /**
@@ -82,8 +83,7 @@ namespace GTLCore {
      */
     class ProxyExpression : public Expression {
       public:
-        ProxyExpression( Expression* expr ) : m_clone( expr)
-        {}
+        ProxyExpression( Expression* expr );
         virtual const GTLCore::Type* type() const { return m_clone->type(); }
         virtual bool isConstant() const { return m_clone->isConstant(); }
         virtual LLVMBackend::ExpressionResult generateValue( LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& ) const;
@@ -106,9 +106,10 @@ namespace GTLCore {
         virtual bool isConstant() const { return true; }
         virtual LLVMBackend::ExpressionResult generateValue( LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& ) const;
         virtual ExpressionResultSP generateValue( GenerationVisitor* _generationVisitor) const;
-        virtual void markAsReturnExpression() { m_expression->markAsReturnExpression(); }
+        virtual void markAsReturnExpression() { m_expression->markAsReturnExpression(); m_isreturn = true; }
       private:
         Expression* m_expression;
+        bool m_isreturn;
     };
     /**
      * @internal
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/FunctionDeclaration.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/FunctionDeclaration.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/FunctionDeclaration.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/FunctionDeclaration.cpp	2012-01-10 11:12:02.120249367 -0500
@@ -90,7 +90,7 @@ void FunctionDeclaration::generate( GTLC
   GTL_DEBUG("Generate function " << m_function->name() );
   m_functionData->setModule( _module );
   // Create the list of parameters as in llvm
-  std::vector<const llvm::Type*> params;
+  std::vector< llvm::Type*> params;
   
   if( m_function->d->isReturnedAsPointer() )
   {
@@ -110,7 +110,7 @@ void FunctionDeclaration::generate( GTLC
   }
     
   // Generate the full function
-  const llvm::Type* returnType = m_function->d->isReturnedAsPointer() ? llvm::Type::getVoidTy(*_llvmContext) : m_function->returnType()->d->asArgumentType(*_llvmContext);
+  llvm::Type* returnType = m_function->d->isReturnedAsPointer() ? llvm::Type::getVoidTy(*_llvmContext) : m_function->returnType()->d->asArgumentType(*_llvmContext);
   llvm::FunctionType* definitionType = llvm::FunctionType::get( returnType, params, false );
   GTLCore::String fullFunctionName = GTLCore::Function::Data::symbolName( m_function->name(), m_function->returnType(), m_function->parameters());
   llvm::Function* fullFunction = _codeGenerator->createFunction( _llvmModule, definitionType, fullFunctionName );
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/GarbageCollectionStatement.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/GarbageCollectionStatement.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/GarbageCollectionStatement.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/GarbageCollectionStatement.cpp	2012-01-10 11:12:02.120249367 -0500
@@ -49,7 +49,7 @@ llvm::BasicBlock* PointerGarbageCollecti
     llvm::Value* test = LLVMBackend::CodeGenerator::createStrictInferiorExpression( _currentBlock, countValue, Type::Integer32, LLVMBackend::CodeGenerator::integerToConstant( _generationContext.llvmContext(), INT32_C(1) ), Type::Integer32 );
     llvm::BasicBlock* first = createBlock( _generationContext );
     llvm::BasicBlock* after = createBlock( _generationContext );
-    llvm::BasicBlock* last = LLVMBackend::Visitor::getVisitorFor( m_type )->cleanUp( _generationContext, first, m_pointer, m_type, 0, true, false, true );
+    llvm::BasicBlock* last = LLVMBackend::Visitor::getVisitorFor( m_type )->cleanUp( _generationContext, first, m_pointer, m_type, 0, false, true );
     LLVMBackend::CodeGenerator::createIfStatement( _currentBlock, test, Type::Boolean, first, last, after);
     return after;
   } else {
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/GenerationVisitor.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/GenerationVisitor.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/GenerationVisitor.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/GenerationVisitor.cpp	2012-01-10 11:12:02.120249367 -0500
@@ -59,6 +59,11 @@ ExpressionResultSP GenerationVisitor::ge
   return generateFunctionCall(_function, arguments, _annotation);
 }
 
+const GTLCore::CompilationMessages& GenerationVisitor::compilationMessages() const
+{
+  return d->errorMessages;
+}
+
 void GenerationVisitor::reportError(const GTLCore::String& _message, const Annotation& _annotation)
 {
   d->errorMessages.d->appendMessage( GTLCore::CompilationMessage(GTLCore::CompilationMessage::ERROR, _message, _annotation.line(), _annotation.fileName() ) );
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/GenerationVisitor.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/GenerationVisitor.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/GenerationVisitor.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/GenerationVisitor.h	2012-01-10 11:12:02.120249367 -0500
@@ -30,6 +30,7 @@ namespace GTLCore {
   class String;
   class Type;
   class CompilationMessage;
+  class CompilationMessages;
   namespace AST {
     class Annotation;
     class Expression;
@@ -97,6 +98,8 @@ namespace GTLCore {
         virtual ExpressionResultSP createCompoundValue(std::vector< ExpressionResultSP> arg1, const Type*, const Annotation& _annotation) = 0;
       public:
         ExpressionResultSP generateFunctionCall(GTLCore::Function* _function, const std::list<AST::Expression*>& _arguments, const Annotation& _annotation);
+      public:
+        const GTLCore::CompilationMessages& compilationMessages() const;
       protected:
         /**
          * Call this function to report an error occuring at generation time.
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Statement.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Statement.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Statement.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Statement.cpp	2012-01-10 11:12:02.121249359 -0500
@@ -20,6 +20,7 @@
 #include "Statement.h"
 
 // LLVM
+#include <llvm/ADT/ArrayRef.h>
 #include <llvm/BasicBlock.h>
 #include <llvm/Constants.h>
 #include <llvm/Function.h>
@@ -283,7 +284,7 @@ PrintStatement::~PrintStatement()
 
 llvm::BasicBlock* PrintStatement::generateStatement( LLVMBackend::GenerationContext& _context, llvm::BasicBlock* _bb1 ) const
 {
-  std::vector<const llvm::Type*> params;
+  std::vector<llvm::Type*> params;
   params.push_back( llvm::Type::getInt32Ty(_context.llvmContext()));
   llvm::FunctionType* definitionType = llvm::FunctionType::get( llvm::Type::getVoidTy(_context.llvmContext()), params, true );
   llvm::Function* func = dynamic_cast<llvm::Function*>( _context.llvmModule()->getOrInsertFunction("print", definitionType));
@@ -317,6 +318,6 @@ llvm::BasicBlock* PrintStatement::genera
       GTL_DEBUG("Unknown type for print " << *type);
     }
   }
-  llvm::CallInst::Create(func, values.begin(), values.end(), "", egc.currentBasicBlock());
+  llvm::CallInst::Create(func, values, "", egc.currentBasicBlock());
   return egc.currentBasicBlock();
 }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Statement.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Statement.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Statement.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Statement.h	2012-01-10 11:12:02.121249359 -0500
@@ -73,7 +73,7 @@ namespace GTLCore {
      * @internal
      * @ingroup GTLCore_AST
      */
-    class StatementsList : public Statement {
+    class GTLCORE_EXPORT StatementsList : public Statement {
       public:
         StatementsList( const std::list<Statement*>& list ) : m_list( list) {}
         ~StatementsList();
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Tree.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Tree.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Tree.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Tree.cpp	2012-01-10 11:12:02.121249359 -0500
@@ -21,6 +21,7 @@
 
 #include <llvm/Constant.h>
 #include <llvm/GlobalVariable.h>
+#include <llvm/Type.h>
 
 #include "FunctionDeclaration.h"
 
@@ -36,17 +37,19 @@
 #include "GTLCore/LLVMBackend/Visitor_p.h"
 
 #include "Expression.h"
+#include <llvm/Module.h>
+#include <llvm/DerivedTypes.h>
 
 using namespace GTLCore::AST;
 
-GlobalConstantDeclaration::GlobalConstantDeclaration( const GTLCore::ScopedName& _name, const GTLCore::Type* _type, Expression* _initialiser, bool _dependant) :
-    m_name( _name), m_initialiser(_initialiser), m_variable( new GTLCore::VariableNG( _type, true, _dependant ) ), m_type(_type), m_constant(not _dependant)
+GlobalConstantDeclaration::GlobalConstantDeclaration( const GTLCore::ScopedName& _name, const GTLCore::Type* _type, Expression* _initialiser, bool _dependant, bool _external) :
+    m_name( _name), m_initialiser(_initialiser), m_variable( new GTLCore::VariableNG( _type, true, _dependant ) ), m_type(_type), m_constant(not _dependant), m_external(_external)
 {
   GTL_ASSERT( _initialiser );
 }
 
-GlobalConstantDeclaration::GlobalConstantDeclaration( const GTLCore::ScopedName& _name, const GTLCore::Type* _type, const std::list< int >& sizes, bool _dependant) :
-    m_name( _name), m_initialiser(0), m_variable( new GTLCore::VariableNG( _type, true, _dependant ) ), m_type(_type), m_sizes(sizes), m_constant(not _dependant)
+GlobalConstantDeclaration::GlobalConstantDeclaration( const GTLCore::ScopedName& _name, const GTLCore::Type* _type, const std::list< int >& sizes, bool _dependant, bool _external) :
+    m_name( _name), m_initialiser(0), m_variable( new GTLCore::VariableNG( _type, true, _dependant ) ), m_type(_type), m_sizes(sizes), m_constant(not _dependant), m_external(_external)
 {
 }
 
@@ -60,21 +63,42 @@ GlobalConstantDeclaration::~GlobalConsta
 void GlobalConstantDeclaration::generate( GTLCore::ModuleData* _module, llvm::Module* _llvmModule, LLVMBackend::CodeGenerator* _codeGenerator, llvm::LLVMContext* _llvmContext)
 {
   LLVMBackend::GenerationContext gc( _codeGenerator, _llvmContext, 0, 0, _module, _llvmModule);
+  llvm::Value* pointer = 0;
   
-  llvm::Constant* value = 0;
-  if( m_initialiser )
+  if(m_external)
   {
-    GTL_DEBUG(*m_initialiser->type());
-    LLVMBackend::ExpressionGenerationContext egc(0);
-    value = _codeGenerator->convertConstantTo( m_initialiser->generateValue( gc, egc ).constant(), m_initialiser->type() , m_type );
-    GTL_ASSERT( value );
+    pointer = _llvmModule->getOrInsertGlobal((const std::string&)nameToSymbol(), m_type->d->type(*_llvmContext));
   } else {
-    value = LLVMBackend::Visitor::getVisitorFor( m_type )->createStaticVariable( _llvmModule, m_type, m_sizes );
+    llvm::Constant* value = 0;
+    if( m_initialiser )
+    {
+      GTL_DEBUG(*m_initialiser->type());
+      LLVMBackend::ExpressionGenerationContext egc(0);
+      value = _codeGenerator->convertConstantTo( m_initialiser->generateValue( gc, egc ).constant(), m_initialiser->type() , m_type );
+      GTL_ASSERT( value );
+    } else {
+      value = LLVMBackend::Visitor::getVisitorFor( m_type )->createStaticVariable( _llvmModule, m_type, m_sizes );
+    }
+    pointer = new llvm::GlobalVariable( *_llvmModule, value ? value->getType() : m_type->d->type(*_llvmContext) , m_constant, llvm::GlobalValue::ExternalLinkage, value, (const std::string&)nameToSymbol() );
   }
-  llvm::Value* pointer = new llvm::GlobalVariable( *_llvmModule, value ? value->getType() : m_type->d->type(*_llvmContext) , m_constant, llvm::GlobalValue::InternalLinkage, value, "" );
+  GTL_ASSERT(pointer);
   m_variable->initialise( gc, 0, pointer);
 }
 
+GTLCore::String GlobalConstantDeclaration::nameToSymbol()
+{
+  return nameToSymbol(m_name);
+}
+
+GTLCore::String GlobalConstantDeclaration::nameToSymbol(const GTLCore::ScopedName& name)
+{
+  if(name.nameSpace().isEmpty())
+  {
+    return name.name();
+  } else {
+    return name.nameSpace() + "_" + name.name();
+  }
+}
 
 Tree::Tree()
 {
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Tree.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Tree.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Tree.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/AST/Tree.h	2012-01-10 11:12:02.121249359 -0500
@@ -45,14 +45,23 @@ namespace GTLCore {
      */
     class GTLCORE_EXPORT GlobalConstantDeclaration {
       public:
-        GlobalConstantDeclaration( const GTLCore::ScopedName& _name, const GTLCore::Type* _type, Expression* _initialiser, bool _dependant);
-        GlobalConstantDeclaration( const GTLCore::ScopedName& _name, const GTLCore::Type* _type, const std::list< int >& sizes,bool _dependant);
+        /**
+         * Create an external global constant
+         */
+        GlobalConstantDeclaration( const GTLCore::ScopedName& _name, const GTLCore::Type* _type, Expression* _initialiser, bool _dependant, bool _external);
+        GlobalConstantDeclaration( const GTLCore::ScopedName& _name, const GTLCore::Type* _type, const std::list< int >& sizes,bool _dependant, bool _external);
         ~GlobalConstantDeclaration();
         GTLCore::ScopedName name() const { return m_name; }
         const Expression* initialiser() const { return m_initialiser; }
         Expression* initialiser() { return m_initialiser; }
         GTLCore::VariableNG* variable() { return m_variable; }
+        const GTLCore::Type* type() { return m_type; }
         void generate( ModuleData* _module, llvm::Module* _llvmModule, LLVMBackend::CodeGenerator* _codeGenerator, llvm::LLVMContext* _llvmContext);
+        bool isConstant() const { return m_constant; }
+      private:
+        GTLCore::String nameToSymbol();
+      public:
+        static GTLCore::String nameToSymbol(const GTLCore::ScopedName& name);
       private:
         GTLCore::ScopedName m_name;
         Expression* m_initialiser;
@@ -60,6 +69,7 @@ namespace GTLCore {
         const GTLCore::Type* m_type;
         std::list< int > m_sizes;
         bool m_constant;
+        bool m_external;
     };
     /**
      * @internal
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/BufferImage.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/BufferImage.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/BufferImage.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/BufferImage.cpp	2012-01-10 11:12:02.122249350 -0500
@@ -38,7 +38,7 @@ struct BufferImage::Private
   char* defaultPixel;
 };
 
-BufferImage::BufferImage( int _width, int _height, GTLCore::Buffer* _buffer, const GTLCore::PixelDescription& _pixelDescription ) : AbstractImage(_pixelDescription), d(new Private)
+BufferImage::BufferImage( int _width, int _height, GTLCore::Buffer* _buffer, const GTLCore::PixelDescription& _pixelDescription, const AbstractColorConverter* _colorConverter ) : AbstractImage(_pixelDescription, _colorConverter), d(new Private)
 {
   d->buffer = _buffer;
   d->lineWidth = _width * pixelSize();
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/BufferImage.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/BufferImage.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/BufferImage.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/BufferImage.h	2012-01-10 11:12:02.122249350 -0500
@@ -40,7 +40,7 @@ namespace GTLCore {
        * 
        * It is expected that (_width * _height * _pixelDescription.bitsSize() / 8) == _buffer->size()
        */
-      BufferImage( int _width, int _height, GTLCore::Buffer* _buffer, const GTLCore::PixelDescription& _pixelDescription );
+      BufferImage( int _width, int _height, GTLCore::Buffer* _buffer, const GTLCore::PixelDescription& _pixelDescription, const AbstractColorConverter* _colorConverter = 0 );
       ~BufferImage();
     public:
       virtual char* rawData( int _x, int _y );
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/ChannelMaths.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/ChannelMaths.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/ChannelMaths.cpp.95a8c6853b97	2012-01-10 11:12:02.122249350 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/ChannelMaths.cpp	2012-01-10 11:12:02.122249350 -0500
@@ -0,0 +1,49 @@
+/*
+ *  Copyright (c) 2006 Cyrille Berger <cberger@cberger.bet
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+*/
+
+#include "ChannelMaths.h"
+
+#include <cfloat>
+
+using namespace GTLCore;
+
+#ifdef _HAS_HALF_SUPPORT_
+
+const half ChannelMathsTraits<half>::zeroValue = 0.0;
+const half ChannelMathsTraits<half>::unitValue = 1.0;
+const half ChannelMathsTraits<half>::max = HALF_MAX;
+const half ChannelMathsTraits<half>::min = -HALF_MAX;
+const half ChannelMathsTraits<half>::epsilon = HALF_EPSILON;
+
+#endif
+
+const float ChannelMathsTraits<float>::zeroValue = 0.0;
+const float ChannelMathsTraits<float>::unitValue = 1.0;
+const float ChannelMathsTraits<float>::max = FLT_MAX;
+const float ChannelMathsTraits<float>::min = -FLT_MAX;
+const float ChannelMathsTraits<float>::epsilon = FLT_EPSILON;
+
+const double ChannelMathsTraits<double>::zeroValue = 0.0;
+const double ChannelMathsTraits<double>::unitValue = 1.0;
+const double ChannelMathsTraits<double>::max = DBL_MAX;
+const double ChannelMathsTraits<double>::min = -DBL_MAX;
+const double ChannelMathsTraits<double>::epsilon = DBL_EPSILON;
+
+const GTLCore::FullLut< IntegerToFloat<gtl_uint16>, float, gtl_uint16> GTLCore::Luts::Uint16ToFloat;
+const GTLCore::FullLut< IntegerToFloat<gtl_uint8>, float, gtl_uint8> GTLCore::Luts::Uint8ToFloat;
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/ChannelMaths.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/ChannelMaths.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/ChannelMaths.h.95a8c6853b97	2012-01-10 11:12:02.122249350 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/ChannelMaths.h	2012-01-10 11:12:02.122249350 -0500
@@ -0,0 +1,560 @@
+/*
+ *  Copyright (c) 2006,2007,2010 Cyrille Berger <cberger@cberger.bet
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _GTLCORE_CHANNEL_MATHS_H_
+#define _GTLCORE_CHANNEL_MATHS_H_
+
+#include <cmath>
+
+#include <GTLCore/Export.h>
+#include <GTLCore/IntegersMath.h>
+#include <GTLCore/Lut.h>
+
+#undef _T
+
+namespace GTLCore
+{
+
+  /**
+  * This is an empty shell that needs to be "specialized" for each possible
+  * numerical type (gtl_uint8, gtl_uint16...).
+  *
+  * It needs to defines some static constant fields :
+  * - zeroValue : the zero for this numerical type
+  * - unitValue : the maximum value of the normal dynamic range
+  * - max : the maximum value
+  * - min : the minimum value
+  * - epsilon : a value close to zero but different of zero
+  * - bits : the bit depth
+  *
+  * And some types :
+  * - compositetype the type used for composite operations (usually one with
+  *   a higher bit depth)
+  */
+  template<typename _T>
+  class ChannelMathsTraits
+  {
+  public:
+  };
+
+  template<>
+  class GTLCORE_EXPORT ChannelMathsTraits<gtl_uint8>
+  {
+  public:
+      typedef gtl_int32 compositetype;
+      static const gtl_uint8 zeroValue = 0;
+      static const gtl_uint8 unitValue = 0x00FF;
+      static const gtl_uint8 max = 0x00FF;
+      static const gtl_uint8 min = 0;
+      static const gtl_uint8 epsilon = 1;
+      static const gtl_int8 bits = 8;
+  };
+
+  template<>
+  class GTLCORE_EXPORT ChannelMathsTraits<gtl_uint16>
+  {
+  public:
+      typedef gtl_int64 compositetype;
+      static const gtl_uint16 zeroValue = 0;
+      static const gtl_uint16 unitValue = 0xFFFF;
+      static const gtl_uint16 max = 0xFFFF;
+      static const gtl_uint16 min = 0;
+      static const gtl_uint16 epsilon = 1;
+      static const gtl_int8 bits = 16;
+  };
+
+  template<>
+  class GTLCORE_EXPORT ChannelMathsTraits<gtl_int16>
+  {
+  public:
+      typedef gtl_int64 compositetype;
+      static const gtl_int16 zeroValue = 0;
+      static const gtl_int16 unitValue = 32767;
+      static const gtl_int16 max = 32767;
+      static const gtl_int16 min = -32768;
+      static const gtl_int16 epsilon = 1;
+      static const gtl_int8 bits = 16;
+  };
+
+  template<>
+  class GTLCORE_EXPORT ChannelMathsTraits<gtl_uint32>
+  {
+  public:
+      typedef gtl_int64 compositetype;
+      static const gtl_uint32 zeroValue = 0;
+      static const gtl_uint32 unitValue = 0xFFFFFFFF;
+      static const gtl_uint32 max = 0xFFFFFFFF;
+      static const gtl_uint32 min = 0;
+      static const gtl_uint32 epsilon = 1;
+      static const gtl_int8 bits = 32;
+  };
+
+  
+#ifdef _HAS_HALF_SUPPORT_
+
+  template<>
+  class GTLCORE_EXPORT ChannelMathsTraits<half>
+  {
+  public:
+      typedef double compositetype;
+      static const half zeroValue;
+      static const half unitValue;
+      static const half max;
+      static const half min;
+      static const half epsilon;
+      static const gtl_int8 bits = 16;
+  };
+
+#endif
+  
+  template<>
+  class GTLCORE_EXPORT ChannelMathsTraits<float>
+  {
+  public:
+      typedef double compositetype;
+      static const float zeroValue;
+      static const float unitValue;
+      static const float max;
+      static const float min;
+      static const float epsilon;
+      static const gtl_int8 bits = 32;
+  };
+
+  template<>
+  class GTLCORE_EXPORT ChannelMathsTraits<double>
+  {
+  public:
+      typedef double compositetype;
+      static const double zeroValue;
+      static const double unitValue;
+      static const double max;
+      static const double min;
+      static const double epsilon;
+      static const gtl_int8 bits = 64;
+  };
+
+  #ifdef _MSC_VER
+  // MSVC do not have lrint
+
+  const double _double2fixmagic = 68719476736.0*1.5;
+  const gtl_int32 _shiftamt        = 16;                    //16.16 fixed point representation,
+
+  #if Q_BYTE_ORDER == Q_BIG_ENDIAN
+          #define iexp_                           0
+          #define iman_                           1
+  #else
+          #define iexp_                           1
+          #define iman_                           0
+  #endif //BigEndian_
+
+  inline int float2int(double val)
+  {
+      val = val + _double2fixmagic;
+      return ((int*)&val)[iman_] >> _shiftamt; 
+  }
+
+  inline int float2int(float val)
+  {
+      return float2int((double)val);
+  }
+
+  #else
+
+  inline int float2int(float x)
+  {
+      return lrintf(x);
+  }
+
+  inline int float2int(double x)
+  {
+      return lrint(x);
+  }
+
+  #endif
+
+  template<typename _T_>
+  struct IntegerToFloat {
+    inline float operator()(_T_ f) const
+    {
+      return f / float(ChannelMathsTraits<_T_>::max);
+    }
+  };
+
+  template<typename _T_>
+  struct FloatToInteger {
+    inline _T_ operator()(float f) const
+    {
+      return float2int(f * ChannelMathsTraits<_T_>::max);
+    }
+  };
+
+  struct Luts {
+
+    static GTLCORE_EXPORT const FullLut< IntegerToFloat<gtl_uint16>, float, gtl_uint16> Uint16ToFloat;
+    static GTLCORE_EXPORT const FullLut< IntegerToFloat<gtl_uint8>, float, gtl_uint8> Uint8ToFloat;
+  };
+  /**
+   * Convert a channel from a gamma color space, to a linear.
+   */
+ template<typename _T_>
+  struct GammaToLinearFloat {
+    inline GammaToLinearFloat(double _gamma) : m_gamma(_gamma)
+    {
+    }
+    inline _T_ operator()(_T_ v) const
+    {
+      if (v < 0.03928) return v / 12.92;
+      return std::pow (double((v + 0.055) / 1.055), double(m_gamma));
+    }
+  private:
+    double m_gamma;
+  };
+  /**
+   * Convert a channel from a linear color space, to one with gamma.
+   */
+  template<typename _T_>
+  struct LinearToGammaFloat {
+    inline LinearToGammaFloat(double _gamma) : m_gamma(_gamma)
+    {
+    }
+    inline _T_ operator()(_T_ v) const
+    {
+      if( v < 0.00304 ) return 12.92 * v;
+      else return 1.055 * pow (double(v), (1.0/m_gamma)) - 0.055;
+    }
+  private:
+    double m_gamma;
+  };
+  
+  template<typename _TOutput_, typename _TInput_, typename _T1_, typename _T2_>
+  struct CombinedOperation {
+    CombinedOperation(const _T1_& op1, const _T2_& op2) : m_op1(op1), m_op2(op2)
+    {
+    }
+    inline _TOutput_ operator()(_TInput_ v) const
+    {
+      return m_op2(m_op1(v));
+    }
+  private:
+    _T1_ m_op1;
+    _T2_ m_op2;
+  };
+  
+  
+  /**
+  * This class defines some elementary operations used by various color
+  * space. It's intended to be generic, but some specialization exists
+  * either for optimization or just for being buildable.
+  *
+  * @param _T some numerical type with an existing trait
+  * @param _Tdst some other numerical type with an existing trait, it is
+  *              only needed if different of _T
+  */
+  template < typename _T, typename _Tdst = _T >
+  class ChannelMaths
+  {
+      typedef ChannelMathsTraits<_T> traits;
+      typedef typename traits::compositetype traits_compositetype;
+  public:
+      inline static traits_compositetype multiply(traits_compositetype a,
+              typename  ChannelMathsTraits<_Tdst>::compositetype b) {
+          return ((traits_compositetype)a * b) /  ChannelMathsTraits<_Tdst>::unitValue;
+      }
+      
+      inline static traits_compositetype multiply(traits_compositetype a,
+              typename  ChannelMathsTraits<_Tdst>::compositetype b,
+              typename  ChannelMathsTraits<_Tdst>::compositetype c) {
+          return ((traits_compositetype)a * b * c) / (ChannelMathsTraits<_Tdst>::unitValue * ChannelMathsTraits<_Tdst>::unitValue);
+      }
+
+      /**
+      * Division : (a * MAX ) / b
+      * @param a
+      * @param b
+      */
+      inline static _T divide(_T a, _Tdst b) {
+          return ((traits_compositetype)a *  ChannelMathsTraits<_Tdst>::unitValue) / b;
+      }
+
+      /**
+      * Blending : (a * alpha) + b * (1 - alpha)
+      * @param a
+      * @param b
+      * @param alpha
+      */
+      inline static _T blend(_T a, _T b, _T alpha) {
+          traits_compositetype c = (((traits_compositetype)a - (traits_compositetype)b) * alpha) / traits::unitValue;
+          return c + b;
+      }
+
+      /**
+      * This function will scale a value of type _T to fit into a _Tdst.
+      */
+      inline static _Tdst scaleToA(_T a) {
+          return (traits_compositetype)a >> (traits::bits - ChannelMathsTraits<_Tdst>::bits);
+      }
+
+      inline static typename  ChannelMathsTraits<_Tdst>::compositetype clamp(typename  ChannelMathsTraits<_Tdst>::compositetype val) {
+          return qBound((typename  ChannelMathsTraits<_Tdst>::compositetype) ChannelMathsTraits<_Tdst>::min,
+                        val,
+                        (typename  ChannelMathsTraits<_Tdst>::compositetype)ChannelMathsTraits<_Tdst>::max);
+      }
+  };
+
+  //------------------------------ double specialization ------------------------------//
+  template<>
+  inline gtl_uint8 ChannelMaths<double, gtl_uint8>::scaleToA(double a)
+  {
+      double v = a * 255;
+      return float2int(bound(0.0, v, 255));
+  }
+
+  template<>
+  inline double ChannelMaths<gtl_uint8, double>::scaleToA(gtl_uint8 a)
+  {
+      return Luts::Uint8ToFloat(a);
+  }
+
+  template<>
+  inline gtl_uint16 ChannelMaths<double, gtl_uint16>::scaleToA(double a)
+  {
+      double v = a * 0xFFFF;
+      return float2int(bound(0, v, 0xFFFF));
+  }
+
+  template<>
+  inline double ChannelMaths<gtl_uint16, double>::scaleToA(gtl_uint16 a)
+  {
+      return Luts::Uint16ToFloat(a);
+  }
+
+  template<>
+  inline double ChannelMaths<double>::clamp(double a)
+  {
+      return a;
+  }
+
+  //------------------------------ float specialization ------------------------------//
+
+  template<>
+  inline float ChannelMaths<double, float>::scaleToA(double a)
+  {
+      return (float)a;
+  }
+
+  template<>
+  inline double ChannelMaths<float, double>::scaleToA(float a)
+  {
+      return a;
+  }
+
+  template<>
+  inline gtl_uint16 ChannelMaths<float, gtl_uint16>::scaleToA(float a)
+  {
+      float v = a * 0xFFFF;
+      return (gtl_uint16)float2int(bound( 0, v, 0xFFFF));
+  }
+
+  template<>
+  inline float ChannelMaths<gtl_uint16, float>::scaleToA(gtl_uint16 a)
+  {
+      return Luts::Uint16ToFloat(a);
+  }
+
+  template<>
+  inline gtl_uint8 ChannelMaths<float, gtl_uint8>::scaleToA(float a)
+  {
+      float v = a * 255;
+      return (gtl_uint8)float2int(bound(0, v, 255));
+  }
+
+  template<>
+  inline float ChannelMaths<gtl_uint8, float>::scaleToA(gtl_uint8 a)
+  {
+      return Luts::Uint8ToFloat(a);
+  }
+
+  template<>
+  inline float ChannelMaths<float>::blend(float a, float b, float alpha)
+  {
+      return (a - b) * alpha + b;
+  }
+
+  template<>
+  inline double ChannelMaths<float>::clamp(double a)
+  {
+      return a;
+  }
+
+  //------------------------------ half specialization ------------------------------//
+
+#ifdef _HAS_HALF_SUPPORT_
+
+  template<>
+  inline half ChannelMaths<double, half>::scaleToA(double a)
+  {
+      return (half)a;
+  }
+
+  template<>
+  inline double ChannelMaths<half, double>::scaleToA(half a)
+  {
+      return a;
+  }
+
+  template<>
+  inline float ChannelMaths<half, float>::scaleToA(half a)
+  {
+      return a;
+  }
+
+  template<>
+  inline half ChannelMaths<float, half>::scaleToA(float a)
+  {
+      return (half) a;
+  }
+
+  template<>
+  inline gtl_uint8 ChannelMaths<half, gtl_uint8>::scaleToA(half a)
+  {
+      half v = a * 255;
+      return (gtl_uint8)(CLAMP(v, 0, 255));
+  }
+
+  template<>
+  inline half ChannelMaths<gtl_uint8, half>::scaleToA(gtl_uint8 a)
+  {
+      return a *(1.0 / 255.0);
+  }
+  template<>
+  inline gtl_uint16 ChannelMaths<half, gtl_uint16>::scaleToA(half a)
+  {
+      double v = a * 0xFFFF;
+      return (gtl_uint16)(CLAMP(v, 0, 0xFFFF));
+  }
+
+  template<>
+  inline half ChannelMaths<gtl_uint16, half>::scaleToA(gtl_uint16 a)
+  {
+      return a *(1.0 / 0xFFFF);
+  }
+
+  template<>
+  inline half ChannelMaths<half, half>::scaleToA(half a)
+  {
+      return a;
+  }
+
+  template<>
+  inline half ChannelMaths<half>::blend(half a, half b, half alpha)
+  {
+      return (a - b) * alpha + b;
+  }
+
+  template<>
+  inline double ChannelMaths<half>::clamp(double a)
+  {
+      return a;
+  }
+
+
+#endif
+
+  //------------------------------ gtl_uint8 specialization ------------------------------//
+
+  template<>
+  inline gtl_int32 ChannelMaths<gtl_uint8>::multiply(gtl_int32 a, gtl_int32 b)
+  {
+      return UINT8_MULT(a, b);
+  }
+
+
+  template<>
+  inline gtl_int32 ChannelMaths<gtl_uint8>::multiply(gtl_int32 a, gtl_int32 b, gtl_int32 c)
+  {
+      return UINT8_MULT3(a, b, c);
+  }
+
+  template<>
+  inline gtl_uint8 ChannelMaths<gtl_uint8>::divide(gtl_uint8 a, gtl_uint8 b)
+  {
+      return UINT8_DIVIDE(a, b);
+  }
+
+  template<>
+  inline gtl_uint8 ChannelMaths<gtl_uint8>::blend(gtl_uint8 a, gtl_uint8 b, gtl_uint8 c)
+  {
+      return UINT8_BLEND(a, b, c);
+  }
+
+  //------------------------------ gtl_uint16 specialization ------------------------------//
+
+  template<>
+  inline gtl_int64 ChannelMaths<gtl_uint16>::multiply(gtl_int64 a, gtl_int64 b)
+  {
+      return UINT16_MULT(a, b);
+  }
+
+  template<>
+  inline gtl_uint16 ChannelMaths<gtl_uint16>::divide(gtl_uint16 a, gtl_uint16 b)
+  {
+      return UINT16_DIVIDE(a, b);
+  }
+
+  //------------------------------ various specialization ------------------------------//
+
+
+  // TODO: use more functions from KoIntegersMaths to do the computation
+
+  /// This specialization is needed because the default implementation won't work when scaling up
+  template<>
+  inline gtl_uint16 ChannelMaths<gtl_uint8, gtl_uint16>::scaleToA(gtl_uint8 a)
+  {
+      return UINT8_TO_UINT16(a);
+  }
+
+  template<>
+  inline gtl_uint8 ChannelMaths<gtl_uint16, gtl_uint8>::scaleToA(gtl_uint16 a)
+  {
+      return UINT16_TO_UINT8(a);
+  }
+
+
+  // Due to once again a bug in gcc, there is the need for those specialized functions:
+
+  template<>
+  inline gtl_uint8 ChannelMaths<gtl_uint8, gtl_uint8>::scaleToA(gtl_uint8 a)
+  {
+      return a;
+  }
+
+  template<>
+  inline gtl_uint16 ChannelMaths<gtl_uint16, gtl_uint16>::scaleToA(gtl_uint16 a)
+  {
+      return a;
+  }
+
+  template<>
+  inline float ChannelMaths<float, float>::scaleToA(float a)
+  {
+      return a;
+  }
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/CMakeLists.txt.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/CMakeLists.txt	2012-01-10 11:12:02.122249350 -0500
@@ -42,6 +42,7 @@ configure_file(Macros.h.cmake ${CMAKE_CU
 ## GTLCore library ##
 
 set(GTLCore_SRCS
+  AbstractColorConverter.cpp
   AbstractImage.cpp
   Array.cpp
   Buffer.cpp
@@ -49,6 +50,7 @@ set(GTLCore_SRCS
   Debug.cpp
   ChannelsFlags.cpp
   Color.cpp
+  ColorConverters.cpp
   CompilationMessage.cpp
   CompilationMessages.cpp
   Function.cpp
@@ -62,8 +64,10 @@ set(GTLCore_SRCS
   Type.cpp
   TypesManager.cpp
   Value.cpp
+  Value_p.cpp
   Version.cpp
 # Internal files
+  ChannelMaths.cpp
   CompilerBase_p.cpp
   ConvertCenter_p.cpp
   ErrorMessages_p.cpp
@@ -73,6 +77,7 @@ set(GTLCore_SRCS
   LexerBase_p.cpp
   MemoryManager_p.cpp
   ModuleData_p.cpp
+  OperatorOverloadCenter_p.cpp
   ParserBase_p.cpp
   SharedPointer.cpp
   Token_p.cpp
@@ -114,6 +119,10 @@ set(GTLCore_SRCS
   Metadata/TextEntry.cpp
   Metadata/ValueEntry.cpp
   Metadata/Factory_p.cpp
+# TimeMachine
+  TimeController.cpp
+  TimeMachine.cpp
+  TimeValue_p.cpp
 # wrappers
   wrappers/Allocate.cpp
   wrappers/ProgressReportWrap.cpp
@@ -126,9 +135,9 @@ set(GTLCore_SRCS
 add_library(GTLCore SHARED ${GTLCore_SRCS} ${llvm_objects})
 
 if(NOT MSVC AND NOT APPLE)
-set(EXTRA_GTLCORE_LINK_OPTIONS -Wl,-u,_ZN4llvm15ExecutionEngine9createJITEPNS_6ModuleEPSsPNS_16JITMemoryManagerENS_10CodeGenOpt5LevelEbNS_9CodeModel5ModelE )
+set(EXTRA_GTLCORE_LINK_OPTIONS -Wl,-u,_ZTVN4llvm3JITE )
 elseif(APPLE)
-set(EXTRA_GTLCORE_LINK_OPTIONS -Wl,-u,__ZN4llvm15ExecutionEngine9createJITEPNS_6ModuleEPSsPNS_16JITMemoryManagerENS_10CodeGenOpt5LevelEbNS_9CodeModel5ModelE )
+set(EXTRA_GTLCORE_LINK_OPTIONS -Wl,-u,__ZTVN4llvm3JITE )
 endif()
 
 target_link_libraries(GTLCore ${LLVM_LDFLAGS} ${LLVM_LIBS} ${EXTRA_GTLCORE_LINK_OPTIONS})
@@ -163,6 +172,8 @@ install( FILES
   ScopedName.h
   StdTypes.h
   String.h
+  TimeController.h
+  TimeMachine.h
   Transform.h
   Type.h
   TypesManager.h
@@ -170,7 +181,12 @@ install( FILES
   Version.h
   DESTINATION ${INCLUDE_INSTALL_DIR}/GTLCore )
 
-install( FILES Metadata/ParameterEntry.h Metadata/Entry.h Metadata/Group.h Metadata/TextEntry.h DESTINATION ${INCLUDE_INSTALL_DIR}/GTLCore/Metadata )
+install( FILES
+  Metadata/ParameterEntry.h
+  Metadata/Entry.h
+  Metadata/Group.h
+  Metadata/TextEntry.h
+  DESTINATION ${INCLUDE_INSTALL_DIR}/GTLCore/Metadata )
 
 # Create and install pc file
 configure_file("GTLCore.pc.cmake" "${CMAKE_CURRENT_BINARY_DIR}/GTLCore.pc" @ONLY)
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/ColorConverters.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/ColorConverters.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/ColorConverters.cpp.95a8c6853b97	2012-01-10 11:12:02.123249341 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/ColorConverters.cpp	2012-01-10 11:12:02.123249341 -0500
@@ -0,0 +1,295 @@
+/*
+ *  Copyright (c) 2011 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "ColorConverters.h"
+
+#include "Macros_p.h"
+#include "PixelDescription.h"
+#include "Type.h"
+
+#include "RgbColorConverter_p.h"
+#include "GrayColorConverter_p.h"
+#include "AbstractColorConverter_p.h"
+
+
+using namespace GTLCore;
+
+struct ColorConverters::Private
+{
+  Private() : sgrayaU8ColorConverterInstance(0), sgrayU8ColorConverterInstance(0),
+              sgrayaU16ColorConverterInstance(0), sgrayU16ColorConverterInstance(0),
+              sgrayaF32ColorConverterInstance(0), sgrayF32ColorConverterInstance(0),
+              srgbaU8ColorConverterInstance(0), srgbU8ColorConverterInstance(0),
+              srgbaU16ColorConverterInstance(0), srgbU16ColorConverterInstance(0),
+              srgbaF32ColorConverterInstance(0), srgbF32ColorConverterInstance(0)
+  {
+  }
+  ~Private()
+  {
+    delete sgrayaU8ColorConverterInstance;
+    delete sgrayU8ColorConverterInstance;
+    delete sgrayaU16ColorConverterInstance;
+    delete sgrayU16ColorConverterInstance;
+    delete sgrayaF32ColorConverterInstance;
+    delete sgrayF32ColorConverterInstance;
+    
+    delete srgbaU8ColorConverterInstance;
+    delete srgbU8ColorConverterInstance;
+    delete srgbaU16ColorConverterInstance;
+    delete srgbU16ColorConverterInstance;
+    delete srgbaF32ColorConverterInstance;
+    delete srgbF32ColorConverterInstance;
+  }
+  
+  GrayColorConverter<gtl_uint8, true>* sgrayaU8ColorConverterInstance;
+  GrayColorConverter<gtl_uint8, false>* sgrayU8ColorConverterInstance;
+  GrayColorConverter<gtl_uint16, true>* sgrayaU16ColorConverterInstance;
+  GrayColorConverter<gtl_uint16, false>* sgrayU16ColorConverterInstance;
+  GrayColorConverter<float, true>* sgrayaF32ColorConverterInstance;
+  GrayColorConverter<float, false>* sgrayF32ColorConverterInstance;
+
+  RgbColorConverter<gtl_uint8, true>* srgbaU8ColorConverterInstance;
+  RgbColorConverter<gtl_uint8, false>* srgbU8ColorConverterInstance;
+  RgbColorConverter<gtl_uint16, true>* srgbaU16ColorConverterInstance;
+  RgbColorConverter<gtl_uint16, false>* srgbU16ColorConverterInstance;
+  RgbColorConverter<float, true>* srgbaF32ColorConverterInstance;
+  RgbColorConverter<float, false>* srgbF32ColorConverterInstance;
+
+};
+
+STATIC_POINTER(ColorConverters, s_instance);
+
+ColorConverters::ColorConverters() : d(new Private)
+{
+
+}
+
+ColorConverters::~ColorConverters()
+{
+  delete d;
+}
+
+
+const ColorConverters* ColorConverters::instance()
+{
+  if( not s_instance )
+  {
+    s_instance = new ColorConverters;
+  }
+  return s_instance;
+}
+
+const AbstractColorConverter* ColorConverters::guess(const GTLCore::PixelDescription& _pixelDescription) const
+{
+  if(_pixelDescription.hasSameTypeChannels())
+  {
+    return guess(_pixelDescription.channelTypes()[0], _pixelDescription.channels());
+  } else {
+    return 0;
+  }
+}
+
+const AbstractColorConverter* ColorConverters::guess(const GTLCore::Type* _type, int _channels) const
+{
+  GTLCore::Type::DataType dt = _type->dataType();
+  switch(_channels)
+  {
+    case 1:
+    {
+      switch(dt)
+      {
+        case Type::UNSIGNED_INTEGER8:
+          return sGrayU8();
+        case Type::UNSIGNED_INTEGER16:
+          return sGrayU16();
+        case Type::FLOAT32:
+          return sGrayF32();
+        default:
+          break;
+      }
+    }
+    case 2:
+    {
+      switch(dt)
+      {
+        case Type::UNSIGNED_INTEGER8:
+          return sGrayaU8();
+        case Type::UNSIGNED_INTEGER16:
+          return sGrayaU16();
+        case Type::FLOAT32:
+          return sGrayaF32();
+        default:
+          break;
+      }
+    }
+    case 3:
+    {
+      switch(dt)
+      {
+        case Type::UNSIGNED_INTEGER8:
+          return sRgbU8();
+        case Type::UNSIGNED_INTEGER16:
+          return sRgbU16();
+        case Type::FLOAT32:
+          return sRgbF32();
+        default:
+          break;
+      }
+    }
+    case 4:
+    {
+      switch(dt)
+      {
+        case Type::UNSIGNED_INTEGER8:
+          return sRgbaU8();
+        case Type::UNSIGNED_INTEGER16:
+          return sRgbaU16();
+        case Type::FLOAT32:
+          return sRgbaF32();
+        default:
+          break;
+      }
+    }
+    default:
+      break;
+  }
+  return 0;
+}
+
+const AbstractColorConverter* ColorConverters::sGrayaU8() const
+{
+  if(d->sgrayaU8ColorConverterInstance == 0)
+  {
+    d->sgrayaU8ColorConverterInstance = new GrayColorConverter<gtl_uint8, true>(2.2, PixelDescription(Type::UnsignedInteger8, 2, 1) );
+    d->sgrayaU8ColorConverterInstance->d->deletable = false;
+  }
+  return d->sgrayaU8ColorConverterInstance;
+}
+
+const AbstractColorConverter* ColorConverters::sGrayU8() const
+{
+  if(d->sgrayU8ColorConverterInstance == 0)
+  {
+    d->sgrayU8ColorConverterInstance = new GrayColorConverter<gtl_uint8, false>(2.2, PixelDescription(Type::UnsignedInteger8, 1) );
+    d->sgrayU8ColorConverterInstance->d->deletable = false;
+  }
+  return d->sgrayU8ColorConverterInstance;
+}
+
+const AbstractColorConverter* ColorConverters::sGrayaU16() const
+{
+  if(d->sgrayaU16ColorConverterInstance == 0)
+  {
+    d->sgrayaU16ColorConverterInstance = new GrayColorConverter<gtl_uint16, true>(2.2, PixelDescription(Type::UnsignedInteger16, 2, 1) );
+    d->sgrayaU16ColorConverterInstance->d->deletable = false;
+  }
+  return d->sgrayaU16ColorConverterInstance;
+}
+
+const AbstractColorConverter* ColorConverters::sGrayU16() const
+{
+  if(d->sgrayU16ColorConverterInstance == 0)
+  {
+    d->sgrayU16ColorConverterInstance = new GrayColorConverter<gtl_uint16, false>(2.2, PixelDescription(Type::UnsignedInteger16, 1) );
+    d->sgrayU16ColorConverterInstance->d->deletable = false;
+  }
+  return d->sgrayU16ColorConverterInstance;
+}
+
+const AbstractColorConverter* ColorConverters::sGrayaF32() const
+{
+  if(d->sgrayaF32ColorConverterInstance == 0)
+  {
+    d->sgrayaF32ColorConverterInstance = new GrayColorConverter<float, true>(2.2, PixelDescription(Type::UnsignedInteger16, 2, 1) );
+    d->sgrayaF32ColorConverterInstance->d->deletable = false;
+  }
+  return d->sgrayaF32ColorConverterInstance;
+}
+
+const AbstractColorConverter* ColorConverters::sGrayF32() const
+{
+  if(d->sgrayF32ColorConverterInstance == 0)
+  {
+    d->sgrayF32ColorConverterInstance = new GrayColorConverter<float, false>(2.2, PixelDescription(Type::UnsignedInteger16, 1) );
+    d->sgrayF32ColorConverterInstance->d->deletable = false;
+  }
+  return d->sgrayF32ColorConverterInstance;
+}
+
+const AbstractColorConverter* ColorConverters::sRgbaU8() const
+{
+  if(d->srgbaU8ColorConverterInstance == 0)
+  {
+    d->srgbaU8ColorConverterInstance = new RgbColorConverter<gtl_uint8, true>(2.2, PixelDescription(Type::UnsignedInteger8, 4, 3) );
+    d->srgbaU8ColorConverterInstance->d->deletable = false;
+  }
+  return d->srgbaU8ColorConverterInstance;
+}
+
+const AbstractColorConverter* ColorConverters::sRgbU8() const
+{
+  if(d->srgbU8ColorConverterInstance == 0)
+  {
+    d->srgbU8ColorConverterInstance = new RgbColorConverter<gtl_uint8, false>(2.2, PixelDescription(Type::UnsignedInteger8, 3) );
+    d->srgbU8ColorConverterInstance->d->deletable = false;
+  }
+  return d->srgbU8ColorConverterInstance;
+}
+
+const AbstractColorConverter* ColorConverters::sRgbaU16() const
+{
+  if(d->srgbaU16ColorConverterInstance == 0)
+  {
+    d->srgbaU16ColorConverterInstance = new RgbColorConverter<gtl_uint16, true>(2.2, PixelDescription(Type::UnsignedInteger16, 4, 3) );
+    d->srgbaU16ColorConverterInstance->d->deletable = false;
+  }
+  return d->srgbaU16ColorConverterInstance;
+}
+
+const AbstractColorConverter* ColorConverters::sRgbU16() const
+{
+  if(d->srgbU16ColorConverterInstance == 0)
+  {
+    d->srgbU16ColorConverterInstance = new RgbColorConverter<gtl_uint16, false>(2.2, PixelDescription(Type::UnsignedInteger16, 3) );
+    d->srgbU16ColorConverterInstance->d->deletable = false;
+  }
+  return d->srgbU16ColorConverterInstance;
+}
+
+const AbstractColorConverter* ColorConverters::sRgbaF32() const
+{
+  if(d->srgbaF32ColorConverterInstance == 0)
+  {
+    d->srgbaF32ColorConverterInstance = new RgbColorConverter<float, true>(2.2, PixelDescription(Type::UnsignedInteger16, 4, 3) );
+    d->srgbaF32ColorConverterInstance->d->deletable = false;
+  }
+  return d->srgbaF32ColorConverterInstance;
+}
+
+const AbstractColorConverter* ColorConverters::sRgbF32() const
+{
+  if(d->srgbF32ColorConverterInstance == 0)
+  {
+    d->srgbF32ColorConverterInstance = new RgbColorConverter<float, false>(2.2, PixelDescription(Type::UnsignedInteger16, 3) );
+    d->srgbF32ColorConverterInstance->d->deletable = false;
+  }
+  return d->srgbF32ColorConverterInstance;
+}
+
+
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/ColorConverters.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/ColorConverters.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/ColorConverters.h.95a8c6853b97	2012-01-10 11:12:02.123249341 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/ColorConverters.h	2012-01-10 11:12:02.123249341 -0500
@@ -0,0 +1,73 @@
+/*
+ *  Copyright (c) 2011 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLCORE_COLOR_CONVERTERS_H_
+#define _GTLCORE_COLOR_CONVERTERS_H_
+
+#include <GTLCore/Export.h>
+
+namespace {
+  class StaticPointerColorConverters;
+}
+
+namespace GTLCore {
+  class PixelDescription;
+  class Type;
+
+  class AbstractColorConverter;
+  class GTLCORE_EXPORT ColorConverters {
+    friend class ::StaticPointerColorConverters;
+    ColorConverters();
+    ~ColorConverters();
+  public:
+    
+    static const ColorConverters* instance();
+    
+    /**
+     * Try to guess what type color converter to use. Only works if all the channels have the same type.
+     * Otherwise return 0.
+     */
+    const AbstractColorConverter* guess(const GTLCore::PixelDescription& _pixelDescription) const;
+    /**
+     * If _channels == 1 assumes Gray
+     * If _channels == 2 assumes Gray + Alpha
+     * If _channels == 3 assumes Rgb
+     * If _channels == 4 assumes Rgb + Alpha
+     */
+    const AbstractColorConverter* guess(const GTLCore::Type* _type, int _channels) const;
+    
+    const AbstractColorConverter* sGrayaU8() const;
+    const AbstractColorConverter* sGrayU8() const;
+    const AbstractColorConverter* sGrayaU16() const;
+    const AbstractColorConverter* sGrayU16() const;
+    const AbstractColorConverter* sGrayaF32() const;
+    const AbstractColorConverter* sGrayF32() const;
+    const AbstractColorConverter* sRgbaU8() const;
+    const AbstractColorConverter* sRgbU8() const;
+    const AbstractColorConverter* sRgbaU16() const;
+    const AbstractColorConverter* sRgbU16() const;
+    const AbstractColorConverter* sRgbaF32() const;
+    const AbstractColorConverter* sRgbF32() const;
+  private:
+    struct Private;
+    Private* const d;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Color.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Color.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Color.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Color.cpp	2012-01-10 11:12:02.123249341 -0500
@@ -20,33 +20,34 @@
 #include "Color.h"
 
 #include "Debug.h"
+#include "RgbaF.h"
 #include "SharedPointer.h"
 
 using namespace GTLCore;
 
 struct Color::Private : public SharedPointerData {
   Private() {}
-  Private(const Private& _rhs) : SharedPointerData(), r(_rhs.r), g(_rhs.g), b(_rhs.b), a(_rhs.a)
+  Private(const Private& _rhs) : SharedPointerData(), rgbaf(_rhs.rgbaf)
   {}
-  float r, g, b, a;
+  RgbaF rgbaf;
 };
 
 Color::Color() : d(new Private)
 {
   d->ref();
-  d->r = 0.0;
-  d->g = 0.0;
-  d->b = 0.0;
-  d->a = 0.0;
+  d->rgbaf.r = 0.0;
+  d->rgbaf.g = 0.0;
+  d->rgbaf.b = 0.0;
+  d->rgbaf.a = 0.0;
 }
 
 Color::Color(float r, float g, float b, float a) : d(new Private)
 {
   d->ref();
-  d->r = r;
-  d->g = g;
-  d->b = b;
-  d->a = a;
+  d->rgbaf.r = r;
+  d->rgbaf.g = g;
+  d->rgbaf.b = b;
+  d->rgbaf.a = a;
 }
 
 GTL_SHARED_DATA(Color)
@@ -54,49 +55,54 @@ GTL_SHARED_DATA(Color)
 bool Color::operator==(const Color& c)
 {
   if (d == c.d) return true;
-  return d->r == c.d->r and d->g == c.d->g and d->b == c.d->b and d->a == c.d->a;
+  return d->rgbaf.r == c.d->rgbaf.r and d->rgbaf.g == c.d->rgbaf.g and d->rgbaf.b == c.d->rgbaf.b and d->rgbaf.a == c.d->rgbaf.a;
 }
 
 float Color::red() const
 {
-  return d->r;
+  return d->rgbaf.r;
 }
 
 float Color::green() const
 {
-  return d->g;
+  return d->rgbaf.g;
 }
 
 float Color::blue() const
 {
-  return d->b;
+  return d->rgbaf.b;
 }
 
 float Color::alpha() const
 {
-  return d->a;
+  return d->rgbaf.a;
 }
 
 void Color::setRed(float r)
 {
   deref();
-  d->r = r;
+  d->rgbaf.r = r;
 }
 
 void Color::setGreen(float r)
 {
   deref();
-  d->g = r;
+  d->rgbaf.g = r;
 }
 
 void Color::setBlue(float r)
 {
   deref();
-  d->b = r;
+  d->rgbaf.b = r;
 }
 
 void Color::setAlpha(float r)
 {
   deref();
-  d->a = r;
+  d->rgbaf.a = r;
+}
+
+const RgbaF& Color::rgbaf() const
+{
+  return d->rgbaf;
 }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Color.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Color.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Color.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Color.h	2012-01-10 11:12:02.123249341 -0500
@@ -23,6 +23,7 @@
 #include <GTLCore/Export.h>
 
 namespace GTLCore {
+  struct RgbaF;
   class GTLCORE_EXPORT Color {
     public:
       Color();
@@ -39,6 +40,7 @@ namespace GTLCore {
       void setGreen(float r);
       void setBlue(float r);
       void setAlpha(float r);
+      const RgbaF& rgbaf() const;
     private:
       void deref();
       struct Private;
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/CompilationMessages.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/CompilationMessages.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/CompilationMessages.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/CompilationMessages.cpp	2012-01-10 11:12:02.123249341 -0500
@@ -59,7 +59,7 @@ const std::list<CompilationMessage>& Com
 
 const std::list<CompilationMessage>& CompilationMessages::messages() const
 {
-  return d->warnings;
+  return d->messages;
 }
 
 void CompilationMessages::Private::appendMessage(const CompilationMessage& _message)
@@ -91,5 +91,6 @@ GTLCore::String CompilationMessages::toS
     }
     os <<  msg.fileName() << " at " << msg.line() << " : " << msg.message()  << std::endl;
   }
+  os << "There are " << d->errors.size() << " errors and " << d->warnings.size() << " warnings" << std::endl;
   return os.str();
 }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/CompilationMessages_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/CompilationMessages_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/CompilationMessages_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/CompilationMessages_p.h	2012-01-10 11:12:02.123249341 -0500
@@ -21,9 +21,11 @@
 
 namespace GTLCore {
   struct CompilationMessages::Private {
+    friend class CompilationMessages;
+    GTLCORE_EXPORT void appendMessage(const CompilationMessage& _message);
+  private:
     std::list<CompilationMessage> errors;
     std::list<CompilationMessage> warnings;
     std::list<CompilationMessage> messages;
-    GTLCORE_EXPORT void appendMessage(const CompilationMessage& _message);
   };
 }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/CompilerBase_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/CompilerBase_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/CompilerBase_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/CompilerBase_p.cpp	2012-01-10 11:12:02.124249333 -0500
@@ -34,6 +34,7 @@
 #include <cstdarg>
 #include "CompilationMessages.h"
 #include "CompilationMessages_p.h"
+#include "OperatorOverloadCenter_p.h"
 
 using namespace GTLCore;
 
@@ -43,6 +44,7 @@ struct CompilerBase::Private {
   std::map< GTLCore::ScopedName, std::list< GTLCore::Function* > > functions;
   std::list<GTLCore::Function*> functionsToDelete;
   ConvertCenter* convertCenter;
+  OperatorOverloadCenter* operatorOverloadCenter;
   ModuleData* moduleData;
   llvm::Module* llvmModule;
 };
@@ -50,10 +52,12 @@ struct CompilerBase::Private {
 CompilerBase::CompilerBase() : d(new Private)
 {
   d->convertCenter = new ConvertCenter;
+  d->operatorOverloadCenter = new OperatorOverloadCenter;
 }
 CompilerBase::~CompilerBase()
 {
   delete d->convertCenter;
+  delete d->operatorOverloadCenter;
   delete d;
 }
 
@@ -159,11 +163,21 @@ bool CompilerBase::declareFunction( cons
     return true;
 }
 
+bool CompilerBase::declareConstant( const GTLCore::ScopedName& _name, const GTLCore::Type* _type, const GTLCore::Value& _value)
+{
+  return d->moduleData->appendConstant(_name, _type, _value);
+}
+
 ConvertCenter* CompilerBase::convertCenter()
 {
   return d->convertCenter;
 }
 
+OperatorOverloadCenter* CompilerBase::operatorOverloadCenter()
+{
+  return d->operatorOverloadCenter;
+}
+
 std::list<GTLCore::Function*>& CompilerBase::functionsToDelete()
 {
   return d->functionsToDelete;
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/CompilerBase_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/CompilerBase_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/CompilerBase_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/CompilerBase_p.h	2012-01-10 11:12:02.124249333 -0500
@@ -29,6 +29,9 @@ namespace llvm {
 }
 
 namespace GTLCore {
+
+class OperatorOverloadCenter;
+
   class ConvertCenter;
   class CompilationMessage;
   class CompilationMessages;
@@ -37,6 +40,7 @@ namespace GTLCore {
   class TypesManager;
   class Type;
   class ModuleData;
+  class Value;
   namespace AST {
     class Expression;
   }
@@ -55,9 +59,11 @@ namespace GTLCore {
        * Append the error and delete the message.
        */
       void appendError( GTLCore::CompilationMessage* );
+      void appendErrors( const std::list<GTLCore::CompilationMessage>& _msgs);
       const CompilationMessages& errorMessages() const;
       const std::list<GTLCore::Function*>* function( const GTLCore::ScopedName&  );
       bool declareFunction( const GTLCore::ScopedName&, GTLCore::Function*);
+      bool declareConstant( const GTLCore::ScopedName& _name, const GTLCore::Type* _type, const GTLCore::Value& _value);
       /**
        * 
        * @return the type manager used for compilation
@@ -67,10 +73,13 @@ namespace GTLCore {
        * @return the \ref ConvertCenter used for compilation
        */
       ConvertCenter* convertCenter();
+      /**
+       * @return the \ref OperatorOverloadCenter used for compilation
+       */
+      OperatorOverloadCenter* operatorOverloadCenter();
     public:
       virtual GTLCore::AST::Expression* standardConstant( const GTLCore::String& _name ) = 0;
     protected:
-      void appendErrors( const std::list<GTLCore::CompilationMessage>& _msgs);
       void setModuleName( const GTLCore::String& moduleName);
       const GTLCore::String& moduleName() const;
        /// List of functions which are not visible in the generated module (like functions coming from an imported module, or standard library functions, and that should be removed at the end of compilation
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/ConvertCenter_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/ConvertCenter_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/ConvertCenter_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/ConvertCenter_p.cpp	2012-01-10 11:12:02.124249333 -0500
@@ -131,10 +131,15 @@ ConvertCenter::ConversionQuality Convert
       return cef->conversionQuality(_srcType, _dstType);
     }
   }
+  if( _srcType->isStructure()
+      and _dstType->isStructure()
+      and _dstType->isSameStructureLayout(_srcType) )
+  {
+    return NONEEDED_CONVERSION;
+  }
   return NOT_CONVERTIBLE;
 }
 
-
 AST::Expression* ConvertCenter::createConvertExpression( AST::Expression* _value, const GTLCore::Type* _dstType ) const
 {
   if( _value->type() == _dstType )
@@ -148,6 +153,14 @@ AST::Expression* ConvertCenter::createCo
       return (*it)->create( _value, _dstType );
     }
   }
+  // It is quiet possible to have two equal structures, but with two different pointer
+  if( _value->type()->isStructure()
+      and _dstType->isStructure()
+      and _dstType->isSameStructureLayout(_value->type()) )
+  {
+    return _value;
+  }
+  GTL_DEBUG("No conversion between " << *_value->type() << " and " << *_dstType);
   return 0;
 }
 
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Debug.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Debug.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Debug.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Debug.cpp	2012-01-10 11:12:02.124249333 -0500
@@ -335,7 +335,7 @@ namespace GTLCore {
         ostr <<"VOID";
         break;
       case Type::STRUCTURE:
-        ostr <<"STRUCTURE";
+        ostr <<"STRUCTURE("  << type.structName() << ")";
         break;
       case Type::ARRAY:
         ostr <<"ARRAY[" << *type.embeddedType() << "]";
@@ -455,7 +455,8 @@ namespace llvm {
   {                                                                       \
     std::string str;                                                      \
     llvm::raw_string_ostream rs(str);                                     \
-    rs << val;                                                            \
+    rs << &val;                                                            \
+    rs.flush();                                                           \
     ostr << str;                                                          \
     return ostr;                                                          \
   }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Debug.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Debug.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Debug.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Debug.h	2012-01-10 11:12:02.124249333 -0500
@@ -99,6 +99,11 @@ namespace llvm {
 #  define FUNC_INFO ""
 #endif
 
+/**
+ * Use this macro to display in the output stream the name of a variable followed by its value.
+ */
+#define ppVar( var ) #var << "=" << var << " "
+
 #define GTL_WARNING(msg) \
   GTLCore::Debug::warning(COUMPONENT_NAME, __FILE__, __LINE__, FUNC_INFO ) << msg << std::endl;
 
@@ -123,6 +128,11 @@ namespace llvm {
   { \
     GTL_ABORT( "Assertion failed: " << #assrt ); \
   }
+#define GTL_ASSERT_X(assrt, msg) \
+  if( not (assrt ) ) \
+  { \
+    GTL_ABORT( "Assertion failed: " << #assrt << " (" << msg << ")" ); \
+  }
 #define GTL_CHECK_PTR(ptr) \
   if( not (assrt ) ) \
   { \
@@ -133,6 +143,11 @@ namespace llvm {
   { \
     GTL_ABORT( #val1 << " != " << #val2 ); \
   }
+#define GTL_CHECK_LLVM_EQUAL(val1, val2) \
+  if( val1 != val2 ) \
+  { \
+    GTL_ABORT( *(val1) << " != " << *(val2) ); \
+  }
 
 
 #include <vector>
@@ -146,8 +161,10 @@ GTLCORE_DEBUG_EXPORT void compareFunctio
 
 #define GTL_DEBUG(msg)
 #define GTL_ASSERT(assrt)
+#define GTL_ASSERT_X(assrt, msg)
 #define GTL_CHECK_PTR(ptr) (void)ptr;
 #define GTL_CHECK_EQUAL(val1, val2) (void)val1; (void)val2;
+#define GTL_CHECK_LLVM_EQUAL(val1, val2) (void)val1; (void)val2;
 #define GTL_COMPARE_FUNCTION_PARAMETERS( _FUNC_, _PARAMS_ ) (void)_FUNC_; (void)_PARAMS_; \
 
 #endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Debug_thread_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Debug_thread_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Debug_thread_p.h.95a8c6853b97	2012-01-10 11:12:02.125249324 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Debug_thread_p.h	2012-01-10 11:12:02.125249324 -0500
@@ -0,0 +1,140 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENCTL_DEBUG_THREAD_H_
+#define _OPENCTL_DEBUG_THREAD_H_
+
+#ifdef OPENGTL_ENABLE_DEBUG_THREAD
+
+#include <algorithm>
+
+#include <llvm/Support/MutexGuard.h>
+#include <llvm/System/Mutex.h>
+#include <llvm/System/Atomic.h>
+
+#include "Debug.h"
+#include "StdTypes.h"
+
+struct Guard {
+  Guard() : value(0)
+  {
+  }
+  void increment()
+  {
+    llvm::sys::AtomicIncrement(&value);
+  }
+  void decrement()
+  {
+    llvm::sys::AtomicDecrement(&value);
+  }
+  llvm::sys::cas_flag value;
+  llvm::sys::Mutex mutexWrite;
+  llvm::sys::Mutex mutex;
+  std::list<int> readers;
+};
+
+/**
+ * @internal
+ * Do not use this class directly, use the macro TEST_GUARD_READ.
+ * 
+ * This class test that no other thread is trying to write the value.
+ */
+struct TestAcquireMutexRead {
+  TestAcquireMutexRead(Guard* _guard) : guard(_guard)
+  {
+    llvm::MutexGuard g(guard->mutex);
+    // Check if this thread is already reading
+    int id = int64_t(pthread_self()) >> 10;
+    alreadyReading = std::find(guard->readers.begin(), guard->readers.end(), id) != guard->readers.end();
+    if(alreadyReading) return;
+    
+    // Check that no thread is writing
+    bool v = guard->mutexWrite.tryacquire();
+    if(v)
+    {
+      guard->mutexWrite.release();
+    } else {
+      GTL_ABORT("Class is been written by an other thread.");
+    }
+    guard->increment();
+    guard->readers.push_back(id);
+  }
+  ~TestAcquireMutexRead()
+  {
+    if(not alreadyReading)
+    {
+      int id = int64_t(pthread_self()) >> 10;
+      llvm::MutexGuard g(guard->mutex);
+      guard->decrement();
+      guard->readers.remove(id);
+    }
+  }
+  Guard* guard;
+  bool alreadyReading;
+};
+
+/**
+ * @internal
+ * Do not use this class directly, use the macro TEST_GUARD_WRITE.
+ * 
+ * This class try to acquire the write right, and test that no other thread is trying to access the value.
+ */
+struct TestAcquireMutexWrite : TestAcquireMutexRead {
+  TestAcquireMutexWrite(Guard* _guard) : TestAcquireMutexRead(_guard)
+  {
+    llvm::MutexGuard g(_guard->mutex);
+    bool v = guard->mutexWrite.tryacquire();
+    if(not v)
+    {
+      GTL_ABORT("Class is been accessed by an other thread.");
+    }
+    if(guard->value > 1)
+    {
+      GTL_ABORT("Class is been readed by an other thread.");
+    }
+  }
+  ~TestAcquireMutexWrite()
+  {
+    llvm::MutexGuard g(guard->mutex);
+    guard->mutexWrite.release();
+  }
+};
+
+/**
+ * Add the guard parameters to a class.
+ */
+#define TEST_GUARD_VARIABLE  Guard guard;
+/**
+ * Add this to a function that read.
+ */
+#define TEST_GUARD_READ(d_ptr) TestAcquireMutexRead testAcquireMutex(&d_ptr->guard);
+/**
+ * Add this to a function that write.
+ */
+#define TEST_GUARD_WRITE(d_ptr) TestAcquireMutexWrite testAcquireWrite(&d_ptr->guard);
+
+#else
+
+#define TEST_GUARD_VARIABLE
+#define TEST_GUARD_READ(d_ptr)
+#define TEST_GUARD_WRITE(d_ptr)
+
+#endif
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore.doxy.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore.doxy
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore.doxy.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore.doxy	2012-01-10 11:12:02.135249239 -0500
@@ -1,6 +1,6 @@
 /**
  * @addtogroup GTLCore GTLCore Library
- * @version 0.9.15
+ * @version 0.9.16
  * @author Cyrille Berger
  * 
  * This library contains the core functionnalities used by the compilers, and some convenient classes.
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/FunctionCaller_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/FunctionCaller_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/FunctionCaller_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/FunctionCaller_p.cpp	2012-01-10 11:12:02.125249324 -0500
@@ -73,8 +73,8 @@ FunctionCaller::FunctionCaller(llvm::Fun
   // }
   llvm::LLVMContext& context = llvmFunction->getContext();
 
-  std::vector<const llvm::Type*> params;
-  const llvm::Type* pointerType = llvm::PointerType::get(llvm::Type::getInt8Ty(context), 0);
+  std::vector<llvm::Type*> params;
+  llvm::Type* pointerType = llvm::PointerType::get(llvm::Type::getInt8Ty(context), 0);
   params.push_back(pointerType);
   params.push_back(pointerType);
   llvm::FunctionType *STy = llvm::FunctionType::get(llvm::Type::getVoidTy(context), params, false);
@@ -118,7 +118,7 @@ FunctionCaller::FunctionCaller(llvm::Fun
   }
   
   // function(arg1, arg2, ..., argN );
-  llvm::CallInst *TheCall = llvm::CallInst::Create(llvmFunction, Args.begin(), Args.end(), "", StubBB);
+  llvm::CallInst *TheCall = llvm::CallInst::Create(llvmFunction, Args, "", StubBB);
   TheCall->setCallingConv(llvmFunction->getCallingConv());
   TheCall->setTailCall();
 
@@ -126,7 +126,7 @@ FunctionCaller::FunctionCaller(llvm::Fun
 
   if(function->returnType() != Type::Void)
   {
-    const llvm::Type* retType = function->returnType()->d->type(context);
+    llvm::Type* retType = function->returnType()->d->type(context);
     llvm::Value* ptr = CodeGenerator::convertPointerTo(StubBB, arg_result, retType);
     new llvm::StoreInst(TheCall,ptr, StubBB);
   }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Function_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Function_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Function_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Function_p.cpp	2012-01-10 11:12:02.125249324 -0500
@@ -75,7 +75,7 @@ Function* Function::Private::createExter
   GTLCore::String _symbolName = GTLCore::Function::Data::symbolName( _functionToCopy->name(), _functionToCopy->returnType(), _functionToCopy->parameters() );
   GTL_DEBUG(_symbolName);
   const llvm::Function* func = _functionToCopy->d->data->function();
-  const llvm::FunctionType *FTy =
+  llvm::FunctionType *FTy =
     llvm::cast<llvm::FunctionType>(llvm::cast<llvm::PointerType>(func->getType())->getElementType());
   llvm::Function* function = dynamic_cast<llvm::Function*>( _llvmModule->getOrInsertFunction( (const std::string&)_symbolName, FTy) );
   GTLCore::Function::Data* data = new GTLCore::Function::Data( _functionToCopy->parameters(), _functionToCopy->d->data->minimumParameters() );
@@ -84,15 +84,37 @@ Function* Function::Private::createExter
   return new GTLCore::Function( _functionToCopy->name(), _functionToCopy->returnType(), data);
 }
 
-GTLCore::Function* Function::Private::createExternalFunction(ModuleData* _module, llvm::Module* _llvmModule, llvm::LLVMContext& _context, const GTLCore::String& _name, const GTLCore::String& _symbolName, const GTLCore::Type* retType, int _count, ...)
+GTLCore::Function* Function::Private::createExternalFunction(ModuleData* _module, llvm::Module* _llvmModule, llvm::LLVMContext& _context, const GTLCore::String& _name, const GTLCore::String& _symbolName, const GTLCore::Type* retType, ExternalFunctionParameters efpParameter, int _count, ...)
 {
   std::vector<GTLCore::Parameter> arguments;
   va_list argp;
   va_start(argp, _count);
-  for(int i = 0; i < _count; ++i)
+  switch(efpParameter)
   {
-    const GTLCore::Type* type = va_arg(argp, const GTLCore::Type*);
-    arguments.push_back(GTLCore::Parameter("", type, false, false, GTLCore::Value() ) );
+    case EFP_ONLY_TYPE:
+    {
+      for(int i = 0; i < _count; ++i)
+      {
+        const GTLCore::Type* type = va_arg(argp, const GTLCore::Type*);
+        arguments.push_back(GTLCore::Parameter("", type, false, false, GTLCore::Value() ) );
+      }
+    }
+    break;
+    case EFP_TYPE_AND_DEFAULT:
+    {
+      for(int i = 0; i < _count; ++i)
+      {
+        const GTLCore::Type* type = va_arg(argp, const GTLCore::Type*);
+        GTLCore::Value* value = va_arg(argp, GTLCore::Value*);
+        if(value)
+        {
+          arguments.push_back(GTLCore::Parameter("", type, false, false, *value ) );
+        } else {
+          arguments.push_back(GTLCore::Parameter("", type, false, false, GTLCore::Value() ) );
+        }
+      }
+    }
+    break;
   }
   va_end(argp);
   return createExternalFunction(_module, _llvmModule, _context, _name, _symbolName, retType, arguments );
@@ -100,24 +122,29 @@ GTLCore::Function* Function::Private::cr
 
 GTLCore::Function* Function::Private::createExternalFunction(ModuleData* _module, llvm::Module* _llvmModule, llvm::LLVMContext& _context, const GTLCore::String& _name, const GTLCore::String& _symbolName, const GTLCore::Type* retType, const std::vector<GTLCore::Parameter>& arguments)
 {
-  std::vector<const llvm::Type*> llvmArguments;
+  int minimumParameters = -1;
+  std::vector<llvm::Type*> llvmArguments;
   for(unsigned int i = 0; i < arguments.size(); ++i)
   {
-    const llvm::Type* type = Type::Private::d( arguments[i].type() )->asArgumentType(_context);
+    llvm::Type* type = Type::Private::d( arguments[i].type() )->asArgumentType(_context);
     if(arguments[i].isOutput())
     {
       type = llvm::PointerType::get( type, 0 );
     }
+    if(arguments[i].defaultValue().type() != Type::Undefined and minimumParameters == -1)
+    {
+      minimumParameters = i;
+    }
     llvmArguments.push_back( type );
   }
-  llvm::Function* function = dynamic_cast<llvm::Function*>( _llvmModule->getOrInsertFunction( (const std::string&)_symbolName, llvm::FunctionType::get( retType->d->type(_context), llvmArguments, false ) ) );
-  GTLCore::Function::Data* data = new GTLCore::Function::Data(arguments, arguments.size() );
+  llvm::Function* function = dynamic_cast<llvm::Function*>( _llvmModule->getOrInsertFunction( (const std::string&)_symbolName, llvm::FunctionType::get( retType->d->asArgumentType(_context), llvmArguments, false ) ) );
+  GTLCore::Function::Data* data = new GTLCore::Function::Data(arguments, minimumParameters == -1 ? arguments.size() : minimumParameters );
   data->setFunction( function );
   data->setModule( _module );
   return new GTLCore::Function( GTLCore::ScopedName("", _name), retType, data );
 }
 
-GTLCore::Function* Function::Private::createInternalFunction(ModuleData* _module, llvm::LLVMContext& _context, const GTLCore::String& _name, llvm::Function* _function, const GTLCore::Type* retType, int _count, ...)
+GTLCore::Function* Function::Private::createInternalFunction(ModuleData* _module, llvm::LLVMContext& _context, const GTLCore::String& _name, llvm::Function* _function, const GTLCore::Type* retType, ExternalFunctionParameters efpParameter, int _count, ...)
 {
   GTL_ASSERT( _function );
   std::vector<GTLCore::Parameter> arguments;
@@ -127,14 +154,41 @@ GTLCore::Function* Function::Private::cr
   const llvm::FunctionType *FTy =
       llvm::cast<llvm::FunctionType>(llvm::cast<llvm::PointerType>(_function->getType())->getElementType());
 #endif
-  for(int i = 0; i < _count; ++i)
+  switch(efpParameter)
   {
-    const GTLCore::Type* type = va_arg(argp, const GTLCore::Type*);
-    arguments.push_back(GTLCore::Parameter("", type, false, false, GTLCore::Value() ) );
+    case EFP_ONLY_TYPE:
+    {
+      for(int i = 0; i < _count; ++i)
+      {
+        const GTLCore::Type* type = va_arg(argp, const GTLCore::Type*);
+        arguments.push_back(GTLCore::Parameter("", type, false, false, GTLCore::Value() ) );
 #ifdef OPENGTL_ENABLE_DEBUG_OUTPUT
-    GTL_DEBUG( *Type::Private::d( type )->asArgumentType(_context) << " == " << *FTy->getParamType(i) );
-    GTL_ASSERT( Type::Private::d( type )->asArgumentType(_context) == FTy->getParamType(i) );
+        GTL_DEBUG( *Type::Private::d( type )->asArgumentType(_context) << " == " << *FTy->getParamType(i) );
+        GTL_ASSERT( Type::Private::d( type )->asArgumentType(_context) == FTy->getParamType(i) );
 #endif
+      }
+    }
+    break;
+    case EFP_TYPE_AND_DEFAULT:
+    {
+      for(int i = 0; i < _count; ++i)
+      {
+        const GTLCore::Type* type = va_arg(argp, const GTLCore::Type*);
+        GTLCore::Value* value = va_arg(argp, GTLCore::Value*);
+        if(value)
+        {
+          arguments.push_back(GTLCore::Parameter("", type, false, false, *value ) );
+        } else {
+          arguments.push_back(GTLCore::Parameter("", type, false, false, GTLCore::Value() ) );
+        }
+        delete value;
+#ifdef OPENGTL_ENABLE_DEBUG_OUTPUT
+        GTL_DEBUG( *Type::Private::d( type )->asArgumentType(_context) << " == " << *FTy->getParamType(i) );
+        GTL_ASSERT( Type::Private::d( type )->asArgumentType(_context) == FTy->getParamType(i) );
+#endif
+      }
+    }
+    break;
   }
   va_end(argp);
   GTLCore::Function::Data* data = new GTLCore::Function::Data(arguments, arguments.size() );
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Function_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Function_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Function_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Function_p.h	2012-01-10 11:12:02.125249324 -0500
@@ -48,8 +48,12 @@ namespace GTLCore {
     FunctionCaller* functionsCaller;
     GTLCORE_EXPORT static Function* createExternalFunction(GTLCore::ModuleData* _module, llvm::Module* _llvmModule, llvm::LLVMContext& _context, const GTLCore::Function* _functionToCopy );
     GTLCORE_EXPORT static Function* createExternalFunction(GTLCore::ModuleData* _module, llvm::Module* _llvmModule, llvm::LLVMContext& _context, const GTLCore::String& _name, const GTLCore::String& _symbolName, const GTLCore::Type* retType, const std::vector< GTLCore::Parameter >& arguments);
-    GTLCORE_EXPORT static Function* createExternalFunction(GTLCore::ModuleData* _module, llvm::Module* _llvmModule, llvm::LLVMContext& _context, const GTLCore::String& _name, const GTLCore::String& _symbolName, const GTLCore::Type* retType, int _count, ...);
-    GTLCORE_EXPORT static Function* createInternalFunction(ModuleData* _module, llvm::LLVMContext& _context, const String& _name, llvm::Function* _function, const Type* retType, int _count, ...);
+    enum ExternalFunctionParameters {
+      EFP_ONLY_TYPE,
+      EFP_TYPE_AND_DEFAULT
+    };
+    GTLCORE_EXPORT static Function* createExternalFunction(GTLCore::ModuleData* _module, llvm::Module* _llvmModule, llvm::LLVMContext& _context, const GTLCore::String& _name, const GTLCore::String& _symbolName, const GTLCore::Type* retType, ExternalFunctionParameters efpParameter, int _count, ...);
+    GTLCORE_EXPORT static Function* createInternalFunction(ModuleData* _module, llvm::LLVMContext& _context, const String& _name, llvm::Function* _function, const Type* retType, ExternalFunctionParameters efpParameter, int _count, ...);
     bool isReturnedAsPointer() const;
   };
   /**
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/GrayColorConverter_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/GrayColorConverter_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/GrayColorConverter_p.h.95a8c6853b97	2012-01-10 11:12:02.125249324 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/GrayColorConverter_p.h	2012-01-10 11:12:02.125249324 -0500
@@ -0,0 +1,110 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENGTL_GRAY_COLOR_CONVERTER_P_H_
+#define _OPENGTL_GRAY_COLOR_CONVERTER_P_H_
+
+#include "AbstractColorConverter.h"
+#include "StdTypes.h"
+#include "Color.h"
+
+#include "RgbColorConverter_p.h"
+
+namespace GTLCore {
+  template<typename _Channel_Type_, bool _has_alpha>
+  class GTLCORE_EXPORT GrayColorConverter : public AbstractColorConverter
+  {
+  private:
+    typedef GTLCore::GammaToLinearFloat<_Channel_Type_> GammaToLinearFloat;
+    typedef GTLCore::IntegerToFloat<_Channel_Type_>     IntegerToFloat;
+    typedef GTLCore::LinearToGammaFloat<_Channel_Type_> LinearToGammaFloat;
+    typedef GTLCore::FloatToInteger<_Channel_Type_>     FloatToInteger;
+    GTL_NO_COPY(GrayColorConverter)
+  public:
+    GrayColorConverter(double _gamma, const GTLCore::PixelDescription& _pixelDescription) : AbstractColorConverter(_pixelDescription), m_gamma(_gamma),
+        m_pixelToRgb( RgbColorConverterTraits<_Channel_Type_>::createPixelToRgbA(_gamma)),
+        m_rgbToPixel( RgbColorConverterTraits<_Channel_Type_>::createRgbAToPixel(_gamma)),
+        m_vectorToRgb(_gamma),
+        m_rgbToVector(_gamma)
+    {
+    }
+  public:
+    virtual ~GrayColorConverter()
+    {
+    }
+    virtual void pixelToRgba(const char* _data, RgbaF* _rgba) const
+    {
+      const _Channel_Type_* data = reinterpret_cast<const _Channel_Type_*>(_data);
+      float v = m_pixelToRgb(data[0]);
+      _rgba->r = v;
+      _rgba->g = v;
+      _rgba->b = v;
+      if(_has_alpha) {
+        _rgba->a = ChannelMaths<_Channel_Type_, float>::scaleToA(data[1]);
+      } else {
+        _rgba->a = 1.0;
+      }
+    }
+    virtual void rgbaToPixel(const RgbaF* _rgba, char* _data) const
+    {
+      _Channel_Type_* data = reinterpret_cast<_Channel_Type_*>(_data);
+      data[0] = m_rgbToPixel((_rgba->r + _rgba->g + _rgba->b) / 3.0);
+      if(_has_alpha) {
+        data[1] = ChannelMaths<float, _Channel_Type_>::scaleToA(_rgba->a);
+      }
+    }
+    virtual void vectorToRgba(const float* _data, RgbaF* _rgba) const
+    {
+      float v = m_vectorToRgb(_data[0]);
+      _rgba->r = v;
+      _rgba->g = v;
+      _rgba->b = v;
+      if(_has_alpha) {
+        _rgba->a = _data[1];
+      } else {
+        _rgba->a = 1.0;
+      }
+    }
+    virtual void rgbaToVector(const RgbaF* _rgba, float* _data) const
+    {
+      _data[0] = m_rgbToVector((_rgba->r + _rgba->g + _rgba->b) / 3.0);
+      if(_has_alpha) {
+        _data[1] = _rgba->a;
+      }
+    }
+  private:
+    // Those are placeholders for the future conversion to/from HSV and to/from LAB
+    virtual void placeholder1() {}
+    virtual void placeholder2() {}
+    virtual void placeholder3() {}
+    virtual void placeholder4() {}
+    virtual void placeholder5() {}
+    virtual void placeholder6() {}
+    virtual void placeholder7() {}
+    virtual void placeholder8() {}
+  private:
+    double m_gamma;
+    typename RgbColorConverterTraits<_Channel_Type_>::PixelToRgb m_pixelToRgb;
+    typename RgbColorConverterTraits<_Channel_Type_>::RgbToPixel m_rgbToPixel;
+    GammaToLinearFloat m_vectorToRgb;
+    LinearToGammaFloat m_rgbToVector;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Image.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Image.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Image.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Image.cpp	2012-01-10 11:12:02.125249324 -0500
@@ -27,7 +27,7 @@ using namespace GTLCore;
 struct Image::Private {
 };
 
-Image::Image(int _width, int _height, const PixelDescription& _pixelDescription) : BufferImage(_width, _height, new Array(_height * _width * _pixelDescription.bitsSize() / 8), _pixelDescription ), d(new Private)
+Image::Image(int _width, int _height, const PixelDescription& _pixelDescription, const AbstractColorConverter* _colorConverter) : BufferImage(_width, _height, new Array(_height * _width * (_pixelDescription.bitsSize() / 8)), _pixelDescription, _colorConverter ), d(new Private)
 {
 }
 
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Image.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Image.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Image.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Image.h	2012-01-10 11:12:02.126249316 -0500
@@ -35,7 +35,7 @@ namespace GTLCore {
   class GTLCORE_EXPORT Image : public BufferImage {
       GTL_NO_COPY(Image);
     public:
-      Image(int _width, int _height, const PixelDescription& _pixelDescription);
+      Image(int _width, int _height, const GTLCore::PixelDescription& _pixelDescription, const GTLCore::AbstractColorConverter* _colorConverter = 0 );
       ~Image();
     private:
       struct Private;
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/IntegersMath.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/IntegersMath.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/IntegersMath.h.95a8c6853b97	2012-01-10 11:12:02.126249316 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/IntegersMath.h	2012-01-10 11:12:02.126249316 -0500
@@ -0,0 +1,127 @@
+/*
+ *  Copyright (c) 2005 Adrian Page <adrian@pagenet.plus.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+*/
+
+#ifndef GTL_INTEGER_MATHS_H
+#define GTL_INTEGER_MATHS_H
+
+#include "StdTypes.h"
+
+namespace GTLCore {
+
+  template<typename _T_, typename _T2_, typename _T3_>
+  inline _T_ bound(_T2_ l, _T_ x, _T3_ u)
+  {
+      if (x < l)
+          return _T_(l);
+      else if (x > u)
+          return _T_(u);
+      return x;
+  }
+
+  /// take a and scale it up by 256*b/255
+  inline unsigned int UINT8_SCALEBY(unsigned int a, unsigned int b)
+  {
+      unsigned int c = a * b + 0x80u;
+      return (c >> 8) + c;
+  }
+
+  /// multiplication of two scale values
+  /// A scale value is interpreted as 255 equaling 1.0 (such as seen in rgb8 triplets)
+  /// thus "255*255=255" because 1.0*1.0=1.0
+  inline unsigned int UINT8_MULT(unsigned int a, unsigned int b)
+  {
+      unsigned int c = a * b + 0x80u;
+      return ((c >> 8) + c) >> 8;
+  }
+
+  inline unsigned int UINT8_DIVIDE(unsigned int a, unsigned int b)
+  {
+      unsigned int c = (a * UINT8_MAX + (b / 2u)) / b;
+      return c;
+  }
+
+  /// Approximation of (a * b * c + 32512) / 65025.0
+  inline unsigned int UINT8_MULT3(unsigned int a, unsigned int b, unsigned int c)
+  {
+    unsigned int t = a * b * c + 0x7F5B;
+    return ((t >> 7) + t) >> 16;
+  }
+
+  /// Blending of two scale values as described by the alpha scale value
+  /// A scale value is interpreted as 255 equaling 1.0 (such as seen in rgb8 triplets)
+  /// Basically we do: a*alpha + b*(1-alpha)
+  inline unsigned int UINT8_BLEND(unsigned int a, unsigned int b, unsigned int alpha)
+  {
+      // However the formula is refactored to (a-b)*alpha + b  since that saves a multiplication
+      // Signed arithmetic is needed since a-b might be negative
+      int c = (int(a) - int(b)) * alpha + 0x80u;
+      c = ((c >> 8) + c) >> 8;
+      return c + b;
+  }
+
+  inline unsigned int UINT16_MULT(unsigned int a, unsigned int b)
+  {
+      unsigned int c = a * b + 0x8000u;
+      return ((c >> 16) + c) >> 16;
+  }
+
+  inline int INT16_MULT(int a, int b)
+  {
+      return (a*b) / INT16_MAX;
+  }
+
+  inline unsigned int UINT16_DIVIDE(unsigned int a, unsigned int b)
+  {
+      unsigned int c = (a * UINT16_MAX + (b / 2u)) / b;
+      return c;
+  }
+
+  inline unsigned int UINT16_BLEND(unsigned int a, unsigned int b, unsigned int alpha)
+  {
+      // Basically we do a*alpha + b*(1-alpha)
+      // However refactored to (a-b)*alpha + b  since that saves a multiplication
+      // Signed arithmetic is needed since a-b might be negative
+      int c = ((int(a) - int(b)) * int(alpha)) >> 16;
+      return (unsigned int)(c + b);
+  }
+
+  inline unsigned int UINT8_TO_UINT16(unsigned int c)
+  {
+      return c | (c << 8);
+  }
+
+  inline unsigned int UINT16_TO_UINT8(unsigned int c)
+  {
+      //return round(c / 257.0);
+      //For all UINT16 this calculation is the same and a lot faster (off by c/65656 which for every c is 0)
+      c = c - (c >> 8) + 128;
+      return c >> 8;
+  }
+
+  inline int INT16_BLEND(int a, int b, unsigned int alpha)
+  {
+      // Basically we do a*alpha + b*(1-alpha)
+      // However refactored to (a-b)*alpha + b  since that saves a multiplication
+      int c = ((int(a) - int(b)) * int(alpha)) >> 16;
+      return c + b;
+  }
+}
+
+#endif
+
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/LLVMBackend/CodeGenerator_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/LLVMBackend/CodeGenerator_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/LLVMBackend/CodeGenerator_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/LLVMBackend/CodeGenerator_p.cpp	2012-01-10 11:12:02.126249316 -0500
@@ -124,7 +124,7 @@ llvm::Constant* CodeGenerator::floatToCo
 
 llvm::Constant* CodeGenerator::nullPointerToConstant(llvm::LLVMContext& _llvmContext)
 {
-  return llvm::ConstantPointerNull::get( static_cast<const llvm::PointerType*>( Type::Pointer->d->type(_llvmContext) ) );
+  return llvm::ConstantPointerNull::get( llvm::cast<llvm::PointerType>( Type::Pointer->d->type(_llvmContext) ) );
 }
 
 llvm::Constant* CodeGenerator::valueToConstant( LLVMBackend::GenerationContext& _gc, const Value& v)
@@ -184,7 +184,7 @@ llvm::Constant* CodeGenerator::constants
   
   arrayStruct.push_back( iptr );
   
-  const llvm::StructType* structType = dynamic_cast<const llvm::StructType*>( _type->d->type(_gc.llvmContext()) );
+  llvm::StructType* structType = llvm::cast<llvm::StructType>( _type->d->type(_gc.llvmContext()) );
   GTL_ASSERT( structType );
   return llvm::ConstantStruct::get( structType, arrayStruct );
 }
@@ -192,16 +192,16 @@ llvm::Constant* CodeGenerator::constants
 llvm::Constant* CodeGenerator::constantsToStructure( LLVMBackend::GenerationContext& _gc, const std::vector< llvm::Constant* >& _constants, const Type* _type )
 {
   GTL_ASSERT(_constants.size() == _type->countStructDataMembers() + STRUCT_FIRST_ELEMENT);
-  const llvm::StructType* structType = dynamic_cast<const llvm::StructType*>( _type->d->type(_gc.llvmContext()) );
+  llvm::StructType* structType = llvm::cast<llvm::StructType>( _type->d->type(_gc.llvmContext()) );
   return llvm::ConstantStruct::get( structType, _constants );
 }
 
 llvm::Constant* CodeGenerator::constantsToVector( LLVMBackend::GenerationContext& _gc, const std::vector< llvm::Constant* >& _constants, const Type* _type )
 {
-  const llvm::VectorType* vectorType = dynamic_cast<const llvm::VectorType*>( _type->d->type(_gc.llvmContext()) );
+  llvm::VectorType* vectorType = llvm::cast<llvm::VectorType>( _type->d->type(_gc.llvmContext()) );
   GTL_ASSERT( vectorType );
   GTL_ASSERT( not _constants.empty());
-  return llvm::ConstantVector::get( vectorType, _constants );
+  return llvm::ConstantVector::get( _constants );
 }
 
 Value CodeGenerator::constantToValue(llvm::Constant* constant, const Type* _type)
@@ -289,10 +289,10 @@ llvm::Value* CodeGenerator::createVector
     inits.push_back( _val );
   }
   GTL_ASSERT( not inits.empty());
-  return llvm::ConstantVector::get( static_cast<const llvm::VectorType*>( _vecType->d->type( _val->getContext() )), inits );
+  return llvm::ConstantVector::get( inits );
 }
 
-llvm::Value* CodeGenerator::createVector( int _size, llvm::Constant* _val, const Type* _valType)
+llvm::Value* CodeGenerator::createVector( int _size, llvm::Constant* _val)
 {
   std::vector<llvm::Constant*> inits;
   for( int i = 0; i < _size; ++i)
@@ -300,7 +300,7 @@ llvm::Value* CodeGenerator::createVector
     inits.push_back( _val );
   }
   GTL_ASSERT( not inits.empty());
-  return llvm::ConstantVector::get( static_cast<const llvm::VectorType*>( TypesManager::getVector( _valType, _size)->d->type( _val->getContext() )), inits );
+  return llvm::ConstantVector::get( inits );
 }
 
 llvm::Value* CodeGenerator::convertPointerToCharP(llvm::BasicBlock* _currentBlock, llvm::Value* _value)
@@ -308,7 +308,7 @@ llvm::Value* CodeGenerator::convertPoint
   return convertPointerTo( _currentBlock, _value, llvm::Type::getInt8Ty(_value->getContext()) );
 }
 
-llvm::Value* CodeGenerator::convertPointerTo(llvm::BasicBlock* _currentBlock, llvm::Value* _value, const llvm::Type* _type)
+llvm::Value* CodeGenerator::convertPointerTo(llvm::BasicBlock* _currentBlock, llvm::Value* _value, llvm::Type* _type)
 {
   return new llvm::BitCastInst( _value, llvm::PointerType::get( _type, 0 ), "", _currentBlock );
 }
@@ -354,7 +354,7 @@ llvm::Value* CodeGenerator::convertValue
 
 llvm::Constant* CodeGenerator::convertConstantTo(llvm::Constant* _constant, const Type* _constantType, const Type* _targetType)
 {
-  const llvm::Type* dstType = _targetType->d->type(_constant->getContext());
+  llvm::Type* dstType = _targetType->d->type(_constant->getContext());
   GTL_DEBUG( *_constant->getType() << " " << *dstType << " "<< *_targetType );
   if(_constant->getType() == dstType )
   { // Don't cast the value as it has already the correct type
@@ -371,7 +371,7 @@ llvm::Constant* CodeGenerator::convertCo
     }
     // store back
     GTL_ASSERT( not constants.empty());
-    return llvm::ConstantVector::get( llvm::cast<const llvm::VectorType>(dstType), constants );
+    return llvm::ConstantVector::get( constants );
   }
   GTL_ASSERT( _targetType->d->type(_constant->getContext())->isFirstClassType() );
   GTL_ASSERT( _constant->getType()->isFirstClassType() );
@@ -384,29 +384,30 @@ llvm::Constant* CodeGenerator::convertCo
 
 llvm::Value* CodeGenerator::convertToHalf( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* currentBlock, llvm::Value* value, const Type* _valueType )
 {
-  std::vector<const llvm::Type*> llvmArguments;
+  std::vector< llvm::Type*> llvmArguments;
   llvmArguments.push_back( llvm::Type::getFloatTy(_generationContext.llvmContext()) );
   llvm::Function* func = dynamic_cast<llvm::Function*>( _generationContext.llvmModule()->getOrInsertFunction( "_Z10float2halff",
       llvm::FunctionType::get( llvm::Type::getInt16Ty(_generationContext.llvmContext()) , llvmArguments, false ) ) );
   std::vector<llvm::Value*> convertedParams;
   convertedParams.push_back( convertValueTo( currentBlock, value, _valueType, Type::Float32 ) );
-  return llvm::CallInst::Create( func, convertedParams.begin(), convertedParams.end(), "", currentBlock );
+  return llvm::CallInst::Create( func, convertedParams, "", currentBlock );
 }
 
 llvm::Value* CodeGenerator::convertFromHalf( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* currentBlock, llvm::Value* value)
 {
-  std::vector<const llvm::Type*> llvmArguments;
+  std::vector<llvm::Type*> llvmArguments;
   llvmArguments.push_back( llvm::Type::getInt16Ty(_generationContext.llvmContext()) );
   llvm::Function* func = dynamic_cast<llvm::Function*>( _generationContext.llvmModule()->getOrInsertFunction( "_Z10half2floatt",
       llvm::FunctionType::get( llvm::Type::getFloatTy(_generationContext.llvmContext()) , llvmArguments, false ) ) );
   std::vector<llvm::Value*> convertedParams;
   convertedParams.push_back( convertValueTo( currentBlock, value, Type::Float16, Type::Integer16 ) );
-  return llvm::CallInst::Create( func, convertedParams.begin(), convertedParams.end(), "", currentBlock );
+  return llvm::CallInst::Create( func, convertedParams, "", currentBlock );
   
 }
 
 llvm::Value* CodeGenerator::convertArrayToVector(LLVMBackend::GenerationContext& gc, LLVMBackend::ExpressionGenerationContext& _egc, llvm::Value* value, const Type* valueType, const Type* type)
 {
+  
   // int arraySize = value->size;
   // if( arraySize > type->vectorSize() ) arraySize = type->vectorSize();
   // 'type' result;
@@ -418,7 +419,7 @@ llvm::Value* CodeGenerator::convertArray
   // int arraySize = value->size;
   llvm::Value* arraySize = accessArraySize(_egc.currentBasicBlock(), value);
   llvm::Value* vectorSize = integerToConstant( gc.llvmContext(), gtl_uint32(type->vectorSize()) );
-  llvm::Value* arraySizeAlloc = new llvm::AllocaInst( llvm::Type::getInt32Ty(gc.llvmContext()), "", _egc.currentBasicBlock() );
+  llvm::Value* arraySizeAlloc = new llvm::AllocaInst( llvm::Type::getInt32Ty(gc.llvmContext()), "arraySizeAlloc", _egc.currentBasicBlock() );
   
   // arraySize > type->vectorSize()
   llvm::Value* aStVComp = createStrictSupperiorExpression(_egc.currentBasicBlock(),
@@ -433,8 +434,8 @@ llvm::Value* CodeGenerator::convertArray
   llvm::BasicBlock* after = gc.createBasicBlock();
   createIfElseStatement( _egc.currentBasicBlock(), aStVComp, Type::Boolean, block1, block1, block2, block2, after);
 
-  arraySize = new llvm::LoadInst( arraySizeAlloc, "", after );
-  llvm::Value* result = createVector( type, floatToConstant( gc.llvmContext(), 0.0 ) );
+  arraySize = new llvm::LoadInst( arraySizeAlloc, "loadArraySizeAlloc", after );
+  llvm::Value* result = new llvm::AllocaInst( type->d->type(gc.llvmContext()), "vector", after );
   
   // int i = 0;
   VariableNG idx(Type::Integer32, false, false );
@@ -445,15 +446,15 @@ llvm::Value* CodeGenerator::convertArray
   //   result[i] = array[i];
   llvm::BasicBlock* forBlock = gc.createBasicBlock();
   llvm::Value* cidx = idx.get( gc, forBlock );
-  llvm::Value* val = accessArrayValueNoClamp( forBlock, value, cidx );
-  llvm::InsertElementInst::Create(result, val, cidx, "", forBlock );
+  llvm::Value* val = new llvm::LoadInst( accessArrayValueNoClamp( forBlock, value, cidx ), "", forBlock);
+  new llvm::StoreInst( llvm::InsertElementInst::Create(new llvm::LoadInst(result, "", forBlock), val, cidx, "", forBlock ), result, "", forBlock );
   
   // for(int i = 0; i < arraySize; ++i )
   llvm::BasicBlock* afterFor = createIterationForStatement(gc, after, &idx, arraySize, Type::Integer32, forBlock, forBlock);
   
   _egc.setCurrentBasicBlock(afterFor);
   
-  return result;
+  return new llvm::LoadInst(result, "", afterFor);
 }
 
 llvm::Constant* CodeGenerator::convertConstantArrayToVector(llvm::Constant* constant, const Type* constantType, const Type* type)
@@ -465,7 +466,7 @@ llvm::Constant* CodeGenerator::convertCo
   GTL_ASSERT(constantType->dataType() == Type::ARRAY );
   GTL_ASSERT(type->dataType() == Type::VECTOR );
   GTL_ASSERT(arrayConstant->getNumOperands() == 3 );
-  llvm::Constant* values = static_cast<llvm::Constant*>(arrayConstant->getOperand(2)->getOperand(0)->getOperand(0));
+  llvm::Constant* values = llvm::cast<llvm::Constant>(llvm::cast<llvm::Constant>(arrayConstant->getOperand(2)->getOperand(0))->getOperand(0));
   GTL_DEBUG(*values);
   GTL_ASSERT(dynamic_cast<llvm::ConstantArray*>(values) );
   std::vector<llvm::Constant*> constants;
@@ -480,7 +481,7 @@ llvm::Constant* CodeGenerator::convertCo
   }
   GTL_ASSERT( constants.size() == type->vectorSize() );
   GTL_ASSERT( not constants.empty());
-  return llvm::ConstantVector::get( static_cast<const llvm::VectorType*>( type->d->type(constant->getContext()) ), constants);
+  return llvm::ConstantVector::get( constants);
 }
 
 llvm::Value* CodeGenerator::vectorValueAt( llvm::BasicBlock* _currentBlock, llvm::Value* _vector, llvm::Value* _index)
@@ -665,6 +666,8 @@ llvm::Value* CodeGenerator::createDivisi
            and lhsType->embeddedType()->dataType() == Type::FLOAT32 ) )
   {
     return llvm::BinaryOperator::CreateFDiv(v1, v2, "", currentBlock );
+  } else if( lhsType->isSigned() and rhsType->isSigned()) {
+    return llvm::BinaryOperator::CreateUDiv(v1, v2, "", currentBlock );
   } else {
     return llvm::BinaryOperator::CreateSDiv(v1, v2, "", currentBlock );
   }
@@ -676,6 +679,8 @@ llvm::Constant* CodeGenerator::createDiv
   if( v1->getType()->isFloatingPointTy() )
   {
     return llvm::ConstantExpr::getFDiv( v1, v2);
+  } else if( lhsType->isSigned() and rhsType->isSigned()) {
+    return llvm::ConstantExpr::getUDiv(v1, v2 );
   } else {
     return llvm::ConstantExpr::getSDiv( v1, v2);
   }
@@ -692,13 +697,21 @@ ExpressionResult CodeGenerator::createDi
 llvm::Value* CodeGenerator::createModuloExpression(llvm::BasicBlock* currentBlock, llvm::Value* lhs, const Type* lhsType, llvm::Value* rhs, const Type* rhsType)
 {
   UNIFORMIZE_VALUE_TYPES( lhs, rhs );
-  return llvm::BinaryOperator::CreateSRem( v1, v2, "", currentBlock );
+  if( lhsType->isSigned() or rhsType->isSigned()) {
+    return llvm::BinaryOperator::CreateSRem( v1, v2, "", currentBlock );
+  } else {
+    return llvm::BinaryOperator::CreateURem( v1, v2, "", currentBlock );
+  }
 }
 
 llvm::Constant* CodeGenerator::createModuloExpression( llvm::Constant* lhs, const Type* lhsType, llvm::Constant* rhs, const Type* rhsType)
 {
   UNIFORMIZE_CONSTANT_TYPES( lhs, rhs );
-  return llvm::ConstantExpr::getSRem( v1, v2);
+  if( lhsType->isSigned() or rhsType->isSigned()) {
+    return llvm::ConstantExpr::getSRem( v1, v2);
+  } else {
+    return llvm::ConstantExpr::getURem( v1, v2);
+  }
 }
 
 ExpressionResult CodeGenerator::createModuloExpression( llvm::BasicBlock* currentBlock, ExpressionResult lhs, const Type* lhsType, ExpressionResult rhs, const Type* rhsType)
@@ -831,7 +844,7 @@ ExpressionResult CodeGenerator::createMi
 
 llvm::Value* CodeGenerator::createMinusExpression(llvm::BasicBlock* currentBlock, llvm::Value* rhs, const Type* rhsType)
 {
-  if(rhsType->isFloatingPoint() or (rhsType->dataType() == Type::VECTOR and rhsType->embeddedType()->isFloatingPoint() ))
+  if(rhsType->isFloatingPoint())
   {
     return llvm::BinaryOperator::CreateFNeg( rhs, "", currentBlock );
   } else {
@@ -841,7 +854,7 @@ llvm::Value* CodeGenerator::createMinusE
 
 llvm::Constant* CodeGenerator::createMinusExpression( llvm::Constant* rhs, const Type* rhsType)
 {
-  if(rhsType->isFloatingPoint() or (rhsType->dataType() == Type::VECTOR and rhsType->embeddedType()->isFloatingPoint() ))
+  if(rhsType->isFloatingPoint())
   {
     return llvm::ConstantExpr::getFNeg( rhs);
   } else {
@@ -881,15 +894,27 @@ llvm::Constant* CodeGenerator::createTil
 
 llvm::Value* CodeGenerator::accessArrayValueClamp( LLVMBackend::GenerationContext& generationContext, LLVMBackend::ExpressionGenerationContext& _expressionGenerationContext, llvm::Value* _pointer, llvm::Value* _index )
 {
-  llvm::BasicBlock* currentBlock = _expressionGenerationContext.currentBasicBlock();
   // Clamp
-  llvm::Value* indexValuePtr = new llvm::AllocaInst(llvm::Type::getInt32Ty(generationContext.llvmContext()), "ClampedPlacehold", currentBlock);
-  new llvm::StoreInst(_index, indexValuePtr, "Store for clamping", currentBlock);
-  currentBlock = createClampExpression(generationContext, currentBlock, indexValuePtr, Type::Integer32, integerToConstant(generationContext.llvmContext(), gtl_uint32(0)), 
-                                       createSubstractionExpression(currentBlock, accessArraySize(currentBlock, _pointer), Type::Integer32, integerToConstant(generationContext.llvmContext(), gtl_uint32(1)), Type::Integer32) );
+  
+  llvm::Value* min = integerToConstant(generationContext.llvmContext(), gtl_uint32(0));
+  llvm::Value* max = createSubstractionExpression(_expressionGenerationContext.currentBasicBlock(),
+                                                  accessArraySize(_expressionGenerationContext.currentBasicBlock(), _pointer),
+                                                  Type::Integer32,
+                                                  integerToConstant(generationContext.llvmContext(), gtl_uint32(1)),
+                                                  Type::Integer32 );
+  
+  _index = clampValue(generationContext, _expressionGenerationContext, _index, min, max );
+  return accessArrayValueNoClamp(_expressionGenerationContext.currentBasicBlock(), _pointer, _index);
+}
+
+llvm::Value* CodeGenerator::clampValue( LLVMBackend::GenerationContext& _generationContext, LLVMBackend::ExpressionGenerationContext& _expressionGenerationContext, llvm::Value* _value, llvm::Value* _min, llvm::Value* _max)
+{
+  llvm::BasicBlock* currentBlock = _expressionGenerationContext.currentBasicBlock();
+  llvm::Value* indexValuePtr = new llvm::AllocaInst(llvm::Type::getInt32Ty(_generationContext.llvmContext()), "ClampedPlacehold", currentBlock);
+  new llvm::StoreInst(_value, indexValuePtr, "Store for clamping", currentBlock);
+  currentBlock = createClampExpression(_generationContext, currentBlock, indexValuePtr, Type::Integer32, _min, _max);
   _expressionGenerationContext.setCurrentBasicBlock(currentBlock);
-  _index = new llvm::LoadInst(indexValuePtr, "Loadnewindex", currentBlock);
-  return accessArrayValueNoClamp(currentBlock, _pointer, _index);
+  return new llvm::LoadInst(indexValuePtr, "Loadnewindex", currentBlock);
 }
 
 llvm::Value* CodeGenerator::accessArrayValueNoClamp( llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, llvm::Value* _index )
@@ -900,7 +925,7 @@ llvm::Value* CodeGenerator::accessArrayV
   indexes.push_back( llvm::ConstantInt::get(llvm::Type::getInt32Ty(_pointer->getContext()), ArrayWrap::POS_DATA)); // Access the data of the array
   
   // Select the pointer
-  llvm::Value* iptr = llvm::GetElementPtrInst::Create( _pointer, indexes.begin(), indexes.end(), "", _currentBlock);
+  llvm::Value* iptr = llvm::GetElementPtrInst::Create( _pointer, indexes, "", _currentBlock);
   // pointer on the values
   llvm::Value* iptr_val = new llvm::LoadInst( iptr, "load array data pointer", _currentBlock);
   return llvm::GetElementPtrInst::Create( iptr_val, _index, "point to the value in the data pointer", _currentBlock);
@@ -911,12 +936,12 @@ llvm::Value* CodeGenerator::accessArrayS
   std::vector<llvm::Value*> indexes;
   indexes.push_back( llvm::ConstantInt::get(llvm::Type::getInt32Ty(_pointer->getContext()), 0)); // Access the structure of the array
   indexes.push_back( llvm::ConstantInt::get(llvm::Type::getInt32Ty(_pointer->getContext()), ArrayWrap::POS_SIZE)); // Access the size of the array
-  return llvm::GetElementPtrInst::Create( _pointer, indexes.begin(), indexes.end(), "", _currentBlock);
+  return llvm::GetElementPtrInst::Create( _pointer, indexes, "", _currentBlock);
 }
 
 llvm::Value* CodeGenerator::accessArraySize( llvm::BasicBlock* _currentBlock, llvm::Value* _pointer )
 {
-  return new llvm::LoadInst( accessArraySizePointer(_currentBlock, _pointer), "", _currentBlock);
+  return new llvm::LoadInst( accessArraySizePointer(_currentBlock, _pointer), "accessArraySize", _currentBlock);
 }
 
 ExpressionResult CodeGenerator::callFunction( LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& egc, const Function* _function, const std::list<AST::Expression*>& _arguments )
@@ -947,7 +972,7 @@ ExpressionResult CodeGenerator::callFunc
       AST::AccessorExpression* aexp = dynamic_cast<AST::AccessorExpression*>( *it );
       GTL_ASSERT( aexp );
       llvm::Value* pointer = aexp->pointer( _gc, egc );
-      GTL_ASSERT( pointer->getType() == llvm::PointerType::get( oparam_it->type()->d->type(_gc.llvmContext()), 0) );
+      GTL_CHECK_LLVM_EQUAL( pointer->getType(), llvm::PointerType::get( oparam_it->type()->d->type(_gc.llvmContext()), 0) );
       convertedParams.push_back( pointer );
       GTL_DEBUG(*pointer->getType() << " " << *oparam_it->type()->d->type(_gc.llvmContext()) << " " << pointer );
     } else {
@@ -1006,7 +1031,7 @@ ExpressionResult CodeGenerator::callFunc
   }
 #endif
   
-  llvm::CallInst *CallInst = llvm::CallInst::Create(llvmFunction, convertedParams.begin(), convertedParams.end(), "", egc.currentBasicBlock());
+  llvm::CallInst *CallInst = llvm::CallInst::Create(llvmFunction, convertedParams, "", egc.currentBasicBlock());
   CallInst->setTailCall(false);
   llvm::Value* result = CallInst;
   if(_function->d->isReturnedAsPointer())
@@ -1022,8 +1047,9 @@ llvm::Value* CodeGenerator::countFieldPo
   std::vector<llvm::Value*> indexes;
   indexes.push_back( llvm::ConstantInt::get(llvm::Type::getInt32Ty(_pointer->getContext()), 0)); // Access the structure of the array/structure
   indexes.push_back( llvm::ConstantInt::get(llvm::Type::getInt32Ty(_pointer->getContext()), 0)); // Access the count field of the array/structure
+  GTL_DEBUG(*_pointer << *_pointer->getType());
   // Select the pointer
-  return llvm::GetElementPtrInst::Create( _pointer, indexes.begin(), indexes.end(), "", _currentBlock);
+  return llvm::GetElementPtrInst::Create( _pointer, indexes, "", _currentBlock);
 }
 
 void CodeGenerator::setCountFieldOf( llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, llvm::Value* _value )
@@ -1050,7 +1076,7 @@ llvm::Value* CodeGenerator::incrementCou
 
 llvm::Function* createGtlMallocFunction( LLVMBackend::GenerationContext& _gc )
 {
-  std::vector<const llvm::Type*> memcpyTyArgs;
+  std::vector< llvm::Type*> memcpyTyArgs;
   memcpyTyArgs.push_back(llvm::Type::getInt32Ty(_gc.llvmContext()));
   llvm::FunctionType* memcpyTy = llvm::FunctionType::get( llvm::PointerType::get(llvm::IntegerType::getInt8Ty(_gc.llvmContext()), 0), memcpyTyArgs, false);
   
@@ -1062,7 +1088,7 @@ llvm::Function* createGtlMallocFunction(
 
 llvm::Function* createGtlFreeFunction( LLVMBackend::GenerationContext& _gc )
 {
-  std::vector<const llvm::Type*> memcpyTyArgs;
+  std::vector< llvm::Type*> memcpyTyArgs;
   memcpyTyArgs.push_back(llvm::PointerType::get(llvm::IntegerType::getInt8Ty(_gc.llvmContext()), 0));
   llvm::FunctionType* memcpyTy = llvm::FunctionType::get( llvm::Type::getVoidTy(_gc.llvmContext()), memcpyTyArgs, false);
   
@@ -1073,7 +1099,7 @@ llvm::Function* createGtlFreeFunction( L
 }
 #endif
 
-llvm::Value* CodeGenerator::allocateMemory( LLVMBackend::GenerationContext& _gc, const llvm::Type* _type, llvm::Value* _size, llvm::BasicBlock* _bb)
+llvm::Value* CodeGenerator::allocateMemory( LLVMBackend::GenerationContext& _gc, llvm::Type* _type, llvm::Value* _size, llvm::BasicBlock* _bb)
 {
 #ifdef _USE_GTL_MM_
   llvm::Function* func = createGtlMallocFunction( _gc );
@@ -1084,7 +1110,7 @@ llvm::Value* CodeGenerator::allocateMemo
     llvm::CastInst::CreateIntegerCast( llvm::ConstantExpr::getSizeOf( _type ),
                                        llvm::Type::getInt32Ty(_gc.llvmContext()), false, "", _bb ), "", _bb  ) );
   GTL_DEBUG( *func );
-  llvm::CallInst *CallFunc = llvm::CallInst::Create(func, params.begin(), params.end(), "", _bb);
+  llvm::CallInst *CallFunc = llvm::CallInst::Create(func, params, "", _bb);
   CallFunc->setTailCall(false);
   return convertPointerTo( _bb, CallFunc, _type );
 #else
@@ -1102,7 +1128,7 @@ void CodeGenerator::freeMemory( LLVMBack
   std::vector<llvm::Value*> params;
   params.push_back( convertPointerTo(_bb, _ptr, llvm::IntegerType::getInt8Ty(_gc.llvmContext()) ) );
   GTL_DEBUG(*params[0]);
-  llvm::CallInst *CallFunc = llvm::CallInst::Create(func, params.begin(), params.end(), "", _bb);
+  llvm::CallInst *CallFunc = llvm::CallInst::Create(func, params, "", _bb);
   CallFunc->setTailCall(false);
 #else
 #ifndef _USE_OS_MM_
@@ -1114,7 +1140,7 @@ void CodeGenerator::freeMemory( LLVMBack
 
 llvm::Function* createProgressReportFunction( llvm::Module* _module, const String& name )
 {
-  std::vector<const llvm::Type*> memcpyTyArgs;
+  std::vector< llvm::Type*> memcpyTyArgs;
   memcpyTyArgs.push_back(llvm::PointerType::get(llvm::Type::getInt8Ty(_module->getContext()), 0));
   llvm::FunctionType* memcpyTy = llvm::FunctionType::get( llvm::Type::getVoidTy(_module->getContext()), memcpyTyArgs, false);
   
@@ -1133,13 +1159,34 @@ llvm::BasicBlock* callProgressReport( LL
   
   std::vector<llvm::Value*> params;
   params.push_back( _a );
-  llvm::CallInst *CallFunc = llvm::CallInst::Create(_function, params.begin(), params.end(), "", ifblock);
+  llvm::CallInst *CallFunc = llvm::CallInst::Create(_function, params, "", ifblock);
   CallFunc->setTailCall(false);
+
+  // Test if canceled
+  llvm::BasicBlock* afterIfInterruptedBlock = _gc.createBasicBlock();
   
-  llvm::BasicBlock* afterBlock = _gc.createBasicBlock();
+  {
+    std::vector< llvm::Type*> memcpyTyArgs;
+    memcpyTyArgs.push_back(llvm::PointerType::get(llvm::Type::getInt8Ty(_gc.llvmContext()), 0));
+    llvm::FunctionType* memcpyTy = llvm::FunctionType::get( llvm::Type::getInt1Ty(_gc.llvmContext()), memcpyTyArgs, false);
+    
+    llvm::Function* func_interrupted = (llvm::Function*)_gc.llvmModule()->getOrInsertFunction(
+          "gtl_progress_report_interrupted", memcpyTy); // (external, no body)
+    func_interrupted->setCallingConv(llvm::CallingConv::C);
+    
+    llvm::BasicBlock* ifInterruptedBlock = _gc.createBasicBlock();
+    llvm::ReturnInst::Create(_gc.llvmContext(), ifInterruptedBlock);
+    
+    llvm::CallInst *CallInterruptedFunc = llvm::CallInst::Create(func_interrupted, params, "", ifblock);
+    CallInterruptedFunc->setTailCall(false);
+    
+    CodeGenerator::createIfStatement(ifblock, CallInterruptedFunc, Type::Boolean, ifInterruptedBlock, ifInterruptedBlock, afterIfInterruptedBlock);
+    
+  }
   
+  llvm::BasicBlock* afterBlock = _gc.createBasicBlock();
   
-  CodeGenerator::createIfStatement(_bb, test, Type::Boolean, ifblock, ifblock, afterBlock);
+  CodeGenerator::createIfStatement(_bb, test, Type::Boolean, ifblock, afterIfInterruptedBlock, afterBlock);
   
   return afterBlock;  
 }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/LLVMBackend/CodeGenerator_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/LLVMBackend/CodeGenerator_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/LLVMBackend/CodeGenerator_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/LLVMBackend/CodeGenerator_p.h	2012-01-10 11:12:02.127249307 -0500
@@ -108,7 +108,7 @@ namespace LLVMBackend {
        * Create a vector of @p _size values equal to @p _val
        * @param _valType the type of the @p _val
        */
-      static llvm::Value* createVector( int _size, llvm::Constant* _val, const GTLCore::Type* _valType);
+      static llvm::Value* createVector( int _size, llvm::Constant* _val);
       /**
        * Create a function and add it to the module.
        * @param name name of the function
@@ -120,7 +120,7 @@ namespace LLVMBackend {
       /**
        * Convert the pointer contained in @p value to a pointer of type @p type
        */
-      static llvm::Value* convertPointerTo(llvm::BasicBlock* currentBlock, llvm::Value* value, const llvm::Type* type);
+      static llvm::Value* convertPointerTo(llvm::BasicBlock* _currentBlock, llvm::Value* _value, llvm::Type* _type);
       static llvm::Value* convertValueTo(llvm::BasicBlock* currentBlock, llvm::Value* value, const GTLCore::Type* valueType, const GTLCore::Type* type);
       static llvm::Constant* convertConstantTo(llvm::Constant* constant, const GTLCore::Type* constantType, const GTLCore::Type* type);
       static llvm::Value* convertToHalf( LLVMBackend::GenerationContext& generationContext, llvm::BasicBlock* currentBlock, llvm::Value* value, const GTLCore::Type* _valueType);
@@ -266,6 +266,10 @@ namespace LLVMBackend {
        * @param _valuePtr pointer to the value
        */
       static llvm::BasicBlock* createClampExpression( LLVMBackend::GenerationContext& _context, llvm::BasicBlock* _current, llvm::Value* _valuePtr, const GTLCore::Type* _type, llvm::Value* _min, llvm::Value* _max);
+      /**
+       * Clamp a value
+       */
+      static llvm::Value* clampValue( LLVMBackend::GenerationContext& _context, LLVMBackend::ExpressionGenerationContext& _expressionGenerationContext, llvm::Value* _value, llvm::Value* _min, llvm::Value* _max);
     public:
       /**
        * Set the count field of a Structure/Array to a given value.
@@ -295,7 +299,25 @@ namespace LLVMBackend {
     public:
       ExpressionResult callFunction( LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& egc, const GTLCore::Function* _function, const std::list<GTLCore::AST::Expression*>& m_arguments );
     public:
-      static llvm::Value* allocateMemory( LLVMBackend::GenerationContext& _gc, const llvm::Type* _type, llvm::Value* _a, llvm::BasicBlock* _bb);
+      /**
+       * This function allocate memory using the @ref MemoryManager (or malloc depending on compilation options).
+       * For safety reason, only use @ref freeMemory to free memory allocated using @ref allocateMemory.
+       * For thread safety, only allocate/free a given memory block from the same thread, however the memory can
+       * be used from different threads, given that the usual threading precautions are taken.
+       *
+       * @param _type the type of the object to allocate
+       * @param _a the number of elements to allocate
+       * @return a pointer to the allocated memory
+       */
+      static llvm::Value* allocateMemory( LLVMBackend::GenerationContext& _gc, llvm::Type* _type, llvm::Value* _size, llvm::BasicBlock* _bb);
+      /**
+       * This function free memory using the @ref MemoryManager (or malloc depending on compilation options).
+       * For safety reason, only use @ref freeMemory to free memory allocated using @ref allocateMemory.
+       * For thread safety, only allocate/free a given memory block from the same thread, however the memory can
+       * be used from different threads, given that the usual threading precautions are taken.
+       *
+       * @param _ptr to the memory
+       */
       static void freeMemory( LLVMBackend::GenerationContext& _gc, llvm::Value* _ptr, llvm::BasicBlock* _bb);
     public:
       static llvm::BasicBlock* callProgressReportNextRow( LLVMBackend::GenerationContext& _gc, llvm::Value* _a, llvm::BasicBlock* _bb);
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/LLVMBackend/Visitor_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/LLVMBackend/Visitor_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/LLVMBackend/Visitor_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/LLVMBackend/Visitor_p.cpp	2012-01-10 11:12:02.127249307 -0500
@@ -115,7 +115,7 @@ ExpressionResult PrimitiveVisitor::get(
   return ExpressionResult( new llvm::LoadInst( _pointer, "PrimitiveVisitor::get", _currentBlock), _pointerType);
 }
 
-llvm::BasicBlock* PrimitiveVisitor::set( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, llvm::Value* _value, const Type* _valueType, bool _allocatedInMemory ) const
+llvm::BasicBlock* PrimitiveVisitor::set( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, llvm::Value* _value, const Type* _valueType ) const
 {
   GTL_ASSERT( _pointerType->dataType() != Type::STRUCTURE and _pointerType->dataType() != Type::ARRAY and _pointerType->dataType() != Type::VECTOR );
   GTL_DEBUG( *_pointer );
@@ -125,13 +125,13 @@ llvm::BasicBlock* PrimitiveVisitor::set(
   return _currentBlock;
 }
 
-llvm::BasicBlock* PrimitiveVisitor::initialise(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, const std::list< llvm::Value*>& _sizes, bool _allocatedInMemory) const
+llvm::BasicBlock* PrimitiveVisitor::initialise(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, const std::list< llvm::Value*>& _sizes) const
 {
   // Don't do nothing
   return _currentBlock;
 }
 
-llvm::BasicBlock* PrimitiveVisitor::cleanUp( LLVMBackend::GenerationContext& , llvm::BasicBlock* _currentBlock, llvm::Value* , const Type* , llvm::Value* , bool, bool /*_ignoreCount*/, bool /*_deletePointer*/ ) const
+llvm::BasicBlock* PrimitiveVisitor::cleanUp( LLVMBackend::GenerationContext& , llvm::BasicBlock* _currentBlock, llvm::Value* , const Type* , llvm::Value* , bool /*_ignoreCount*/, bool /*_deletePointer*/ ) const
 {
   return _currentBlock;
 }
@@ -171,7 +171,7 @@ ExpressionResult ArrayVisitor::get( LLVM
   return ExpressionResult(_pointer, _pointerType);
 }
 
-llvm::BasicBlock* ArrayVisitor::set( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, llvm::Value* _value, const Type* _valueType, bool _allocatedInMemory) const
+llvm::BasicBlock* ArrayVisitor::set( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, llvm::Value* _value, const Type* _valueType) const
 {
     // Check if size are identical or update the size of this array
     {
@@ -181,9 +181,9 @@ llvm::BasicBlock* ArrayVisitor::set( LLV
       std::list<llvm::Value*> sizes;
       sizes.push_back( getSize( _generationContext, ifContent, _value ) );
       
-      llvm::BasicBlock* endIfContent = cleanUp(_generationContext, ifContent, _pointer, _pointerType, 0, _allocatedInMemory, true, false );
+      llvm::BasicBlock* endIfContent = cleanUp(_generationContext, ifContent, _pointer, _pointerType, 0, true, false );
       
-      endIfContent = initialise( _generationContext, endIfContent, _pointer, _pointerType, sizes, _allocatedInMemory );
+      endIfContent = initialise( _generationContext, endIfContent, _pointer, _pointerType, sizes );
       
       llvm::BasicBlock* afterIf = llvm::BasicBlock::Create( _generationContext.llvmContext() );
       _generationContext.llvmFunction()->getBasicBlockList().push_back( afterIf);
@@ -209,7 +209,7 @@ llvm::BasicBlock* ArrayVisitor::set( LLV
           visitor->get( _generationContext, bodyBlock, 
                   _generationContext.codeGenerator()->accessArrayValueNoClamp(
                                     bodyBlock, _value, index->get( _generationContext, bodyBlock ) ), _pointerType->embeddedType() ).value(),
-          _valueType->embeddedType(), _allocatedInMemory );
+          _valueType->embeddedType());
     
     // Create the for statement
     llvm::BasicBlock* returnBlock = CodeGenerator::createIterationForStatement(
@@ -224,7 +224,7 @@ llvm::BasicBlock* ArrayVisitor::set( LLV
     return returnBlock;
 }
 
-llvm::BasicBlock* ArrayVisitor::setSize(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, llvm::Value* _size, bool _allocatedInMemory) const
+llvm::BasicBlock* ArrayVisitor::setSize(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, llvm::Value* _size) const
 {
   GTL_ASSERT( _pointerType->dataType() == Type::ARRAY );
   GTL_DEBUG( *_size );
@@ -233,22 +233,16 @@ llvm::BasicBlock* ArrayVisitor::setSize(
   indexes.push_back( llvm::ConstantInt::get(llvm::Type::getInt32Ty(_generationContext.llvmContext()), ArrayWrap::POS_SIZE)); // Access the size of the array
   { // Init the size
     GTL_DEBUG( *_pointer );
-    llvm::Value* ptr = llvm::GetElementPtrInst::Create( _pointer, indexes.begin(), indexes.end(), "ArrayVisitor::setSize", _currentBlock);
+    llvm::Value* ptr = llvm::GetElementPtrInst::Create( _pointer, indexes, "ArrayVisitor::setSize", _currentBlock);
     new llvm::StoreInst(_generationContext.codeGenerator()->convertValueTo( _currentBlock, _size, Type::Integer32, Type::Integer32 ), ptr, "", _currentBlock);
   }
   // Allocate the Array
   indexes[1] = llvm::ConstantInt::get(llvm::Type::getInt32Ty(_generationContext.llvmContext()), ArrayWrap::POS_DATA);
   {
-    llvm::Value* ptr = llvm::GetElementPtrInst::Create( _pointer, indexes.begin(), indexes.end(), "ArrayVisitor::setSize", _currentBlock);
+    llvm::Value* ptr = llvm::GetElementPtrInst::Create( _pointer, indexes, "ArrayVisitor::setSize", _currentBlock);
     llvm::Value* array = 0;
-    if( _allocatedInMemory )
-    {
-      array = CodeGenerator::allocateMemory( _generationContext,
-                    _pointerType->embeddedType()->d->type(_generationContext.llvmContext()), _size, _currentBlock);
-    } else {
-      array = new llvm::AllocaInst(
-                    _pointerType->embeddedType()->d->type(_generationContext.llvmContext()), _size, "ArrayVisitor::setSize", _currentBlock);
-    }
+    array = CodeGenerator::allocateMemory( _generationContext,
+                  _pointerType->embeddedType()->d->type(_generationContext.llvmContext()), _size, _currentBlock);
     new llvm::StoreInst( array, ptr, "ArrayVisitor::setSize", _currentBlock);
   }
   return _currentBlock;
@@ -259,7 +253,7 @@ llvm::Value* ArrayVisitor::getSize(LLVMB
   return CodeGenerator::accessArraySize(currentBlock, _pointer);
 }
 
-llvm::BasicBlock* ArrayVisitor::initialise(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, const std::list< llvm::Value*>& _sizes, bool _allocatedInMemory) const
+llvm::BasicBlock* ArrayVisitor::initialise(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, const std::list< llvm::Value*>& _sizes) const
 {
   GTL_ASSERT( _pointerType->dataType() == Type::ARRAY );
   GTL_DEBUG( _sizes.empty() );
@@ -267,7 +261,7 @@ llvm::BasicBlock* ArrayVisitor::initiali
   if( not _sizes.empty())
   {
     llvm::Value* currentSize = _sizes.front();
-    _currentBlock = setSize( _generationContext, _currentBlock, _pointer, _pointerType, currentSize, _allocatedInMemory );
+    _currentBlock = setSize( _generationContext, _currentBlock, _pointer, _pointerType, currentSize );
     std::list< llvm::Value*> sizeAfter = _sizes;
     sizeAfter.pop_front();
     //   int i = 0;
@@ -285,7 +279,7 @@ llvm::BasicBlock* ArrayVisitor::initiali
             _generationContext.codeGenerator()->accessArrayValueNoClamp(
                       bodyBlock, _pointer, index->get( _generationContext, bodyBlock ) ),
             _pointerType->embeddedType(),
-            sizeAfter, _allocatedInMemory );
+            sizeAfter );
     
     // Create the for statement
     llvm::BasicBlock* returnBB = CodeGenerator::createIterationForStatement(
@@ -303,13 +297,13 @@ llvm::BasicBlock* ArrayVisitor::initiali
     indexes.push_back( llvm::ConstantInt::get(llvm::Type::getInt32Ty(_generationContext.llvmContext()), 0)); // Access the structure of the array
     indexes.push_back( llvm::ConstantInt::get(llvm::Type::getInt32Ty(_generationContext.llvmContext()), ArrayWrap::POS_SIZE)); // Access the size of the array
     // Init the size
-    llvm::Value* ptr = llvm::GetElementPtrInst::Create( _pointer, indexes.begin(), indexes.end(), "ArrayVisitor::initialise", _currentBlock);
+    llvm::Value* ptr = llvm::GetElementPtrInst::Create( _pointer, indexes, "ArrayVisitor::initialise", _currentBlock);
     new llvm::StoreInst( CodeGenerator::integerToConstant( _generationContext.llvmContext(), INT32_C(0) ), ptr, "ArrayVisitor::initialise", _currentBlock);
   }
   return _currentBlock;
 }
 
-llvm::BasicBlock* ArrayVisitor::cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, llvm::Value* _donttouch, bool _allocatedInMemory, bool _ignoreCount, bool _deletePointer ) const
+llvm::BasicBlock* ArrayVisitor::cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, llvm::Value* _donttouch, bool _ignoreCount, bool _deletePointer ) const
 {
   // TODO use _donttouch in the array as well
     //   int i = 0;
@@ -346,7 +340,7 @@ llvm::BasicBlock* ArrayVisitor::cleanUp(
           _generationContext,
           bodyBlock, 
           _generationContext.codeGenerator()->accessArrayValueNoClamp( bodyBlock, _pointer, index->get( _generationContext, bodyBlock  ) ),
-          _pointerType->embeddedType(), _donttouch, _allocatedInMemory, _ignoreCount, false );
+          _pointerType->embeddedType(), _donttouch, _ignoreCount, false );
     // Create the for statement
     llvm::BasicBlock*  afterBlock = CodeGenerator::createIterationForStatement(
                     _generationContext,
@@ -356,18 +350,15 @@ llvm::BasicBlock* ArrayVisitor::cleanUp(
                     Type::Integer32,
                     bodyBlock,
                     endBodyBlock );
-    if( _allocatedInMemory )
+    std::vector<llvm::Value*> indexes;
+    indexes.push_back( llvm::ConstantInt::get(llvm::Type::getInt32Ty(_generationContext.llvmContext()), 0)); // Access the structure of the array
+    indexes.push_back( llvm::ConstantInt::get(llvm::Type::getInt32Ty(_generationContext.llvmContext()), ArrayWrap::POS_DATA )); // Access the data of the array
+    // Free the array
+    llvm::Value* ptrToData = llvm::GetElementPtrInst::Create( _pointer, indexes, "ArrayVisitor::cleanUp", afterBlock);
+    CodeGenerator::freeMemory(_generationContext, new llvm::LoadInst( ptrToData, "ArrayVisitor::cleanUp", afterBlock ), afterBlock );
+    if( _deletePointer )
     {
-      std::vector<llvm::Value*> indexes;
-      indexes.push_back( llvm::ConstantInt::get(llvm::Type::getInt32Ty(_generationContext.llvmContext()), 0)); // Access the structure of the array
-      indexes.push_back( llvm::ConstantInt::get(llvm::Type::getInt32Ty(_generationContext.llvmContext()), ArrayWrap::POS_DATA )); // Access the data of the array
-      // Free the array
-      llvm::Value* ptrToData = llvm::GetElementPtrInst::Create( _pointer, indexes.begin(), indexes.end(), "ArrayVisitor::cleanUp", afterBlock);
-      CodeGenerator::freeMemory(_generationContext, new llvm::LoadInst( ptrToData, "ArrayVisitor::cleanUp", afterBlock ), afterBlock );
-      if( _deletePointer )
-      {
-        CodeGenerator::freeMemory( _generationContext, _pointer, afterBlock );
-      }
+      CodeGenerator::freeMemory( _generationContext, _pointer, afterBlock );
     }
     
     llvm::BasicBlock* afterIfBlock = llvm::BasicBlock::Create(_generationContext.llvmContext(), "afterIfBlock");
@@ -442,10 +433,10 @@ llvm::Constant* ArrayVisitor::createStat
   std::vector<llvm::Constant*> indices;
   indices.push_back( CodeGenerator::integerToConstant( _module->getContext(), INT32_C(0) ) );
   indices.push_back( CodeGenerator::integerToConstant( _module->getContext(), INT32_C(0) ) );
-  initialisers.push_back( llvm::ConstantExpr::getGetElementPtr(arrayData, &indices[0], indices.size() ) );
+  initialisers.push_back( llvm::ConstantExpr::getGetElementPtr(arrayData, indices, indices.size() ) );
   
   GTL_DEBUG(* initialisers[2] << " " <<  *type->d->type(_module->getContext()));
-  return llvm::ConstantStruct::get( dynamic_cast<const llvm::StructType*>(type->d->type(_module->getContext())), initialisers );
+  return llvm::ConstantStruct::get( llvm::cast<llvm::StructType>(type->d->type(_module->getContext())), initialisers );
 }
 
 //--------- VectorVisitor ---------///
@@ -474,7 +465,7 @@ ExpressionResult VectorVisitor::get( LLV
   return ExpressionResult(new llvm::LoadInst( _pointer, "VectorVisitor::get", _currentBlock), _pointerType );
 }
 
-llvm::BasicBlock* VectorVisitor::set(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, llvm::Value* _value, const Type* _valueType, bool _allocatedInMemory) const
+llvm::BasicBlock* VectorVisitor::set(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, llvm::Value* _value, const Type* _valueType) const
 {
   GTL_ASSERT( _pointerType->dataType() == Type::VECTOR );
   GTL_DEBUG( "value = " << *_value << " type = " << *_valueType );
@@ -484,13 +475,13 @@ llvm::BasicBlock* VectorVisitor::set(LLV
   return _currentBlock;
 }
 
-llvm::BasicBlock* VectorVisitor::initialise( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, const std::list< llvm::Value*>& _sizes, bool _allocatedInMemory) const
+llvm::BasicBlock* VectorVisitor::initialise( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, const std::list< llvm::Value*>& _sizes) const
 {
   // Don't do nothing
   return _currentBlock;
 }
 
-llvm::BasicBlock* VectorVisitor::cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, llvm::Value* _donttouch, bool _allocatedInMemory, bool /*_ignoreCount*/, bool /*_deletePointer*/ ) const
+llvm::BasicBlock* VectorVisitor::cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, llvm::Value* _donttouch, bool /*_ignoreCount*/, bool /*_deletePointer*/ ) const
 {
   // Don't do nothing
   return _currentBlock;
@@ -511,7 +502,7 @@ llvm::Constant* VectorVisitor::createSta
     constants.push_back( visitor->createStaticVariable( _module, _type->embeddedType(), std::list<int>() ) );
   }
   GTL_ASSERT( not constants.empty());
-  return llvm::ConstantVector::get( dynamic_cast<const llvm::VectorType*>(_type->d->type(_module->getContext()) ), constants);
+  return llvm::ConstantVector::get( constants);
 }
 
 //--------- StructureVisitor ---------///
@@ -531,12 +522,12 @@ const Type* StructureVisitor::pointerToI
 
 llvm::Value* StructureVisitor::pointerToValue( LLVMBackend::GenerationContext& _generationContext,
                                                 llvm::BasicBlock* _currentBlock,
-                                                llvm::Value* _pointer, int _index ) const
+                                                llvm::Value* _pointer, int _index )
 {
   std::vector<llvm::Value*> indexes;
   indexes.push_back( llvm::ConstantInt::get(llvm::Type::getInt32Ty(_generationContext.llvmContext()), 0));
   indexes.push_back( llvm::ConstantInt::get(llvm::Type::getInt32Ty(_generationContext.llvmContext()), _index + STRUCT_FIRST_ELEMENT ));
-  return llvm::GetElementPtrInst::Create( _pointer, indexes.begin(), indexes.end(), "StructureVisitor::pointerToValue", _currentBlock);
+  return llvm::GetElementPtrInst::Create( _pointer, indexes, "StructureVisitor::pointerToValue", _currentBlock);
 }
 
 llvm::Value* StructureVisitor::pointerToIndex(LLVMBackend::GenerationContext& _generationContext, LLVMBackend::ExpressionGenerationContext& _expressionGenerationContext, llvm::Value* _pointer, const Type* _type, llvm::Value* _index) const
@@ -550,7 +541,7 @@ ExpressionResult StructureVisitor::get(
   return ExpressionResult(_pointer, _pointerType);
 }
 
-llvm::BasicBlock* StructureVisitor::set( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, llvm::Value* _value, const Type* _valueType, bool _allocatedInMemory ) const
+llvm::BasicBlock* StructureVisitor::set( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, llvm::Value* _value, const Type* _valueType) const
 {
   GTL_ASSERT( _pointerType->dataType() == Type::STRUCTURE );
   for(std::size_t i = 0; i < _pointerType->countStructDataMembers(); ++i)
@@ -560,12 +551,12 @@ llvm::BasicBlock* StructureVisitor::set(
     llvm::Value* nptrToValueMember = pointerToValue( _generationContext, _currentBlock, _value, i);
     const Visitor* visitor = Visitor::getVisitorFor( type );
     llvm::Value* memberValue = visitor->get( _generationContext, _currentBlock, nptrToValueMember, type ).value();
-    _currentBlock = visitor->set( _generationContext, _currentBlock, nptrToOwnMember, type, memberValue, type, _allocatedInMemory );
+    _currentBlock = visitor->set( _generationContext, _currentBlock, nptrToOwnMember, type, memberValue, type);
   }
   return _currentBlock;
 }
 
-llvm::BasicBlock* StructureVisitor::initialise(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, const std::list< llvm::Value*>& _sizes, bool _allocatedInMemory) const
+llvm::BasicBlock* StructureVisitor::initialise(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, const std::list< llvm::Value*>& _sizes) const
 {
   GTL_ASSERT( _pointerType->dataType() == Type::STRUCTURE );
   
@@ -582,13 +573,13 @@ llvm::BasicBlock* StructureVisitor::init
     const Visitor* visitor = Visitor::getVisitorFor( type );
     _currentBlock = visitor->initialise( _generationContext, _currentBlock,
                             pointerToValue( _generationContext, _currentBlock, _pointer, i ),
-                            type, sizes, _allocatedInMemory );
+                            type, sizes );
   }
   CodeGenerator::setCountFieldOf( _currentBlock, _pointer, CodeGenerator::integerToConstant( _generationContext.llvmContext(), INT32_C(1) ) );
   return _currentBlock;
 }
 
-llvm::BasicBlock* StructureVisitor::cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, llvm::Value* _donttouch, bool _allocatedInMemory, bool _ignoreCount, bool _deletePointer ) const
+llvm::BasicBlock* StructureVisitor::cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const Type* _pointerType, llvm::Value* _donttouch, bool _ignoreCount, bool _deletePointer ) const
 {
   // TODO use ignoreCount
 #ifdef OPENGTL_ENABLE_DEBUG_OUTPUT
@@ -614,12 +605,12 @@ llvm::BasicBlock* StructureVisitor::clea
   {
     const Type* type = _pointerType->structDataMember(i).type();
     const Visitor* visitor = Visitor::getVisitorFor( type );
-    lastIfBlock = visitor->cleanUp( _generationContext, lastIfBlock, pointerToValue( _generationContext, lastIfBlock, _pointer, i ), type, _donttouch, _allocatedInMemory, _ignoreCount, false );
+    lastIfBlock = visitor->cleanUp( _generationContext, lastIfBlock, pointerToValue( _generationContext, lastIfBlock, _pointer, i ), type, _donttouch, _ignoreCount, false );
   }
   
   llvm::BasicBlock* afterIfBlock = llvm::BasicBlock::Create(_generationContext.llvmContext(), "afterIfBlockStructureVisitorCleanUp");
   _generationContext.llvmFunction()->getBasicBlockList().push_back( afterIfBlock);
-  if( _allocatedInMemory and _deletePointer )
+  if( _deletePointer )
   {
     CodeGenerator::freeMemory( _generationContext, _pointer, lastIfBlock );
   }
@@ -651,5 +642,5 @@ llvm::Constant* StructureVisitor::create
     const Visitor* visitor = Visitor::getVisitorFor( type );
     initialisers.push_back( visitor->createStaticVariable( _module, type, _type->structDataMember(i).initialSizes() ) );
   }
-  return llvm::ConstantStruct::get( dynamic_cast<const llvm::StructType*>(_type->d->type(_module->getContext())), initialisers );
+  return llvm::ConstantStruct::get( llvm::cast<llvm::StructType>(_type->d->type(_module->getContext())), initialisers );
 }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/LLVMBackend/Visitor_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/LLVMBackend/Visitor_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/LLVMBackend/Visitor_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/LLVMBackend/Visitor_p.h	2012-01-10 11:12:02.127249307 -0500
@@ -88,7 +88,7 @@ namespace LLVMBackend {
        * @param _value the new value
        * @param _ma
        */
-      virtual llvm::BasicBlock* set(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _value, const GTLCore::Type* _valueType, bool _allocatedInMemory) const = 0;
+      virtual llvm::BasicBlock* set(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _value, const GTLCore::Type* _valueType) const = 0;
       /**
        * initialise a the data which is pointed by this Visitor.
        * @param _errMsg a pointer to a pointer (usually initialised to 0), the pointer will be
@@ -98,8 +98,8 @@ namespace LLVMBackend {
        * @param _pointer a pointer toward the data
        * @param _size the size of the array, if applicable
        */
-      virtual llvm::BasicBlock* initialise(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, const std::list< llvm::Value*>& _sizes, bool _allocatedInMemory) const = 0;
-      virtual llvm::BasicBlock* cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _donttouch, bool _allocatedInMemory, bool _ignoreCount, bool _deletePointer ) const = 0;
+      virtual llvm::BasicBlock* initialise(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, const std::list< llvm::Value*>& _sizes) const = 0;
+      virtual llvm::BasicBlock* cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _donttouch, bool _ignoreCount, bool _deletePointer ) const = 0;
       virtual llvm::BasicBlock* mark( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* increment ) const = 0;
       /**
        * Create a static variable. (ie static float v;)
@@ -125,9 +125,9 @@ namespace LLVMBackend {
       virtual llvm::Value* pointerToIndex(LLVMBackend::GenerationContext& _generationContext, LLVMBackend::ExpressionGenerationContext& _expressionGenerationContext, llvm::Value* _pointer, const GTLCore::Type* _type, llvm::Value* _index) const;
       virtual LLVMBackend::ExpressionResult get( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* currentBlock,
                                 llvm::Value* pointer, const GTLCore::Type* _pointerType) const;
-      virtual llvm::BasicBlock* set(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* currentBlock, llvm::Value* pointer, const GTLCore::Type* _pointerType, llvm::Value*, const GTLCore::Type* _valueType, bool _allocatedInMemory) const;
-      virtual llvm::BasicBlock* initialise(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, const std::list< llvm::Value*>& _sizes, bool _allocatedInMemory) const;
-      virtual llvm::BasicBlock* cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _donttouch, bool _allocatedInMemory, bool _ignoreCount, bool _deletePointer ) const;
+      virtual llvm::BasicBlock* set(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* currentBlock, llvm::Value* pointer, const GTLCore::Type* _pointerType, llvm::Value*, const GTLCore::Type* _valueType) const;
+      virtual llvm::BasicBlock* initialise(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, const std::list< llvm::Value*>& _sizes) const;
+      virtual llvm::BasicBlock* cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _donttouch, bool _ignoreCount, bool _deletePointer ) const;
       virtual llvm::BasicBlock* mark( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* increment ) const;
       virtual llvm::Constant* createStaticVariable( llvm::Module*, const GTLCore::Type* type, const std::list< int>& _sizes ) const;
   };
@@ -144,9 +144,9 @@ namespace LLVMBackend {
       virtual const GTLCore::Type* pointerToIndexType( const GTLCore::Type* _type ) const;
       virtual llvm::Value* pointerToIndex(LLVMBackend::GenerationContext& _generationContext, LLVMBackend::ExpressionGenerationContext& _expressionGenerationContext, llvm::Value* _pointer, const GTLCore::Type* _type, llvm::Value* _index) const;
       virtual LLVMBackend::ExpressionResult get( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType) const;
-      virtual llvm::BasicBlock* set(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value*, const GTLCore::Type* _valueType, bool _allocatedInMemory) const;
-      virtual llvm::BasicBlock* initialise( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, const std::list< llvm::Value*>& _sizes, bool _allocatedInMemory) const;
-      virtual llvm::BasicBlock* cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _donttouch, bool _allocatedInMemory, bool _ignoreCount, bool _deletePointer ) const;
+      virtual llvm::BasicBlock* set(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value*, const GTLCore::Type* _valueType) const;
+      virtual llvm::BasicBlock* initialise( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, const std::list< llvm::Value*>& _sizes) const;
+      virtual llvm::BasicBlock* cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _donttouch, bool _ignoreCount, bool _deletePointer ) const;
       virtual llvm::BasicBlock* mark( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* increment ) const;
       virtual llvm::Constant* createStaticVariable( llvm::Module*, const GTLCore::Type* type, const std::list< int>& _sizes ) const;
     private:
@@ -169,7 +169,7 @@ namespace LLVMBackend {
        * @param _pointer a pointer toward the data
        * @param _size the new size of the array
        */
-      llvm::BasicBlock* setSize(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _size, bool _allocatedInMemory) const;
+      llvm::BasicBlock* setSize(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _size) const;
   };
 
   /**
@@ -184,9 +184,9 @@ namespace LLVMBackend {
       virtual const GTLCore::Type* pointerToIndexType( const GTLCore::Type* _type ) const;
       virtual llvm::Value* pointerToIndex(LLVMBackend::GenerationContext& _generationContext, LLVMBackend::ExpressionGenerationContext& _expressionGenerationContext, llvm::Value* _pointer, const GTLCore::Type* _type, llvm::Value* _index) const;
       virtual LLVMBackend::ExpressionResult get( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* currentBlock, llvm::Value* pointer, const GTLCore::Type* _pointerType) const;
-      virtual llvm::BasicBlock* set(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* currentBlock, llvm::Value* pointer, const GTLCore::Type* _pointerType, llvm::Value*, const GTLCore::Type* _valueType, bool _allocatedInMemory) const;
-      virtual llvm::BasicBlock* initialise( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, const std::list< llvm::Value*>& _sizes, bool _allocatedInMemory) const;
-      virtual llvm::BasicBlock* cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _donttouch, bool _allocatedInMemory, bool _ignoreCount, bool _deletePointer ) const;
+      virtual llvm::BasicBlock* set(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* currentBlock, llvm::Value* pointer, const GTLCore::Type* _pointerType, llvm::Value*, const GTLCore::Type* _valueType) const;
+      virtual llvm::BasicBlock* initialise( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, const std::list< llvm::Value*>& _sizes) const;
+      virtual llvm::BasicBlock* cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _donttouch, bool _ignoreCount, bool _deletePointer ) const;
       virtual llvm::BasicBlock* mark( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* increment ) const;
       virtual llvm::Constant* createStaticVariable( llvm::Module*, const GTLCore::Type* type, const std::list< int>& _sizes ) const;
   };
@@ -203,13 +203,13 @@ namespace LLVMBackend {
       virtual const GTLCore::Type* pointerToIndexType( const GTLCore::Type* _type ) const;
       virtual llvm::Value* pointerToIndex(LLVMBackend::GenerationContext& _generationContext,LLVMBackend::ExpressionGenerationContext& _expressionGenerationContext, llvm::Value* _pointer, const GTLCore::Type* _type, llvm::Value* _index) const;
       virtual LLVMBackend::ExpressionResult get( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* currentBlock, llvm::Value* pointer, const GTLCore::Type* _pointerType) const;
-      virtual llvm::BasicBlock* set(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* currentBlock, llvm::Value* pointer, const GTLCore::Type* _pointerType, llvm::Value*, const GTLCore::Type* _valueType, bool _allocatedInMemory) const;
-      virtual llvm::BasicBlock* initialise( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, const std::list< llvm::Value*>& _sizes, bool _allocatedInMemory) const;
-      virtual llvm::BasicBlock* cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _donttouch, bool _allocatedInMemory, bool _ignoreCount, bool _deletePointer ) const;
+      virtual llvm::BasicBlock* set(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* currentBlock, llvm::Value* pointer, const GTLCore::Type* _pointerType, llvm::Value*, const GTLCore::Type* _valueType) const;
+      virtual llvm::BasicBlock* initialise( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, const std::list< llvm::Value*>& _sizes) const;
+      virtual llvm::BasicBlock* cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _donttouch, bool _ignoreCount, bool _deletePointer ) const;
       virtual llvm::BasicBlock* mark( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* increment ) const;
       virtual llvm::Constant* createStaticVariable( llvm::Module*, const GTLCore::Type* type, const std::list< int>& _sizes ) const;
-    private:
-      llvm::Value* pointerToValue(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, int index ) const;
+    public:
+      static llvm::Value* pointerToValue(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, int index );
   };
 
 }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Lut.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Lut.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Lut.h.95a8c6853b97	2012-01-10 11:12:02.127249307 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Lut.h	2012-01-10 11:12:02.127249307 -0500
@@ -0,0 +1,37 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.bet
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+*/
+
+// The file lut.h comes from http://bitbucket.org/cyrille/lut, keep it as much untouched as possible for easier sync
+
+#ifndef _GTLCORE_LUT_H_
+#define _GTLCORE_LUT_H_
+
+#define _USE_CUSTOM_TYPES_
+
+#include <GTLCore/StdTypes.h>
+
+typedef gtl_uint8 lut_uint8;
+typedef gtl_uint16 lut_uint16;
+typedef gtl_uint32 lut_uint32;
+
+namespace GTLCore {
+  #include "lut_impl.h"
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/lut_impl.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/lut_impl.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/lut_impl.h.95a8c6853b97	2012-01-10 11:12:02.128249299 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/lut_impl.h	2012-01-10 11:12:02.128249299 -0500
@@ -0,0 +1,334 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LUT_H_
+#define _LUT_H_
+
+template<typename _InputT_>
+class LutKey;
+
+template<typename _InputT_>
+class FullLutKey;
+
+/**
+ * Provide an implementation for a look-up table for a function. Do not use directly, instead
+ * use @ref Lut when you are not interested in having the full look-up table or for floating
+ * point, or use @ref FullLut for 8bits and 16bits when you want to have a full Lut.
+ *
+ * @code
+ * struct MyFunction {
+ *  inline static int compute(int i)
+ *  {
+ *    return 1-i;
+ *  }
+ * }
+ * Lut<MyFunction, int, int> myLut;
+ * @endcode
+ */
+template<typename _FunctionT_, typename _OutputT_, typename _InputT_, typename _LutKeyT_ >
+class BaseLut {
+  private:
+    /**
+     * Initialization of the table.
+     */
+    inline void init()
+    {
+      int size = m_key.size();
+      m_table = new _OutputT_[size];
+      for(int i = 0; i < size; ++i)
+      {
+        m_table[i] = m_function(m_key.keyToInput(i));
+      }
+    }
+  public:
+    /**
+     * Create the lut with the specific key.
+     */
+    inline BaseLut(_LutKeyT_ key, _FunctionT_ function = _FunctionT_()) : m_key(key), m_function(function)
+    {
+      init();
+    }
+    inline ~BaseLut() {
+      delete[] m_table;
+    }
+  public:
+    /**
+     * @return the function value for parameter @p i
+     */
+    inline _OutputT_ operator()(_InputT_ i) const
+    {
+      if(m_key.inrange(i))
+      {
+        return m_table[m_key.inputToKey(i)];
+      }
+      return m_function(i);
+    }
+  private:
+    _OutputT_* m_table;
+    _LutKeyT_ m_key;
+    _FunctionT_ m_function;
+};
+
+/**
+ * This Lut is limited to a range of values.
+ */
+template<typename _FunctionT_, typename _OutputT_, typename _InputT_>
+class Lut : public BaseLut<_FunctionT_, _OutputT_, _InputT_, LutKey<_InputT_> > {
+  public:
+    /**
+     * Create the lut between @p _min and @p _max .
+     */
+    inline Lut(_InputT_ _min, _InputT_ _max, _FunctionT_ function = _FunctionT_()) :
+        BaseLut<_FunctionT_, _OutputT_, _InputT_, LutKey<_InputT_> >( LutKey<_InputT_>(_min, _max), function)
+    {
+    }
+    inline Lut(LutKey<_InputT_> key, _FunctionT_ function = _FunctionT_()) :
+        BaseLut<_FunctionT_, _OutputT_, _InputT_, LutKey<_InputT_> >( key, function)
+    {
+    }
+};
+
+/**
+ * This Lut has precomputed values for all elements.
+ */
+template<typename _FunctionT_, typename _OutputT_, typename _InputT_>
+class FullLut : public BaseLut<_FunctionT_, _OutputT_, _InputT_, FullLutKey<_InputT_> > {
+  public:
+    inline FullLut( _FunctionT_ function = _FunctionT_()) :
+        BaseLut<_FunctionT_, _OutputT_, _InputT_, FullLutKey<_InputT_> >( FullLutKey<_InputT_>(), function)
+    {
+    }
+};
+
+#ifdef _USE_QT_TYPES_
+typedef quint8 lut_uint8;
+typedef quint16 lut_uint16;
+typedef quint32 lut_uint32;
+#else
+#ifndef _USE_CUSTOM_TYPES_
+#include <stdint.h>
+typedef uint8_t lut_uint8;
+typedef uint16_t lut_uint16;
+typedef uint32_t lut_uint32;
+#endif
+#endif
+
+// integer specialization
+
+#define PARTIAL_LUT_INT_SPECIALIZATION(_INT_TYPE_)                                \
+  template<>                                                                      \
+  class LutKey<_INT_TYPE_> {                                               \
+    public:                                                                       \
+      LutKey<_INT_TYPE_>(_INT_TYPE_ min, _INT_TYPE_ max) : m_min(min), m_max(max) \
+      {                                                                           \
+      }                                                                           \
+    public:                                                                       \
+      inline int inputToKey(_INT_TYPE_ i) const                                   \
+      {                                                                           \
+        return i - m_min;                                                         \
+      }                                                                           \
+      inline _INT_TYPE_ keyToInput(int k) const                                   \
+      {                                                                           \
+        return k + m_min;                                                         \
+      }                                                                           \
+      inline bool inrange(_INT_TYPE_ i) const                                     \
+      {                                                                           \
+        return i >= m_min && i <= m_max;                                          \
+      }                                                                           \
+      inline _INT_TYPE_ minimum() const                                           \
+      {                                                                           \
+        return m_min;                                                             \
+      }                                                                           \
+      inline _INT_TYPE_ maximum() const                                           \
+      {                                                                           \
+        return m_max;                                                             \
+      }                                                                           \
+      inline int size() const                                                     \
+      {                                                                           \
+        return m_max - m_min + 1;                                                 \
+      }                                                                           \
+    private:                                                                      \
+      _INT_TYPE_ m_min, m_max;                                                    \
+  };
+
+PARTIAL_LUT_INT_SPECIALIZATION(lut_uint8)
+PARTIAL_LUT_INT_SPECIALIZATION(lut_uint16)
+PARTIAL_LUT_INT_SPECIALIZATION(lut_uint32)
+
+#define FULL_LUT_INT_SPECIALIZATION(_INT_TYPE_, _MIN_, _MAX_)                     \
+  template<>                                                                      \
+  class FullLutKey<_INT_TYPE_> {                                                  \
+    public:                                                                       \
+      FullLutKey<_INT_TYPE_>()                                                    \
+      {                                                                           \
+      }                                                                           \
+    public:                                                                       \
+      inline int inputToKey(_INT_TYPE_ i) const                                   \
+      {                                                                           \
+        return i - _MIN_;                                                         \
+      }                                                                           \
+      inline _INT_TYPE_ keyToInput(int k) const                                   \
+      {                                                                           \
+        return k + _MIN_;                                                         \
+      }                                                                           \
+      inline bool inrange(_INT_TYPE_ ) const                                      \
+      {                                                                           \
+        return true;                                                              \
+      }                                                                           \
+      inline _INT_TYPE_ minimum() const                                           \
+      {                                                                           \
+        return _MIN_;                                                             \
+      }                                                                           \
+      inline _INT_TYPE_ maximum() const                                           \
+      {                                                                           \
+        return _MAX_;                                                             \
+      }                                                                           \
+      inline int size() const                                                     \
+      {                                                                           \
+        return _MAX_ - _MIN_ + 1;                                                 \
+      }                                                                           \
+    private:                                                                      \
+  };
+
+FULL_LUT_INT_SPECIALIZATION(lut_uint8, 0, 255)
+FULL_LUT_INT_SPECIALIZATION(lut_uint16, 0, 65535)
+
+// float specialization
+
+/**
+ * This provide an implementation for a LutKey for floating point input values.
+ *
+ * Based on "High-speed Conversion of Floating Point Images to 8-bit" by Bill Spitzaks
+ * (http://mysite.verizon.net/spitzak/conversion/)
+ */
+template<>
+class LutKey<float> {
+  public:
+    union IFNumber {
+      lut_uint32 i;
+      float f;
+    };
+  public:
+    LutKey<float>(float min, float max, float precision = 0.0001f) : m_min(min), m_max(max), m_precision(precision)
+    {
+      // Those values where computed using the test_linear and setting the shift and then using
+      // the standard deviation.
+      if (precision <= 0.000011809f) {
+        m_min =  1;
+        m_max = -1;
+      }
+      else if (precision <= 0.0000237291f) m_shift =  8;
+      else if (precision <= 0.0000475024f) m_shift =  9;
+      else if (precision <= 0.0000948575f) m_shift = 10;
+      else if (precision <= 0.00019013f) m_shift = 11;
+      else if (precision <= 0.000379523f) m_shift = 12;
+      else if (precision <= 0.000758431f) m_shift = 13;
+      else if (precision <= 0.00151891f) m_shift = 14;
+      else if (precision <= 0.00303725f) m_shift = 15;
+      else m_shift = 16;
+
+      if ( 0.0 <= m_min && m_min <= precision)
+        m_min = precision;
+      if ( -precision <= m_max && m_max <= 0.0)
+        m_max = -precision;
+      
+      IFNumber uf;
+      
+      if(m_min > 0 && m_max > 0)
+      {
+        uf.f = m_min;
+        m_tMin_p = uf.i >> m_shift;
+        uf.f = m_max;
+        m_tMax_p = uf.i >> m_shift;
+        m_tMin_n = m_tMax_p;
+        m_tMax_n = m_tMax_p;
+     } else if( m_max < 0)
+      {
+        uf.f = m_min;
+        m_tMax_n = uf.i >> m_shift;
+        uf.f = m_max;
+        m_tMin_n = uf.i >> m_shift;
+        m_tMin_p = m_tMax_n;
+        m_tMax_p = m_tMax_n;
+      } else { // m_min <0 && m_max > 0
+        uf.f = precision;
+        m_tMin_p = uf.i >> m_shift;
+        uf.f = m_max;
+        m_tMax_p = uf.i >> m_shift;
+        uf.f = -precision;
+        m_tMin_n = uf.i >> m_shift;
+        uf.f = m_min;
+        m_tMax_n = uf.i >> m_shift;
+      }
+      m_diff_p = m_tMax_p - m_tMin_p;
+    }
+  public:
+    inline int inputToKey(float i) const
+    {
+      IFNumber uf;
+      uf.f = i;
+      int k = (uf.i >> m_shift);
+      if(k <= m_tMax_p)
+      {
+        return k - m_tMin_p;
+      } else {
+        return k - m_tMin_n + m_diff_p;
+      }
+    }
+    inline float keyToInput(int k) const
+    {
+      IFNumber uf;
+      if( k <= m_diff_p ) {
+        uf.i = ((k + m_tMin_p) << m_shift);
+      } else {
+        uf.i = ((k + m_tMin_n - m_diff_p ) << m_shift);
+      }
+      return uf.f;
+    }
+    inline bool inrange(float i) const
+    {
+       return i >= m_min && i <= m_max && (i < -m_precision || i > m_precision);
+    }
+    inline float minimum() const
+    {
+      return m_min;
+    }
+    inline float maximum() const
+    {
+      return m_max;
+    }
+    inline int size() const
+    {
+      return m_diff_p + m_tMax_n - m_tMin_p + 1;
+    }
+  private:
+    float m_min, m_max, m_precision;
+    int m_tMin_p, m_tMax_p, m_tMin_n, m_tMax_n, m_diff_p;
+    int m_shift;
+};
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Math.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Math.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Math.h.95a8c6853b97	2012-01-10 11:12:02.128249299 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Math.h	2012-01-10 11:12:02.128249299 -0500
@@ -0,0 +1,41 @@
+/*
+ *  Copyright (c) 2011 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLCORE_MATH_H_
+#define _GTLCORE_MATH_H_
+
+#include <cmath>
+
+#if _MSC_VER
+
+#define M_PI 3.14159265358979323846
+
+namespace std {
+  inline long lround(double num) {
+    return (long)(num > 0 ? num + 0.5 : ceil(num - 0.5));
+  }
+  inline int round(double d) {
+    return (d>0) ? int(d+0.5) : int(d-0.5);
+  }
+}
+
+#endif
+
+#endif
+
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/MemoryManager_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/MemoryManager_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/MemoryManager_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/MemoryManager_p.cpp	2012-01-10 11:12:02.128249299 -0500
@@ -38,6 +38,7 @@ using namespace GTLCore;
 
 #else
 
+// #define MM_DEBUG(msg) std::cout << msg << std::endl;
 #define MM_DEBUG(msg)
 
 #endif
@@ -117,8 +118,8 @@ struct MemoryManager::Segment {
           MM_DEBUG("No previous, free = " << (unsigned int)(end - nextFree) );
           nextFree = reinterpret_cast<gtl_uint8*>(currentHeader);
           previous = 0;
-	  printStatus();
-	  MM_DEBUG( "End desallocate" );
+          printStatus();
+          MM_DEBUG( "End desallocate" );
           return;
         }
         Header* previousCurrentHeader = currentHeader->previous;
@@ -132,9 +133,9 @@ struct MemoryManager::Segment {
           previous = previousCurrentHeader;
           previous->next = 0;
           nextFree = reinterpret_cast<gtl_uint8*>(currentHeader);
-	  MM_DEBUG("Now free" << (unsigned int)(end - nextFree));
-	  printStatus();
-	  MM_DEBUG( "End desallocate" );
+          MM_DEBUG("Now free" << (unsigned int)(end - nextFree));
+          printStatus();
+          MM_DEBUG( "End desallocate" );
           return;
         }
       }
@@ -147,8 +148,8 @@ struct MemoryManager::Segment {
     if(previous)
     {
       MM_DEBUG( "### previous->status = " << previous->status << " previous->size = " << previous->size
-	     << " previous->previous = " << previous->previous << " previous->next = " << previous->next
-	     << " previous->data = " << (void*)previous->data );
+             << " previous->previous = " << previous->previous << " previous->next = " << previous->next
+             << " previous->data = " << (void*)previous->data );
     }
   }
   gtl_uint8* nextFree;
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Metadata/Group.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Metadata/Group.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Metadata/Group.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Metadata/Group.h	2012-01-10 11:12:02.128249299 -0500
@@ -22,7 +22,7 @@
 
 #include <GTLCore/Metadata/Entry.h>
 
-namespace OpenShiva {
+namespace GTLFragment {
   class Metadata;
 }
 
@@ -35,7 +35,7 @@ namespace GTLCore {
     class GTLCORE_EXPORT Group : public Entry {
         friend class Factory;
         friend class ParameterEntry;
-        friend class OpenShiva::Metadata;
+        friend class GTLFragment::Metadata;
         GTL_NO_COPY(Group);
         Group( const GTLCore::String& _name, const std::list< const Entry* >& _entries);
         virtual ~Group();
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Metadata/Metadata.doxy.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Metadata/Metadata.doxy
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Metadata/Metadata.doxy.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Metadata/Metadata.doxy	2012-01-10 11:12:02.128249299 -0500
@@ -1,6 +1,6 @@
 /**
  * @addtogroup GTLCore_Metadata GTLCore Metadata Library
- * @version 0.9.15
+ * @version 0.9.16
  * @author Cyrille Berger
  * @ingroup GTLCore
  * 
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Metadata/ParameterEntry.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Metadata/ParameterEntry.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Metadata/ParameterEntry.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Metadata/ParameterEntry.cpp	2012-01-10 11:12:02.128249299 -0500
@@ -151,6 +151,14 @@ ParameterEntry::ParameterEntry( const GT
     } else if( d->type == Type::Float32 )
     {
       d->minimumValue.setFloat32( 0.0 );
+    } else if( d->type->dataType() == Type::VECTOR)
+    {
+      std::vector< Value > values;
+      for(std::size_t i = 0; i < d->type->vectorSize(); ++i)
+      {
+        values.push_back(0.0f);
+      }
+      d->minimumValue = Value(values, d->type);
     }
   }
   if( not maxEntry )
@@ -161,6 +169,14 @@ ParameterEntry::ParameterEntry( const GT
     } else if( d->type == Type::Float32 )
     {
       d->maximumValue.setFloat32( 1.0 );
+    } else if( d->type->dataType() == Type::VECTOR)
+    {
+      std::vector< Value > values;
+      for(std::size_t i = 0; i < d->type->vectorSize(); ++i)
+      {
+        values.push_back(1.0f);
+      }
+      d->maximumValue = Value(values, d->type);
     }
   }
   if( not defaultEntry )
@@ -177,9 +193,13 @@ ParameterEntry::ParameterEntry( const GT
       std::vector< GTLCore::Value > v2; v2.push_back( 1.0f ); v2.push_back( 1.0f );
       std::vector< GTLCore::Value > v3; v3.push_back( v1 ); v3.push_back( v2 );
       d->defaultValue.setArray( v3, d->type );
-    } else if( d->type == TypesManager::getVector( Type::Float32, 3 ) )
+    } else if( d->type->dataType() == Type::VECTOR )
     {
-      std::vector< GTLCore::Value > v1; v1.push_back( 0.0f ); v1.push_back( 0.0f ); v1.push_back( 0.0f );
+      std::vector< GTLCore::Value > v1;
+      for(unsigned int i = 0; i < d->type->vectorSize(); ++i )
+      {
+        v1.push_back( 0.5f );
+      }
       d->defaultValue.setArray( v1, d->type );
     }
   }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/ModuleData_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/ModuleData_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/ModuleData_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/ModuleData_p.cpp	2012-01-10 11:12:02.129249291 -0500
@@ -97,9 +97,9 @@ const std::list<Function*>* ModuleData::
   return 0;
 }
 
-const std::list<Function*>* ModuleData::function(const ScopedName& name)
+const std::list<Function*>* ModuleData::function(const ScopedName& name) const
 {
-  std::map<ScopedName, std::list<Function*>* >::iterator it = m_functions.find(name);
+  std::map<ScopedName, std::list<Function*>* >::const_iterator it = m_functions.find(name);
   if( it == m_functions.end())
   {
     return 0;
@@ -197,6 +197,28 @@ const GTLCore::Function* ModuleData::fun
   return bestFunction;
 }
 
+bool ModuleData::appendConstant(const GTLCore::ScopedName& name, const GTLCore::Type* type, const GTLCore::Value& val)
+{
+  if (m_constants.find(name) == m_constants.end())
+  {
+    m_constants[name] = type;
+    m_constantsValue[name] = val;
+    return true;
+  } else {
+    return false;
+  }
+}
+
+const std::map<GTLCore::ScopedName, const GTLCore::Type*>& ModuleData::constants() const
+{
+  return m_constants;
+}
+
+const std::map<ScopedName, GTLCore::Value>& ModuleData::constantsValue() const
+{
+  return m_constantsValue;
+}
+
 void ModuleData::linkWith( const ModuleData* _module )
 {
   foreach( const llvm::Module* mod, _module->m_linkModuleWith )
@@ -217,6 +239,7 @@ void ModuleData::linkWith( const llvm::M
 
 void ModuleData::doLink()
 {
+  std::list<GTLCore::String> hide;
   GTL_ASSERT( not m_llvmLinkedModule );
   m_llvmLinkedModule = m_llvmModule;
   m_llvmModule = llvm::CloneModule( m_llvmModule );
@@ -225,7 +248,31 @@ void ModuleData::doLink()
   foreach( const llvm::Module* mod, m_linkModuleWith )
   {
     llvm::Module* clone = llvm::CloneModule( mod );
+    
+    for(llvm::Module::iterator it = clone->getFunctionList().begin();
+        it != clone->getFunctionList().end(); ++it)
+    {
+      GTLCore::String name(it->getName());
+      if(name.isEmpty())
+      {
+        it->setLinkage(llvm::GlobalValue::InternalLinkage);
+      } else {
+        hide.push_back(name);
+      }
+    }
+    for(llvm::Module::global_iterator it = clone->getGlobalList().begin();
+        it != clone->getGlobalList().end(); ++it)
+    {
+      GTLCore::String name(it->getName());
+      if(name.isEmpty())
+      {
+        it->setLinkage(llvm::GlobalValue::InternalLinkage);
+      } else {
+        hide.push_back(name);
+      }
+    }
     linker.LinkInModule( clone, &errorMessage );
+    
     GTL_DEBUG("Linking error: " << errorMessage );
     delete clone;
   }
@@ -236,4 +283,34 @@ void ModuleData::doLink()
   }
   
   linker.releaseModule();
+  
+  // Hide symbols
+  foreach(GTLCore::String name, hide)
+  {
+    llvm::GlobalValue* value = m_llvmLinkedModule->getNamedValue((const std::string&)name);
+    if(value and not value->isDeclaration())
+    {
+      value->setLinkage(llvm::GlobalValue::InternalLinkage);
+    }
+  }
+}
+
+void ModuleData::hideAllSymbolsBut(std::list<GTLCore::String> _keepVisible)
+{
+  for(llvm::Module::iterator it = m_llvmLinkedModule->getFunctionList().begin();
+      it != m_llvmLinkedModule->getFunctionList().end(); ++it)
+  {
+    if(not it->isDeclaration() and std::find(_keepVisible.begin(), _keepVisible.end(), GTLCore::String(it->getName())) == _keepVisible.end() )
+    {
+      it->setLinkage(llvm::GlobalValue::InternalLinkage);
+    }
+  }
+  for(llvm::Module::global_iterator it = m_llvmLinkedModule->getGlobalList().begin();
+      it != m_llvmLinkedModule->getGlobalList().end(); ++it)
+  {
+    if(not it->isDeclaration() and std::find(_keepVisible.begin(), _keepVisible.end(), GTLCore::String(it->getName())) == _keepVisible.end() )
+    {
+      it->setLinkage(llvm::GlobalValue::InternalLinkage);
+    }
+  }
 }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/ModuleData_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/ModuleData_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/ModuleData_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/ModuleData_p.h	2012-01-10 11:12:02.129249291 -0500
@@ -22,6 +22,7 @@
 
 #include <map>
 #include <list>
+#include <GTLCore/Value.h>
 #include <GTLCore/ScopedName.h>
 #include <vector>
 
@@ -34,6 +35,7 @@ namespace GTLCore {
   class Function;
   class Parameter;
   class TypesManager;
+  class Type;
   /**
    * @internal
    * This class is not part of the public API of GTLCore.
@@ -45,14 +47,18 @@ namespace GTLCore {
       ~ModuleData();
       bool appendFunction(const ScopedName& name, Function* function);
       const std::list<Function*>* function(const String& _currentNameSpace, const String& _name) const;
-      const std::list<Function*>* function(const ScopedName& name);
+      const std::list<Function*>* function(const ScopedName& name) const;
       const GTLCore::Function* function(const GTLCore::String& _nameSpace, const GTLCore::String& name, std::vector<GTLCore::Parameter>& arguments) const;
       std::list<Function*> functions();
-      std::map< ScopedName, llvm::Constant* > constants() { return m_constants; }
-      void addConstant( const ScopedName& _scopedName, llvm::Constant* _constant )
-      {
-        m_constants[_scopedName] = _constant;
-      }
+      /**
+       * Append a constant with the given name, and of the given type.
+       */
+      bool appendConstant(const ScopedName& name, const GTLCore::Type* type, const GTLCore::Value& val);
+      /**
+       * @return all the constants of that module
+       */
+      const std::map<ScopedName, const GTLCore::Type*>& constants() const;
+      const std::map<ScopedName, GTLCore::Value>& constantsValue() const;
       void linkWith( const ModuleData* _module );
       void doLink();
       const llvm::Module* llvmModule() const { return m_llvmModule; }
@@ -60,14 +66,16 @@ namespace GTLCore {
       const llvm::Module* llvmLinkedModule() const { return m_llvmLinkedModule; }
       TypesManager* typesManager() { return m_typesManager; }
       const TypesManager* typesManager() const { return m_typesManager; }
+      void hideAllSymbolsBut(std::list<GTLCore::String> _keepVisible);
     private:
       void linkWith( const llvm::Module* _module );
     private:
+      std::map<ScopedName, const GTLCore::Type*> m_constants;
+      std::map<ScopedName, GTLCore::Value> m_constantsValue;
       llvm::Module* m_llvmModule;
       llvm::Module* m_llvmLinkedModule;
       std::map<ScopedName, std::list<Function*>* > m_functions;
       TypesManager* m_typesManager;
-      std::map< ScopedName, llvm::Constant* > m_constants;
       std::list< const llvm::Module* > m_linkModuleWith;
       std::list< GTLCore::String > m_linkModuleWithArchives;
   };
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/OperatorOverloadCenter_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/OperatorOverloadCenter_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/OperatorOverloadCenter_p.cpp.95a8c6853b97	2012-01-10 11:12:02.129249291 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/OperatorOverloadCenter_p.cpp	2012-01-10 11:12:02.129249291 -0500
@@ -0,0 +1,73 @@
+/*
+ *  Copyright (c) 2011 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "OperatorOverloadCenter_p.h"
+#include <list>
+
+#include "Macros_p.h"
+#include "AST/Expression.h"
+
+using namespace GTLCore;
+
+//--------------------------- OperatorOverloadCenter ---------------------------//
+
+struct OperatorOverloadCenter::Private {
+  std::list< OperatorOverloadExpressionFactory* > factories;
+};
+
+OperatorOverloadCenter::OperatorOverloadCenter() : d(new Private)
+{
+}
+
+OperatorOverloadCenter::~OperatorOverloadCenter()
+{
+  delete d;
+}
+
+AST::BinaryExpression* OperatorOverloadCenter::createBinaryExpression( AST::Expression* value1, AST::Expression* value2, Operator::Type type  ) const
+{
+  foreach( OperatorOverloadExpressionFactory* cef, d->factories )
+  {
+    if(cef->canOverload(value1->type(), value2->type(), type))
+    {
+      return cef->create(value1, value2, type);
+    }
+  }
+  return 0;
+}
+
+void OperatorOverloadCenter::addOperatorOverloadExpressionFactory( OperatorOverloadExpressionFactory* _factory)
+{
+  d->factories.push_back(_factory);
+}
+
+//--------------------------- ConvertExpressionFactory ---------------------------//
+
+struct OperatorOverloadExpressionFactory::Private {
+};
+
+OperatorOverloadExpressionFactory::OperatorOverloadExpressionFactory( ) : d(new Private)
+{
+}
+
+OperatorOverloadExpressionFactory::~OperatorOverloadExpressionFactory()
+{
+  delete d;
+}
+
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/OperatorOverloadCenter_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/OperatorOverloadCenter_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/OperatorOverloadCenter_p.h.95a8c6853b97	2012-01-10 11:12:02.129249291 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/OperatorOverloadCenter_p.h	2012-01-10 11:12:02.129249291 -0500
@@ -0,0 +1,82 @@
+/*
+ *  Copyright (c) 2011 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLCORE_OPERATOR_OVERLOAD_CENTER_P_H_
+#define _GTLCORE_OPERATOR_OVERLOAD_CENTER_P_H_
+
+#include <GTLCore/Export.h>
+
+namespace GTLCore
+{
+  class Type;
+  namespace AST
+  {
+    class Expression;
+    class BinaryExpression;
+  }
+
+  class OperatorOverloadExpressionFactory;
+  namespace Operator
+  {
+    enum Type
+    {
+      Unknown = -1,
+      Equal = 0
+    };
+  }
+  /**
+   * Operator overload is checked by the @ref ParserBase before any conversion attempt is made.
+   * Which means that if an operator can support different type, it needs to check for them.
+   */
+  class GTLCORE_EXPORT OperatorOverloadCenter
+  {
+  public:
+    OperatorOverloadCenter();
+    ~OperatorOverloadCenter();
+    AST::BinaryExpression* createBinaryExpression( AST::Expression* value1, AST::Expression* value2, Operator::Type type  ) const;
+    void addOperatorOverloadExpressionFactory( GTLCore::OperatorOverloadExpressionFactory* _factory );
+  private:
+    struct Private;
+    Private* const d;
+  };
+  /**
+   * @internal
+   * This class allows to create the \ref AST::BinaryExpression that can operate between two values
+   * @ingroup GTLCore
+   */
+  class GTLCORE_EXPORT OperatorOverloadExpressionFactory {
+    public:
+      OperatorOverloadExpressionFactory( );
+      virtual ~OperatorOverloadExpressionFactory();
+      /**
+       * Create the \ref AST::BinaryExpression that can affect the given @p value2 to the given @p value1
+       */
+      virtual AST::BinaryExpression* create( AST::Expression* value1, AST::Expression* value2, Operator::Type type ) const = 0;
+      /**
+       * @return true if this \ref OperatorOverloadExpressionFactory can create a BinaryExpression between @p srcType and @p dstType
+       */
+      virtual bool canOverload( const GTLCore::Type* srcType, const GTLCore::Type* dstType, Operator::Type type ) const = 0;
+    private:
+      struct Private;
+      Private* const d;
+  };
+
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/ParserBase_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/ParserBase_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/ParserBase_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/ParserBase_p.cpp	2012-01-10 11:12:02.130249282 -0500
@@ -39,6 +39,7 @@
 #include "LexerBase_p.h"
 #include "Debug.h"
 #include "Macros_p.h"
+#include "OperatorOverloadCenter_p.h"
 #include "Token_p.h"
 #include "Function_p.h"
 #include "Utils_p.h"
@@ -50,6 +51,7 @@
 #include "TypesManager.h"
 #include "TypesManager_p.h"
 #include "ModuleData_p.h"
+#include "CompilationMessages.h"
 
 using namespace GTLCore;
 
@@ -127,9 +129,8 @@ void ParserBase::parseConstantDeclaratio
           {
             reportError("Constant '" + scopedName.toString() + "' has already been declared", currentToken());
           } else {
-            AST::GlobalConstantDeclaration* gcd = new AST::GlobalConstantDeclaration( scopedName, type , expression, false );
-            variablesManager()->declareConstant( scopedName, gcd->variable() );
-            tree()->append( gcd );
+            AST::GlobalConstantDeclaration* gcd = new AST::GlobalConstantDeclaration( scopedName, type , expression, false, false );
+            appendGlobalConstantDeclaration(gcd);
           }
         }
       }
@@ -145,6 +146,20 @@ void ParserBase::parseConstantDeclaratio
   }
 }
 
+void ParserBase::appendGlobalConstantDeclaration(AST::GlobalConstantDeclaration* gcd)
+{
+  variablesManager()->declareConstant( gcd->name(), gcd->variable() );
+  tree()->append( gcd );
+  if (d->compiler)
+  {
+    ASTBackend::GenerationVisitor visitor;
+    AST::ExpressionResultSP result = gcd->initialiser()->generateValue(&visitor);
+    d->compiler->appendErrors(visitor.compilationMessages().messages());
+    const Value& val = result.scast<ASTBackend::ExpressionResult>()->value();
+    d->compiler->declareConstant(gcd->name(), gcd->type(), val);
+  }
+}
+
 void ParserBase::parseStructDefinition()
 {
   GTL_ASSERT( d->currentToken.type == Token::STRUCT );
@@ -222,11 +237,15 @@ AST::Expression* ParserBase::parseMember
     if( d->currentToken.type == Token::DOT )
     {
       getNextToken();
-      if( d->currentToken.type == Token::SIZE )
+      if( d->currentToken.type == Token::SIZE && _expression->type()->dataType() != Type::STRUCTURE )
       {
         return new AST::NumberExpression<gtl_int32>( compound->size() );
-      } else if( isOfType( d->currentToken, Token::IDENTIFIER ) ) {
+      } else if( d->currentToken.type == Token::SIZE || isOfType( d->currentToken, Token::IDENTIFIER ) ) {
         String name = d->currentToken.string;
+        if( d->currentToken.type == Token::SIZE )
+        {
+          name = "size";
+        }
         getNextToken();
         if( _expression->type()->dataType() == Type::STRUCTURE ) {
           idx = structMemberNameToIdx( _expression->type(), name );
@@ -244,6 +263,7 @@ AST::Expression* ParserBase::parseMember
       {
         ASTBackend::GenerationVisitor visitor;
         AST::ExpressionResultSP result = expr->generateValue(&visitor);
+        d->compiler->appendErrors(visitor.compilationMessages().messages());
         const Value& val = result.scast<ASTBackend::ExpressionResult>()->value();
         idx = val.asInt32();
       } else {
@@ -277,24 +297,31 @@ AST::AccessorExpression* ParserBase::par
   if( d->currentToken.type == Token::DOT )
   {
     getNextToken();
-    if( d->currentToken.type == Token::SIZE )
+    if( d->currentToken.type == Token::SIZE && _expression->type()->dataType() != Type::STRUCTURE )
     {
       getNextToken(); // eat size
       return new AST::ArraySizeAccessorExpression( _expression );
-    } else if( isOfType( d->currentToken, Token::IDENTIFIER ) ) {
+    } else if( d->currentToken.type == Token::SIZE || isOfType( d->currentToken, Token::IDENTIFIER ) ) {
       String name = d->currentToken.string;
+      if( d->currentToken.type == Token::SIZE )
+      {
+        name = "size";
+      }
       getNextToken();
       if( d->currentToken.type == Token::STARTBRACKET )
       {
         getNextToken(); // Eat the start bracket
-        const Type::StructFunctionMember* sfm = _expression->type()->d->functionMember( name );
-        if( not sfm )
+        std::vector<const Type::StructFunctionMember*> sfms = _expression->type()->d->functionMembers( name );
+        if( sfms.empty() )
         {
           reportError("Unknown member: '" + name + "' for structure " + _expression->type()->structName(), d->currentToken );
         } else {
           std::list<Function*> functions;
-          std::list<AST::Expression*> arguments = parseArguments( sfm->name() );
-          functions.push_back(const_cast<Function*>( sfm->function() ) );
+          std::list<AST::Expression*> arguments = parseArguments( name );
+          foreach(const Type::StructFunctionMember* sfm, sfms)
+          {
+            functions.push_back(const_cast<Function*>( sfm->function() ) );
+          }
           GTLCore::Function* function = 0;
           arguments = selectFunction(arguments, functions, &function, 1);
           if( not function )
@@ -302,8 +329,17 @@ AST::AccessorExpression* ParserBase::par
             delete _expression;
             return 0;
           }
-          GTL_ASSERT(function == sfm->function());
-          return new AST::FunctionMemberAccessorExpression(_expression, sfm, arguments);
+          const Type::StructFunctionMember* selectedSfm = 0;
+          foreach(const Type::StructFunctionMember* sfm, sfms)
+          {
+            if(function == sfm->function())
+            {
+              selectedSfm = sfm;
+              break;
+            }
+          }
+          GTL_ASSERT(selectedSfm);
+          return new AST::FunctionMemberAccessorExpression(_expression, selectedSfm, arguments);
         }
       } else if( _expression->type()->dataType() == Type::STRUCTURE ) {
         return parseMemberArrayExpression( new AST::StructAccessorExpression( _expression ,  structMemberNameToIdx( _expression->type(), name ) ), _constantExpression);
@@ -439,6 +475,11 @@ AST::Expression* ParserBase::parseCompou
     } else if( d->currentToken.type == endToken )
     {
       getNextToken();
+      GTL_DEBUG(*_type << " " << expressions_.size());
+      if(_type->dataType() == Type::VECTOR and _type->vectorSize() != expressions_.size())
+      {
+        reportError("Invalid number of parameters for coumpound expression.", currentToken());
+      }
       if( _constantExpression )
       {
         return new AST::ConstantCompoundExpression(_type, expressions_);
@@ -509,7 +550,7 @@ AST::Expression* ParserBase::parseExpres
     }
   } else if( currentToken().type == Token::STARTBRACE )
   {
-    AST::Expression* compoundExpression = parseCompoundExpression( _type, true );
+    AST::Expression* compoundExpression = parseCompoundExpression( _type, _constantExpression );
     if( compoundExpression )
     {
       return new AST::GlobalDataExpression( compoundExpression );
@@ -596,7 +637,7 @@ AST::Expression* ParserBase::parseBinary
       } else if( d->currentToken.isUnaryOperator() ) {
         expr = parseUnaryOperator(_constantExpression);
       } else if( currentToken().type == Token::STARTBRACE ) {
-        AST::Expression* compoundExpression = parseCompoundExpression( _lhs->type() , true );
+        AST::Expression* compoundExpression = parseCompoundExpression( _lhs->type() , _constantExpression );
         if( compoundExpression )
         {
           expr = new AST::GlobalDataExpression( compoundExpression );
@@ -742,12 +783,6 @@ AST::Expression* ParserBase::parseUnaryO
   AST::Expression* expr = 0;
   if( d->currentToken.type == Token::STARTBRACKET ) {
     expr = parseExpression(_constantExpression);
-    if( not isOfType( d->currentToken, Token::ENDBRACKET ) )
-    {
-      delete expr;
-      return 0;
-    }
-    getNextToken();
   } else if( d->currentToken.isPrimary() )
   {
     expr = parsePrimaryExpression(_constantExpression);
@@ -837,7 +872,7 @@ void ParserBase::parseFunction()
   {
     Token nameToken = d->currentToken;
     ScopedName name( d->nameSpace, d->currentToken.string );
-    startParsingFunction( name.name() );
+    AST::StatementsList* initiallistofstatements = startParsingFunction( name.name() );
     getNextToken();
     // Next is start bracket
     if( isOfType( d->currentToken, Token::STARTBRACKET ) )
@@ -909,6 +944,7 @@ void ParserBase::parseFunction()
                 {
                   ASTBackend::GenerationVisitor visitor;
                   AST::ExpressionResultSP result = initialiser->generateValue(&visitor);
+                  d->compiler->appendErrors(visitor.compilationMessages().messages());
                   initialiserValue = result.scast<ASTBackend::ExpressionResult>()->value();
                   if(!initialiserValue.isValid())
                   {
@@ -939,17 +975,31 @@ void ParserBase::parseFunction()
           if( isOfType( d->currentToken, Token::STARTBRACE ) )
           {
             AST::FunctionDeclaration* fd = new AST::FunctionDeclaration( name, returnType, params );
+            if(not validateFunctionParameters(fd->function()))
+            {
+              reportError( "Invalid parameters list for function " + name.toString(), d->currentToken);
+            }
+            // Declare the function now to allow recursive call
+            bool v = d->compiler->declareFunction( name, fd->function() );
             // TODO insert functions arguments in the context
             for( unsigned int i = 0; i < params.size(); ++i)
             {
               d->variablesManager.declareParameter( ScopedName("",params[i]->parameter().name() ), fd->parametersVariable()[i] );
             }
             d->variablesManager.startContext();
-            AST::Statement* statement =appendCurrentContextGarbageCollecting(parseStatementList());
+            
+            AST::StatementsList* statementsList = parseStatementList();
+            if(initiallistofstatements)
+            {
+              AST::StatementsList* newlist = new AST::StatementsList(std::list<AST::Statement*>());
+              newlist->appendStatement(initiallistofstatements);
+              newlist->appendStatement(statementsList);
+              statementsList = newlist;
+            }
+            AST::Statement* statement =appendCurrentContextGarbageCollecting(statementsList);
             d->variablesManager.endContext();
             if( statement )
             {
-              bool v = d->compiler->declareFunction( name, fd->function() );
               if(v)
               {
                 fd->setStatement( statement );
@@ -1148,19 +1198,21 @@ AST::Statement* ParserBase::parseReturnS
   GTL_ASSERT( d->currentToken.type == Token::RETURN );
   getNextToken();
   GTL_ASSERT( d->currentReturnType );
+  GTL_DEBUG("Parse return statement");
   if( d->currentReturnType->dataType() == Type::VOID  )
   {
     isOfType(d->currentToken, Token::SEMI);
     getNextToken(); // eat the coma
     return new AST::ReturnStatement( 0, d->variablesManager.garbageCollectEverything() );
   } else {
-    AST::Expression* expr = parseExpression(false);
+    AST::Expression* expr = parseExpression(false, d->currentReturnType);
     if( expr )
     {
+      GTL_DEBUG(*expr->type());
       expr = d->compiler->convertCenter()->createConvertExpression( expr, d->currentReturnType );
       if(not expr)
       {
-        reportError("Can't conert expression to return type", d->currentToken);
+        reportError("Can't convert expression to return type", d->currentToken);
       }
       if(isOfType( d->currentToken, Token::SEMI ) )
       {
@@ -1357,6 +1409,12 @@ AST::Expression* ParserBase::parsePrimar
         {
           if( (*it)->name().name() == d->currentToken.string )
           {
+            if( not (*it)->isConstant() )
+            {
+              reportError( "Cannot use parameter or dependant '" + (*it)->name().toString() + "' in constant expressions.", d->currentToken );                                          
+              getNextToken();
+              return 0;
+            }
             getNextToken();
             // Put the expr in a proxy to avoid double free when the AST tree is deleted
             return new AST::ProxyExpression( parseMemberArrayConstantExpression( (*it)->initialiser() ) );
@@ -1411,6 +1469,7 @@ AST::Expression* ParserBase::parsePrimar
             return 0;
           }
         } else {
+          GTL_ASSERT(not _constantExpression);
           VariableNG* var = d->variablesManager.getVariable( name );
           if(not var)
           {
@@ -1633,6 +1692,17 @@ void ParserBase::reportUnexpected( const
   getNextToken();
 }
 
+Operator::Type operatorTokenToCenter(Token::Type arg1)
+{
+  switch(arg1)
+  {
+    case Token::EQUALEQUAL:
+      return Operator::Equal;
+    default:
+      return Operator::Unknown;
+  }
+}
+
 AST::Expression* ParserBase::createBinaryOperator( const Token& token, AST::Expression* lhs, AST::Expression* rhs )
 {
   if( not lhs or not rhs )
@@ -1641,6 +1711,13 @@ AST::Expression* ParserBase::createBinar
     delete rhs;
     return 0;
   }
+  {
+    AST::BinaryExpression* overloadedExpression = 0;
+    if(d->compiler and (overloadedExpression = d->compiler->operatorOverloadCenter()->createBinaryExpression(lhs, rhs, operatorTokenToCenter(token.type)) ) )
+    {
+      return overloadedExpression;
+    }
+  }
   if( token.type == Token::EQUAL or token.type == Token::PLUSEQUAL or token.type == Token::MINUSEQUAL or token.type == Token::MULTIPLYEQUAL or token.type == Token::DIVIDEEQUAL)
   {
     rhs = d->compiler->convertCenter()->createConvertExpression( rhs, lhs->type() );
@@ -1652,7 +1729,7 @@ AST::Expression* ParserBase::createBinar
       return 0;
     }
     AST::AccessorExpression* ve = dynamic_cast<AST::AccessorExpression*>( lhs );
-    GTL_ASSERT( rhs->type() == ve->type() );
+    GTL_ASSERT( rhs->type() == ve->type() or rhs->type()->isSameStructureLayout(ve->type()));
     if( ve )
     {
       if( token.type == Token::PLUSEQUAL )
@@ -1745,7 +1822,7 @@ AST::Expression* ParserBase::createBinar
         return new AST::DivisionBinaryExpression( lhs, rhs );
       case Token::MODULO:
       {
-        if( lhs->type() != rhs->type() or rhs->type()  != Type::Integer32 )
+        if( lhs->type() != rhs->type() or (rhs->type()  != Type::Integer32 and rhs->type() != Type::UnsignedInteger32 ))
         {
           reportError( "'%' operator only work with integer" , token );
           delete lhs;
@@ -1792,6 +1869,7 @@ std::list<int> ParserBase::expressionsLi
     }
     delete *it;
   }
+  d->compiler->appendErrors(visitor.compilationMessages().messages());
   return integersList;
 }
 
@@ -1844,10 +1922,16 @@ int ParserBase::structMemberNameToIdx( c
   return index;
 }
 
-void ParserBase::startParsingFunction( const GTLCore::String& _name )
+AST::StatementsList* ParserBase::startParsingFunction( const GTLCore::String& _name )
 {
+  return 0;
 }
 
 void ParserBase::endParsingFunction( const GTLCore::String& _name )
 {
 }
+
+bool ParserBase::validateFunctionParameters(const Function* /*function*/)
+{
+  return true;
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/ParserBase_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/ParserBase_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/ParserBase_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/ParserBase_p.h	2012-01-10 11:12:02.130249282 -0500
@@ -45,6 +45,7 @@ namespace GTLCore {
     class Statement;
     class AccessorExpression;
     class StatementsList;
+    class GlobalConstantDeclaration;
   };
   /**
    * @internal
@@ -66,6 +67,10 @@ namespace GTLCore {
     protected:
       virtual AST::Tree* tree() = 0;
     protected:
+      /**
+       * Check if the function has valid parameters.
+       */
+      virtual bool validateFunctionParameters(const Function* function);
     // Parse functions
       AST::Expression* parseExpression( bool _constantExpression, const GTLCore::Type* _type = 0 );
       AST::Expression* parseUnaryOperator( bool _constantExpression );
@@ -110,6 +115,12 @@ namespace GTLCore {
       const Type* parseFunctionType();
       void parseStructDefinition();
       void parseConstantDeclaration();
+    public:
+      /**
+       * Insert a new global constant declaration in the tree.
+       */
+      void appendGlobalConstantDeclaration(AST::GlobalConstantDeclaration* gcd);
+    protected:
       /**
        * Parse the arguments of a function.
        */
@@ -172,7 +183,7 @@ namespace GTLCore {
       TypesManager* typesManager();
       VariablesManager* variablesManager();
     protected: // Events
-      virtual void startParsingFunction( const GTLCore::String& _name );
+      virtual AST::StatementsList* startParsingFunction( const GTLCore::String& _name );
       virtual void endParsingFunction( const GTLCore::String& _name );
     private:
       int vectorMemberNameToIdx( const GTLCore::String& _name );
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Region.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Region.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Region.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Region.h	2012-01-10 11:12:02.130249282 -0500
@@ -34,33 +34,43 @@ namespace GTLCore {
   template<typename _T_>
   class Region {
     protected:
-      Region();
-      Region( _T_ _x, _T_ _y, _T_ _cols, _T_ _rows );
+      inline Region();
+      inline Region( _T_ _x, _T_ _y, _T_ _cols, _T_ _rows );
     public:
-      ~Region();
-      _T_ x() const;
-      _T_ y() const;
+      inline ~Region();
+      inline _T_ x() const;
+      inline _T_ y() const;
       /**
        * @return the number of rows in that region
        */
-      _T_ rows() const;
+      inline _T_ rows() const;
       /**
        * @return the number of columns in that region
        */
-      _T_ columns() const;
+      inline _T_ columns() const;
       /**
        * @return the coordinate of the left pixel in the region
        */
-      _T_ left() const;
+      inline _T_ left() const;
       /**
        * @return the coordinate of the top pixel in the region
        */
-      _T_ top() const;
-      void setRows( _T_ _rows );
-      void setCols( _T_ cols );
-      GTLCore::Region<_T_> united( const Region<_T_>& _region ) const;
-      GTLCore::Region<_T_>& operator+=( const Region<_T_>& _region );
-      bool operator!=( const Region<_T_>& _region ) const;
+      inline _T_ top() const;
+      /**
+       * Set the top coordinate without changing bottom, making
+       * needed adjustment to the number of rows
+       */
+      inline void setTop(_T_);
+      /**
+       * Set the left coordinate without changing right, making
+       * needed adjustment to the number of columns
+       */
+      inline void setLeft(_T_);
+      inline void setRows( _T_ _rows );
+      inline void setCols( _T_ cols );
+      inline GTLCore::Region<_T_> united( const Region<_T_>& _region ) const;
+      inline GTLCore::Region<_T_>& operator+=( const Region<_T_>& _region );
+      inline bool operator!=( const Region<_T_>& _region ) const;
     private:
       static inline _T_ min(_T_ v1, _T_ v2) { return (v1 < v2) ? v1 : v2; }
       static inline _T_ max(_T_ v1, _T_ v2) { return (v1 < v2) ? v2 : v1; }
@@ -89,6 +99,22 @@ namespace GTLCore {
       {
           return y() + rows() - 1;
       }
+      /**
+       * Set the bottom coordinate without changing top, making
+       * needed adjustment to the number of rows
+       */
+      void setBottom(int v)
+      {
+        setRows(v - y() + 1);
+      }
+      /**
+       * Set the right coordinate without changing left, making
+       * needed adjustment to the number of columns
+       */
+      void setRight(int v)
+      {
+        setCols(v - x() + 1);
+      }
   };
   
   /**
@@ -108,6 +134,22 @@ namespace GTLCore {
       {
           return y() + rows();
       }
+      /**
+       * Set the bottom coordinate without changing top, making
+       * needed adjustment to the number of rows
+       */
+      void setBottom(int v)
+      {
+        setRows(v - y());
+      }
+      /**
+       * Set the right coordinate without changing left, making
+       * needed adjustment to the number of columns
+       */
+      void setRight(int v)
+      {
+        setCols(v - x());
+      }
     };
   
   //--- Implementation ---//
@@ -175,6 +217,18 @@ namespace GTLCore {
   {
     return m_y;
   }
+  template<typename _T_>
+  void Region<_T_>::setTop(_T_ v)
+  {
+    m_rows += m_y - v;
+    m_y = v;
+  }
+  template<typename _T_>
+  void Region<_T_>::setLeft(_T_ v)
+  {
+    m_cols += m_x - v;
+    m_x = v;
+  }
 
   template<typename _T_>
   bool Region<_T_>::operator!=( const Region& _region ) const
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/RgbaF.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/RgbaF.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/RgbaF.h.95a8c6853b97	2012-01-10 11:12:02.130249282 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/RgbaF.h	2012-01-10 11:12:02.130249282 -0500
@@ -0,0 +1,29 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLCORE_RGBAF_H_
+#define _GTLCORE_RGBAF_H_
+
+namespace GTLCore {
+  struct RgbaF {
+    float r, g, b, a;
+  }; 
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/RgbColorConverter_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/RgbColorConverter_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/RgbColorConverter_p.h.95a8c6853b97	2012-01-10 11:12:02.130249282 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/RgbColorConverter_p.h	2012-01-10 11:12:02.130249282 -0500
@@ -0,0 +1,162 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENGTL_RGB_COLOR_CONVERTER_P_H_
+#define _OPENGTL_RGB_COLOR_CONVERTER_P_H_
+#include <iostream>
+#include "AbstractColorConverter.h"
+#include "StdTypes.h"
+#include "RgbaF.h"
+
+#include "ChannelMaths.h"
+
+namespace GTLCore {
+  template<typename _T_>
+  struct RgbColorConverterTraits {};
+  
+#define GTLCORE_MAKE_COLOR_CONVERTER_TRAIT(_T_)                               \
+  template<>                                                                  \
+  struct RgbColorConverterTraits<_T_> {                                       \
+    typedef GTLCore::GammaToLinearFloat<_T_> GammaToLinearFloat;              \
+    typedef GTLCore::IntegerToFloat<_T_>     IntegerToFloat;                  \
+    typedef GTLCore::LinearToGammaFloat<_T_> LinearToGammaFloat;              \
+    typedef GTLCore::FloatToInteger<_T_>     FloatToInteger;                  \
+    typedef FullLut< CombinedOperation<float, _T_, IntegerToFloat, GammaToLinearFloat>, float, _T_ > PixelToRgb;             \
+    typedef Lut< CombinedOperation<_T_, float, LinearToGammaFloat, FloatToInteger  >, _T_, float> RgbToPixel;                 \
+                                                                              \
+    static PixelToRgb createPixelToRgbA(double _gamma)                        \
+    {                                                                         \
+      return PixelToRgb( CombinedOperation<float, _T_, IntegerToFloat, GammaToLinearFloat>( IntegerToFloat(), GammaToLinearFloat(_gamma)) );                                          \
+    }                                                                         \
+    static RgbToPixel createRgbAToPixel(double _gamma)                        \
+    {                                                                         \
+      return RgbToPixel( 0.0, 1.0, CombinedOperation<_T_, float, LinearToGammaFloat, FloatToInteger>( LinearToGammaFloat(_gamma), FloatToInteger() ) );             \
+    }                                                                         \
+  };
+  
+  GTLCORE_MAKE_COLOR_CONVERTER_TRAIT(gtl_uint8)
+  GTLCORE_MAKE_COLOR_CONVERTER_TRAIT(gtl_uint16)
+#undef GTLCORE_MAKE_COLOR_CONVERTER_TRAIT
+
+  #define GTLCORE_MAKE_COLOR_CONVERTER_TRAIT(_T_)                             \
+  template<>                                                                  \
+  struct RgbColorConverterTraits<_T_> {                                       \
+    typedef GTLCore::GammaToLinearFloat<_T_> GammaToLinearFloat;              \
+    typedef GTLCore::LinearToGammaFloat<_T_> LinearToGammaFloat;              \
+    typedef Lut< GammaToLinearFloat, float, _T_ > PixelToRgb;                 \
+    typedef Lut< LinearToGammaFloat, _T_, float> RgbToPixel;                  \
+                                                                              \
+    static PixelToRgb createPixelToRgbA(double _gamma)                        \
+    {                                                                         \
+      return PixelToRgb( 0.0, 1.0, GammaToLinearFloat(_gamma) );              \
+    }                                                                         \
+    static RgbToPixel createRgbAToPixel(double _gamma)                        \
+    {                                                                         \
+      return RgbToPixel( 0.0, 1.0, LinearToGammaFloat(_gamma) );              \
+    }                                                                         \
+  };
+
+  GTLCORE_MAKE_COLOR_CONVERTER_TRAIT(float)
+#undef GTLCORE_MAKE_COLOR_CONVERTER_TRAIT
+
+  template<typename _Channel_Type_, bool _has_alpha>
+  class GTLCORE_EXPORT RgbColorConverter : public AbstractColorConverter
+  {
+  private:
+    typedef GTLCore::GammaToLinearFloat<float> GammaFloatToLinearFloat;
+    typedef GTLCore::LinearToGammaFloat<float> LinearFloatToGammaFloat;
+    GTL_NO_COPY(RgbColorConverter)
+  public:
+    RgbColorConverter(double _gamma, const GTLCore::PixelDescription& _pixelDescription, int rIndex = 0, int gIndex = 1, int bIndex = 2, int aIndex = 3) :
+        AbstractColorConverter(_pixelDescription),
+        m_gamma(_gamma),
+        m_pixelToRgb( RgbColorConverterTraits<_Channel_Type_>::createPixelToRgbA(_gamma)),
+        m_rgbToPixel( RgbColorConverterTraits<_Channel_Type_>::createRgbAToPixel(_gamma)),
+        m_vectorToRgb(_gamma),
+        m_rgbToVector(_gamma),
+        m_rIndex(rIndex), m_gIndex(gIndex), m_bIndex(bIndex), m_aIndex(aIndex)
+    {
+    }
+  public:
+    virtual ~RgbColorConverter()
+    {
+    }
+    virtual void pixelToRgba(const char* _data, RgbaF* _rgba) const
+    {
+      const _Channel_Type_* data = reinterpret_cast<const _Channel_Type_*>(_data);
+      _rgba->r = m_pixelToRgb(data[m_rIndex]);
+      _rgba->g = m_pixelToRgb(data[m_gIndex]);
+      _rgba->b = m_pixelToRgb(data[m_bIndex]);
+      if(_has_alpha) {
+        _rgba->a = ChannelMaths<_Channel_Type_, float>::scaleToA(data[m_aIndex]);
+      } else {
+        _rgba->a = 1.0;
+      }
+    }
+    virtual void rgbaToPixel(const RgbaF* _rgba, char* _data) const
+    {
+      _Channel_Type_* data = reinterpret_cast<_Channel_Type_*>(_data);
+      data[m_rIndex] = m_rgbToPixel(_rgba->r);
+      data[m_gIndex] = m_rgbToPixel(_rgba->g);
+      data[m_bIndex] = m_rgbToPixel(_rgba->b);
+      if(_has_alpha) {
+        data[m_aIndex] = ChannelMaths<float, _Channel_Type_>::scaleToA(_rgba->a);
+      }
+    }
+    virtual void vectorToRgba(const float* _data, RgbaF* _rgba) const
+    {
+      _rgba->r = m_vectorToRgb(_data[m_rIndex]);
+      _rgba->g = m_vectorToRgb(_data[m_gIndex]);
+      _rgba->b = m_vectorToRgb(_data[m_bIndex]);
+      if(_has_alpha) {
+        _rgba->a = _data[m_aIndex];
+      } else {
+        _rgba->a = 1.0;
+      }
+    }
+    virtual void rgbaToVector(const RgbaF* _rgba, float* _data) const
+    {
+      _data[m_rIndex] = m_rgbToVector(_rgba->r);
+      _data[m_gIndex] = m_rgbToVector(_rgba->g);
+      _data[m_bIndex] = m_rgbToVector(_rgba->b);
+      if(_has_alpha) {
+        _data[m_aIndex] = _rgba->a;
+      }
+    }
+  private:
+    // Those are placeholders for the future conversion to/from HSV and to/from LAB
+    virtual void placeholder1() {}
+    virtual void placeholder2() {}
+    virtual void placeholder3() {}
+    virtual void placeholder4() {}
+    virtual void placeholder5() {}
+    virtual void placeholder6() {}
+    virtual void placeholder7() {}
+    virtual void placeholder8() {}
+  private:
+    double m_gamma;
+    typename RgbColorConverterTraits<_Channel_Type_>::PixelToRgb m_pixelToRgb;
+    typename RgbColorConverterTraits<_Channel_Type_>::RgbToPixel m_rgbToPixel;
+    GammaFloatToLinearFloat m_vectorToRgb;
+    LinearFloatToGammaFloat m_rgbToVector;
+    int m_rIndex, m_gIndex, m_bIndex, m_aIndex;
+  };
+};
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/SharedPointer.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/SharedPointer.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/SharedPointer.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/SharedPointer.h	2012-01-10 11:12:02.131249273 -0500
@@ -23,7 +23,7 @@
 #include "Export.h"
 #include "StdTypes.h"
 
-#define GTL_SHARED_DATA_CLASS(_NAME_, _CLASS_NAME_) \
+#define GTL_SHARED_DATA_CLASS_NO_DEREF(_NAME_, _CLASS_NAME_) \
   _NAME_::_CLASS_NAME_(const _NAME_& str) : d(str.d) \
   { \
     d->ref(); \
@@ -48,7 +48,10 @@
     } else { \
       GTL_ASSERT(d->count() > 0); \
     } \
-  } \
+  }
+
+#define GTL_SHARED_DATA_CLASS(_NAME_, _CLASS_NAME_) \
+  GTL_SHARED_DATA_CLASS_NO_DEREF(_NAME_, _CLASS_NAME_) \
   void _NAME_::deref() \
   { \
     if(d->count() == 1 ) return; \
@@ -58,9 +61,29 @@
     d->ref(); \
   }
 
+
+#define GTL_SHARED_DATA_NO_DEREF(_NAME_) \
+  GTL_SHARED_DATA_CLASS_NO_DEREF(_NAME_, _NAME_ )
+
 #define GTL_SHARED_DATA(_NAME_) \
   GTL_SHARED_DATA_CLASS(_NAME_, _NAME_ )
 
+#define GTL_INHERITED_SHARED_DATA_CLASS(_NAME_, _CLASS_NAME_, _PARENT_) \
+  _NAME_::_CLASS_NAME_(const _NAME_& str) : _PARENT_(str) \
+  { \
+  } \
+  _NAME_& _NAME_::operator=(const _NAME_& _rhs) \
+  { \
+    _PARENT_::operator=(_rhs); \
+    return *this; \
+  } \
+  _NAME_::~_CLASS_NAME_() \
+  { \
+  }
+
+#define GTL_INHERITED_SHARED_DATA(_NAME_, _PARENT_) \
+  GTL_INHERITED_SHARED_DATA_CLASS(_NAME_, _NAME_ , _PARENT_)
+
 namespace GTLCore {
   class GTLCORE_EXPORT SharedPointerData {
       SharedPointerData(const SharedPointerData&);
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeController.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeController.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeController.cpp.95a8c6853b97	2012-01-10 11:12:02.131249273 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeController.cpp	2012-01-10 11:12:02.131249273 -0500
@@ -0,0 +1,84 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "TimeController.h"
+
+#include <cfloat>
+#include "Math.h"
+
+using namespace GTLCore;
+
+TimeController::TimeController()
+{
+}
+
+TimeController::~TimeController()
+{
+}
+
+struct LinearTimeController::Private
+{
+  double length;
+  int restart;
+  double stoplength;
+};
+
+LinearTimeController::LinearTimeController(double _length, int _restart) : d(new Private)
+{
+  d->length = _length;
+  d->stoplength = (_restart == -1) ? FLT_MAX : _length * (_restart + 1);
+  d->restart = _restart;
+}
+
+LinearTimeController::~LinearTimeController()
+{
+  delete d;
+}
+
+double LinearTimeController::valueAt(double time) const
+{
+  if(time >= d->stoplength)
+  {
+    return 1.0;
+  } else {
+    time = fmod(time, d->length);
+    return time / d->length;
+  }
+}
+
+struct SinusoidalTimeController::Private {
+  double waveLength;
+  double phasis;
+};
+
+SinusoidalTimeController::SinusoidalTimeController(double _waveLength, double _phasis) : d(new Private)
+{
+  d->waveLength = 2 * M_PI / _waveLength;
+  d->phasis = _phasis;
+}
+
+SinusoidalTimeController::~SinusoidalTimeController()
+{
+  delete d;
+}
+
+double SinusoidalTimeController::valueAt(double time) const
+{
+  return sin(time * d->waveLength + d->phasis) * 0.5 + 0.5;
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeController.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeController.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeController.h.95a8c6853b97	2012-01-10 11:12:02.131249273 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeController.h	2012-01-10 11:12:02.131249273 -0500
@@ -0,0 +1,83 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTL_CORE_TIME_CONTROLLER_
+#define _GTL_CORE_TIME_CONTROLLER_
+
+#include <GTLCore/Export.h>
+
+namespace GTLCore {
+  /**
+    * @ingroup GTLCore_TimeMachine
+    *
+    * This class control the value of the time changed.
+    */
+  class GTLCORE_EXPORT TimeController {
+    GTL_NO_COPY(TimeController);
+    public:
+      TimeController();
+      virtual ~TimeController();
+      /**
+        * @return a value between 0 and 1, dependant of the time.
+        */
+      virtual double valueAt(double time) const = 0;
+  };
+  /**
+    * @ingroup GTLCore_TimeMachine
+    *
+    * This class control the time lineary.
+    */
+  class GTLCORE_EXPORT LinearTimeController : public TimeController {
+    GTL_NO_COPY(LinearTimeController);
+    public:
+      /**
+        * @p _length of the time interval
+        * @p _restart the number of time the controller is reset, if set to -1 it always restart to 0
+        *             after reaching _length, otherwise once the time is superior to
+        *             (_restart * _length) the value is constant to 1.0
+        */
+      LinearTimeController(double _length, int _restart = -1);
+      virtual ~LinearTimeController();
+      virtual double valueAt(double time) const;
+    private:
+      struct Private;
+      Private* const d;
+  };
+  /**
+    * @ingroup GTLCore_TimeMachine
+    *
+    * This class control the time with a sinusoid.
+    */
+  class GTLCORE_EXPORT SinusoidalTimeController : public TimeController {
+    GTL_NO_COPY(SinusoidalTimeController);
+    public:
+      /**
+        * @param _waveLength
+        * @param _phasis
+        */
+      SinusoidalTimeController(double _waveLength, double _phasis);
+      virtual ~SinusoidalTimeController();
+      virtual double valueAt(double time) const;
+    private:
+      struct Private;
+      Private* const d;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeMachine.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeMachine.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeMachine.cpp.95a8c6853b97	2012-01-10 11:12:02.131249273 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeMachine.cpp	2012-01-10 11:12:02.131249273 -0500
@@ -0,0 +1,130 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "TimeMachine.h"
+
+#include <algorithm>
+
+#include "Debug.h"
+#include "Value.h"
+#include "String.h"
+#include "Utils_p.h"
+
+#include "TimeController.h"
+#include "TimeValue_p.h"
+#include "Type.h"
+#include "Metadata/ParameterEntry.h"
+
+using namespace GTLCore;
+
+struct TimeMachine::Private {
+  std::map< GTLCore::String, TimeValue* > timeValues;
+  std::list<const TimeController*> controllers;
+  void registerController(const TimeController* controler);
+  static TimeValue* minMaxToNumericalTimeValue(const GTLCore::Type* _type, const TimeController* controler, const GTLCore::Value& min, const GTLCore::Value& max);
+};
+
+void TimeMachine::Private::registerController(const TimeController* controler)
+{
+  if(std::find(controllers.begin(), controllers.end(), controler) == controllers.end())
+  {
+    controllers.push_back(controler);
+  }
+}
+
+TimeValue* TimeMachine::Private::minMaxToNumericalTimeValue(const GTLCore::Type* _type, const TimeController* controler, const GTLCore::Value& min, const GTLCore::Value& max)
+{
+  GTL_ASSERT(_type->isNumber());
+  GTL_ASSERT(min.type()->isNumber());
+  GTL_ASSERT(max.type()->isNumber());
+  switch(_type->dataType())
+  {
+    case Type::INTEGER32:
+      return new TimeNumericValue<gtl_int32>(min.asInt32(), max.asInt32(), controler);
+      break;
+    case Type::FLOAT32:
+      return new TimeNumericValue<float>(min.asFloat32(), max.asFloat32(), controler);
+      break;
+    default:
+      GTL_ABORT("Unimplemented");
+  }
+}
+
+TimeMachine::TimeMachine() : d(new Private)
+{
+}
+
+TimeMachine::~TimeMachine()
+{
+  deleteAll(d->controllers);
+  for(std::map<GTLCore::String, TimeValue*>::iterator it = d->timeValues.begin();
+      it != d->timeValues.end(); ++it)
+  {
+    delete it->second;
+  }
+  delete d;
+}
+
+void TimeMachine::startControlling(const Metadata::ParameterEntry* _entry, const TimeController* _timeController)
+{
+  stopControlling(_entry->name());
+  d->timeValues[_entry->name()] = Private::minMaxToNumericalTimeValue(_entry->type(), _timeController, _entry->minimumValue(), _entry->maximumValue());
+}
+
+void TimeMachine::startControlling(const Metadata::ParameterEntry* _entry, const std::vector<const TimeController*>& _timeControllers)
+{
+  stopControlling(_entry->name());
+  if(_timeControllers.size() == 1)
+  {
+    startControlling(_entry, _timeControllers.front());
+  } else {
+    if(_entry->type() == Type::Color)
+    {
+      GTL_ASSERT(_timeControllers.size() == 4);
+      d->timeValues[_entry->name()] = new TimeColorValue(_timeControllers[0], _timeControllers[1], _timeControllers[2], _timeControllers[3] );
+    } else {
+      GTL_ASSERT(_entry->type()->dataType() == Type::VECTOR);
+      GTL_ASSERT(_entry->type()->vectorSize() == _timeControllers.size());
+      const GTLCore::Type* embeddedType = _entry->type()->embeddedType();
+      std::vector< TimeValue* > values;
+      for (std::size_t i = 0; i < _timeControllers.size(); ++i)
+      {
+        values.push_back(Private::minMaxToNumericalTimeValue(embeddedType, _timeControllers[i], _entry->minimumValue().asArray()[i], _entry->maximumValue().asArray()[i] ) );
+      }
+      d->timeValues[_entry->name()] = new TimeVectorArrayValue(_entry->type(), values);
+    }
+  }
+}
+
+void TimeMachine::stopControlling(const String&  _name)
+{
+  delete d->timeValues[_name];
+  d->timeValues.erase(_name);
+}
+
+std::map< GTLCore::String, GTLCore::Value> TimeMachine::parametersAt(double t) const
+{
+  std::map< GTLCore::String, GTLCore::Value> m;
+  for(std::map<GTLCore::String, TimeValue*>::iterator it = d->timeValues.begin();
+      it != d->timeValues.end(); ++it)
+  {
+    m[it->first] = it->second->value(t);
+  }
+  return m;
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeMachine.doxy.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeMachine.doxy
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeMachine.doxy.95a8c6853b97	2012-01-10 11:12:02.131249273 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeMachine.doxy	2012-01-10 11:12:02.131249273 -0500
@@ -0,0 +1,9 @@
+/**
+ * @addtogroup GTLCore_TimeMachine GTLCore TimeMachine Library
+ * @version 0.9.16
+ * @author Cyrille Berger
+ * @ingroup GTLCore
+ * 
+ * This library contains classes used to animate Kernels and Programs.
+ * 
+ */
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeMachine.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeMachine.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeMachine.h.95a8c6853b97	2012-01-10 11:12:02.131249273 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeMachine.h	2012-01-10 11:12:02.131249273 -0500
@@ -0,0 +1,64 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTL_CORE_TIME_MACHINE_
+#define _GTL_CORE_TIME_MACHINE_
+
+#include <vector>
+#include <map>
+
+#include <GTLCore/Macros.h>
+#include <GTLCore/Export.h>
+
+namespace GTLCore {
+  class String;
+  class Value;
+  namespace Metadata {
+    class ParameterEntry;
+  }
+  class TimeController;
+  /**
+    * @ingroup GTLCore_TimeMachine
+    *
+    * This class control the advancement of time.
+    *
+    * When a @p TimeController is passed to the @p TimeMachine the time machine will take
+    * care of deleting it. But you can pass a @p TimeController multiple time to the same
+    * @p TimeMachine.
+    */
+  class GTLCORE_EXPORT TimeMachine {
+    GTL_NO_COPY(TimeMachine);
+    public:
+      TimeMachine();
+      ~TimeMachine();
+      /**
+        * Start controlling a parameter entry with the given time controller.
+        * @param _timeController the @p TimeMachine will take ownership of that controller.
+        */
+      void startControlling(const Metadata::ParameterEntry* _entry, const TimeController* _timeController);
+      void startControlling(const Metadata::ParameterEntry* _entry, const std::vector<const TimeController*>& _timeController);
+      void stopControlling(const String&  _name);
+      std::map< GTLCore::String, GTLCore::Value> parametersAt(double t) const;
+    private:
+      struct Private;
+      Private* const d;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeValue_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeValue_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeValue_p.cpp.95a8c6853b97	2012-01-10 11:12:02.131249273 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeValue_p.cpp	2012-01-10 11:12:02.131249273 -0500
@@ -0,0 +1,62 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "TimeValue_p.h"
+
+#include "Color.h"
+#include "Macros_p.h"
+
+using namespace GTLCore;
+
+TimeValue::~TimeValue()
+{
+
+}
+
+TimeVectorArrayValue::TimeVectorArrayValue( const GTLCore::Type* type, std::vector<TimeValue*> timeValues ) : m_type(type), m_timeValues(timeValues)
+{
+}
+
+TimeVectorArrayValue::~TimeVectorArrayValue()
+{
+}
+
+Value TimeVectorArrayValue::value(double t) const
+{
+  std::vector< Value > values;
+  foreach(const TimeValue* val, m_timeValues)
+  {
+    values.push_back(val->value(t));
+  }
+  
+  return Value(values, m_type );
+}
+
+TimeColorValue::TimeColorValue( const TimeController* redController, const TimeController* greenController, const TimeController* blueController, const TimeController* alphaController ) : m_red(redController), m_green(greenController), m_blue(blueController), m_alpha(alphaController)
+{
+}
+
+TimeColorValue::~TimeColorValue()
+{
+}
+
+Value TimeColorValue::value(double t) const
+{
+    return Color(float(m_red->valueAt(t)), float(m_green->valueAt(t)), float(m_blue->valueAt(t)), float(m_alpha->valueAt(t)));
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeValue_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeValue_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeValue_p.h.95a8c6853b97	2012-01-10 11:12:02.131249273 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/TimeValue_p.h	2012-01-10 11:12:02.131249273 -0500
@@ -0,0 +1,74 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTL_CORE_TIME_MACHINE_VALUE_P_H_
+#define _GTL_CORE_TIME_MACHINE_VALUE_P_H_
+
+#include "Value.h"
+#include "TimeController.h"
+
+namespace GTLCore {
+  /**
+    * @internal
+    * @ingroup GTLCore_TimeMachine
+    *
+    * This class control a @ref Value when the time changed.
+    */
+  class TimeValue {
+    public:
+      virtual ~TimeValue();
+      virtual Value value(double t) const = 0;
+  };
+  template<typename _T_>
+  class TimeNumericValue : public TimeValue {
+    public:
+      TimeNumericValue(_T_ min, _T_ max, const TimeController* timeController) : m_min(min), m_max(max), m_timeController(timeController) {}
+      virtual ~TimeNumericValue() {}
+      virtual Value value(double t) const
+      {
+        t = m_timeController->valueAt(t);
+        return _T_(t * m_max + (1-t) * m_min);
+      }
+    private:
+      _T_ m_min, m_max;
+      const TimeController* m_timeController;
+  };
+  class TimeVectorArrayValue : public TimeValue {
+    public:
+      TimeVectorArrayValue( const Type* type, std::vector<TimeValue*> timeValues );
+      virtual ~TimeVectorArrayValue();
+      virtual Value value(double t) const;
+    private:
+      const Type* m_type;
+      std::vector<TimeValue*> m_timeValues;
+  };
+  class TimeColorValue : public TimeValue {
+    public:
+      TimeColorValue( const TimeController* redController, const TimeController* greenController, const TimeController* blueController, const TimeController* alphaController );
+      virtual ~TimeColorValue();
+      virtual Value value(double t) const;
+    private:
+      const TimeController* m_red;
+      const TimeController* m_green;
+      const TimeController* m_blue;
+      const TimeController* m_alpha;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Token_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Token_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Token_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Token_p.cpp	2012-01-10 11:12:02.131249273 -0500
@@ -167,6 +167,8 @@ GTLCore::String Token::typeToString(Type
       return "long";
     case RETURN:
       return "return";
+    case SKETCH:
+      return "sketch";
     case SHORT:
       return "short";
     case SIGNED:
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Token_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Token_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Token_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Token_p.h	2012-01-10 11:12:02.132249264 -0500
@@ -110,6 +110,7 @@ namespace GTLCore {
       LONG,
       RETURN,
       SHORT,
+      SKETCH,
       SIGNED,
       SIZE,
       STRUCT,
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Type.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Type.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Type.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Type.cpp	2012-01-10 11:12:02.132249264 -0500
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2007,2010 Cyrille Berger <cberger@cberger.net>
+ *  Copyright (c) 2007,2008,2009,2010 Cyrille Berger <cberger@cberger.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -37,28 +37,34 @@ using namespace GTLCore;
 struct Type::StructDataMember::Private : public SharedPointerData
 {
   Private() {}
-  Private(const Private& _rhs) : name(_rhs.name), type(_rhs.type), initialSizes(_rhs.initialSizes) {}
+  Private(const Private& _rhs) : name(_rhs.name), type(_rhs.type), initialSizes(_rhs.initialSizes), information(new Information(*_rhs.information)) {}
+  ~Private() {
+    delete information;
+  }
   GTLCore::String name;
   const Type* type;
   std::list<int> initialSizes;
+  Information* information;
 };
 
 GTL_SHARED_DATA_CLASS(Type::StructDataMember, StructDataMember);
 
-Type::StructDataMember::StructDataMember(const GTLCore::String& _name, const Type* _type) : d(new Private)
+Type::StructDataMember::StructDataMember(const GTLCore::String& _name, const Type* _type, Information* information) : d(new Private)
 {
   d->ref();
   d->name = _name;
   d->type = _type;
+  d->information = information;
   GTL_ASSERT( _type->dataType() != Type::ARRAY);
 }
 
-Type::StructDataMember::StructDataMember(const GTLCore::String& _name, const Type* _type, const std::list<int>& _initialSizes) : d(new Private)
+Type::StructDataMember::StructDataMember(const GTLCore::String& _name, const Type* _type, const std::list<int>& _initialSizes, Information* _information) : d(new Private)
 {
   d->ref();
   d->name = _name;
   d->type = _type;
   d->initialSizes = _initialSizes;
+  d->information = _information;
   GTL_ASSERT( d->initialSizes.empty() or ( not d->initialSizes.empty() and _type->dataType() == Type::ARRAY) );
 }
 
@@ -77,6 +83,11 @@ const std::list<int>& Type::StructDataMe
   return d->initialSizes;
 }
 
+const Type::StructDataMember::Information* Type::StructDataMember::information() const
+{
+  return d->information;
+}
+
 //-------- Type -------//
 
 const Type* Type::Undefined = new Type(Type::UNDEFINED);
@@ -94,7 +105,7 @@ const Type* Type::Float32 = new Type(Typ
 const Type* Type::Float16 = new Type(Type::FLOAT16);
 const Type* Type::Void = new Type(Type::VOID);
 const Type* Type::Pointer = new Type(Type::POINTER);
-const Type* Type::Color = new Type("Color", std::vector<Type::StructDataMember>());
+const Type* Type::Color = new Type("color", std::vector<Type::StructDataMember>());
 
 STATIC_DELETER(DeleteTypes)
 {
@@ -252,20 +263,45 @@ MatrixSize Type::matrixSize() const
 
 bool Type::isNumber() const
 {
-  return isInteger() or isFloatingPoint();
+  return (isInteger() or isFloatingPoint());
 }
 
 bool Type::isInteger() const
 {
-  return d->dataType == BOOLEAN or d->dataType == INTEGER8 or d->dataType == UNSIGNED_INTEGER8 or d->dataType == INTEGER16 or d->dataType == UNSIGNED_INTEGER16 or d->dataType == INTEGER32 or d->dataType == UNSIGNED_INTEGER32;
+  return d->dataType == BOOLEAN or d->dataType == INTEGER8 or d->dataType == UNSIGNED_INTEGER8 or d->dataType == INTEGER16 or d->dataType == UNSIGNED_INTEGER16 or d->dataType == INTEGER32 or d->dataType == UNSIGNED_INTEGER32 or ( d->dataType == VECTOR and d->arrayType->isInteger() );
 }
 
 bool Type::isFloatingPoint() const
 {
-  return d->dataType == FLOAT16 or d->dataType == FLOAT32 or d->dataType == FLOAT64;
+  return d->dataType == FLOAT16 or d->dataType == FLOAT32 or d->dataType == FLOAT64 or ( d->dataType == VECTOR and d->arrayType->isFloatingPoint() );
 }
 
 bool Type::isStructure() const
 {
   return d->dataType == STRUCTURE;
 }
+
+bool Type::isSameStructureLayout(const GTLCore::Type* type) const
+{
+  GTL_ASSERT(type->isStructure());
+  GTL_ASSERT(isStructure());
+  if (countStructDataMembers() != type->countStructDataMembers()) {
+    return false;
+  }
+  for(std::size_t i = 0; i < countStructDataMembers(); ++i)
+  {
+    Type::StructDataMember sm1 = structDataMember(i);
+    Type::StructDataMember sm2 = type->structDataMember(i);
+    
+    if( sm1.type() != sm2.type())
+    {
+      if( sm1.type()->dataType() != Type::STRUCTURE
+          or sm2.type()->dataType() != Type::STRUCTURE
+          or not sm1.type()->isSameStructureLayout(sm2.type()) )
+      {
+        return false;
+      }
+    }
+  }
+  return true;
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Type.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Type.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Type.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Type.h	2012-01-10 11:12:02.132249264 -0500
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2007 Cyrille Berger <cberger@cberger.net>
+ *  Copyright (c) 2007,2008,2009,2010 Cyrille Berger <cberger@cberger.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -62,6 +62,8 @@ namespace GTLCore {
        */
       class GTLCORE_EXPORT StructDataMember {
         public:
+          class GTLCORE_EXPORT Information;
+        public:
           /**
            * @param _name the name of the member
            * @param _type the type of this member
@@ -70,8 +72,8 @@ namespace GTLCore {
            *                      it should be set to -1 if the type is not an array)
            * @param _pointer set to true if this struct member is a pointer
            */
-          StructDataMember(const GTLCore::String& _name, const Type* _type);
-          StructDataMember(const GTLCore::String& _name, const Type* _type, const std::list<int>& _initialSizes);
+          StructDataMember(const GTLCore::String& _name, const Type* _type, Information* infor = 0);
+          StructDataMember(const GTLCore::String& _name, const Type* _type, const std::list<int>& _initialSizes, Information* infor = 0);
           StructDataMember(const StructDataMember& rhs);
           StructDataMember& operator=(const StructDataMember& rhs);
           ~StructDataMember();
@@ -87,6 +89,7 @@ namespace GTLCore {
            * @return the initial size of the member.
            */
           const std::list<int>& initialSizes() const;
+          const Information* information() const;
         private:
           void deref();
           struct Private;
@@ -177,6 +180,10 @@ namespace GTLCore {
        * @return true if the type is a structure (aka if dataType() == STRUCTURE)
        */
       bool isStructure() const;
+      /**
+       * @return true if the this type and @p type have the same structure layout
+       */
+      bool isSameStructureLayout(const GTLCore::Type* type) const;
     public:
       struct Private;
       Private* const d;
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Type_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Type_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Type_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Type_p.cpp	2012-01-10 11:12:02.132249264 -0500
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2008-2009 Cyrille Berger <cberger@cberger.net>
+ *  Copyright (c) 2008,2009,2010 Cyrille Berger <cberger@cberger.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -19,6 +19,8 @@
 
 #include "Type_p.h"
 
+#include <llvm/ADT/ArrayRef.h>
+
 #include "Debug.h"
 #include "Function.h"
 #include "Parameter.h"
@@ -31,6 +33,12 @@ using namespace GTLCore;
 #include <llvm/Type.h>
 #include <llvm/DerivedTypes.h>
 
+Type::StructDataMember::Information::~Information()
+{
+//   delete m_setter; // TODO fix me don't leak functions
+}
+
+
 struct Type::StructFunctionMember::Private
 {
   GTLCore::Function* function; // TODO make it shareable, and free memory
@@ -143,7 +151,7 @@ Type::Private::~Private()
   delete structPrivateFunctionMembers;
 }
 
-const llvm::Type * Type::Private::type(llvm::LLVMContext& _context) const
+llvm::Type * Type::Private::type(llvm::LLVMContext& _context) const
 {
   if(m_factory)
   {
@@ -180,7 +188,7 @@ const llvm::Type * Type::Private::type(l
     case Type::STRUCTURE:
     {
       // Init the llvm type
-      std::vector< const llvm::Type * > types;
+      std::vector< llvm::Type * > types;
       for(std::vector<StructDataMember>::iterator it = structDataMembers->begin();
           it != structDataMembers->end(); ++it)
       {
@@ -190,7 +198,7 @@ const llvm::Type * Type::Private::type(l
     }
     case Type::ARRAY:
     {
-      std::vector< const llvm::Type * > types;
+      std::vector< llvm::Type * > types;
       types.push_back( llvm::Type::getInt32Ty(_context)); // Counter from structure
       types.push_back( llvm::Type::getInt32Ty(_context));
       types.push_back( llvm::PointerType::get( arrayType->d->type(_context), 0));
@@ -206,12 +214,12 @@ const llvm::Type * Type::Private::type(l
   }
 }
 
-const llvm::Type * Type::Private::pointerType(llvm::LLVMContext& _context) const
+llvm::Type * Type::Private::pointerType(llvm::LLVMContext& _context) const
 {
   return llvm::PointerType::get( type(_context), 0);
 }
 
-const llvm::Type * Type::Private::asArgumentType(llvm::LLVMContext& _context) const
+llvm::Type * Type::Private::asArgumentType(llvm::LLVMContext& _context) const
 {
   if( dataType == Type::ARRAY or dataType == Type::STRUCTURE )
   {
@@ -250,18 +258,19 @@ int Type::Private::memberToIndex(const G
   return -1;
 }
 
-const Type::StructFunctionMember* Type::Private::functionMember( const GTLCore::String& _name) const
+std::vector<const Type::StructFunctionMember*> Type::Private::functionMembers( const GTLCore::String& _name) const
 {
-  if(not structFunctionMembers) return 0;
+  std::vector<const Type::StructFunctionMember*> members;
+  if(not structFunctionMembers) return members;
   for( std::vector<GTLCore::Type::StructFunctionMember>::const_iterator it = structFunctionMembers->begin();
         it != structFunctionMembers->end(); ++it)
   {
     if( it->name() == _name)
     {
-      return &*it;
+      members.push_back(&*it);
     }
   }
-  return 0;
+  return members;
 }
 
 const Type::StructFunctionMember* Type::Private::privateFunctionMember( const GTLCore::String& _name) const
@@ -374,9 +383,9 @@ const GTLCore::Type* Type::Private::crea
   return type;
 }
 
-std::vector<const llvm::Type*> Type::Private::createFunctionParams(llvm::LLVMContext& _context, const Function* function)
+std::vector< llvm::Type*> Type::Private::createFunctionParams(llvm::LLVMContext& _context, const Function* function)
 {
-  std::vector<const llvm::Type*> params;
+  std::vector< llvm::Type*> params;
   for(std::vector< Parameter >::const_iterator it = function->parameters().begin();
       it != function->parameters().end(); ++it)
   {
@@ -390,7 +399,7 @@ std::vector<const llvm::Type*> Type::Pri
   return params;
 }
 
-const llvm::FunctionType* Type::Private::createFunctionFunctionType(llvm::LLVMContext& _context, const Function* function)
+llvm::FunctionType* Type::Private::createFunctionFunctionType(llvm::LLVMContext& _context, const Function* function)
 {
   return llvm::FunctionType::get( function->returnType()->d->asArgumentType(_context), createFunctionParams(_context, function), false );
 }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Type_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Type_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Type_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Type_p.h	2012-01-10 11:12:02.133249255 -0500
@@ -1,5 +1,5 @@
  /*
- *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *  Copyright (c) 2008,2009,2010 Cyrille Berger <cberger@cberger.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,6 +20,7 @@
 #ifndef _GTLCore_TYPE_P_H_
 #define _GTLCore_TYPE_P_H_
 
+#include "Debug.h"
 #include "Type.h"
 #include "Parameter.h"
 namespace llvm {
@@ -37,6 +38,32 @@ namespace GTLCore {
   /**
    * @internal
    * @ingroup GTLCore
+   */
+  class GTLCORE_EXPORT Type::StructDataMember::Information {
+    public:
+      /**
+       * @param setter is the name of a function that will take a pointer
+       *               to the structure as first parameter, and the value
+       *               as second parameter, and that will be called in operation=
+       *               to change the value.
+       */
+      Information(Function* _setter) : m_setter(_setter) {
+      }
+      ~Information();
+      const Function* setter() const {
+        return m_setter;
+      }
+      void setSetter(Function* function)
+      {
+        GTL_ASSERT(m_setter == 0);
+        m_setter = function;
+      }
+    private:
+      Function* m_setter;
+  };
+  /**
+   * @internal
+   * @ingroup GTLCore
    *
    * Represent a function member of a structure.
    */
@@ -106,23 +133,23 @@ namespace GTLCore {
       Private() : structDataMembers(0), structFunctionMembers(0), structPrivateFunctionMembers(0), m_visitor(0), m_factory(0) {}
       Private( Type::DataType _dataType );
       ~Private();
-      const llvm::Type * type(llvm::LLVMContext& _context) const;
+      llvm::Type * type(llvm::LLVMContext& _context) const;
       /**
        * @return a pointer version of the type a.k.a. llvm::PointerType::get( type(), 0)
        */
-      const llvm::Type * pointerType(llvm::LLVMContext& _context) const;
+      llvm::Type * pointerType(llvm::LLVMContext& _context) const;
       /**
        * @return how the type will be used as function argument (usually return type(),
        *         except for ARRAY and STRUCTURE where it return pointerType() )
        */
-      const llvm::Type * asArgumentType(llvm::LLVMContext& _context) const;
+      llvm::Type * asArgumentType(llvm::LLVMContext& _context) const;
       void addFunctionMember( const StructFunctionMember& );
       void addPrivateFunctionMember( const StructFunctionMember& );
       int memberToIndex(const GTLCore::String&);
       /**
        * @return the function member associated with that name, or null if none
        */
-      const Type::StructFunctionMember* functionMember( const GTLCore::String&) const;
+      std::vector<const Type::StructFunctionMember*> functionMembers( const GTLCore::String& _name) const;
       /**
        * @return the private function member associated with that name, or null if none
        */
@@ -157,8 +184,8 @@ namespace GTLCore {
       const GTLCore::Type* subtypeAt( unsigned int _index );
       const GTLCore::String& symbolName() const;
       static const GTLCore::Type* createArbitraryType( AribtraryTypeFactory* _factory);
-      static std::vector<const llvm::Type*> createFunctionParams(llvm::LLVMContext& _context, const Function* function);
-      static const llvm::FunctionType* createFunctionFunctionType(llvm::LLVMContext& _context, const Function* function);
+      static std::vector< llvm::Type*> createFunctionParams(llvm::LLVMContext& _context, const Function* function);
+      llvm::FunctionType* createFunctionFunctionType(llvm::LLVMContext& _context, const GTLCore::Function* function);
       static void deleteTypes();
     private:
       DataType dataType;
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/TypesManager.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/TypesManager.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/TypesManager.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/TypesManager.cpp	2012-01-10 11:12:02.133249255 -0500
@@ -84,8 +84,6 @@ const GTLCore::Type* TypesManager::getVe
 {
   GTL_ASSERT( _type );
   GTL_ASSERT( _size > 0 );
-  std::map< const GTLCore::Type*, std::map< int, const GTLCore::Type* > >::const_iterator it
-      = TypesManager::Private::knownVectors.find( _type );
   const GTLCore::Type*& type = TypesManager::Private::knownVectors[ _type ][ _size ];
   if( type == 0 )
   {
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Value_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Value_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Value_p.cpp.95a8c6853b97	2012-01-10 11:12:02.133249255 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Value_p.cpp	2012-01-10 11:12:02.133249255 -0500
@@ -0,0 +1,46 @@
+/*
+ *  Copyright (c) 2008,2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Value_p.h"
+
+#include <llvm/DerivedTypes.h>
+#include <llvm/Type.h>
+
+#include "Debug.h"
+#include "Value.h"
+
+namespace GTLCore {
+
+void copyValueToPtr(const GTLCore::Value& _value, const llvm::Type* type, llvm::LLVMContext& context, void* ptr)
+{
+    if( type == llvm::Type::getInt32Ty(context) )
+    {
+        *(int*)ptr =_value.asInt32();
+    } else if( type == llvm::Type::getInt1Ty(context) )
+    {
+        *(bool*)ptr = _value.asBoolean();
+    } else if( type == llvm::Type::getFloatTy(context) )
+    {
+        GTL_DEBUG("Set " << _value.asFloat32() << " on ptr " << ptr << " from value = " << *(float*)ptr);
+        *(float*)ptr = _value.asFloat32();
+        GTL_DEBUG( *(float*)ptr );
+    }
+}
+
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Value_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Value_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Value_p.h.95a8c6853b97	2012-01-10 11:12:02.133249255 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Value_p.h	2012-01-10 11:12:02.133249255 -0500
@@ -0,0 +1,35 @@
+/*
+ *  Copyright (c) 2008,2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLCORE_VALUE_P_H_
+#define _GTLCORE_VALUE_P_H_
+
+#include <GTLCore/Export.h>
+
+namespace llvm {
+  class Type;
+  class LLVMContext;
+}
+
+namespace GTLCore {
+  class Value;
+  GTLCORE_EXPORT void copyValueToPtr(const GTLCore::Value& _value, const llvm::Type* type, llvm::LLVMContext& context, void* ptr);
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/VariableNG_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/VariableNG_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/VariableNG_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/VariableNG_p.cpp	2012-01-10 11:12:02.133249255 -0500
@@ -40,12 +40,15 @@ struct VariableNG::Private
   bool constant;
   bool isInitialised;
   llvm::Value* pointer;
-  bool directlyOnTheStack;
-  bool allocatedInMemory;
   bool constantPointer;
   bool dependant;
+  bool isInMemoryObject()
+  {
+    return type->dataType() == Type::ARRAY or type->dataType() == Type::STRUCTURE;
+  }
+  bool storedOnStack;
 #ifdef OPENGTL_ENABLE_DEBUG_OUTPUT
-  bool dependantWasChangedToConst;
+  int dependantWasChangedToConst;
 #endif
 };
 
@@ -57,11 +60,10 @@ VariableNG::VariableNG(const GTLCore::Ty
   d->visitor = LLVMBackend::Visitor::getVisitorFor( _type );
   d->pointer = 0;
   d->constantPointer = false;
-  d->allocatedInMemory = false;
-  setAllocatedInMemory( true ); // Currently it's not possible to not allocate array/structure in memory until function return a structure and not a pointer, and structure/arrays knows wether they are allocated on stack or not
   d->dependant = _dependant;
+  d->storedOnStack = false;
 #ifdef OPENGTL_ENABLE_DEBUG_OUTPUT
-  d->dependantWasChangedToConst = false;
+  d->dependantWasChangedToConst = 2;
 #endif
 }
 
@@ -80,9 +82,9 @@ void VariableNG::setConstant( bool v )
 #ifdef OPENGTL_ENABLE_DEBUG_OUTPUT
   if( not v )
   {
-    GTL_ASSERT( not d->dependantWasChangedToConst );
+    --d->dependantWasChangedToConst;
+    GTL_ASSERT( d->dependantWasChangedToConst >= 0 );
   }
-  d->dependantWasChangedToConst = true;
 #endif
   d->constant = v;
 }
@@ -95,25 +97,30 @@ const GTLCore::Type* VariableNG::type()
 llvm::BasicBlock* VariableNG::initialise( GenerationContext& _generationContext, llvm::BasicBlock* _bb, const ExpressionResult& _initialiser, const std::list<llvm::Value*>& _initialSize )
 {
   GTL_DEBUG( _initialSize.size() );
+  d->storedOnStack = true;
   llvm::Value* pointer_ = 0;
   if( _initialiser.value() and _initialiser.functionResult()
       and (type()->dataType() == Type::ARRAY or type()->dataType() == Type::STRUCTURE ) )
   {
-    initialise( _generationContext, _bb, _initialiser.value() );
+    pointer_ = new llvm::AllocaInst( d->type->d->pointerType(_generationContext.llvmContext()), llvm::ConstantInt::get(llvm::Type::getInt32Ty(_generationContext.llvmContext()), 1), "Variable", _bb);
+    new llvm::StoreInst(_initialiser.value(), pointer_, _bb);
+    initialise( _generationContext, _bb, pointer_ );
     _bb = d->visitor->mark( _generationContext, _bb, pointer(_bb), d->type, CodeGenerator::integerToConstant( _generationContext.llvmContext(), INT32_C(1) ) );
   } else {
-    if( d->allocatedInMemory )
+    if( d->isInMemoryObject() )
     {
-      pointer_ = CodeGenerator::allocateMemory(_generationContext, d->type->d->type(_generationContext.llvmContext()), CodeGenerator::integerToConstant(_generationContext.llvmContext(), INT32_C(1)), _bb);
+      pointer_ = new llvm::AllocaInst( d->type->d->pointerType(_generationContext.llvmContext()), llvm::ConstantInt::get(llvm::Type::getInt32Ty(_generationContext.llvmContext()), 1), "Variable", _bb);
+      llvm::Value* value = CodeGenerator::allocateMemory(_generationContext, d->type->d->type(_generationContext.llvmContext()), CodeGenerator::integerToConstant(_generationContext.llvmContext(), INT32_C(1)), _bb);
+      new llvm::StoreInst(value, pointer_, _bb);
     } else {
       pointer_ = new llvm::AllocaInst( d->type->d->type(_generationContext.llvmContext()), llvm::ConstantInt::get(llvm::Type::getInt32Ty(_generationContext.llvmContext()), 1), "Variable", _bb);
     }
     initialise( _generationContext, _bb, pointer_ );
-    _bb = d->visitor->initialise( _generationContext, _bb, pointer_, d->type, _initialSize, d->allocatedInMemory);
+    _bb = d->visitor->initialise( _generationContext, _bb, pointer(_bb), d->type, _initialSize);
     
     if( _initialiser.value() )
     {
-      _bb = d->visitor->set( _generationContext, _bb, pointer_, d->type, _initialiser.value(), _initialiser.type() , d->allocatedInMemory);
+      _bb = d->visitor->set( _generationContext, _bb, pointer(_bb), d->type, _initialiser.value(), _initialiser.type());
     }
   }
   d->constantPointer = false;
@@ -124,16 +131,9 @@ void VariableNG::initialise( GenerationC
 {
   GTL_ASSERT( _pointer->getType()->getTypeID() == llvm::Type::PointerTyID );
   GTL_ASSERT(not d->isInitialised);
+  GTL_DEBUG(*_pointer << *_pointer->getType());
   d->isInitialised = true;
-  d->directlyOnTheStack = _currentBlock and ( d->type->dataType() == Type::ARRAY or d->type->dataType() == Type::STRUCTURE );
-  if( d->directlyOnTheStack )
-  {
-    d->pointer = new llvm::AllocaInst( llvm::PointerType::get( d->type->d->type(_generationContext.llvmContext()), 0 ), "Variable Pointer", _currentBlock );
-    GTL_DEBUG( *d->pointer << " " << *_pointer );
-    new llvm::StoreInst( _pointer, d->pointer, "Variable Pointer", _currentBlock );
-  } else {
-    d->pointer = _pointer;
-  }
+  d->pointer = _pointer;
   d->constantPointer = true;
 }
 
@@ -146,45 +146,31 @@ llvm::Value* VariableNG::get(LLVMBackend
 llvm::BasicBlock* VariableNG::set(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _value, const GTLCore::Type* _valueType )
 {
   GTL_ASSERT(not constant() );
-  return d->visitor->set( _generationContext, _currentBlock, d->pointer, d->type, _value, _valueType, d->allocatedInMemory);
+  return d->visitor->set( _generationContext, _currentBlock, d->pointer, d->type, _value, _valueType);
 }
 
 llvm::BasicBlock* VariableNG::replacePointer( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer)
 {
-  GTL_ASSERT( _pointer->getType() == d->pointer->getType() );
+  GTL_DEBUG( "_pointer: " << *_pointer->getType() << " d->pointer: " << *d->pointer->getType() << " " << d->pointer );
+  GTL_ASSERT( _pointer->getType() == d->pointer->getType()->getContainedType(0) );
   GTL_ASSERT( not d->constantPointer );
-  GTL_ASSERT( d->allocatedInMemory );
+  GTL_ASSERT( d->isInMemoryObject() );
   _currentBlock = cleanUp( _generationContext, _currentBlock, 0 );
-  d->pointer = _pointer;
-  _currentBlock = d->visitor->mark( _generationContext, _currentBlock, d->pointer, d->type, CodeGenerator::integerToConstant( _generationContext.llvmContext(), INT32_C(1) ) );
+  new llvm::StoreInst(_pointer, d->pointer, _currentBlock);
+  _currentBlock = d->visitor->mark( _generationContext, _currentBlock, _pointer, d->type, CodeGenerator::integerToConstant( _generationContext.llvmContext(), INT32_C(1) ) );
   return _currentBlock;
 }
 
 llvm::Value* VariableNG::pointer(llvm::BasicBlock* _currentBlock)
 {
-  GTL_DEBUG( *d->pointer << " " << d->directlyOnTheStack );
-  if( d->directlyOnTheStack )
-  {
-    return new llvm::LoadInst( d->pointer, "Load Variable Pointer", _currentBlock );
-  } else {
-    return d->pointer;
-  }
-}
-
-bool VariableNG::allocatedInMemory() const
-{
-  return d->allocatedInMemory;
-}
-
-void VariableNG::setAllocatedInMemory( bool _allocated )
-{
-  if( d->type->dataType() == Type::ARRAY or d->type->dataType() == Type::STRUCTURE )
+  GTL_DEBUG( *d->pointer->getType() << *d->pointer );
+  if(d->isInMemoryObject() and d->storedOnStack)
   {
-    d->allocatedInMemory = _allocated;
+    return new llvm::LoadInst(d->pointer, "", _currentBlock);
   }
+  return d->pointer;
 }
 
-
 bool VariableNG::constantPointer() const
 {
   return d->constantPointer;
@@ -192,12 +178,12 @@ bool VariableNG::constantPointer() const
 
 llvm::BasicBlock* VariableNG::cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _donttouch )
 {
-  if( d->allocatedInMemory and not d->constantPointer )
+  if( d->isInMemoryObject() and not d->constantPointer )
   {
     llvm::Value* pointer_ = pointer( _currentBlock);
     _currentBlock = d->visitor->mark( _generationContext, _currentBlock, pointer_, d->type, CodeGenerator::integerToConstant( _generationContext.llvmContext(), INT32_C(-1) ) );
     // pointer_ is deallocated inside cleanup
-    _currentBlock = d->visitor->cleanUp( _generationContext, _currentBlock, pointer_, d->type, _donttouch, d->allocatedInMemory, true, true );
+    _currentBlock = d->visitor->cleanUp( _generationContext, _currentBlock, pointer_, d->type, _donttouch, true, true );
   }
   return _currentBlock;
 }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/VariableNG_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/VariableNG_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/VariableNG_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/VariableNG_p.h	2012-01-10 11:12:02.133249255 -0500
@@ -99,14 +99,6 @@ namespace GTLCore {
        */
       llvm::Value* pointer(llvm::BasicBlock* _currentBlock);
       /**
-       * @return true if the variable is allocated in memory, false otherwise
-       */
-      bool allocatedInMemory() const;
-      /**
-       * Make the variable allocated in memory if the type is structure or array
-       */
-      void setAllocatedInMemory( bool _allocated );
-      /**
        * @return true if the pointer is constant (which means it can't be replaced)
        */
       bool constantPointer() const;
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/VariablesManager_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/VariablesManager_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/VariablesManager_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/VariablesManager_p.cpp	2012-01-10 11:12:02.134249247 -0500
@@ -105,6 +105,15 @@ VariableNG* VariablesManager::getVariabl
   {
     return var;
   }
+  if(d->nameSpace != "" and n.nameSpace() == "")
+  {
+    ScopedName n2(d->nameSpace, n.name());
+    VariableNG* var = d->getVariableInMap( d->constants, n2 );
+    if(var)
+    {
+      return var;
+    }
+  }  
   return d->getVariableInMap( d->constants, n );
 }
 
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Version.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Version.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Version.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Version.cpp	2012-01-10 11:12:02.134249247 -0500
@@ -23,7 +23,7 @@
 namespace GTLCore {
   String LibraryShortName() { return "OpenGTL Core"; }
   String LibraryName() { return "Open Graphics Transformation Languages Core"; }
-  String LibraryCopyright() { return "Copyright (c) 2007-2010 Cyrille Berger (cberger@cberger.net)"; }
+  String LibraryCopyright() { return "Copyright (c) 2007,2008,2009,2010 Cyrille Berger (cberger@cberger.net)"; }
   String LibraryLicence() { return "GNU Lesser General Public License Version 2, or later"; }
   String LibraryVersionString() { return String::number( GTL_CORE_VERSION_MAJOR ) + "." + String::number( GTL_CORE_VERSION_MINOR ) + "." + String::number( GTL_CORE_VERSION_REVISION ); }
   int LibraryVersionMajor()
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/Version.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/Version.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/Version.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/Version.h	2012-01-10 11:12:02.134249247 -0500
@@ -24,7 +24,7 @@
 
 #define GTL_CORE_VERSION_MAJOR 0
 #define GTL_CORE_VERSION_MINOR 9
-#define GTL_CORE_VERSION_REVISION 14
+#define GTL_CORE_VERSION_REVISION 16
 
 namespace GTLCore {
   String LibraryShortName();
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/VirtualMachine_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/VirtualMachine_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/VirtualMachine_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/VirtualMachine_p.cpp	2012-01-10 11:12:02.134249247 -0500
@@ -24,14 +24,11 @@
 #include <llvm/Module.h>
 #include <llvm/DerivedTypes.h>
 #include <llvm/Target/TargetOptions.h>
-#include <llvm/Target/TargetSelect.h>
 #include <llvm/LLVMContext.h>
 #include <llvm/Support/CommandLine.h>
-#ifdef LLVM_27_OR_28
-#include <llvm/System/Threading.h>
-#else
 #include <llvm/Support/Threading.h>
-#endif
+#include <llvm/Support/ErrorHandling.h>
+#include <llvm/Support/TargetSelect.h>
 
 #include "Function_p.h"
 #include "Value.h"
@@ -51,9 +48,22 @@ struct VirtualMachine::Private {
 VirtualMachine* VirtualMachine::Private::virtualMachine = 0;
 int VirtualMachine::Private::optimLevel = 2;
 
+void gtl_llvm_error_handler(void *user_data, const std::string& reason)
+{
+  GTL_ABORT(reason);
+}
+
+
 VirtualMachine::VirtualMachine() : d(new Private)
 {
   d->executionEngine = 0;
+  
+#ifdef LLVM_27
+  llvm::llvm_install_error_handler(&gtl_llvm_error_handler);
+#else
+  llvm::install_fatal_error_handler(&gtl_llvm_error_handler);
+#endif
+  
   llvm::llvm_start_multithreaded();
 
   std::string errorMessage;
@@ -87,7 +97,9 @@ VirtualMachine::VirtualMachine() : d(new
 VirtualMachine::~VirtualMachine()
 {
   llvm::llvm_stop_multithreaded();
+#ifndef LLVM_27_OR_28
   delete d->executionEngine;
+#endif
   delete d;
 }
 
@@ -131,9 +143,9 @@ void *VirtualMachine::getPointerToFuncti
   return getPointerToFunction( F->d->data->function( ) );
 }
 
-void* VirtualMachine::getGlobalVariablePointer( llvm::GlobalVariable* GV)
+void* VirtualMachine::getGlobalVariablePointer( const llvm::GlobalVariable* _pointer)
 {
-    return d->executionEngine->getPointerToGlobal( GV );
+    return d->executionEngine->getPointerToGlobal( _pointer );
 }
 
 #if 0
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/VirtualMachine_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/VirtualMachine_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/VirtualMachine_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/VirtualMachine_p.h	2012-01-10 11:12:02.134249247 -0500
@@ -69,7 +69,7 @@ namespace GTLCore {
        * @return a pointer to the function
        */
       void *getPointerToFunction(Function *F);
-      void* getGlobalVariablePointer( llvm::GlobalVariable* _pointer);
+      void* getGlobalVariablePointer(const llvm::GlobalVariable* _pointer);
 #if 0
       /**
        * Set the value of a global variable.
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/wrappers/Allocate.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/wrappers/Allocate.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/wrappers/Allocate.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/wrappers/Allocate.h	2012-01-10 11:12:02.135249239 -0500
@@ -31,10 +31,10 @@ GTLCORE_EXPORT void gtl_free( void* _dat
 }
 
 template<class T>
-T* gtlAllocate(int elt = 1)
+T* gtlAllocate()
 {
-  T* t = (T*)gtl_malloc( elt * sizeof(T) );
-  // t.count = 1;
+  T* t = (T*)gtl_malloc( sizeof(T) );
+  t->count = 0;
   return t;
 }
 
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/wrappers/ArrayWrap.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/wrappers/ArrayWrap.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/wrappers/ArrayWrap.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/wrappers/ArrayWrap.h	2012-01-10 11:12:02.135249239 -0500
@@ -53,7 +53,7 @@ inline ArrayWrap* gtlAllocateArray( int
 {
   ArrayWrap* arrayWrap = gtlAllocate<ArrayWrap>( );
   arrayWrap->size = _size;
-  arrayWrap->data = gtlAllocate<_T_>( _size );
+  arrayWrap->data = gtl_malloc( _size * sizeof(_T_) );
   return arrayWrap;
 }
 
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/wrappers/ProgressReportWrap.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/wrappers/ProgressReportWrap.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/wrappers/ProgressReportWrap.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/wrappers/ProgressReportWrap.cpp	2012-01-10 11:12:02.135249239 -0500
@@ -38,4 +38,11 @@ void gtl_progress_report_next_pixel( voi
   report->nextPixel();
 }
 
+bool gtl_progress_report_interrupted( void* _reporter )
+{
+  GTL_ASSERT(_reporter);
+  GTLCore::ProgressReport* report = static_cast<GTLCore::ProgressReport*>(_reporter);
+  return report->interrupted();  
+}
+
 }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLCore/wrappers/ProgressReportWrap.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLCore/wrappers/ProgressReportWrap.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLCore/wrappers/ProgressReportWrap.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLCore/wrappers/ProgressReportWrap.h	2012-01-10 11:12:02.135249239 -0500
@@ -26,6 +26,7 @@ extern "C" {
 
 GTLCORE_EXPORT void gtl_progress_report_next_row( void* _reporter );
 GTLCORE_EXPORT void gtl_progress_report_next_pixel( void* _reporter );
+GTLCORE_EXPORT bool gtl_progress_report_interrupted( void* _reporter );
 
 }
 
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/AbstractLibrariesManager.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/AbstractLibrariesManager.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/AbstractLibrariesManager.cpp.95a8c6853b97	2012-01-10 11:12:02.135249239 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/AbstractLibrariesManager.cpp	2012-01-10 11:12:02.135249239 -0500
@@ -0,0 +1,26 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "AbstractLibrariesManager.h"
+
+using namespace GTLFragment;
+
+AbstractLibrariesManager::AbstractLibrariesManager() {}
+AbstractLibrariesManager::~AbstractLibrariesManager() {}
+
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/AbstractLibrariesManager.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/AbstractLibrariesManager.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/AbstractLibrariesManager.h.95a8c6853b97	2012-01-10 11:12:02.135249239 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/AbstractLibrariesManager.h	2012-01-10 11:12:02.135249239 -0500
@@ -0,0 +1,52 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLFRAGMENT_ABSTRACT_LIBRARY_MANAGER_H_
+#define _GTLFRAGMENT_ABSTRACT_LIBRARY_MANAGER_H_
+
+#include <GTLFragment/Library.h>
+
+namespace GTLFragment {
+  class Library;
+  class GTLFRAGMENT_EXPORT AbstractLibrariesManager {
+      GTL_NO_COPY(AbstractLibrariesManager)
+    protected:
+      AbstractLibrariesManager();
+      virtual ~AbstractLibrariesManager();
+    public:
+      /**
+       * @return a library if it's already loaded or return 0
+       */
+      virtual Library* library(const GTLCore::String& name, int _channelsNb) = 0;
+      /**
+       * Add a directory to the list of directory that get searched for library.
+       */
+      virtual void addDirectory(const GTLCore::String& directory) = 0;
+      /**
+       * Load a library with the given name.
+       */
+      virtual Library* loadLibrary( const GTLCore::String& filename, int _channelsNb) = 0;
+      /**
+       * @return the type of libraries produced by this LibrariesManager
+       */
+      virtual Library::Type libraryType() const = 0;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/CMakeLists.txt.95a8c6853b97	2012-01-10 11:12:02.136249231 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/CMakeLists.txt	2012-01-10 11:12:02.136249231 -0500
@@ -0,0 +1,54 @@
+if(OPENGTL_BUILD_TESTS)
+  add_subdirectory(tests)
+endif(OPENGTL_BUILD_TESTS)
+
+include_directories( ${LLVM_INCLUDE_DIR} )
+
+## GTLFragment library ##
+
+set(GTLFragment_SRCS
+    AbstractLibrariesManager.cpp
+    LibrariesManager.cpp
+    Library.cpp
+    Source.cpp
+    # Private
+    LibraryCompilation_p.cpp
+    Compiler_p.cpp
+    Lexer_p.cpp
+    Parser_p.cpp
+    Source_p.cpp
+    Wrapper.cpp
+    wrappers/ColorWrap_p.cpp
+    # Metadata
+    MetadataLexer_p.cpp
+    MetadataParser_p.cpp
+    Metadata.cpp
+    )
+
+add_library(GTLFragment SHARED ${GTLFragment_SRCS} )
+target_link_libraries(GTLFragment GTLCore )
+
+# __STDC_LIMIT_MACROS is needed by LLVM's DataTypes.h
+add_definitions( "-D__STDC_LIMIT_MACROS" )
+add_definitions( "-D__STDC_CONSTANT_MACROS" )
+add_definitions( -DCOUMPONENT_NAME="GTLFragment" )
+
+add_definitions( -D_GTLFRAGMENT_LIB_="${CMAKE_INSTALL_PREFIX}/lib/libGTLFragment.so.${OPENGTL_VERSION}")
+add_definitions( -D_GTLFRAGMENT_STD_LIB_SRC_DIR_="${CMAKE_CURRENT_SOURCE_DIR}")
+add_definitions( -D_GTLFRAGMENT_LIBRARIES_DIR_="${SHARE_INSTALL_DIR}/common/libraries" )
+
+# Set the ABI version of the library
+set_target_properties(GTLFragment PROPERTIES VERSION ${OPENGTL_LIB_VERSION} SOVERSION ${OPENGTL_LIB_SOVERSION} )
+
+# Install target
+install(TARGETS GTLFragment ${INSTALL_TARGETS_DEFAULT_ARGS} )
+install( FILES
+  Export.h
+  LibrariesManager.h
+  Library.h
+  Metadata.h
+  Source.h
+  DESTINATION ${INCLUDE_INSTALL_DIR}/GTLFragment )
+
+# Install standard library
+install(FILES stdlib.fragment DESTINATION ${SHARE_INSTALL_DIR}/common/libraries )
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Compiler_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Compiler_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Compiler_p.cpp.95a8c6853b97	2012-01-10 11:12:02.136249231 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Compiler_p.cpp	2012-01-10 11:12:02.136249231 -0500
@@ -0,0 +1,248 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Compiler_p.h"
+
+#include <llvm/Module.h>
+#include <llvm/PassManager.h>
+
+#include "GTLCore/AST/Expression.h"
+#include "GTLCore/AST/FunctionDeclaration.h"
+#include "GTLCore/AST/Tree.h"
+#include "GTLCore/LLVMBackend/CodeGenerator_p.h"
+#include "GTLCore/ModuleData_p.h"
+#include "GTLCore/CompilationMessage.h"
+#include "GTLCore/Function.h"
+#include "GTLCore/Type.h"
+#include "GTLCore/Macros_p.h"
+#include "GTLCore/Function_p.h"
+#include "GTLCore/Value.h"
+
+#include "GTLCore/Debug.h"
+#include "Lexer_p.h"
+#include "Library.h"
+#include "LibrariesManager.h"
+#include "Parser_p.h"
+#include <GTLCore/CompilationMessages.h>
+#include "Library_p.h"
+
+using namespace GTLFragment;
+
+struct Compiler::Private {
+  llvm::Module* llvmModule;
+  GTLCore::ModuleData* moduleData;
+  LLVMBackend::CodeGenerator* codeGenerator;
+  Lexer* lexer;
+  Parser* parser;
+  int channelsNb;
+  Library::Type type;
+  WhichStdLibrary stdLibrary;
+  std::map< GTLCore::String, GTLCore::Value > parameters;
+};
+
+Compiler::Compiler( Library::Type _type, int _channelsNb ) : d(new Private)
+{
+  d->moduleData = 0;
+  d->codeGenerator = 0;
+  d->channelsNb = _channelsNb;
+  d->type = _type;
+}
+
+Compiler::~Compiler()
+{
+  delete d;
+}
+
+WhichStdLibrary Compiler::whichStdLibrary() const
+{
+  return d->stdLibrary;
+}
+
+Library::Type Compiler::libraryType() const
+{
+  return d->type;
+}
+
+bool Compiler::compile(WhichStdLibrary _stdLibrary, const GTLCore::String& _sourceCode, const GTLCore::String& _kernelName, GTLCore::ModuleData* _moduleData, llvm::Module* _module, GTLCore::String& _nameSpace, const std::vector< ParameterInfo >& parameters)
+{
+  d->stdLibrary = _stdLibrary;
+  GTL_DEBUG("Compile: " << _kernelName << " : " << _sourceCode);
+  // Initialise the module structure
+  d->llvmModule = _module;
+  d->moduleData = _moduleData;
+  d->codeGenerator = new LLVMBackend::CodeGenerator( d->moduleData );
+  setModuleData(d->moduleData, _module);
+  
+  foreach(ParameterInfo pi, parameters)
+  {
+    d->parameters[pi.name] = pi.value;
+  }
+
+  llvm::LLVMContext& context = d->moduleData->llvmModule()->getContext();
+  
+  // Create Standard Library functions
+  // CtlStdLib functions (except print which get a special treatement)
+  createStdLibFunction( context, "assert", "assert", GTLCore::Type::Void, 1, GTLCore::Type::Boolean, false);
+  createStdLibFunction( context, "isnan_f", "isnan_f", GTLCore::Type::Boolean, 1, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "isnan_h", "isnan_h", GTLCore::Type::Boolean, 1, GTLCore::Type::Float32, false);
+  // C Math functions
+  createStdLibFunction( context, "rand", "intRandomAt", GTLCore::Type::Integer32, 3, GTLCore::Type::Integer32, false, GTLCore::Type::Integer32, false, GTLCore::Type::Integer32, false);
+  createStdLibFunction( context, "frand", "floatRandomAt", GTLCore::Type::Float32, 3, GTLCore::Type::Integer32, false, GTLCore::Type::Integer32, false, GTLCore::Type::Integer32, false);
+  createStdLibFunction( context, "acos", "acosf", GTLCore::Type::Float32, 1, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "asin", "asinf", GTLCore::Type::Float32, 1, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "atan", "atanf", GTLCore::Type::Float32, 1, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "atan2", "atan2f", GTLCore::Type::Float32, 2, GTLCore::Type::Float32, false, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "cos", "cosf", GTLCore::Type::Float32, 1, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "sin", "sinf", GTLCore::Type::Float32, 1, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "tan", "tanf", GTLCore::Type::Float32, 1, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "cosh", "coshf", GTLCore::Type::Float32, 1, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "sinh", "sinhf", GTLCore::Type::Float32, 1, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "tanh", "tanhf", GTLCore::Type::Float32, 1, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "exp", "expf", GTLCore::Type::Float32, 1, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "log", "logf", GTLCore::Type::Float32, 1, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "log10", "log10f", GTLCore::Type::Float32, 1, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "pow", "powf", GTLCore::Type::Float32, 2, GTLCore::Type::Float32, false, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "sqrt", "sqrtf", GTLCore::Type::Float32, 1, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "floor", "floorf", GTLCore::Type::Float32, 1, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "ceil", "ceilf", GTLCore::Type::Float32, 1, GTLCore::Type::Float32, false);
+  createStdLibFunction( context, "mod", "fmodf", GTLCore::Type::Float32, 2, GTLCore::Type::Float32, false, GTLCore::Type::Float32, false);
+  
+  // Init the lexer
+  std::istringstream iss(_sourceCode);
+  d->lexer = new Lexer( &iss, d->type );
+  d->parser = new Parser( this, d->lexer );
+  
+  // Import standard libaries
+  if( d->stdLibrary != RijnWrappersLibrary)
+  {
+    if( d->stdLibrary != FragmentStdLibrary)
+    { // of course you don't want to import the standard library when building the standard library
+      importModule("stdlib");
+    }
+    if( d->stdLibrary != RijnStdLibrary and (d->type == Library::RIJN_LIBRARY or d->type == Library::RIJN_SKETCH) )
+    {
+      importModule("rijnstdlib");
+    }
+  }
+
+  // Parse
+  GTLCore::AST::Tree* tree = d->parser->parse();
+  bool success = (tree and errorMessages().errors().size() == 0);
+  if( success )
+  {
+    tree->generate( d->moduleData, _module, d->codeGenerator, &context );
+    GTL_DEBUG( *_module );
+    for( std::list<GTLCore::AST::FunctionDeclaration*>::const_iterator it = tree->functionsDeclarations().begin();
+         it != tree->functionsDeclarations().end(); ++it)
+    {
+      _moduleData->appendFunction( (*it)->function()->name(), (*it)->function());
+    }
+  } else {
+    // Failure
+    GTL_DEBUG("failure " << errorMessages().toString());
+//     delete d->module;
+  }
+  _nameSpace = d->parser->nameSpace();
+  // Clean up
+  GTL_DEBUG("Clean up");
+  
+  delete tree;
+
+/*  foreach(GTLCore::Function* function, functionsToDelete())
+  {
+    delete function;
+  }*/
+  GTL_DEBUG("Namespace = " << d->parser->nameSpace() );
+  delete d->lexer;
+  d->lexer = 0;
+  delete d->parser;
+  d->parser = 0;
+  delete d->codeGenerator;
+  d->codeGenerator = 0;
+  d->moduleData = 0;
+  GTL_DEBUG("Compilation finished");
+  return success;
+}
+
+bool Compiler::importModule(const GTLCore::String& name)
+{
+  Library* library = LibrariesManager::instance()->loadLibrary( name, d->channelsNb, d->type );
+  if( library )
+  {
+    if(not library->isCompiled())
+    {
+      library->compile();
+      if(not library->isCompiled())
+      {
+        GTL_DEBUG("Compilation error: " << std::endl << library->compilationMessages().toString() ); // TODO: report the error
+        appendErrors( library->compilationMessages().errors() );
+        return false;
+      }
+    }
+    d->moduleData->linkWith( library->data() );
+    // Append the function coming from the imported module
+    std::list<GTLCore::Function*> functions = library->functions();
+    foreach( GTLCore::Function* function, functions )
+    {
+      GTL_DEBUG(function->name());
+      GTLCore::Function* newFunction = GTLCore::Function::Private::createExternalFunction( d->moduleData, d->llvmModule, d->moduleData->llvmModule()->getContext(), function );
+      declareFunction( newFunction->name(), newFunction );
+      functionsToDelete().push_back( newFunction );
+    }
+    
+    // Declare constant
+    GTL_ASSERT(d->parser);
+    for(std::map<GTLCore::ScopedName, const GTLCore::Type*>::const_iterator it = library->data()->constants().begin();
+        it != library->data()->constants().end(); ++it)
+    {
+      
+      d->parser->appendGlobalConstantDeclaration( new GTLCore::AST::GlobalConstantDeclaration(it->first, it->second, GTLCore::AST::Expression::fromValue(library->data()->constantsValue().at(it->first)), false, true ));
+    }
+  }
+  return library;
+}
+
+GTLCore::TypesManager* Compiler::typesManager()
+{
+  return d->moduleData->typesManager();
+}
+
+GTLCore::AST::Expression* Compiler::standardConstant( const GTLCore::String& _name )
+{
+  // TODO standardConstant
+  
+/*  // Check if it is a parameter
+  std::map< GTLCore::String, GTLCore::Value >::iterator it = d->parameters.find(_name);
+  if( it != d->parameters.end() )
+  {
+    return GTLCore::AST::Expression::fromValue( it->second );
+  }*/
+  
+  return 0;
+}
+
+const std::map< GTLCore::String, GTLCore::Value >& Compiler::parameters() const
+{
+  return d->parameters;
+}
+
+int Compiler::channelsNb() const
+{
+  return d->channelsNb;
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Compiler_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Compiler_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Compiler_p.h.95a8c6853b97	2012-01-10 11:12:02.136249231 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Compiler_p.h	2012-01-10 11:12:02.136249231 -0500
@@ -0,0 +1,66 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLFRAGMENT_COMPILER_H_
+#define _GTLFRAGMENT_COMPILER_H_
+
+#include <GTLCore/String.h>
+#include <GTLCore/CompilerBase_p.h>
+#include <GTLFragment/WhichStdLibrary_p.h>
+
+#include "Library.h"
+
+#include <map>
+
+namespace llvm {
+  class Module;
+}
+
+namespace GTLCore {
+  class ModuleData;
+  class Value;
+}
+
+namespace GTLFragment {
+  struct ParameterInfo;
+  /**
+   * @internal
+   * @ingroup GTLFragment
+   */
+  class Compiler : public GTLCore::CompilerBase {
+    public:
+      Compiler( Library::Type _type, int _channelsNb );
+      ~Compiler();
+      bool compile(WhichStdLibrary _stdLibrary, const GTLCore::String& _sourceCode, const GTLCore::String& _kernelName, GTLCore::ModuleData* _moduleData, llvm::Module* _module, GTLCore::String& _nameSpace, const std::vector< ParameterInfo>& parameters );
+      bool importModule(const GTLCore::String& name);
+      virtual GTLCore::TypesManager* typesManager();
+      Library::Type libraryType() const;
+      WhichStdLibrary whichStdLibrary() const;
+      const std::map< GTLCore::String, GTLCore::Value >& parameters() const;
+      int channelsNb() const;
+    public:
+      GTLCore::AST::Expression* standardConstant( const GTLCore::String& _name );
+    private:
+      struct Private;
+      Private* const d;
+  };
+  
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment.doxy.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment.doxy
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment.doxy.95a8c6853b97	2012-01-10 11:12:02.140249196 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment.doxy	2012-01-10 11:12:02.140249196 -0500
@@ -0,0 +1,13 @@
+/**
+ * @addtogroup GTLFragment GTLFragment Base Library for Shiva and Rijn
+ * @version 0.9.16
+ * @author Cyrille Berger
+ */
+
+
+// Explanation for the name
+// sketch (outline) 概 述 [gàishù]
+// trunk  [+of tree] 树 干 [shùgàn] 
+// tree  n c 树 [shù]
+//
+// Meaning that library is the outline of other libraries, and the shù part can also be seen as the trunk of other libraries
\ No newline at end of file
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Export.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Export.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Export.h.95a8c6853b97	2012-01-10 11:12:02.136249231 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Export.h	2012-01-10 11:12:02.136249231 -0500
@@ -0,0 +1,52 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2009 Cyrille Berger <cberger@cberger.net>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef GTLFRAGMENT_EXPORT_H
+#define GTLFRAGMENT_EXPORT_H
+
+/* needed for GTL_EXPORT and GTL_IMPORT macros */
+#include <GTLCore/Macros.h>
+
+#ifndef GTLFRAGMENT_EXPORT
+# if defined(OpenShiva_EXPORTS)
+   /* We are building this library */ 
+#  define GTLFRAGMENT_EXPORT GTL_EXPORT
+# else
+   /* We are using this library */ 
+#  define GTLFRAGMENT_EXPORT GTL_IMPORT
+# endif
+#endif
+
+# ifndef GTLFRAGMENT_EXPORT_DEPRECATED
+#  define GTLFRAGMENT_EXPORT_DEPRECATED GTL_DEPRECATED GTLFRAGMENT_EXPORT
+# endif
+
+# ifdef OPENGTL_ENABLE_TESTS
+#  define GTLFRAGMENT_TESTS_EXPORT GTLFRAGMENT_EXPORT
+# else
+#  define GTLFRAGMENT_TESTS_EXPORT
+# endif
+
+#ifdef OPENGTL_ENABLE_DEBUG_OUTPUT
+#  define GTLFRAGMENT_DEBUG_EXPORT GTLFRAGMENT_EXPORT
+# else
+#  define GTLFRAGMENT_DEBUG_EXPORT
+# endif
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Lexer_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Lexer_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Lexer_p.cpp.95a8c6853b97	2012-01-10 11:12:02.136249231 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Lexer_p.cpp	2012-01-10 11:12:02.136249231 -0500
@@ -0,0 +1,153 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Lexer_p.h"
+
+using namespace GTLFragment;
+
+#include "GTLCore/Token_p.h"
+
+#include "GTLCore/Debug.h"
+
+Lexer::Lexer(std::istream* istream, Library::Type type) : GTLCore::LexerBase(istream), m_type(type)
+{
+}
+
+Lexer::~Lexer()
+{
+}
+
+GTLCore::Token Lexer::nextToken()
+{
+  int lastChar = getNextNonSeparatorChar();
+  int initial_line = line() - 1;
+  int initial_col = column() - 1;
+  if( eof() ) return GTLCore::Token(GTLCore::Token::END_OF_FILE, line(), initial_col);
+  GTLCore::String identifierStr;
+  // Test for comment
+  GTLCore::Token commentToken;
+  if( ignoreComment( commentToken, lastChar ) )
+  {
+    return commentToken;
+  }
+  // if it is alpha, it's an identifier or a keyword
+  if(isalpha(lastChar) or lastChar == '_')
+  {
+    identifierStr = getIdentifier(lastChar);
+    IDENTIFIER_IS_KEYWORD( "and", AND );
+    IDENTIFIER_IS_KEYWORD( "or", OR );
+    IDENTIFIER_IS_KEYWORD( "not", NOT );
+    IDENTIFIER_IS_KEYWORD( "library", LIBRARY );
+    IDENTIFIER_IS_KEYWORD( "bool", BOOL );
+    IDENTIFIER_IS_KEYWORD( "bool2", BOOL2 );
+    IDENTIFIER_IS_KEYWORD( "bool3", BOOL3 );
+    IDENTIFIER_IS_KEYWORD( "bool4", BOOL4 );
+    IDENTIFIER_IS_KEYWORD( "const", CONST );
+    IDENTIFIER_IS_KEYWORD( "float", FLOAT );
+    IDENTIFIER_IS_KEYWORD( "float2", FLOAT2 );
+    IDENTIFIER_IS_KEYWORD( "float3", FLOAT3 );
+    IDENTIFIER_IS_KEYWORD( "float4", FLOAT4 );
+    IDENTIFIER_IS_KEYWORD( "else", ELSE );
+    IDENTIFIER_IS_KEYWORD( "for", FOR );
+    IDENTIFIER_IS_KEYWORD( "if", IF );
+    IDENTIFIER_IS_KEYWORD( "import", IMPORT );
+    IDENTIFIER_IS_KEYWORD( "int", INT );
+    IDENTIFIER_IS_KEYWORD( "int2", INT2 );
+    IDENTIFIER_IS_KEYWORD( "int3", INT3 );
+    IDENTIFIER_IS_KEYWORD( "int4", INT4 );
+    IDENTIFIER_IS_KEYWORD( "long", LONG );
+    IDENTIFIER_IS_KEYWORD( "return", RETURN );
+    IDENTIFIER_IS_KEYWORD( "size", SIZE );
+    IDENTIFIER_IS_KEYWORD( "struct", STRUCT );
+    IDENTIFIER_IS_KEYWORD( "unsigned", UNSIGNED );
+    IDENTIFIER_IS_KEYWORD( "void", VOID );
+    IDENTIFIER_IS_KEYWORD( "while", WHILE );
+    IDENTIFIER_IS_KEYWORD( "input", INPUT );
+    IDENTIFIER_IS_KEYWORD( "output", OUTPUT );
+    IDENTIFIER_IS_KEYWORD( "in", INPUT );
+    IDENTIFIER_IS_KEYWORD( "out", OUTPUT );
+    IDENTIFIER_IS_KEYWORD( "print", PRINT );
+    IDENTIFIER_IS_KEYWORD( "true", TTRUE );
+    IDENTIFIER_IS_KEYWORD( "false", TFALSE );
+    IDENTIFIER_IS_KEYWORD( "dependent", DEPENDENT );
+    
+    switch (m_type)
+    {
+      case Library::FRAGMENT_LIBRARY:
+        // By definition nothing go there, since Fragment is the common denominator between Shiva and Rijn
+        break;
+      case Library::SHIVA_KERNEL:
+      case Library::SHIVA_LIBRARY:
+      {
+        IDENTIFIER_IS_KEYWORD( "kernel", KERNEL );
+        IDENTIFIER_IS_KEYWORD( "floatn", FLOATN );
+        IDENTIFIER_IS_KEYWORD( "booln", BOOLN );
+        IDENTIFIER_IS_KEYWORD( "intn", INTN );
+      }
+        break;
+      case Library::RIJN_SKETCH:
+      case Library::RIJN_LIBRARY:
+      {
+        IDENTIFIER_IS_KEYWORD( "sketch", SKETCH );
+      }
+        break;
+    }
+
+    return GTLCore::Token(GTLCore::Token::IDENTIFIER, identifierStr,line(), initial_col);
+  } else if( isdigit(lastChar) )
+  { // if it's a digit 
+    return getDigit(lastChar);
+  } else if( lastChar == '"' ) {
+    return getString(lastChar);
+  } else {
+    CHAR_IS_TOKEN(';', SEMI );
+    if( lastChar == ':' and getNextChar() == ':' )
+    {
+        return GTLCore::Token(GTLCore::Token::COLONCOLON, line(), initial_col);
+    }
+    CHAR_IS_TOKEN( ',', COMA );
+    CHAR_IS_TOKEN( '.', DOT );
+    CHAR_IS_TOKEN( ':', COLON );
+    CHAR_IS_TOKEN( '{', STARTBRACE );
+    CHAR_IS_TOKEN( '}', ENDBRACE );
+    CHAR_IS_TOKEN( '(', STARTBRACKET );
+    CHAR_IS_TOKEN( ')', ENDBRACKET );
+    CHAR_IS_TOKEN( '[', STARTBOXBRACKET );
+    CHAR_IS_TOKEN( ']', ENDBOXBRACKET );
+    CHAR_IS_TOKEN_OR_TOKEN( '=', '=', EQUAL, EQUALEQUAL );
+    CHAR_IS_TOKEN_OR_TOKEN( '!', '=', NOT, DIFFERENT );
+    CHAR_IS_TOKEN_OR_TOKEN( '&', '&', BITAND, AND);
+    CHAR_IS_TOKEN_OR_TOKEN( '|', '|', BITOR, OR );
+    CHAR_IS_TOKEN( '^', BITXOR );
+    CHAR_IS_TOKEN_OR_TOKEN_OR_TOKEN( '<', '=', '<', INFERIOR, INFERIOREQUAL, LEFTSHIFT );
+    CHAR_IS_TOKEN_OR_TOKEN_OR_TOKEN( '>', '=', '>', SUPPERIOR, SUPPERIOREQUAL, RIGHTSHIFT );
+    CHAR_IS_TOKEN_OR_TOKEN_OR_TOKEN( '+', '+', '=', PLUS, PLUSPLUS, PLUSEQUAL );
+    CHAR_IS_TOKEN_OR_TOKEN_OR_TOKEN( '-', '-', '=', MINUS, MINUSMINUS, MINUSEQUAL );
+    CHAR_IS_TOKEN_OR_TOKEN( '*', '=', MULTIPLY, MULTIPLYEQUAL);
+    CHAR_IS_TOKEN_OR_TOKEN( '/', '=', DIVIDE, DIVIDEEQUAL);
+    CHAR_IS_TOKEN( '%', MODULO );
+    CHAR_IS_TOKEN( '~', TILDE );
+  }
+  if( lastChar > 128 ) return nextToken();
+  identifierStr = lastChar;
+  GTL_DEBUG("Unknown token : " << lastChar << " '" << identifierStr << "' at " << initial_line << "," << initial_col);
+  GTL_ASSERT( not isspace(lastChar));
+  return GTLCore::Token(GTLCore::Token::UNKNOWN, initial_line, initial_col);
+}
+
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Lexer_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Lexer_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Lexer_p.h.95a8c6853b97	2012-01-10 11:12:02.136249231 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Lexer_p.h	2012-01-10 11:12:02.136249231 -0500
@@ -0,0 +1,58 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLFRAGMENT_LEXER_P_H_
+#define _GTLFRAGMENT_LEXER_P_H_
+
+#include <GTLCore/LexerBase_p.h>
+#include <GTLFragment/Export.h>
+#include "Library.h"
+
+namespace GTLCore {
+  class Token;
+}
+
+namespace GTLFragment {
+  /**
+   * @internal
+   * @ingroup GTLFragment
+   *
+   * Lexer for Shiva kernels and Rijn sketches
+   */
+  class GTLFRAGMENT_EXPORT Lexer : public GTLCore::LexerBase {
+    public:
+      /**
+       * Creates a new lexer with the given stream.
+       * @code
+       *  std::istringstream iss(sourceCode);
+       *  OpenShiva::Lexer lng( &iss);
+       * @endcode
+       */
+      Lexer(std::istream* sstream, Library::Type type);
+      ~Lexer();
+    public:
+      /**
+       * @return the next token
+       */
+      GTLCore::Token nextToken();
+      Library::Type m_type;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/LibrariesManager.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/LibrariesManager.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/LibrariesManager.cpp.95a8c6853b97	2012-01-10 11:12:02.136249231 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/LibrariesManager.cpp	2012-01-10 11:12:02.136249231 -0500
@@ -0,0 +1,168 @@
+/*
+ *  Copyright (c) 2008, 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "LibrariesManager.h"
+
+#include <map>
+
+// LLVM
+#ifdef LLVM_27_OR_28
+#include <llvm/System/Path.h>
+#else
+#include <llvm/Support/Path.h>
+#endif
+
+#include "GTLCore/Debug.h"
+#include "Library.h"
+
+#include <GTLCore/Macros_p.h>
+
+using namespace GTLFragment;
+
+struct LibrariesManager::Private {
+  std::map<GTLCore::String, Library*> libraries;
+  std::list<GTLCore::String> directories;
+  AbstractLibrariesManager* gaisuManager;
+  AbstractLibrariesManager* shivaManager;
+  AbstractLibrariesManager* rijnManager;
+};
+
+STATIC_POINTER(LibrariesManager, s_instance);
+
+LibrariesManager::LibrariesManager() : d(new Private)
+{
+  addDirectory( "." );
+  addDirectory( _GTLFRAGMENT_STD_LIB_SRC_DIR_ );
+  addDirectory( _GTLFRAGMENT_LIBRARIES_DIR_ );
+  d->gaisuManager = this;
+  d->shivaManager = 0;
+  d->rijnManager = 0;
+}
+
+LibrariesManager::~LibrariesManager()
+{
+  for(std::map<GTLCore::String, Library*>::iterator it = d->libraries.begin();
+      it != d->libraries.end(); ++it)
+  {
+    delete it->second;
+  }
+  delete d;
+}
+
+void LibrariesManager::addDirectory(const GTLCore::String& directory)
+{
+  d->directories.push_back( directory );
+}
+
+Library* LibrariesManager::library(const GTLCore::String& name, int _channelsNb)
+{
+  std::map<GTLCore::String, Library*>::iterator it = d->libraries.find(name);
+  if( it == d->libraries.end())
+  {
+    return 0;
+  }
+  return it->second;
+}
+
+
+Library* LibrariesManager::loadLibrary( const GTLCore::String& name, int _channelsNb)
+{
+  Library* l = library( name, _channelsNb );
+  if(not l )
+  {
+    GTLCore::String sourceName = name + ".fragment";
+    for( std::list<GTLCore::String>::iterator it = d->directories.begin();
+        it != d->directories.end(); ++it )
+    {
+      llvm::sys::Path path( (const std::string&)*it );
+      path.appendComponent( (const std::string&)sourceName);
+      GTL_DEBUG("try " << path.c_str() );
+      if(path.exists() and path.canRead())
+      {
+        l = new Library( Library::FRAGMENT_LIBRARY, _channelsNb );
+        registerLibrary( name, l );
+        l->loadFromFile( path.c_str());
+        break;
+      }
+    }
+  }
+  return l;
+}
+
+Library* LibrariesManager::loadLibrary( const GTLCore::String& filename, int _channelsNb, Library::Type _type)
+{
+  switch(_type) {
+    case Library::FRAGMENT_LIBRARY:
+      // Will be handled after the switch
+      break;
+    case Library::SHIVA_KERNEL:
+    case Library::SHIVA_LIBRARY:
+    {
+      GTL_ASSERT(d->shivaManager);
+      Library* l = d->shivaManager->loadLibrary(filename, _channelsNb);
+      if(l) return l;
+    }
+      break;
+    case Library::RIJN_SKETCH:
+    case Library::RIJN_LIBRARY:
+    {
+      GTL_ASSERT(d->rijnManager);
+      Library* l = d->rijnManager->loadLibrary(filename, _channelsNb);
+      if(l) return l;
+    }
+      break;
+  }
+  return loadLibrary(filename, _channelsNb);
+}
+
+void LibrariesManager::registerLibrary(const GTLCore::String& name, Library* l)
+{
+  d->libraries[ name ] = l;
+}
+
+void LibrariesManager::registerLibrariesManager(AbstractLibrariesManager* manager)
+{
+  switch(manager->libraryType())
+  {
+    case Library::SHIVA_LIBRARY:
+      GTL_ASSERT(d->shivaManager == 0);
+      d->shivaManager = manager;
+      break;
+    case Library::RIJN_LIBRARY:
+      GTL_ASSERT(d->rijnManager == 0);
+      d->rijnManager = manager;
+      break;
+    default:
+      GTL_ABORT("Unsupported type");
+  }
+}
+
+LibrariesManager* LibrariesManager::instance()
+{
+  if( not s_instance )
+  {
+    s_instance = new LibrariesManager;
+  }
+  return s_instance;
+}
+
+Library::Type LibrariesManager::libraryType() const
+{
+  return Library::FRAGMENT_LIBRARY;
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/LibrariesManager.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/LibrariesManager.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/LibrariesManager.h.95a8c6853b97	2012-01-10 11:12:02.136249231 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/LibrariesManager.h	2012-01-10 11:12:02.136249231 -0500
@@ -0,0 +1,79 @@
+/*
+ *  Copyright (c) 2008, 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLFRAGMENT_LIBRARY_MANAGER_H_
+#define _GTLFRAGMENT_LIBRARY_MANAGER_H_
+
+#include <GTLCore/String.h>
+#include <GTLFragment/Export.h>
+#include <GTLFragment/AbstractLibrariesManager.h>
+
+namespace {
+  class StaticPointerLibrariesManager;
+}
+
+namespace GTLFragment {
+  class Library;
+  /**
+   * @ingroup GTLFragment
+   *
+   * Manage the different @ref Library that are used by the kernels.
+   */
+  class GTLFRAGMENT_EXPORT LibrariesManager : public AbstractLibrariesManager {
+      friend class ::StaticPointerLibrariesManager;
+    private:
+      LibrariesManager();
+      ~LibrariesManager();
+      GTL_NO_COPY(LibrariesManager);
+    public:
+      /**
+       * @return a library if it's already loaded or return 0
+       */
+      Library* library(const GTLCore::String& name, int _channelsNb);
+      /**
+       * Add a directory to the list of directory that get searched for library.
+       */
+      void addDirectory(const GTLCore::String& directory);
+      void registerLibrary(const GTLCore::String& name, Library* );
+      /**
+       * This allow other libarries manager to provide libraries
+       */
+      void registerLibrariesManager(AbstractLibrariesManager* manager);
+      /**
+       * Load a library with the given name.
+       */
+      Library* loadLibrary( const GTLCore::String& filename, int _channelsNb);
+      /**
+       * Load a library with the given name, for use with the given library type
+       */
+      Library* loadLibrary( const GTLCore::String& filename, int _channelsNb, Library::Type _type);
+      virtual Library::Type libraryType() const;
+    public:
+      /**
+       * @return the instance to the singleton \ref LibraryManager
+       */
+      static LibrariesManager* instance();
+    private:
+      struct Private;
+      Private* const d;
+  };
+  
+};
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/LibraryCompilation_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/LibraryCompilation_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/LibraryCompilation_p.cpp.95a8c6853b97	2012-01-10 11:12:02.136249231 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/LibraryCompilation_p.cpp	2012-01-10 11:12:02.136249231 -0500
@@ -0,0 +1,26 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "LibraryCompilation_p.h"
+
+using namespace GTLFragment;
+
+LibraryCompilation::LibraryCompilation() {}
+LibraryCompilation::~LibraryCompilation() {}
+
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/LibraryCompilation_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/LibraryCompilation_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/LibraryCompilation_p.h.95a8c6853b97	2012-01-10 11:12:02.137249223 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/LibraryCompilation_p.h	2012-01-10 11:12:02.137249223 -0500
@@ -0,0 +1,57 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLFRAGMENT_LIBRARY_COMPILATION_H_
+#define _GTLFRAGMENT_LIBRARY_COMPILATION_H_
+
+#include "Export.h"
+#include <GTLFragment/WhichStdLibrary_p.h>
+
+namespace llvm {
+  class Module;
+}
+
+namespace GTLCore {
+  class ModuleData;
+  class OperatorOverloadCenter;
+}
+
+namespace GTLFragment {
+  class Wrapper;
+  /**
+   * @internal
+   * @ingroup GTLFragment
+   * 
+   * Interface class to define preCompilation step of a @ref Library
+   */
+  class GTLFRAGMENT_EXPORT LibraryCompilation {
+    public:
+      LibraryCompilation();
+      virtual ~LibraryCompilation();
+      virtual void preCompilation() = 0;
+      virtual void cleanup() = 0;
+      virtual void postCompilation() = 0;
+      virtual void createWrapper(GTLCore::ModuleData* _moduleData, llvm::Module* module, int _channels, WhichStdLibrary _library) = 0;
+      virtual void addOperatorOverloads(GTLCore::OperatorOverloadCenter*) = 0;
+      virtual Wrapper* wrapper() = 0;
+  };
+  
+};
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Library.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Library.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Library.cpp.95a8c6853b97	2012-01-10 11:12:02.137249223 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Library.cpp	2012-01-10 11:12:02.137249223 -0500
@@ -0,0 +1,250 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Library.h"
+#include "Library_p.h"
+
+#include <sstream>
+
+#include <llvm/Module.h>
+#ifdef LLVM_27_OR_28
+#include <llvm/System/DynamicLibrary.h>
+#else
+#include <llvm/Support/DynamicLibrary.h>
+#endif
+#include <llvm/LLVMContext.h>
+
+#include "GTLCore/CompilationMessage.h"
+#include "GTLCore/Function.h"
+#include "GTLCore/ModuleData_p.h"
+#include "GTLCore/PixelDescription.h"
+#include "GTLCore/Region.h"
+#include "GTLCore/Type.h"
+#include "GTLCore/Macros_p.h"
+#include "GTLCore/TypesManager.h"
+#include "GTLCore/Value.h"
+#include "GTLCore/VirtualMachine_p.h"
+#include "GTLCore/Metadata/Group.h"
+#include "GTLCore/Metadata/ParameterEntry.h"
+#include "Metadata.h"
+#include "GTLCore/Metadata/Factory_p.h"
+
+#include "GTLCore/Debug.h"
+#include "Compiler_p.h"
+
+#include "LibraryCompilation_p.h"
+#include "Wrapper_p.h"
+
+using namespace GTLFragment;
+
+void Library::Private::metadataToParameters( const GTLCore::Metadata::Group* group)
+{
+  GTL_ASSERT( group );
+  foreach( const GTLCore::Metadata::Entry* entry, group->entries() )
+  {
+    if( const GTLCore::Metadata::ParameterEntry* pe = entry->asParameterEntry() )
+    {
+      createParameter(pe->name(), pe->defaultValue());
+    } else if( const GTLCore::Metadata::Group* ge = entry->asGroup() )
+    {
+      metadataToParameters( ge );
+    }
+  }
+}
+
+void Library::Private::initparameters()
+{
+  const Metadata* metadata = source.metadata();
+  parameters_info.clear();
+  parameters_name2id.clear();
+  if( metadata and metadata->parameters() )
+  {
+    metadataToParameters( metadata->parameters() );
+  }
+  GTL_ASSERT(parameters_info.size() == parameters_name2id.size());
+}
+
+int Library::Private::createParameter(GTLCore::String _name, GTLCore::Value _value)
+{
+  int id = parameters_name2id.size();
+  parameters_name2id[ _name ] = id;
+  parameters_info.resize(id + 1);
+  parameters_info[ id ].value = _value;
+  parameters_info[ id ].name = _name;
+  return id;
+}
+
+// -------- Library -------- //
+
+Library::Library( Type _mode , int _channelsNb) : d(new Private)
+{
+  d->name = "";
+  d->compiled = false;
+  d->m_llvmModule = 0;
+  d->m_moduleData = 0;
+  d->count_channels_generic = _channelsNb;
+  d->mode = _mode;
+}
+
+Library::~Library()
+{
+  cleanup();
+  delete d;
+}
+
+void Library::cleanup()
+{
+  TEST_GUARD_WRITE(d)
+  if(d->m_moduleData and d->m_moduleData->llvmLinkedModule())
+  {
+    GTLCore::VirtualMachine::instance()->unregisterModule( d->m_moduleData->llvmLinkedModule());
+  }
+  delete d->m_moduleData;
+  d->m_llvmModule = 0;
+  d->m_moduleData = 0;
+  if( d->libraryCompilation )
+  {
+    d->libraryCompilation->cleanup();
+  }
+}
+
+
+GTLCore::String Library::name() const
+{
+  return d->name;
+}
+
+void Library::setSource(const GTLCore::String& _source )
+{
+  d->source.setSource(_source);
+  d->initparameters();
+}
+
+void Library::setSource(const Source& source)
+{
+    d->source = source;
+    d->initparameters();
+}
+
+Source Library::source() const
+{
+    return d->source;
+}
+
+void Library::loadFromFile(const GTLCore::String& _fileName)
+{
+  if( _fileName.endWith( "stdlib.fragment" ) ) {
+    d->standardLibrary = FragmentStdLibrary;
+  } else if( _fileName.endWith( "rijnstdlib.rijn" ) ) {
+    d->standardLibrary = RijnStdLibrary;
+  } else if( _fileName.endWith( "rijnwrappers.rijn" ) ) {
+    d->standardLibrary = RijnWrappersLibrary;
+  } else if( _fileName.endWith( "shivawrappers.shiva" ) ) {
+    d->standardLibrary = ShivaWrappersLibrary;
+  }
+  d->source.loadFromFile(_fileName);
+  d->initparameters();
+}
+
+void Library::compile()
+{
+  TEST_GUARD_WRITE(d)
+  if( d->libraryCompilation )
+  {
+    d->libraryCompilation->preCompilation();
+  }
+  if(not d->source.metadata() )
+  {
+    d->compilationErrors = d->source.metadataCompilationMessages();
+    return;
+  }
+  if(d->source.source().isEmpty()) return;
+  cleanup();
+  llvm::LLVMContext& context = llvm::getGlobalContext(); // TODO someday (llvm 2.7 ?) use own context
+  d->m_llvmModule = new llvm::Module((const std::string&)d->name, context);
+  d->m_moduleData = new GTLCore::ModuleData(d->m_llvmModule);
+  Compiler c( d->mode,  d->count_channels_generic );
+  if( d->libraryCompilation )
+  {
+    d->libraryCompilation->createWrapper(d->m_moduleData, d->m_llvmModule, d->count_channels_generic, d->standardLibrary);
+    GTL_ASSERT(d->libraryCompilation->wrapper());
+    d->libraryCompilation->wrapper()->fillTypesManager( d->m_moduleData->typesManager(), c.convertCenter() );
+    d->libraryCompilation->addOperatorOverloads(c.operatorOverloadCenter());
+  } else {
+    Wrapper::createColorType(d->m_moduleData->typesManager(), c.convertCenter());
+  }
+  GTLCore::String nameSpace;
+  bool result = c.compile( d->standardLibrary, d->source.source(), d->name, d->m_moduleData, d->m_llvmModule, nameSpace, d->parameters_info );
+
+  if(result)
+  {
+    d->m_llvmModule = 0;
+    d->compiled = true;
+    // Register the compiled module in the virtual machine
+    llvm::sys::DynamicLibrary::LoadLibraryPermanently( _GTLFRAGMENT_LIB_, 0 ); // This needed because when OpenShiva is used in a plugins, OpenShiva symbols aren't loaded globally and then llvm can't find them (FIXME move that somewhere else)
+    d->m_moduleData->doLink();
+    GTLCore::VirtualMachine::instance()->registerModule( d->m_moduleData->llvmLinkedModule() );
+    d->name = nameSpace;
+    if( d->libraryCompilation )
+    {
+      d->libraryCompilation->postCompilation();
+    }
+    GTL_ASSERT( d->standardLibrary != NotAStdLibrary or d->name != "" );
+  } else {
+    d->compiled = false;
+    cleanup();
+    d->compilationErrors = c.errorMessages();
+  }
+  
+}
+
+bool Library::isCompiled() const
+{
+  return d->compiled;
+}
+
+const GTLCore::CompilationMessages& Library::compilationMessages() const
+{
+  return d->compilationErrors;
+}
+
+GTLCore::String Library::asmSourceCode() const
+{
+  TEST_GUARD_READ(d)
+  std::ostringstream os;
+  os << *d->m_moduleData->llvmModule() << std::endl;
+  return os.str();
+}
+
+const GTLCore::ModuleData* Library::data() const
+{
+  TEST_GUARD_READ(d)
+  return d->m_moduleData;
+}
+
+std::list<GTLCore::Function*> Library::functions()
+{
+  TEST_GUARD_READ(d)
+  return d->m_moduleData->functions();
+}
+
+const Metadata* Library::metadata() const
+{
+  return d->source.metadata();
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Library.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Library.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Library.h.95a8c6853b97	2012-01-10 11:12:02.137249223 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Library.h	2012-01-10 11:12:02.137249223 -0500
@@ -0,0 +1,127 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLFRAGMENT_LIBRARY_H_
+#define _GTLFRAGMENT_LIBRARY_H_
+
+#include <GTLCore/String.h>
+#include <GTLFragment/Export.h>
+#include <map>
+
+namespace GTLCore {
+  class CompilationMessage;
+  class CompilationMessages;
+  class ModuleData;
+  class Function;
+  class Value;
+}
+
+namespace OpenShiva {
+  class Library;
+  class Kernel;
+  class KernelPrivate;
+}
+
+namespace OpenRijn {
+  class Library;
+  class Sketch;
+}
+
+namespace GTLFragment {
+  class Source;
+  class Metadata;
+  /**
+   * @ingroup GTLFragment
+   *
+   * Represent a Fragment Library, it is also the base class for kernels and sketches.
+   */
+  class GTLFRAGMENT_EXPORT Library {
+    public:
+      enum Type {
+        FRAGMENT_LIBRARY,
+        SHIVA_KERNEL,
+        SHIVA_LIBRARY,
+        RIJN_SKETCH,
+        RIJN_LIBRARY
+      };
+    private:
+    friend class OpenRijn::Library;
+    friend class OpenRijn::Sketch;
+    friend class OpenShiva::Library;
+    friend class OpenShiva::Kernel;
+    friend class OpenShiva::KernelPrivate;
+    friend struct KernelPrivate;
+    friend class LibrariesManager;
+      Library( Type _mode, int _channelsNb );
+      ~Library();
+      GTL_NO_COPY(Library);
+    public:
+      /**
+       * @return the name of the kernel
+       */
+      GTLCore::String name() const;
+      /**
+       * Set the code source of the module.
+       */
+      void setSource(const GTLCore::String& source);
+      void setSource(const Source& source);
+      Source source() const;
+      /**
+       * Load the module from the given file name.
+       */
+      void loadFromFile(const GTLCore::String& fileName);
+      /**
+       * Start the compilation of the module.
+       */
+      void compile();
+      /**
+       * @return true if the module was successfully compiled.
+       */
+      bool isCompiled() const;
+      /**
+       * @return a string with the content of the compilation error.
+       */
+      const GTLCore::CompilationMessages& compilationMessages() const;
+      /**
+       * @return the assembly source code, it's mostly usefull for testing purpose
+       */
+      GTLCore::String asmSourceCode() const;
+      /**
+       * @return a pointer to the internal Data of this module (the class Module::Data
+       *         is not part of the public API and therefore there is no reason
+       *         to use this function).
+       */
+      const GTLCore::ModuleData* data() const;
+      /**
+       * @return the list of functions available in this module.
+       */
+      std::list<GTLCore::Function*> functions();
+      /**
+       * @return the metadata for this kernel.
+       */
+      const Metadata* metadata() const;
+    private:
+      void cleanup();
+    private:
+      struct Private;
+      Private* const d;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Library_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Library_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Library_p.h.95a8c6853b97	2012-01-10 11:12:02.137249223 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Library_p.h	2012-01-10 11:12:02.137249223 -0500
@@ -0,0 +1,82 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLFRAGMENT_LIBRARY_P_H_
+#define _GTLFRAGMENT_LIBRARY_P_H_
+
+#include "Compiler_p.h"
+#include "Library.h"
+
+#include <GTLCore/CompilationMessages.h>
+#include <GTLCore/Debug_thread_p.h>
+#include <GTLCore/String.h>
+#include <GTLCore/Value.h>
+
+#include "Source.h"
+
+#include <map>
+
+namespace llvm {
+  class Function;
+  class Module;
+}
+
+namespace GTLCore {
+  class ModuleData;
+  namespace Metadata {
+    class Group;
+  }
+}
+
+namespace GTLFragment {
+  struct ParameterInfo {
+    GTLCore::Value value;
+    GTLCore::String name;
+  };
+  class LibraryCompilation;
+  /**
+   * @internal
+   * @ingroup GTLFragment
+   * Private structure for a @ref Library
+   */
+  struct Library::Private {    
+    Private() : m_moduleData(0), standardLibrary(NotAStdLibrary), libraryCompilation(0)
+    {
+    }
+    void metadataToParameters( const GTLCore::Metadata::Group* );
+    void initparameters();
+    int createParameter(GTLCore::String _name, GTLCore::Value _value);
+    
+    GTLCore::String name;
+    Source source;
+    bool compiled;
+    llvm::Module* m_llvmModule;
+    GTLCore::ModuleData* m_moduleData;
+    int count_channels_generic;
+    Type mode;
+    WhichStdLibrary standardLibrary;
+    std::vector< ParameterInfo > parameters_info;
+    std::map< GTLCore::String, int > parameters_name2id;
+    GTLCore::CompilationMessages compilationErrors;
+    LibraryCompilation* libraryCompilation;
+    TEST_GUARD_VARIABLE
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Metadata.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Metadata.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Metadata.cpp.95a8c6853b97	2012-01-10 11:12:02.137249223 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Metadata.cpp	2012-01-10 11:12:02.137249223 -0500
@@ -0,0 +1,113 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Metadata.h"
+
+#include "GTLCore/Macros_p.h"
+#include "GTLCore/Value.h"
+#include "GTLCore/Metadata/Group.h"
+#include "GTLCore/Metadata/ParameterEntry.h"
+#include "GTLCore/Metadata/ValueEntry.h"
+
+#include "GTLCore/Debug.h"
+#include "Version.h"
+
+using namespace GTLFragment;
+using namespace GTLCore::Metadata;
+
+struct Metadata::Private {
+  int version;
+  const Group* infoList;
+  const Group* parametersList;
+};
+
+inline std::list<const Entry*> createList( const Entry* _version, const Group* _infoList, const Group* _parametersList )
+{
+  std::list<const Entry*> list;
+  if( _version )
+  {
+    list.push_back( _version );
+  }
+  if( _infoList )
+  {
+    list.push_back( _infoList );
+  }
+  if( _parametersList )
+  {
+    list.push_back( _parametersList );
+  }
+  return list;
+}
+
+Metadata::Metadata( const Entry* _version, const Group* _infoList, const Group* _parametersList ) : Group( "Kernel", createList( _version, _infoList, _parametersList ) ), d(new Private)
+{
+  d->version = 0;
+  if( _version )
+  {
+    const ValueEntry* te = _version->asValueEntry();
+    GTL_ASSERT( te );
+    d->version = te->value().asInt32();
+  }
+  d->infoList = _infoList;
+  d->parametersList = _parametersList;
+}
+
+Metadata::~Metadata()
+{
+  delete d;
+}
+
+int Metadata::version() const
+{
+  return d->version;
+}
+const Group* Metadata::informationRecords() const
+{
+  return d->infoList;
+}
+
+const Group* Metadata::parameters() const
+{
+  return d->parametersList;
+}
+
+const GTLCore::Metadata::ParameterEntry* recursiveFoundParameter(const GTLCore::String& _name, const Group* _group)
+{
+  foreach(const Entry* entry, _group->entries())
+  {
+    if(entry->asParameterEntry())
+    {
+      if(entry->name() == _name)
+      {
+        return entry->asParameterEntry();
+      }
+    } else if(entry->asGroup())
+    {
+      const GTLCore::Metadata::ParameterEntry* pe = recursiveFoundParameter(_name, entry->asGroup());
+      if(pe) return pe;
+    }
+  }
+  return 0;
+}
+
+const GTLCore::Metadata::ParameterEntry* Metadata::parameter(const GTLCore::String& _name) const
+{
+  if(not d->parametersList) return 0;
+  return recursiveFoundParameter( _name, d->parametersList );
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Metadata.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Metadata.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Metadata.h.95a8c6853b97	2012-01-10 11:12:02.137249223 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Metadata.h	2012-01-10 11:12:02.137249223 -0500
@@ -0,0 +1,49 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLFRAGMENT_KERNEL_METADATA_H_
+#define _GTLFRAGMENT_KERNEL_METADATA_H_
+
+#include <GTLCore/Metadata/Group.h>
+#include <GTLFragment/Export.h>
+
+namespace GTLFragment {
+  /**
+   * Hold metadata information from Sketches and Kernels
+   * @ingroup GTLFragment
+   */
+  class GTLFRAGMENT_EXPORT Metadata : public GTLCore::Metadata::Group {
+      friend class MetadataParser;
+      friend class Kernel;
+      Metadata( const GTLCore::Metadata::Entry* _version, const GTLCore::Metadata::Group* _infoList, const GTLCore::Metadata::Group* _parametersList );
+      ~Metadata();
+      GTL_NO_COPY(Metadata);
+    public:
+      int version() const;
+      const GTLCore::Metadata::Group* informationRecords() const;
+      const GTLCore::Metadata::Group* parameters() const;
+      const GTLCore::Metadata::ParameterEntry* parameter(const GTLCore::String& _name) const;
+    private:
+      struct Private;
+      Private* const d;
+  };
+}
+
+#endif
+
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/MetadataLexer_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/MetadataLexer_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/MetadataLexer_p.cpp.95a8c6853b97	2012-01-10 11:12:02.137249223 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/MetadataLexer_p.cpp	2012-01-10 11:12:02.137249223 -0500
@@ -0,0 +1,72 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "MetadataLexer_p.h"
+
+#include "GTLCore/Token_p.h"
+
+#include "GTLCore/Debug.h"
+
+using namespace GTLFragment;
+
+MetadataLexer::MetadataLexer(std::istream* sstream) : LexerBase(sstream)
+{
+}
+
+MetadataLexer::~MetadataLexer()
+{
+}
+
+GTLCore::Token MetadataLexer::nextToken()
+{
+  int lastChar = getNextNonSeparatorChar();
+  int initial_line = line() - 1;
+  int initial_col = column() - 1;
+  if( eof() ) return GTLCore::Token(GTLCore::Token::END_OF_FILE, line(), initial_col);
+  // Test for comment
+  GTLCore::Token commentToken;
+  if( ignoreComment( commentToken, lastChar ) )
+  {
+    return commentToken;
+  }
+  if(isalpha(lastChar))
+  {
+    return GTLCore::Token(GTLCore::Token::IDENTIFIER, getIdentifier(lastChar),line(), initial_col);
+  } else if( isdigit(lastChar) )
+  { // if it's a digit 
+    return getDigit(lastChar);
+  } else if( lastChar == '"' ) {
+    return getString(lastChar);
+  } else {
+    CHAR_IS_TOKEN('-', MINUS );
+    CHAR_IS_TOKEN(';', SEMI );
+    CHAR_IS_TOKEN(':', COLON );
+    CHAR_IS_TOKEN('<', INFERIOR );
+    CHAR_IS_TOKEN('>', SUPPERIOR );
+    CHAR_IS_TOKEN('{', STARTBRACE );
+    CHAR_IS_TOKEN('}', ENDBRACE );
+    CHAR_IS_TOKEN(',', COMA );
+  }
+  if( lastChar > 128 ) return nextToken();
+  GTLCore::String str;
+  str = lastChar;
+  GTL_DEBUG("Unknown token : " << lastChar << " " << str << " at " << initial_line << "," << initial_col);
+  return GTLCore::Token(GTLCore::Token::UNKNOWN, initial_line, initial_col);
+}
+
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/MetadataLexer_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/MetadataLexer_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/MetadataLexer_p.h.95a8c6853b97	2012-01-10 11:12:02.137249223 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/MetadataLexer_p.h	2012-01-10 11:12:02.137249223 -0500
@@ -0,0 +1,39 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLFRAGMENT_METADATA_LEXER_P_H_
+#define _GTLFRAGMENT_METADATA_LEXER_P_H_
+
+#include "GTLCore/LexerBase_p.h"
+#include <GTLFragment/Export.h>
+
+namespace GTLFragment {
+  /**
+    * @internal
+    * @ingroup GTLFragment
+    */
+  class GTLFRAGMENT_TESTS_EXPORT MetadataLexer : public GTLCore::LexerBase {
+    public:
+      MetadataLexer(std::istream* sstream);
+      virtual ~MetadataLexer();
+      virtual GTLCore::Token nextToken();
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/MetadataParser_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/MetadataParser_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/MetadataParser_p.cpp.95a8c6853b97	2012-01-10 11:12:02.138249214 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/MetadataParser_p.cpp	2012-01-10 11:12:02.138249214 -0500
@@ -0,0 +1,440 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "MetadataParser_p.h"
+
+#include "GTLCore/Color.h"
+#include "GTLCore/CompilationMessage.h"
+#include "GTLCore/CompilationMessages.h"
+#include "GTLCore/Macros_p.h"
+#include "GTLCore/Type.h"
+#include "GTLCore/TypesManager.h"
+#include "GTLCore/Value.h"
+
+#include "GTLCore/Metadata/TextEntry.h"
+#include "GTLCore/Metadata/ValueEntry.h"
+#include "GTLCore/Metadata/Factory_p.h"
+#include "GTLCore/Metadata/Group.h"
+#include "GTLCore/Metadata/ParameterEntry.h"
+
+#include "GTLCore/Debug.h"
+#include "MetadataLexer_p.h"
+#include "Metadata.h"
+#include <GTLCore/CompilationMessages_p.h>
+
+using namespace GTLFragment;
+
+struct MetadataParser::Private {
+  MetadataLexer* lexer;
+  GTLCore::Token token;
+  GTLCore::CompilationMessages errorMessages;
+  GTLCore::String fileName;
+};
+
+MetadataParser::MetadataParser( MetadataLexer* _lexer, const GTLCore::String& fileName) : d(new Private)
+{
+  d->lexer = _lexer;
+  d->fileName = fileName;
+}
+
+MetadataParser::~MetadataParser()
+{
+  delete d->lexer;
+  delete d;
+}
+
+Metadata* MetadataParser::parse()
+{
+  const GTLCore::Metadata::Entry* version = 0;
+  const GTLCore::Metadata::Group* infoList = 0;
+  const GTLCore::Metadata::Group* parametersList = 0;
+  getNextToken() ;
+  if( currentToken().type == GTLCore::Token::INFERIOR )
+  {
+    getNextToken();
+    while( currentToken().type != GTLCore::Token::SUPPERIOR and currentToken().type != GTLCore::Token::END_OF_FILE )
+    {
+      if( currentToken().type == GTLCore::Token::IDENTIFIER )
+      {
+        GTL_DEBUG( currentToken().string );
+        GTLCore::String str = currentToken().string;
+        getNextToken();
+        isOfType( currentToken(), GTLCore::Token::COLON );
+        getNextToken();
+        if( str == "version" )
+        {
+          version = parseValueEntry("version", 0);
+        } else if( str == "info" ) {
+          const GTLCore::Metadata::Entry* entry = parseGroupOrParameterEntry("info", false);
+          if( entry )
+          {
+            infoList = entry->asGroup();
+            GTL_ASSERT( infoList );
+          }
+        } else if( str == "parameters" ) {
+          const GTLCore::Metadata::Entry* entry = parseGroupOrParameterEntry("parameters", true);
+          if( entry )
+          {
+            parametersList = entry->asGroup();
+            validateParameters( parametersList);
+            GTL_ASSERT( parametersList );
+          }
+        } else {
+          GTL_DEBUG("Unexpected");
+          reportUnexpected( currentToken() );
+          getNextToken();
+        }
+      } else {
+        GTL_DEBUG("Unexpected");
+        reportUnexpected( currentToken() );
+        getNextToken();
+      }
+    }
+  }
+  return new Metadata( version, infoList, parametersList );
+}
+
+void MetadataParser::getNextToken()
+{
+  d->token = d->lexer->nextToken();
+}
+
+const GTLCore::Token& MetadataParser::currentToken()
+{
+  return d->token;
+}
+
+void MetadataParser::reportError( const GTLCore::String& errMsg, const GTLCore::Token& token )
+{
+  GTL_DEBUG( errMsg );
+  d->errorMessages.d->appendMessage(GTLCore::CompilationMessage( GTLCore::CompilationMessage::ERROR, errMsg, token.line, d->fileName ) );
+}
+
+void MetadataParser::reportUnexpected( const GTLCore::Token& token )
+{
+  reportError("Unexpected: " + GTLCore::Token::typeToString( token.type ), token );
+  getNextToken();
+}
+
+const GTLCore::CompilationMessages& MetadataParser::errorMessages() const
+{
+  return d->errorMessages;
+}
+
+bool MetadataParser::isOfType( const GTLCore::Token& token, GTLCore::Token::Type type )
+{
+  if( token.type == type )
+  {
+    return true;
+  } else {
+    reportError("Expected " + GTLCore::Token::typeToString(type) + " before " + GTLCore::Token::typeToString(token.type)  + ".", token);
+    return false;
+  }
+}
+
+const GTLCore::Metadata::ParameterEntry* MetadataParser::parseParameterEntry(const GTLCore::String& name)
+{
+  GTL_ABORT("oh");
+  return 0;
+}
+
+const GTLCore::Metadata::TextEntry* MetadataParser::parseTextEntry( const GTLCore::String& name)
+{
+  GTL_DEBUG( "parseTextEntry" );
+  if( currentToken().type == GTLCore::Token::STRING_CONSTANT or currentToken().type == GTLCore::Token::IDENTIFIER )
+  {
+    GTLCore::String v = currentToken().string;
+    getNextToken();
+    if( isOfType( currentToken(), GTLCore::Token::SEMI ) )
+    {
+      getNextToken();
+      return GTLCore::Metadata::Factory::createTextEntry( name, v );
+    }
+  } else {
+    GTL_DEBUG("Unexpected " << currentToken());
+    reportUnexpected( currentToken() );
+  }
+  return 0;
+}
+
+GTLCore::Value MetadataParser::parseCompoundValue(const GTLCore::Metadata::TextEntry* entryType)
+{
+  std::vector< GTLCore::Value > values;
+  enum { UNKNOWN, ARRAY, FLOAT } compoundType = UNKNOWN;
+  if( isOfType( currentToken(), GTLCore::Token::STARTBRACE ) )
+  {
+    getNextToken();
+    if( currentToken().type == GTLCore::Token::STARTBRACE )
+    {
+      compoundType = ARRAY;
+    } else {
+      compoundType = FLOAT;
+    }
+    while(true )
+    {
+      if( compoundType == ARRAY and isOfType( currentToken(), GTLCore::Token::STARTBRACE ) )
+      {
+        values.push_back( parseCompoundValue(0) );
+        getNextToken();
+      } else if( compoundType == FLOAT )
+      {
+        int v = 1;
+        if( currentToken().type == GTLCore::Token::MINUS )
+        {
+          v = -1;
+          getNextToken();
+        }
+        if( currentToken().type == GTLCore::Token::FLOAT_CONSTANT )
+        {
+          values.push_back( v * currentToken().f );
+        } else if( currentToken().type == GTLCore::Token::INTEGER_CONSTANT )
+        {
+          values.push_back( (float)v * currentToken().i );
+        } else {
+          GTL_DEBUG("Unexpected");
+          reportUnexpected( currentToken() );
+        }
+        getNextToken();
+      } else {
+        GTL_DEBUG("Unexpected");
+        reportUnexpected( currentToken() );
+        return values;
+      }
+      if( currentToken().type == GTLCore::Token::ENDBRACE )
+      {
+        const GTLCore::Type* type = 0;
+        if(values.size() < 1 )
+        {
+          reportError("Empty array", currentToken());
+          return GTLCore::Value();
+        }
+        if( entryType and entryType->text() == "color")
+        {
+          switch(values.size())
+          {
+            case 1:
+              return GTLCore::Value(GTLCore::Color(values[0].asFloat32(), values[0].asFloat32(), values[0].asFloat32()));
+            case 2:
+              return GTLCore::Value(GTLCore::Color(values[0].asFloat32(), values[0].asFloat32(), values[0].asFloat32(), values[1].asFloat32()));
+            case 3:
+              return GTLCore::Value(GTLCore::Color(values[0].asFloat32(), values[1].asFloat32(), values[2].asFloat32()));
+            case 4:
+              return GTLCore::Value(GTLCore::Color(values[0].asFloat32(), values[1].asFloat32(), values[2].asFloat32(), values[3].asFloat32()));
+            default:
+              reportError("Invalid number of elements for a color", currentToken());
+          }
+        } else if( compoundType == FLOAT )
+        {
+          type = GTLCore::TypesManager::getVector( GTLCore::Type::Float32, values.size() );
+        }
+        return GTLCore::Value(values, type);
+      }
+      if( not isOfType( currentToken(), GTLCore::Token::COMA ) )
+      {
+        return GTLCore::Value();
+      }
+      getNextToken();
+    }
+    getNextToken();
+  }
+  return GTLCore::Value();
+}
+
+const GTLCore::Metadata::ValueEntry* MetadataParser::parseValueEntry(const GTLCore::String& name, const GTLCore::Metadata::TextEntry* entryType)
+{
+  GTL_DEBUG( "parseValueEntry" );
+  GTLCore::Value val;
+  bool neg = false;
+  if( currentToken().type == GTLCore::Token::MINUS )
+  {
+    neg = true;
+    getNextToken();
+  }
+  if( currentToken().type == GTLCore::Token::FLOAT_CONSTANT )
+  {
+    if(neg)
+    {
+      val.setFloat32( -currentToken().f );
+    } else {
+      val.setFloat32( currentToken().f );
+    }
+  } else if( currentToken().type == GTLCore::Token::INTEGER_CONSTANT )
+  {
+    if(neg)
+    {
+      val.setInt32( -currentToken().i );
+    } else {
+      val.setInt32( currentToken().i );
+    }
+  } else if( currentToken().type == GTLCore::Token::STARTBRACE )
+  {
+    if(entryType)
+    {
+      val = parseCompoundValue(entryType);
+    } else {
+      reportError("Type must be declared before a value", currentToken());
+    }
+  } else if( currentToken().type == GTLCore::Token::IDENTIFIER ) {
+    if( currentToken().string == "true" )
+    {
+      val.setBoolean( true );
+    } else if( currentToken().string == "false" )
+    {
+      val.setBoolean( false );
+    } else {
+      GTL_DEBUG("Unexpected");
+      reportUnexpected( currentToken() );
+      getNextToken();
+      return 0;
+    }
+  } else {
+    GTL_DEBUG("Unexpected");
+    reportUnexpected( currentToken() );
+    getNextToken();
+    return 0;
+  }
+  getNextToken();
+  if( isOfType( currentToken(), GTLCore::Token::SEMI ) and val.isValid() )
+  {
+    getNextToken();
+    return GTLCore::Metadata::Factory::createValueEntry( name, val );
+  }
+  getNextToken();
+  return 0;
+}
+
+const GTLCore::Metadata::Entry* MetadataParser::parseGroupOrParameterEntry( const GTLCore::String& _name, bool _parameter)
+{
+  bool isAParameter = false;
+  GTL_DEBUG( "parseListEntry" );
+  std::list< const GTLCore::Metadata::Entry*> entries;
+  const GTLCore::Metadata::TextEntry* entryType = 0;
+  if( isOfType( currentToken(), GTLCore::Token::INFERIOR ) )
+  {
+    getNextToken();
+    bool valid = true;
+    while( currentToken().type != GTLCore::Token::SUPPERIOR and currentToken().type != GTLCore::Token::END_OF_FILE )
+    {
+      if( isOfType( currentToken(), GTLCore::Token::IDENTIFIER ) )
+      {
+        GTLCore::String str = currentToken().string;
+        getNextToken();
+        if( isOfType( currentToken(), GTLCore::Token::COLON ) )
+        {
+          getNextToken();
+          const GTLCore::Metadata::Entry* entry = 0;
+          if( currentToken().type == GTLCore::Token::INFERIOR )
+          {
+            entry = parseGroupOrParameterEntry( str, _parameter );
+          } else if( not _parameter or str == "description" or str == "label" ) {
+            GTL_DEBUG("t: " << str);
+            entry = parseTextEntry( str );
+          } else {
+            GTL_DEBUG("t: " << str);
+            if( str == "type" )
+            {
+              entryType = parseTextEntry( str );
+              if( entryType )
+              {
+                if( entryType->text() == "int" or entryType->text() == "float"
+                    or entryType->text() == "curve"
+                    or entryType->text() == "color" or entryType->text() == "float2"
+                    or entryType->text() == "float3" or entryType->text() == "float4"
+                    or entryType->text() == "bool" )
+                {
+                  isAParameter = true;
+                  entry = entryType;
+                } else {
+                  GTLCore::Metadata::Factory::deleteEntry( entryType );
+                  entryType = 0;
+                }
+              }
+            } else if( str == "minValue" or str == "maxValue" or str == "defaultValue" )
+            {
+              isAParameter = true;
+              entry = parseValueEntry( str, entryType );
+              valid = valid and entry;
+            } else {
+              GTL_DEBUG("Unexpected");
+              reportUnexpected( currentToken() );
+            }
+          }
+          if( entry )
+          {
+            entries.push_back( entry );
+          }
+        } else {
+          break;
+        }
+      } else {
+        break;
+      }
+    }
+    getNextToken();
+    if( isOfType( currentToken(), GTLCore::Token::SEMI ) and valid )
+    {
+      getNextToken();
+      if( isAParameter )
+      {
+        GTL_ASSERT( _parameter );
+        return GTLCore::Metadata::Factory::createParameterEntry( _name, entries);
+      } else {
+        return GTLCore::Metadata::Factory::createGroup( _name, entries);
+      }
+    } else {
+      foreach( const GTLCore::Metadata::Entry* entry, entries)
+      {
+        GTLCore::Metadata::Factory::deleteEntry( entry );
+      }
+      return 0;
+    }
+  }
+  getNextToken();
+  return 0;
+}
+
+void MetadataParser::validateParameters(const GTLCore::Metadata::Group* arg1)
+{
+  foreach(const GTLCore::Metadata::Entry* entry, arg1->entries())
+  {
+    if(const GTLCore::Metadata::ParameterEntry* pEntry = entry->asParameterEntry())
+    {
+      using GTLCore::Metadata::ParameterEntry;
+      foreach(const GTLCore::Metadata::Entry* cEntry, pEntry->entries())
+      {
+        if(const GTLCore::Metadata::ValueEntry* vEntry = cEntry->asValueEntry())
+        {
+          const GTLCore::Value& val = vEntry->value();
+          const GTLCore::Type* type = val.type();
+          if(pEntry->type()->isNumber())
+          {
+            if(not type->isNumber())
+            {
+              reportError( pEntry->name() + "'s " + vEntry->name() + " requires a number.", currentToken());
+            }
+            break;
+          }
+        }
+      }
+    } else if(const GTLCore::Metadata::Group* gEntry = entry->asGroup())
+    {
+      validateParameters(gEntry);
+    }
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/MetadataParser_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/MetadataParser_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/MetadataParser_p.h.95a8c6853b97	2012-01-10 11:12:02.138249214 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/MetadataParser_p.h	2012-01-10 11:12:02.138249214 -0500
@@ -0,0 +1,73 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLFRAGMENT_METADATA_PARSER_P_H_
+#define _GTLFRAGMENT_METADATA_PARSER_P_H_
+
+#include <list>
+#include <GTLCore/Token_p.h>
+#include <GTLFragment//Export.h>
+
+namespace GTLCore {
+  class CompilationMessages;
+  class String;
+  struct Token;
+  class Value;
+  namespace Metadata {
+    class Entry;
+    class ParameterEntry;
+    class ValueEntry;
+    class TextEntry;
+    class Group;
+  }
+}
+
+namespace GTLFragment {
+  class Metadata;
+  class MetadataLexer;
+  /**
+    * @internal
+    * @ingroup GTLFragment
+    */
+  class GTLFRAGMENT_TESTS_EXPORT MetadataParser {
+    public:
+      MetadataParser( MetadataLexer* _lexer, const GTLCore::String& fileName);
+      ~MetadataParser();
+      Metadata* parse();
+      const GTLCore::CompilationMessages& errorMessages() const;
+    private:
+      const GTLCore::Metadata::ValueEntry* parseValueEntry(const GTLCore::String& name, const GTLCore::Metadata::TextEntry* entryType);
+      GTLCore::Value parseCompoundValue(const GTLCore::Metadata::TextEntry* entryType);
+      const GTLCore::Metadata::ParameterEntry* parseParameterEntry(const GTLCore::String& name);
+      const GTLCore::Metadata::TextEntry* parseTextEntry(const GTLCore::String& name);
+      const GTLCore::Metadata::Entry* parseGroupOrParameterEntry(const GTLCore::String& name, bool _parameter);
+    private:
+      void getNextToken();
+      const GTLCore::Token& currentToken();
+      void reportError( const GTLCore::String& errMsg, const GTLCore::Token& token );
+      void reportUnexpected( const GTLCore::Token& token );
+      bool isOfType( const GTLCore::Token& , GTLCore::Token::Type type );
+      void validateParameters(const GTLCore::Metadata::Group* arg1);
+    private:
+      struct Private;
+      Private* const d;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Parser_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Parser_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Parser_p.cpp.95a8c6853b97	2012-01-10 11:12:02.138249214 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Parser_p.cpp	2012-01-10 11:12:02.138249214 -0500
@@ -0,0 +1,421 @@
+/*
+ *  Copyright (c) 2008,2009,2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Parser_p.h"
+
+#include "GTLCore/Debug.h"
+
+#include "Compiler_p.h"
+#include "Lexer_p.h"
+
+#include <GTLCore/AST/Expression.h>
+#include <GTLCore/AST/Statement.h>
+#include <GTLCore/AST/Tree.h>
+#include <GTLCore/CompilerBase_p.h>
+#include <GTLCore/Macros_p.h>
+#include <GTLCore/Type.h>
+#include <GTLCore/TypesManager.h>
+#include <GTLCore/Value.h>
+#include <GTLCore/VariableNG_p.h>
+#include <GTLCore/VariablesManager_p.h>
+#include <GTLCore/Function.h>
+#include <GTLCore/Parameter.h>
+#include <GTLCore/ConvertCenter_p.h>
+#include <GTLCore/AST/BinaryExpression.h>
+#include <GTLCore/AST/FunctionDeclaration.h>
+
+namespace AST = GTLCore::AST;
+using namespace GTLFragment;
+
+struct Parser::Private {
+  GTLCore::String kernelName;
+  GTLCore::AST::Tree* tree;
+  Compiler* compiler;
+  std::list<GTLCore::VariableNG*> dependents;
+  std::list<GTLCore::AST::Statement*> dependentsExpressions;
+  bool parsingStarted;
+  bool dependentFunctionParsed;
+};
+
+Parser::Parser( Compiler* _compiler , Lexer* _lexer) : ParserBase(_compiler, _lexer), d(new Private)
+{
+  d->compiler = _compiler;
+  d->tree = new GTLCore::AST::Tree();
+  d->parsingStarted = false;
+  d->dependentFunctionParsed = false;
+}
+
+Parser::~Parser()
+{
+  delete d;
+}
+
+GTLCore::AST::Tree* Parser::parse()
+{
+  GTL_DEBUG("Parsing with ParserNG");
+  GTL_ASSERT( d->tree );
+  GTL_ASSERT( not d->parsingStarted );
+
+  d->parsingStarted = true;
+  variablesManager()->startContext();
+  
+  getNextToken();
+  // Start by ingoring metadata if any
+  if( currentToken().type == GTLCore::Token::INFERIOR )
+  {
+    int count = 0;
+    do
+    {
+      switch( currentToken().type )
+      {
+        case GTLCore::Token::INFERIOR:
+          ++count;
+          break;
+        case GTLCore::Token::SUPPERIOR:
+          --count;
+          break;
+        default:
+          break;
+      }
+      getNextToken();
+    } while( count > 0 and currentToken().type != GTLCore::Token::END_OF_FILE  );
+    if( isOfType( currentToken(), GTLCore::Token::SEMI ) )
+    {
+      getNextToken();
+    }
+  }
+  
+  // Parse "import"
+  while( currentToken().type == GTLCore::Token::IMPORT )
+  {
+    getNextToken();
+    if( isOfType( currentToken(), GTLCore::Token::STRING_CONSTANT ) )
+    {
+      d->compiler->importModule( currentToken().string );
+    }
+    checkNextTokenIsSemi();
+    getNextToken();
+  }
+  
+  GTL_DEBUG("Parse body");
+  // Parse "kernel" or "library"
+  if( (d->compiler->libraryType() == Library::SHIVA_KERNEL and isOfType( currentToken(), GTLCore::Token::KERNEL ) )
+      or (d->compiler->libraryType() == Library::RIJN_SKETCH and isOfType( currentToken(), GTLCore::Token::SKETCH ) )
+      or isOfType( currentToken(), GTLCore::Token::LIBRARY ) )
+  {
+    getNextToken();
+    if( isOfType( currentToken(), GTLCore::Token::IDENTIFIER ) )
+    {
+      d->kernelName = currentToken().string;
+      GTL_ASSERT( d->kernelName != "" );
+      GTL_DEBUG( d->compiler->whichStdLibrary() << " " << d->kernelName );
+      if( d->compiler->whichStdLibrary() == NotAStdLibrary || d->compiler->whichStdLibrary() == RijnWrappersLibrary  || d->compiler->whichStdLibrary() == ShivaWrappersLibrary )
+      {
+        setNameSpace( d->kernelName );
+        GTL_ASSERT( d->kernelName == nameSpace() );
+      }
+      GTL_DEBUG("Set parameters as constants");
+      // Set parameters as constants
+      for( std::map< GTLCore::String, GTLCore::Value >::const_iterator it = d->compiler->parameters().begin();
+          it != d->compiler->parameters().end(); ++it )
+      {
+        GTLCore::ScopedName scopedName( nameSpace(), it->first );
+        const GTLCore::Type* declarationType = it->second.type();
+        if (declarationType == GTLCore::Type::Color)
+        {
+          declarationType = typesManager()->getStructure("color");
+          GTL_ASSERT(declarationType);
+        }
+        AST::GlobalConstantDeclaration* gcd = new AST::GlobalConstantDeclaration(
+            scopedName, declarationType,
+            GTLCore::AST::Expression::fromValue( it->second, declarationType ), true, false );
+        variablesManager()->declareConstant( scopedName, gcd->variable() );
+        tree()->append( gcd );
+      }
+      getNextToken();
+      if( isOfType( currentToken(), GTLCore::Token::STARTBRACE ) )
+      {
+        getNextToken();
+        parseKernelBody();
+        isOfType( currentToken(), GTLCore::Token::ENDBRACE );
+        getNextToken();
+      }
+    }
+  }
+  if(not d->dependentFunctionParsed and not d->dependentsExpressions.empty())
+  {
+    // Create a dependent function
+    AST::FunctionDeclaration* fd = new AST::FunctionDeclaration( GTLCore::ScopedName(nameSpace(), "evaluateDependents"), GTLCore::Type::Void, std::vector<AST::FunctionParameter*>() );
+    fd->setStatement(new AST::StatementsList(d->dependentsExpressions));
+    d->tree->append(fd);
+  }
+  
+  return d->tree;
+}
+
+void Parser::parseKernelBody()
+{
+  while(true)
+  {
+    switch(currentToken().type)
+    {
+      case GTLCore::Token::END_OF_FILE:
+      case GTLCore::Token::ENDBRACE:
+        return;
+      case GTLCore::Token::CONST:
+        parseConstantDeclaration();
+        break;
+      case GTLCore::Token::STRUCT:
+        parseStructDefinition();
+        break;
+      case GTLCore::Token::DEPENDENT:
+        parseDependentDeclaration();
+        break;
+      default:
+      {
+        if( currentToken().isFunctionType() )
+        {
+          parseFunction();
+        } else {
+          GTL_DEBUG("unexpected " << GTLCore::Token::typeToString( currentToken().type ) );
+          reportUnexpected( currentToken() );
+          getNextToken();
+        }
+      }
+    }
+  }
+}
+
+GTLCore::AST::Tree* Parser::tree()
+{
+  return d->tree;
+}
+
+AST::Statement* Parser::parseStatement()
+{
+  if( isType(currentToken()) )
+  {
+    return parseVariableDeclaration();
+  }
+  switch( currentToken().type )
+  {
+    case GTLCore::Token::CONST:
+      return parseVariableDeclaration();
+    case GTLCore::Token::STRUCT:
+    {
+      parseStructDefinition();
+      return new AST::DummyStatement();
+    }
+    case GTLCore::Token::STARTBRACKET:
+    case GTLCore::Token::IDENTIFIER:
+      return parseExpressionStatement();
+    case GTLCore::Token::IF:
+      return parseIfStatement();
+    case GTLCore::Token::WHILE:
+      return parseWhileStatement();
+    case GTLCore::Token::FOR:
+      return parseForStatement();
+    case GTLCore::Token::RETURN:
+      return parseReturnStatement();
+    case GTLCore::Token::STARTBRACE:
+    {
+      variablesManager()->startContext();
+      AST::Statement* statement = appendCurrentContextGarbageCollecting(parseStatementList());
+      variablesManager()->endContext();
+      return statement;
+    }
+    case GTLCore::Token::PRINT:
+    {
+      return parsePrintStatement();
+    }
+    default:
+      if( currentToken().isUnaryOperator() or currentToken().isConstant() )
+      {
+        return parseExpressionStatement();
+      }
+      GTL_DEBUG("unexpected");
+      reportUnexpected( currentToken() );
+      getNextToken();
+      return 0;
+  }
+}
+
+const GTLCore::Type* Parser::parseType()
+{
+  switch( currentToken().type )
+  {
+    case GTLCore::Token::BOOL2:
+      getNextToken();
+      return typesManager()->getVector( GTLCore::Type::Boolean, 2 );
+    case GTLCore::Token::BOOL3:
+      getNextToken();
+      return typesManager()->getVector( GTLCore::Type::Boolean, 3 );
+    case GTLCore::Token::BOOL4:
+      getNextToken();
+      return typesManager()->getVector( GTLCore::Type::Boolean, 4 );
+    case GTLCore::Token::BOOLN:
+      getNextToken();
+      return typesManager()->getVector( GTLCore::Type::Boolean, d->compiler->channelsNb() );
+    case GTLCore::Token::INT2:
+      getNextToken();
+      return typesManager()->getVector( GTLCore::Type::Integer32, 2 );
+    case GTLCore::Token::INT3:
+      getNextToken();
+      return typesManager()->getVector( GTLCore::Type::Integer32, 3 );
+    case GTLCore::Token::INT4:
+      getNextToken();
+      return typesManager()->getVector( GTLCore::Type::Integer32, 4 );
+    case GTLCore::Token::INTN:
+      getNextToken();
+      return typesManager()->getVector( GTLCore::Type::Integer32, d->compiler->channelsNb() );
+    case GTLCore::Token::FLOAT2:
+      getNextToken();
+      return typesManager()->getVector( GTLCore::Type::Float32, 2 );
+    case GTLCore::Token::FLOAT3:
+      getNextToken();
+      return typesManager()->getVector( GTLCore::Type::Float32, 3 );
+    case GTLCore::Token::FLOAT4:
+      getNextToken();
+      return typesManager()->getVector( GTLCore::Type::Float32, 4 );
+    case GTLCore::Token::FLOATN:
+      getNextToken();
+      return typesManager()->getVector( GTLCore::Type::Float32, d->compiler->channelsNb() );
+    default:
+      return GTLCore::ParserBase::parseType();
+  }
+}
+
+void Parser::parseDependentDeclaration()
+{
+  if(d->dependentFunctionParsed)
+  {
+    reportError("Dependents must be declared before the dependent function", currentToken());
+  }
+  getNextToken();
+  const GTLCore::Type* type = parseType();
+  if( not type ) return;
+  if( type->dataType() == GTLCore::Type::STRUCTURE 
+      and ( type->structName().startWith("pixel")
+            or type->structName().startWith("image") ) )
+  {
+    reportError( type->structName() + " can't be a dependent", currentToken());
+  }
+  while(true)
+  {
+    if( isOfType( currentToken(), GTLCore::Token::IDENTIFIER ) )
+    {
+      GTLCore::String name = currentToken().string;
+      getNextToken();
+      GTL_DEBUG("Dependent: " << name);
+      std::list<int> memberArraySize = expressionsListToIntegersList( parseArraySize(true) );
+      type = d->compiler->typesManager()->getArray( type, memberArraySize.size() );
+      GTLCore::ScopedName scopedName( nameSpace(), name );
+      if( tree()->containsGlobalConstant( scopedName ) )
+      {
+        reportError("Constant '" + scopedName.toString() + "' has already been declared", currentToken());
+      } else {
+        AST::GlobalConstantDeclaration* gcd = new AST::GlobalConstantDeclaration( scopedName, type , memberArraySize, true, false );
+        variablesManager()->declareConstant( scopedName, gcd->variable() );
+        d->dependents.push_back( gcd->variable() );
+        tree()->append( gcd );
+        if(currentToken().type == GTLCore::Token::EQUAL) {
+          getNextToken();
+          AST::Expression* expression = parseExpression(false, gcd->type());
+          expression = d->compiler->convertCenter()->createConvertExpression(expression, gcd->type());
+          gcd->variable()->setConstant(false);
+          d->dependentsExpressions.push_back(new GTLCore::AST::AssignementBinaryExpression( new GTLCore::AST::VariableAccessorExpression(gcd->variable()), expression ));
+          gcd->variable()->setConstant(true);
+        }
+      }
+    } else {
+      GTL_DEBUG("Unexpected");
+      reportUnexpected( currentToken() );
+      reachNextSemi();
+    }
+    if( currentToken().type == GTLCore::Token::COMA ) {
+      getNextToken();
+    } else {
+      break;
+    }
+  }
+  isOfType( currentToken(), GTLCore::Token::SEMI );
+  getNextToken();
+}
+
+AST::StatementsList* Parser::startParsingFunction( const GTLCore::String& _name )
+{
+  if( _name == "evaluateDependents" )
+  {
+    d->dependentFunctionParsed = true;
+    foreach( GTLCore::VariableNG* var, d->dependents )
+    {
+      var->setConstant( false );
+    }
+    if(d->dependentsExpressions.empty())
+    {
+      return 0;
+    } else {
+      return new AST::StatementsList(d->dependentsExpressions);
+    }
+  }
+  return 0;
+}
+
+void Parser::endParsingFunction( const GTLCore::String& _name )
+{
+  if( _name == "evaluateDependents" )
+  {
+    foreach( GTLCore::VariableNG* var, d->dependents )
+    {
+      var->setConstant( true );
+    }
+  }
+}
+
+bool isRegion(const GTLCore::Type* t)
+{
+  return t->isStructure() and t->structName() == "region";
+}
+
+bool Parser::validateFunctionParameters(const GTLCore::Function* function)
+{
+  if(function->name().name() == "evaluatePixel") {
+    if(function->parameters().empty()) return false;
+    std::size_t last_idx = function->parameters().size() - 1;
+    for(std::size_t i = 0; i < last_idx; ++i)
+    {
+      const GTLCore::Type* t = function->parameters()[i].type();
+      if(not t->isStructure() and function->parameters()[i].isOutput() and not t->structName().startWith("image"))
+      {
+        return false;
+      }
+    }
+    const GTLCore::Type* t = function->parameters()[last_idx].type();
+    return t->isStructure() and function->parameters()[last_idx].isOutput() and t->structName().startWith("pixel");
+  } else if(function->name().name() == "changed" or function->name().name() == "needed") {
+    if(function->parameters().size() != 3) return false;
+    const GTLCore::Type* t0 = function->parameters()[0].type();
+    const GTLCore::Type* t1 = function->parameters()[1].type();
+    const GTLCore::Type* t2 = function->parameters()[2].type();
+    return isRegion(function->returnType()) and isRegion(t0) and t1 == GTLCore::Type::Integer32 and t2->dataType() == GTLCore::Type::ARRAY and isRegion(t2->embeddedType());
+  } else if(function->name().name() == "generated") {
+    return function->parameters().empty() and isRegion(function->returnType());
+  } 
+  return true;
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Parser_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Parser_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Parser_p.h.95a8c6853b97	2012-01-10 11:12:02.138249214 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Parser_p.h	2012-01-10 11:12:02.138249214 -0500
@@ -0,0 +1,69 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLFRAGMENT_PARSER_H_
+#define _GTLFRAGMENT_PARSER_H_
+
+#include "GTLCore/ParserBase_p.h"
+
+namespace GTLCore {
+  namespace AST {
+    class Tree;
+  }
+}
+
+namespace GTLFragment {
+  class Compiler;
+  class Lexer;
+  /**
+   * @internal
+   * @ingroup GTLFragment
+   *
+   * This is the parser of shiva kernels and rijn sketches.
+   */
+  class Parser : public GTLCore::ParserBase {
+    public:
+      /**
+       * Create a new parser using the @ref Compiler @p _compiler and the @ref Lexer
+       * @p _lexer .
+       */
+      Parser( Compiler* _compiler, Lexer* _lexer);
+      ~Parser();
+      /**
+       * Start parsing and return the resulting @ref GTLCore::AST::Tree or null if the parsing failed
+       */
+      GTLCore::AST::Tree* parse();
+    protected:
+      virtual GTLCore::AST::Tree* tree();
+      virtual GTLCore::AST::Statement* parseStatement();
+      virtual const GTLCore::Type* parseType();
+    protected: // Events
+      virtual GTLCore::AST::StatementsList* startParsingFunction( const GTLCore::String& _name );
+      virtual void endParsingFunction( const GTLCore::String& _name );
+      virtual bool validateFunctionParameters(const GTLCore::Function* function);
+    private:
+      void parseDependentDeclaration();
+      void parseKernelBody();
+    private:
+      struct Private;
+      Private* const d;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Source.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Source.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Source.cpp.95a8c6853b97	2012-01-10 11:12:02.138249214 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Source.cpp	2012-01-10 11:12:02.138249214 -0500
@@ -0,0 +1,103 @@
+/*
+ *  Copyright (c) 2009-2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Source_p.h"
+
+using namespace GTLFragment;
+
+#include <fstream>
+
+#include <GTLCore/String.h>
+
+#include "GTLCore/Debug.h"
+#include "Lexer_p.h"
+#include "MetadataLexer_p.h"
+#include "MetadataParser_p.h"
+#include "Metadata.h"
+
+#include "GTLCore/Metadata/Factory_p.h"
+#include <GTLCore/CompilationMessages.h>
+#include <GTLCore/SharedPointer.h>
+
+Source::Source(Source::Private* nd) : d(nd)
+{
+  nd->ref();
+}
+
+Source::Source() : d(new Private)
+{
+  d->ref();
+}
+
+GTL_SHARED_DATA(Source)
+
+GTLCore::String Source::name() const
+{
+  d->update();
+  return d->name;
+}
+
+GTLCore::String Source::source() const
+{
+  return d->source;
+}
+
+void Source::setSource( const GTLCore::String& _source)
+{
+  deref();
+  GTLCore::Metadata::Factory::deleteEntry( d->metadata );
+  d->metadata = 0;
+  d->metadataCompilationFailed = false;
+  d->uptodate = false;
+  d->source = _source;
+}
+
+void Source::loadFromFile(const GTLCore::String& _fileName)
+{
+  GTLCore::String source = "";
+  std::ifstream in;
+  in.open(_fileName.c_str() );
+  if(not in)
+  {
+    GTL_DEBUG( "Impossible to open file " << _fileName );
+    return;
+  }
+  std::string str;
+  std::getline(in,str);
+  while ( in ) {
+    source += str;
+    source += "\n";
+    std::getline(in,str);
+  }
+  setSource(source);
+}
+
+const Metadata* Source::metadata() const
+{
+  if(not d->metadata and not d->metadataCompilationFailed)
+  {
+    d->compileMetaData();
+  }
+  return d->metadata;
+}
+
+GTLCore::CompilationMessages Source::metadataCompilationMessages() const
+{
+  return d->compilationErrors;
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Source.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Source.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Source.h.95a8c6853b97	2012-01-10 11:12:02.138249214 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Source.h	2012-01-10 11:12:02.138249214 -0500
@@ -0,0 +1,64 @@
+/*
+ *  Copyright (c) 2009 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLFRAGMENT_KERNEL_SOURCE_H_
+#define _GTLFRAGMENT_KERNEL_SOURCE_H_
+
+#include <list>
+#include <GTLFragment/Export.h>
+
+namespace GTLCore {
+  class CompilationMessages;
+  class String;
+}
+
+namespace GTLFragment {
+  class Metadata;
+  /**
+   * @ingroup GTLFragment
+   * 
+   * Define the source code of a Kernel. Allow to access to information like the metadata,
+   * or the source code, or the parameters of the evaluateParam function.
+   */
+  class GTLFRAGMENT_EXPORT Source {
+    protected:
+      struct Private;
+      Source(Private* nd);
+    public:
+      Source();
+      Source(const Source& );
+      Source& operator=(const Source& );
+      ~Source();
+      GTLCore::String name() const;
+      GTLCore::String source() const;
+      void setSource( const GTLCore::String& );
+      void loadFromFile(const GTLCore::String& _fileName);
+      /**
+       * @return the metadata for this kernel.
+       */
+      const Metadata* metadata() const;
+      GTLCore::CompilationMessages metadataCompilationMessages() const;
+    private:
+      inline void deref();
+    protected:
+      Private* d;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Source_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Source_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Source_p.cpp.95a8c6853b97	2012-01-10 11:12:02.138249214 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Source_p.cpp	2012-01-10 11:12:02.138249214 -0500
@@ -0,0 +1,70 @@
+/*
+ *  Copyright (c) 2009-2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Source_p.h"
+
+using namespace GTLFragment;
+
+#include <fstream>
+
+#include "GTLCore/Debug.h"
+#include "MetadataLexer_p.h"
+#include "MetadataParser_p.h"
+#include "Metadata.h"
+#include "GTLCore/CompilationMessage.h"
+
+#include "GTLCore/Metadata/Factory_p.h"
+#include <GTLCore/CompilationMessages.h>
+
+
+// ---- Library::Private ---- //
+
+void Source::Private::compileMetaData()
+{
+  metadata = 0;
+  std::istringstream iss(source);
+  MetadataLexer* lexer = new MetadataLexer(&iss);
+  MetadataParser parser( lexer, "" );
+  metadata = parser.parse();
+  compilationErrors = parser.errorMessages();
+  metadataCompilationFailed = not compilationErrors.errors().empty();
+  GTL_DEBUG( compilationErrors.errors().size() );
+  GTL_DEBUG( parser.errorMessages().errors().size() );
+  if( compilationErrors.errors().size() != 0 )
+  {
+    GTLCore::Metadata::Factory::deleteEntry( metadata );
+    metadata = 0;
+  }
+}
+
+void Source::Private::update()
+{
+  if(uptodate) return;
+  uptodate = true;
+  specificUpdate(source, name);
+}
+
+Source::Private* Source::Private::clone()
+{
+  return new Private(*this);
+}
+
+void Source::Private::specificUpdate(const GTLCore::String& _source, GTLCore::String& name)
+{
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Source_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Source_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Source_p.h.95a8c6853b97	2012-01-10 11:12:02.138249214 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Source_p.h	2012-01-10 11:12:02.138249214 -0500
@@ -0,0 +1,48 @@
+/*
+ *  Copyright (c) 2009-2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Source.h"
+
+#include <GTLCore/SharedPointer.h>
+#include <GTLCore/String.h>
+#include "GTLCore/CompilationMessages.h"
+
+namespace GTLFragment {
+
+  /**
+   * @internal
+   * @ingroup GTLFragment
+   */
+  struct Source::Private : public GTLCore::SharedPointerData
+  {
+    Private() : metadata(0), metadataCompilationFailed(false), uptodate(false) {}
+    Private(const Private& _rhs) : SharedPointerData(), name(_rhs.name), source(_rhs.source), metadata(0), metadataCompilationFailed(false), uptodate(false) {}
+    
+    void compileMetaData();
+    void update();
+    GTLCore::String name;
+    GTLCore::String source;
+    Metadata* metadata;
+    bool metadataCompilationFailed;
+    GTLCore::CompilationMessages compilationErrors;
+    bool uptodate; ///< Hold wether name and type have been extracted from source
+    virtual Private* clone();
+    virtual void specificUpdate(const GTLCore::String& _source, GTLCore::String& name);
+  };
+}
\ No newline at end of file
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/stdlib.fragment.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/stdlib.fragment
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/stdlib.fragment.95a8c6853b97	2012-01-10 11:12:02.139249205 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/stdlib.fragment	2012-01-10 11:12:02.139249205 -0500
@@ -0,0 +1,440 @@
+/*
+ *  Copyright (c) 2008,2009,2010,2011 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * version 2 of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+library stdlib
+{
+  const float PI = 3.14159265358979323846;
+  const unsigned int RAND_MAX = 16777215; // 0xFFFFFF
+  // abs functions
+  float abs( float v )
+  {
+    if( v < 0) return -v;
+    return v;
+  }
+  float2 abs(float2 v)
+  {
+    return float2( abs(v.x), abs(v.y) );
+  }
+  float3 abs(float3 v)
+  {
+    return float3( abs(v.x), abs(v.y), abs(v.z) );
+  }
+  float4 abs(float4 v)
+  {
+    return float4( abs(v.x), abs(v.y), abs(v.z), abs(v.a) );
+  }
+  // Sign function
+  float sign( float v )
+  {
+    if( v < 0 ) return -1;
+    if( v > 0 ) return 1;
+    return v;
+  }
+  // min functions
+  float min(float a, float b)
+  {
+    if( a > b) return b;
+    return a;
+  }
+  float2 min(float2 v, float2 v2)
+  {
+    return float2( min(v.x, v2.x), min(v.y, v2.y) );
+  }
+  float3 min(float3 v, float3 v2)
+  {
+    return float3( min(v.x, v2.x), min(v.y, v2.y), min(v.z, v2.z) );
+  }
+  float4 min(float4 v, float4 v2)
+  {
+    return float4( min(v.x, v2.x), min(v.y, v2.y), min(v.z, v2.z), min(v.a, v2.a) );
+  }
+  // max functions
+  float max(float a, float b)
+  {
+    if( a < b) return b;
+    return a;
+  }
+  float2 max(float2 v, float2 v2)
+  {
+    return float2( max(v.x, v2.x), max(v.y, v2.y) );
+  }
+  float3 max(float3 v, float3 v2)
+  {
+    return float3( max(v.x, v2.x), max(v.y, v2.y), max(v.z, v2.z) );
+  }
+  float4 max(float4 v, float4 v2)
+  {
+    return float4( max(v.x, v2.x), max(v.y, v2.y), max(v.z, v2.z), max(v.a, v2.a) );
+  }
+  // mix functions
+  color mix(color a, color b, float c)
+  {
+    color r;
+    r.red = a.red * (1-c) + b.red * c;
+    r.green = a.green * (1-c) + b.green * c;
+    r.blue = a.blue * (1-c) + b.blue * c;
+    r.opacity = a.red * (1-c) + b.opacity * c;
+    return r;
+  }
+  float mix(float a, float b, float c)
+  {
+    return a * (1 - c) + b * c;
+  }
+  float2 mix(float2 a, float2 b, float c)
+  {
+    return a * (1 - c) + b * c;
+  }
+  float3 mix(float3 a, float3 b, float c)
+  {
+    return a * (1 - c) + b * c;
+  }
+  float4 mix(float4 a, float4 b, float c)
+  {
+    return a * (1 - c) + b * c;
+  }
+  // clamp functions
+  float clamp(float a, float min, float max)
+  {
+    if( a < min ) return min;
+    if( a > max ) return max;
+    return a;
+  }
+  float2 clamp(float2 a, float2 min, float2 max)
+  {
+    return float2(clamp(a.x, min.x, max.x), clamp(a.y, min.y, max.y));
+  }
+  float3 clamp(float3 a, float3 min, float3 max)
+  {
+    return float3(clamp(a.x, min.x, max.x), clamp(a.y, min.y, max.y), clamp(a.z, min.z, max.z));
+  }
+  float4 clamp(float4 a, float4 min, float4 max)
+  {
+    return float4(clamp(a.x, min.x, max.x), clamp(a.y, min.y, max.y), clamp(a.z, min.z, max.z), clamp(a.a, min.a, max.a));
+  }
+  // Lengths functions
+  float length( float2 v )
+  {
+    v *= v;
+    return sqrt(v.x + v.y);
+  }
+  float length( float3 v )
+  {
+    v *= v;
+    return sqrt(v.x + v.y + v.z);
+  }
+  float length( float4 v )
+  {
+    v *= v;
+    return sqrt(v.x + v.y + v.z + v.a);
+  }
+  // floor
+  float2 floor(float2 v)
+  {
+    return float2( floor(v.x), floor(v.y) );
+  }
+  float3 floor(float3 v)
+  {
+    return float3( floor(v.x), floor(v.y), floor(v.z) );
+  }
+  float4 floor(float4 v)
+  {
+    return float4( floor(v.x), floor(v.y), floor(v.z), floor(v.a) );
+  }
+  // ceil
+  float2 ceil(float2 v)
+  {
+    return float2( ceil(v.x), ceil(v.y) );
+  }
+  float3 ceil(float3 v)
+  {
+    return float3( ceil(v.x), ceil(v.y), ceil(v.z) );
+  }
+  float4 ceil(float4 v)
+  {
+    return float4( ceil(v.x), ceil(v.y), ceil(v.z), ceil(v.a) );
+  }
+  // fract
+  float fract(float v)
+  {
+    return v - floor(v);
+  }
+  float2 fract(float2 v)
+  {
+    return float2( fract(v.x), fract(v.y) );
+  }
+  float3 fract(float3 v)
+  {
+    return float3( fract(v.x), fract(v.y), fract(v.z) );
+  }
+  float4 fract(float4 v)
+  {
+    return float4( fract(v.x), fract(v.y), fract(v.z), fract(v.a) );
+  }
+  // cos functions
+  float2 cos(float2 v)
+  {
+    return float2( cos(v.x), cos(v.y) );
+  }
+  float3 cos(float3 v)
+  {
+    return float3( cos(v.x), cos(v.y), cos(v.z) );
+  }
+  float4 cos(float4 v)
+  {
+    return float4( cos(v.x), cos(v.y), cos(v.z), cos(v.a) );
+  }
+  // acos functions
+  float2 acos(float2 v)
+  {
+    return float2( acos(v.x), acos(v.y) );
+  }
+  float3 acos(float3 v)
+  {
+    return float3( acos(v.x), acos(v.y), acos(v.z) );
+  }
+  float4 acos(float4 v)
+  {
+    return float4( acos(v.x), acos(v.y), acos(v.z), acos(v.a) );
+  }
+  // sin functions
+  float2 sin(float2 v)
+  {
+    return float2( sin(v.x), sin(v.y) );
+  }
+  float3 sin(float3 v)
+  {
+    return float3( sin(v.x), sin(v.y), sin(v.z) );
+  }
+  float4 sin(float4 v)
+  {
+    return float4( sin(v.x), sin(v.y), sin(v.z), sin(v.a) );
+  }
+  // asin functions
+  float2 asin(float2 v)
+  {
+    return float2( asin(v.x), asin(v.y) );
+  }
+  float3 asin(float3 v)
+  {
+    return float3( asin(v.x), asin(v.y), asin(v.z) );
+  }
+  float4 asin(float4 v)
+  {
+    return float4( asin(v.x), asin(v.y), asin(v.z), asin(v.a) );
+  }
+  // tan functions
+  float2 tan(float2 v)
+  {
+    return float2( tan(v.x), tan(v.y) );
+  }
+  float3 tan(float3 v)
+  {
+    return float3( tan(v.x), tan(v.y), tan(v.z) );
+  }
+  float4 tan(float4 v)
+  {
+    return float4( tan(v.x), tan(v.y), tan(v.z), tan(v.a) );
+  }
+  // atan functions
+  float2 atan(float2 v)
+  {
+    return float2( atan(v.x), atan(v.y) );
+  }
+  float3 atan(float3 v)
+  {
+    return float3( atan(v.x), atan(v.y), atan(v.z) );
+  }
+  float4 atan(float4 v)
+  {
+    return float4( atan(v.x), atan(v.y), atan(v.z), atan(v.a) );
+  }
+  // atan2 functions
+  float2 atan2(float2 v, float2 v2)
+  {
+    return float2( atan2(v.x, v2.x), atan2(v.y, v2.y) );
+  }
+  float3 atan2(float3 v, float3 v2)
+  {
+    return float3( atan2(v.x, v2.x), atan2(v.y, v2.y), atan2(v.z, v2.z) );
+  }
+  float4 atan2(float4 v, float4 v2)
+  {
+    return float4( atan2(v.x, v2.x), atan2(v.y, v2.y), atan2(v.z, v2.z), atan2(v.a, v2.a) );
+  }
+  // cosh functions
+  float2 cosh(float2 v)
+  {
+    return float2( cosh(v.x), cosh(v.y) );
+  }
+  float3 cosh(float3 v)
+  {
+    return float3( cosh(v.x), cosh(v.y), cosh(v.z) );
+  }
+  float4 cosh(float4 v)
+  {
+    return float4( cosh(v.x), cosh(v.y), cosh(v.z), cosh(v.a) );
+  }
+  // sinh functions
+  float2 sinh(float2 v)
+  {
+    return float2( sinh(v.x), sinh(v.y) );
+  }
+  float3 sinh(float3 v)
+  {
+    return float3( sinh(v.x), sinh(v.y), sinh(v.z) );
+  }
+  float4 sinh(float4 v)
+  {
+    return float4( sinh(v.x), sinh(v.y), sinh(v.z), sinh(v.a) );
+  }
+  // tanh functions
+  float2 tanh(float2 v)
+  {
+    return float2( tanh(v.x), tanh(v.y) );
+  }
+  float3 tanh(float3 v)
+  {
+    return float3( tanh(v.x), tanh(v.y), tanh(v.z) );
+  }
+  float4 tanh(float4 v)
+  {
+    return float4( tanh(v.x), tanh(v.y), tanh(v.z), tanh(v.a) );
+  }
+  // exp functions
+  float2 exp(float2 v)
+  {
+    return float2( exp(v.x), exp(v.y) );
+  }
+  float3 exp(float3 v)
+  {
+    return float3( exp(v.x), exp(v.y), exp(v.z) );
+  }
+  float4 exp(float4 v)
+  {
+    return float4( exp(v.x), exp(v.y), exp(v.z), exp(v.a) );
+  }
+  // log functions
+  float2 log(float2 v)
+  {
+    return float2( log(v.x), log(v.y) );
+  }
+  float3 log(float3 v)
+  {
+    return float3( log(v.x), log(v.y), log(v.z) );
+  }
+  float4 log(float4 v)
+  {
+    return float4( log(v.x), log(v.y), log(v.z), log(v.a) );
+  }
+  // log10 functions
+  float2 log10(float2 v)
+  {
+    return float2( log10(v.x), log10(v.y) );
+  }
+  float3 log10(float3 v)
+  {
+    return float3( log10(v.x), log10(v.y), log10(v.z) );
+  }
+  float4 log10(float4 v)
+  {
+    return float4( log10(v.x), log10(v.y), log10(v.z), log10(v.a) );
+  }
+  // sqrt functions
+  float2 sqrt(float2 v)
+  {
+    return float2( sqrt(v.x), sqrt(v.y) );
+  }
+  float3 sqrt(float3 v)
+  {
+    return float3( sqrt(v.x), sqrt(v.y), sqrt(v.z) );
+  }
+  float4 sqrt(float4 v)
+  {
+    return float4( sqrt(v.x), sqrt(v.y), sqrt(v.z), sqrt(v.a) );
+  }
+  // pow functions
+  float2 pow(float2 v, float p)
+  {
+    return float2( pow(v.x, p), pow(v.y, p) );
+  }
+  float3 pow(float3 v, float p)
+  {
+    return float3( pow(v.x, p), pow(v.y, p), pow(v.z, p) );
+  }
+  float4 pow(float4 v, float p)
+  {
+    return float4( pow(v.x, p), pow(v.y, p), pow(v.z, p), pow(v.a, p) );
+  }
+  float2 pow(float2 v, float2 p)
+  {
+    return float2( pow(v.x, p.x), pow(v.y, p.y) );
+  }
+  float3 pow(float3 v, float3 p)
+  {
+    return float3( pow(v.x, p.x), pow(v.y, p.y), pow(v.z, p.z) );
+  }
+  float4 pow(float4 v, float4 p)
+  {
+    return float4( pow(v.x, p.x), pow(v.y, p.y), pow(v.z, p.z), pow(v.a, p.a) );
+  }
+  // deg2rad
+  float deg2rad(float d)
+  {
+    return d / 180 * PI;
+  }
+  float2 deg2rad(float2 v)
+  {
+    return float2( deg2rad(v.x), deg2rad(v.y) );
+  }
+  float3 deg2rad(float3 v)
+  {
+    return float3( deg2rad(v.x), deg2rad(v.y), deg2rad(v.z) );
+  }
+  float4 deg2rad(float4 v)
+  {
+    return float4( deg2rad(v.x), deg2rad(v.y), deg2rad(v.z), deg2rad(v.a) );
+  }
+  // rad2deg
+  float rad2deg(float d)
+  {
+    return d / PI * 180;
+  }
+  float2 rad2deg(float2 v)
+  {
+    return float2( rad2deg(v.x), rad2deg(v.y) );
+  }
+  float3 rad2deg(float3 v)
+  {
+    return float3( rad2deg(v.x), rad2deg(v.y), rad2deg(v.z) );
+  }
+  float4 rad2deg(float4 v)
+  {
+    return float4( rad2deg(v.x), rad2deg(v.y), rad2deg(v.z), rad2deg(v.a) );
+  }
+  // Random function
+  unsigned int rand(output unsigned int seed)
+  {
+    seed = seed * 1103515245 + 12345;
+    return (seed % RAND_MAX);
+  }
+  float frand(output unsigned int seed)
+  {
+    return rand(seed) / float(RAND_MAX);
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/CMakeLists.txt.95a8c6853b97	2012-01-10 11:12:02.139249205 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/CMakeLists.txt	2012-01-10 11:12:02.139249205 -0500
@@ -0,0 +1,11 @@
+include_directories( ${GTL_Core_DIR} )
+
+set(TestGTLFragment_SRCS
+  TestGTLFragment.cpp
+    )
+
+add_definitions( "-D__STDC_LIMIT_MACROS" )
+
+add_executable(TestGTLFragment ${TestGTLFragment_SRCS})
+target_link_libraries(TestGTLFragment GTLFragment GTLTest )
+add_test(TestGTLFragment TestGTLFragment)
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/TestGTLFragment.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/TestGTLFragment.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/TestGTLFragment.cpp.95a8c6853b97	2012-01-10 11:12:02.139249205 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/TestGTLFragment.cpp	2012-01-10 11:12:02.139249205 -0500
@@ -0,0 +1,30 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "GTLTest/Test.h"
+
+#include "TestLexer.h"
+#include "TestMetadataLexer.h"
+#include "TestMetadataParser.h"
+
+GTLTEST_MAIN_BEGIN(TestGTLFragment)
+GTLTEST_MAIN_ADD_CASE(TestLexer)
+GTLTEST_MAIN_ADD_CASE(TestMetadataLexer )
+GTLTEST_MAIN_ADD_CASE(TestMetadataParser)
+GTLTEST_MAIN_END()
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/TestLexer.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/TestLexer.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/TestLexer.h.95a8c6853b97	2012-01-10 11:12:02.139249205 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/TestLexer.h	2012-01-10 11:12:02.139249205 -0500
@@ -0,0 +1,273 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "GTLFragment/Lexer_p.h"
+#include "GTLCore/Token_p.h"
+
+#define TEST_FOR_TOKEN( toktype ) \
+  { \
+    GTLCore::Token tok = lng.nextToken(); \
+    GTLTEST_CHECK_EQUAL(tok.type, GTLCore::Token::toktype ); \
+  }
+
+#define TEST_FOR_TOKEN_AND_POS( toktype, _line_, _column_ ) \
+  { \
+    GTLCore::Token tok = lng.nextToken(); \
+    GTLTEST_CHECK_EQUAL(tok.type, GTLCore::Token::toktype ); \
+    GTLTEST_CHECK_EQUAL(tok.line, _line_ ); \
+    GTLTEST_CHECK_EQUAL(tok.column, _column_ ); \
+  }
+
+#define TEST_FOR_TOKEN_AND_VALUE( toktype, field, value ) \
+  { \
+    GTLCore::Token tok = lng.nextToken(); \
+    GTLTEST_CHECK_EQUAL(tok.type, GTLCore::Token::toktype ); \
+    GTLTEST_CHECK_NEAR_EQUAL(tok.field, value); \
+  }
+
+#define TEST_FOR_TOKEN_AND_VALUE_STRICT( toktype, field, value ) \
+  { \
+    GTLCore::Token tok = lng.nextToken(); \
+    GTLTEST_CHECK_EQUAL(tok.type, GTLCore::Token::toktype ); \
+    GTLTEST_CHECK_EQUAL(tok.field, value); \
+  }
+
+class TestLexerKeywords : public GTLTest::Case {
+  public:
+    TestLexerKeywords() : GTLTest::Case("Keywords") {}
+    virtual void runTest()
+    {
+      std::istringstream iss(" bool bool2 bool3 bool4 const float float2 float3 float4 else for if import int int2 int3 int4 long return size struct void while input output print true false library");
+      GTLFragment::Lexer lng( &iss, GTLFragment::Library::FRAGMENT_LIBRARY);
+      TEST_FOR_TOKEN( BOOL );
+      TEST_FOR_TOKEN( BOOL2 );
+      TEST_FOR_TOKEN( BOOL3 );
+      TEST_FOR_TOKEN( BOOL4 );
+      TEST_FOR_TOKEN( CONST );
+      TEST_FOR_TOKEN( FLOAT );
+      TEST_FOR_TOKEN( FLOAT2 );
+      TEST_FOR_TOKEN( FLOAT3 );
+      TEST_FOR_TOKEN( FLOAT4 );
+      TEST_FOR_TOKEN( ELSE );
+      TEST_FOR_TOKEN( FOR );
+      TEST_FOR_TOKEN( IF );
+      TEST_FOR_TOKEN( IMPORT );
+      TEST_FOR_TOKEN( INT );
+      TEST_FOR_TOKEN( INT2 );
+      TEST_FOR_TOKEN( INT3 );
+      TEST_FOR_TOKEN( INT4 );
+      TEST_FOR_TOKEN( LONG );
+      TEST_FOR_TOKEN( RETURN );
+      TEST_FOR_TOKEN( SIZE );
+      TEST_FOR_TOKEN( STRUCT );
+      TEST_FOR_TOKEN( VOID );
+      TEST_FOR_TOKEN( WHILE );
+      TEST_FOR_TOKEN( INPUT );
+      TEST_FOR_TOKEN( OUTPUT );
+      TEST_FOR_TOKEN( PRINT );
+      TEST_FOR_TOKEN( TTRUE );
+      TEST_FOR_TOKEN( TFALSE );
+      TEST_FOR_TOKEN( LIBRARY );
+    }
+};
+
+class TestLexerKeywordsRijn : public GTLTest::Case {
+  public:
+    TestLexerKeywordsRijn() : GTLTest::Case("KeywordsRijn") {}
+    virtual void runTest()
+    {
+      std::istringstream iss(" sketch kernel booln intn floatn library");
+      GTLFragment::Lexer lng( &iss, GTLFragment::Library::RIJN_LIBRARY);
+      TEST_FOR_TOKEN( SKETCH );
+      TEST_FOR_TOKEN( IDENTIFIER );
+      TEST_FOR_TOKEN( IDENTIFIER );
+      TEST_FOR_TOKEN( IDENTIFIER );
+      TEST_FOR_TOKEN( IDENTIFIER );
+      TEST_FOR_TOKEN( LIBRARY );
+    }
+};
+
+class TestLexerKeywordsFragment : public GTLTest::Case {
+  public:
+    TestLexerKeywordsFragment() : GTLTest::Case("KeywordsFragment") {}
+    virtual void runTest()
+    {
+      std::istringstream iss(" sketch kernel booln intn floatn library");
+      GTLFragment::Lexer lng( &iss, GTLFragment::Library::FRAGMENT_LIBRARY);
+      TEST_FOR_TOKEN( IDENTIFIER );
+      TEST_FOR_TOKEN( IDENTIFIER );
+      TEST_FOR_TOKEN( IDENTIFIER );
+      TEST_FOR_TOKEN( IDENTIFIER );
+      TEST_FOR_TOKEN( IDENTIFIER );
+      TEST_FOR_TOKEN( LIBRARY );
+    }
+};
+
+class TestLexerKeywordsShiva : public GTLTest::Case {
+  public:
+    TestLexerKeywordsShiva() : GTLTest::Case("KeywordsShiva") {}
+    virtual void runTest()
+    {
+      std::istringstream iss(" sketch kernel booln intn floatn library");
+      GTLFragment::Lexer lng( &iss, GTLFragment::Library::SHIVA_LIBRARY);
+      TEST_FOR_TOKEN( IDENTIFIER );
+      TEST_FOR_TOKEN( KERNEL );
+      TEST_FOR_TOKEN( BOOLN );
+      TEST_FOR_TOKEN( INTN );
+      TEST_FOR_TOKEN( FLOATN );
+      TEST_FOR_TOKEN( LIBRARY );
+    }
+};
+
+class TestLexerConstants : public GTLTest::Case {
+  public:
+    TestLexerConstants() : GTLTest::Case("Constants") {}
+    virtual void runTest()
+    {
+      std::istringstream iss(" 10 10.0 10e-7 20 30. 42.0 \"hello\" 8 \"escape \\\"me\\\"\"");
+      GTLFragment::Lexer lng( &iss, GTLFragment::Library::FRAGMENT_LIBRARY);
+      TEST_FOR_TOKEN_AND_VALUE_STRICT( INTEGER_CONSTANT, i, 10);
+      TEST_FOR_TOKEN_AND_VALUE( FLOAT_CONSTANT, f, 10.0);
+      TEST_FOR_TOKEN_AND_VALUE( FLOAT_CONSTANT, f, 10e-7);
+      TEST_FOR_TOKEN_AND_VALUE_STRICT( INTEGER_CONSTANT, i, 20);
+      TEST_FOR_TOKEN_AND_VALUE( FLOAT_CONSTANT, f, 30.);
+      TEST_FOR_TOKEN_AND_VALUE( FLOAT_CONSTANT, f, 42.0);
+      TEST_FOR_TOKEN_AND_VALUE_STRICT( STRING_CONSTANT, string, "hello");
+      TEST_FOR_TOKEN_AND_VALUE_STRICT( INTEGER_CONSTANT, i, 8);
+      TEST_FOR_TOKEN_AND_VALUE_STRICT( STRING_CONSTANT, string, "escape \\\"me\\\"");
+  }
+};
+
+class TestLexerSpecialCharacters : public GTLTest::Case {
+  public:
+    TestLexerSpecialCharacters() : GTLTest::Case("SpecialCharacters") {}
+    virtual void runTest()
+    {
+      std::istringstream iss(" ; :: , . { } ( ) [ ] = == ! != & && || | ^ < <= << > >= >> + ++ - -- * / % ~");
+      GTLFragment::Lexer lng( &iss, GTLFragment::Library::FRAGMENT_LIBRARY);
+      TEST_FOR_TOKEN( SEMI );
+      TEST_FOR_TOKEN( COLONCOLON );
+      TEST_FOR_TOKEN( COMA );
+      TEST_FOR_TOKEN( DOT );
+      TEST_FOR_TOKEN( STARTBRACE );
+      TEST_FOR_TOKEN( ENDBRACE );
+      TEST_FOR_TOKEN( STARTBRACKET );
+      TEST_FOR_TOKEN( ENDBRACKET );
+      TEST_FOR_TOKEN( STARTBOXBRACKET );
+      TEST_FOR_TOKEN( ENDBOXBRACKET );
+      TEST_FOR_TOKEN( EQUAL );
+      TEST_FOR_TOKEN( EQUALEQUAL );
+      TEST_FOR_TOKEN( NOT );
+      TEST_FOR_TOKEN( DIFFERENT );
+      TEST_FOR_TOKEN( BITAND );
+      TEST_FOR_TOKEN( AND );
+      TEST_FOR_TOKEN( OR );
+      TEST_FOR_TOKEN( BITOR );
+      TEST_FOR_TOKEN( BITXOR );
+      TEST_FOR_TOKEN( INFERIOR );
+      TEST_FOR_TOKEN( INFERIOREQUAL );
+      TEST_FOR_TOKEN( LEFTSHIFT );
+      TEST_FOR_TOKEN( SUPPERIOR );
+      TEST_FOR_TOKEN( SUPPERIOREQUAL );
+      TEST_FOR_TOKEN( RIGHTSHIFT );
+      TEST_FOR_TOKEN( PLUS );
+      TEST_FOR_TOKEN( PLUSPLUS );
+      TEST_FOR_TOKEN( MINUS );
+      TEST_FOR_TOKEN( MINUSMINUS );
+      TEST_FOR_TOKEN( MULTIPLY );
+      TEST_FOR_TOKEN( DIVIDE );
+      TEST_FOR_TOKEN( MODULO );
+      TEST_FOR_TOKEN( TILDE );
+    }
+};
+
+class TestLexerNoSpace : public GTLTest::Case {
+  public:
+    TestLexerNoSpace() : GTLTest::Case("NoSpace") {}
+    virtual void runTest()
+    {
+      std::istringstream iss("32)=(<<<3<==");
+      GTLFragment::Lexer lng( &iss, GTLFragment::Library::FRAGMENT_LIBRARY);
+      TEST_FOR_TOKEN( INTEGER_CONSTANT );
+      TEST_FOR_TOKEN( ENDBRACKET );
+      TEST_FOR_TOKEN( EQUAL );
+      TEST_FOR_TOKEN( STARTBRACKET );
+      TEST_FOR_TOKEN( LEFTSHIFT );
+      TEST_FOR_TOKEN( INFERIOR );
+      TEST_FOR_TOKEN( INTEGER_CONSTANT );
+      TEST_FOR_TOKEN( INFERIOREQUAL );
+      TEST_FOR_TOKEN( EQUAL );
+  }
+};
+
+class TestLexerIdentifier : public GTLTest::Case {
+  public:
+    TestLexerIdentifier() : GTLTest::Case("Identifier") {}
+    virtual void runTest()
+    {
+      std::istringstream iss(" HOHOH BOUH23 GLOB_");
+      GTLFragment::Lexer lng(&iss, GTLFragment::Library::FRAGMENT_LIBRARY);
+      TEST_FOR_TOKEN_AND_VALUE_STRICT( IDENTIFIER, string, "HOHOH");
+      TEST_FOR_TOKEN_AND_VALUE_STRICT( IDENTIFIER, string, "BOUH23");
+      TEST_FOR_TOKEN_AND_VALUE_STRICT( IDENTIFIER, string, "GLOB_");
+    }
+};
+
+class TestLexerPos : public GTLTest::Case {
+  public:
+    TestLexerPos() : GTLTest::Case("Pos") {}
+    virtual void runTest()
+    {
+      std::istringstream iss(" HELLO\nWORLD !");
+      GTLFragment::Lexer lng(&iss, GTLFragment::Library::FRAGMENT_LIBRARY);
+      TEST_FOR_TOKEN_AND_POS( IDENTIFIER, 1, 2);
+      TEST_FOR_TOKEN_AND_POS( IDENTIFIER, 2, 1);
+      TEST_FOR_TOKEN_AND_POS( NOT, 2, 7);
+    }
+};
+
+
+class TestLexerComments : public GTLTest::Case {
+  public:
+    TestLexerComments() : GTLTest::Case("Comments") {}
+    virtual void runTest()
+    {
+      std::istringstream iss(" /* HELLO\nWORLD ! */ + // BOUH \n -");
+      GTLFragment::Lexer lng(&iss, GTLFragment::Library::FRAGMENT_LIBRARY);
+      TEST_FOR_TOKEN( PLUS );
+      TEST_FOR_TOKEN( MINUS );
+    }
+};
+
+class TestLexer : public GTLTest::Suite {
+  public:
+    TestLexer() : GTLTest::Suite("Lexer")
+    {
+      addCase(new TestLexerConstants );
+      addCase(new TestLexerKeywords );
+      addCase(new TestLexerKeywordsRijn );
+      addCase(new TestLexerKeywordsFragment );
+      addCase(new TestLexerKeywordsShiva );
+      addCase(new TestLexerSpecialCharacters );
+      addCase(new TestLexerNoSpace );
+      addCase(new TestLexerPos );
+      addCase(new TestLexerIdentifier );
+      addCase(new TestLexerComments );
+    }
+};
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/TestMetadataLexer.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/TestMetadataLexer.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/TestMetadataLexer.h.95a8c6853b97	2012-01-10 11:12:02.139249205 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/TestMetadataLexer.h	2012-01-10 11:12:02.139249205 -0500
@@ -0,0 +1,42 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "GTLFragment/MetadataLexer_p.h"
+
+class TestMetadataLexer : public GTLTest::Case {
+  public:
+    TestMetadataLexer() : GTLTest::Case("MetadataLexer") {}
+    virtual void runTest()
+    {
+      std::istringstream iss(" < version: 0; info: < \"bouh\"; \"b\\\"o;\" 12.0 >");
+      GTLFragment::MetadataLexer lng(&iss);
+      TEST_FOR_TOKEN( INFERIOR );
+      TEST_FOR_TOKEN_AND_VALUE_STRICT( IDENTIFIER, string, "version" );
+      TEST_FOR_TOKEN( COLON );
+      TEST_FOR_TOKEN_AND_VALUE_STRICT( INTEGER_CONSTANT, i, 0);
+      TEST_FOR_TOKEN( SEMI );
+      TEST_FOR_TOKEN_AND_VALUE_STRICT( IDENTIFIER, string, "info" );
+      TEST_FOR_TOKEN( COLON );
+      TEST_FOR_TOKEN( INFERIOR );
+      TEST_FOR_TOKEN_AND_VALUE_STRICT( STRING_CONSTANT, string, "bouh" );
+      TEST_FOR_TOKEN( SEMI );
+      TEST_FOR_TOKEN_AND_VALUE_STRICT( STRING_CONSTANT, string, "b\\\"o;" );
+      TEST_FOR_TOKEN_AND_VALUE( FLOAT_CONSTANT, f, 12.0);
+    }
+};
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/TestMetadataParser.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/TestMetadataParser.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/TestMetadataParser.h.95a8c6853b97	2012-01-10 11:12:02.139249205 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/tests/TestMetadataParser.h	2012-01-10 11:12:02.139249205 -0500
@@ -0,0 +1,140 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "GTLFragment/MetadataParser_p.h"
+#include "GTLFragment/Metadata.h"
+
+#include "GTLCore/Color.h"
+#include "GTLCore/CompilationMessage.h"
+#include "GTLCore/Debug.h"
+#include "GTLCore/Type.h"
+#include "GTLCore/TypesManager.h"
+#include "GTLCore/Value.h"
+#include "GTLCore/Metadata/TextEntry.h"
+#include "GTLCore/Metadata/Group.h"
+#include "GTLCore/Metadata/ValueEntry.h"
+#include "GTLCore/Metadata/ParameterEntry.h"
+#include <GTLCore/CompilationMessages.h>
+
+#define TESTMEDATAPARSER_TEST_TEXT_ENTRY( entry, txt ) \
+  GTLTEST_CHECK_NOT_EQUAL( entry, 0 ) \
+  GTLTEST_CHECK_EQUAL( entry->asTextEntry(), entry ) \
+  GTLTEST_CHECK_EQUAL( entry->asTextEntry()->text(), txt )
+
+#define TESTMEDATAPARSER_TEST_VALUE_ENTRY( entry, val ) \
+  GTLTEST_CHECK_NOT_EQUAL( entry, 0 ) \
+  GTLTEST_CHECK_EQUAL( entry->asValueEntry(), entry ) \
+  GTLTEST_CHECK_EQUAL( entry->asValueEntry()->value(), GTLCore::Value( val ) )
+
+class TestMetadataParser : public GTLTest::Case {
+  public:
+    TestMetadataParser() : GTLTest::Case("MetadataParser") {}
+    virtual void runTest()
+    {
+      std::istringstream iss(" \
+< \
+  version: 0; \
+  info: < \
+    author: \"Joe Doe; Joe Doe Jr\"; \
+    vendor: < \
+      name: \"DoeGraphics\"; \
+      address: \"1242 Main Street\"; \
+    >; \
+    license: \"LGPLv2+\"; \
+  >; \
+  parameters: < \
+    param1: < \
+      type: int; \
+      minValue:-10; \
+      maxValue: 100; \
+      defaultValue: 50; \
+      description: \"This is the first parameter\"; \
+    >; \
+    categorie2: < \
+      description: \"This is a categorie of parameters\"; \
+      param2: < \
+        type: curve; \
+        defaultValue: {{0.25,0},{1,0.5}}; \
+      >; \
+      param3: < \
+          type: color; \
+          defaultValue: {1,0,0}; \
+        >; \
+     >; \
+  >; \
+>");
+      GTLFragment::MetadataLexer* lng = new GTLFragment::MetadataLexer(&iss);
+      GTLFragment::MetadataParser parser( lng, "");
+      GTLFragment::Metadata* km = parser.parse();
+      GTLTEST_CHECK_EQUAL( parser.errorMessages().errors().size(), 0 );
+      GTLTEST_CHECK_EQUAL( km->version(), 0 );
+      
+      // Test info
+      TESTMEDATAPARSER_TEST_TEXT_ENTRY( km->informationRecords()->entry( "author" ), "Joe Doe; Joe Doe Jr");
+      TESTMEDATAPARSER_TEST_TEXT_ENTRY( km->informationRecords()->entry( "license" ), "LGPLv2+");
+      GTLTEST_CHECK_NOT_EQUAL( km->informationRecords()->entry( "vendor" ), 0 );
+      const GTLCore::Metadata::Group* vendorGroup = km->informationRecords()->entry( "vendor" )->asGroup();
+      GTLTEST_CHECK_NOT_EQUAL( vendorGroup, 0 );
+      TESTMEDATAPARSER_TEST_TEXT_ENTRY( vendorGroup->entry( "name" ), "DoeGraphics");
+      TESTMEDATAPARSER_TEST_TEXT_ENTRY( vendorGroup->entry( "address" ), "1242 Main Street");
+      
+      // Test parameters
+      GTLTEST_CHECK_NOT_EQUAL( km->parameters()->entry( "param1" ), 0 );
+      const GTLCore::Metadata::ParameterEntry* param1 = km->parameters()->entry( "param1" )->asParameterEntry();
+      GTLTEST_CHECK_NOT_EQUAL( param1, 0 );
+      TESTMEDATAPARSER_TEST_TEXT_ENTRY( param1->entry( "type" ), "int");
+      TESTMEDATAPARSER_TEST_TEXT_ENTRY( param1->entry( "description" ), "This is the first parameter");
+      GTLTEST_CHECK_EQUAL( param1->description(), "This is the first parameter");
+      TESTMEDATAPARSER_TEST_VALUE_ENTRY( param1->entry( "minValue" ), -10);
+      GTLTEST_CHECK_EQUAL( param1->minimumValue(), -10);
+      TESTMEDATAPARSER_TEST_VALUE_ENTRY( param1->entry( "defaultValue" ), 50);
+      GTLTEST_CHECK_EQUAL( param1->defaultValue(), 50);
+      TESTMEDATAPARSER_TEST_VALUE_ENTRY( param1->entry( "maxValue" ), 100);
+      GTLTEST_CHECK_EQUAL( param1->maximumValue(), 100);
+      
+      // Test categorie parameter
+      GTLTEST_CHECK_NOT_EQUAL( km->parameters()->entry( "categorie2" ), 0 );
+      const GTLCore::Metadata::Group* categorie2 = km->parameters()->entry( "categorie2" )->asGroup();
+      GTLTEST_CHECK_NOT_EQUAL( categorie2, 0 );
+      TESTMEDATAPARSER_TEST_TEXT_ENTRY( categorie2->entry( "description" ), "This is a categorie of parameters");
+      
+      // Test parameter2
+      GTLTEST_CHECK_NOT_EQUAL( categorie2->entry("param2"), 0 );
+      const GTLCore::Metadata::ParameterEntry* param2 = categorie2->entry( "param2" )->asParameterEntry();
+      GTLTEST_CHECK_NOT_EQUAL( param2, 0 );
+      TESTMEDATAPARSER_TEST_TEXT_ENTRY( param2->entry( "type" ), "curve");
+      const GTLCore::Type* typeVector2 = GTLCore::TypesManager::getVector( GTLCore::Type::Float32, 2 );
+      std::vector< GTLCore::Value > v1; v1.push_back( 0.25f ); v1.push_back( 0.0f );
+      std::vector< GTLCore::Value > v2; v2.push_back( 1.0f ); v2.push_back( 0.5f );
+      std::vector< GTLCore::Value > v3; v3.push_back( GTLCore::Value( v1, typeVector2 ) ); v3.push_back( GTLCore::Value( v2, typeVector2 ) );
+      GTLCore::Value param2value( v3, GTLCore::TypesManager::getArray( typeVector2 ) );
+      TESTMEDATAPARSER_TEST_VALUE_ENTRY( param2->entry( "defaultValue" ), param2value);
+      GTLTEST_CHECK_EQUAL( param2->defaultValue(), param2value);
+      
+      // Test parameter3
+      GTLTEST_CHECK_NOT_EQUAL( categorie2->entry("param3"), 0 );
+      const GTLCore::Metadata::ParameterEntry* param3 = categorie2->entry( "param3" )->asParameterEntry();
+      GTLTEST_CHECK_NOT_EQUAL( param3, 0 );
+      TESTMEDATAPARSER_TEST_TEXT_ENTRY( param3->entry( "type" ), "color");
+      GTLCore::Color param3value(1.0, 0.0, 0.0);
+      TESTMEDATAPARSER_TEST_VALUE_ENTRY( param3->entry( "defaultValue" ), param3value);
+      GTLTEST_CHECK_EQUAL( param3->defaultValue(), param3value);
+      GTLTEST_CHECK_EQUAL( param3->defaultValue().type(), param3->type());
+    }
+};
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Version.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Version.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Version.cpp.95a8c6853b97	2012-01-10 11:12:02.139249205 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Version.cpp	2012-01-10 11:12:02.139249205 -0500
@@ -0,0 +1,51 @@
+/*
+ *  Copyright (c) 2009 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Version.h"
+
+
+namespace GTLFragment {
+  GTLCore::String LibraryShortName() { return "GTLFragment"; }
+  GTLCore::String LibraryName() { return "GTLFragment KS Library"; }
+  GTLCore::String LibraryCopyright() { return "Copyright (c) 2007-2010 Cyrille Berger (cberger@cberger.net)"; }
+  GTLCore::String LibraryLicence() { return "GNU Lesser General Public License Version 2, or later"; }
+  GTLCore::String LibraryVersionString() { return GTLCore::String::number( GTLFRAGMENT_VERSION_MAJOR ) + "." + GTLCore::String::number( GTLFRAGMENT_VERSION_MAJOR ) + "." + GTLCore::String::number( GTLFRAGMENT_VERSION_MAJOR ); }
+  int LibraryVersionMajor()
+  {
+      return GTLFRAGMENT_VERSION_MAJOR;
+  }
+  int LibraryVersionMinor()
+  {
+      return GTLFRAGMENT_VERSION_MAJOR;
+  }
+  int LibraryVersionRevision()
+  {
+      return GTLFRAGMENT_VERSION_MAJOR;
+  }
+  int LanguageVersion()
+  {
+      return 0;
+  }
+  int LanguageVersionRevision()
+  {
+      return 0;
+  }
+  
+}
+
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Version.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Version.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Version.h.95a8c6853b97	2012-01-10 11:12:02.139249205 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Version.h	2012-01-10 11:12:02.139249205 -0500
@@ -0,0 +1,41 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLFRAGMENT_VERSION_H_
+#define _GTLFRAGMENT_VERSION_H_
+
+#include <GTLCore/Version.h>
+#include <GTLFragment/Export.h>
+
+#define GTLFRAGMENT_VERSION_MAJOR GTL_CORE_VERSION_MAJOR
+#define GTLFRAGMENT_VERSION_MINOR GTL_CORE_VERSION_MINOR
+#define GTLFRAGMENT_VERSION_REVISION GTL_CORE_VERSION_REVISION
+
+namespace GTLFragment {
+  GTLFRAGMENT_EXPORT GTLCore::String LibraryShortName();
+  GTLFRAGMENT_EXPORT GTLCore::String LibraryName();
+  GTLFRAGMENT_EXPORT GTLCore::String LibraryCopyright();
+  GTLFRAGMENT_EXPORT GTLCore::String LibraryLicence();
+  GTLFRAGMENT_EXPORT GTLCore::String LibraryVersionString();;
+  GTLFRAGMENT_EXPORT int LibraryVersionMajor();
+  GTLFRAGMENT_EXPORT int LibraryVersionMinor();
+  GTLFRAGMENT_EXPORT int LibraryVersionRevision();
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/WhichStdLibrary_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/WhichStdLibrary_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/WhichStdLibrary_p.h.95a8c6853b97	2012-01-10 11:12:02.139249205 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/WhichStdLibrary_p.h	2012-01-10 11:12:02.139249205 -0500
@@ -0,0 +1,35 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLFRAGMENT_WHICHSTDLIBRARY_P_H_
+#define _GTLFRAGMENT_WHICHSTDLIBRARY_P_H_
+
+namespace GTLFragment {
+
+  enum WhichStdLibrary {
+    NotAStdLibrary,
+    FragmentStdLibrary,
+    RijnStdLibrary,
+    RijnWrappersLibrary,
+    ShivaWrappersLibrary
+  };
+
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Wrapper.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Wrapper.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Wrapper.cpp.95a8c6853b97	2012-01-10 11:12:02.140249196 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Wrapper.cpp	2012-01-10 11:12:02.140249196 -0500
@@ -0,0 +1,96 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Wrapper_p.h"
+
+#include <GTLCore/Debug.h>
+#include <GTLCore/Function.h>
+#include <GTLCore/ModuleData_p.h>
+#include <GTLCore/Type.h>
+#include <GTLCore/TypesManager.h>
+#include <GTLCore/TypesManager_p.h>
+#include <GTLCore/Macros_p.h>
+
+#include "Library.h"
+#include <GTLCore/Function_p.h>
+#include <llvm/Module.h>
+#include <GTLCore/Type_p.h>
+
+using namespace GTLFragment;
+
+struct Wrapper::Private {
+  GTLCore::ModuleData* moduleData;
+  int channels;
+  llvm::Module* llvmModule;
+};
+
+Wrapper::Wrapper(GTLCore::ModuleData* _moduleData, llvm::Module* _llvmModule, int _channels) : d(new Private)
+{
+  d->moduleData =_moduleData;
+  d->channels = _channels;
+  d->llvmModule = _llvmModule;
+}
+
+Wrapper::~Wrapper()
+{
+}
+
+GTLCore::ModuleData* Wrapper::moduleData() const
+{
+  return d->moduleData;
+}
+
+int Wrapper::channels() const
+{
+  return d->channels;
+}
+
+llvm::Module* Wrapper::llvmModule()
+{
+  return d->llvmModule;
+}
+
+const GTLCore::Type* Wrapper::createColorType(GTLCore::TypesManager* _typesManager, GTLCore::ConvertCenter* _convertCenter)
+{
+  //---------------------- WARNING ----------------------//
+  // Whenever the following structure is edited,         //
+  // its llvm declaration must be changed too in         //
+  // struct ColorWrap !                                  //
+  //---------------------- WARNING ----------------------//
+  std::vector<GTLCore::Type::StructDataMember> regionDataMembers;
+  regionDataMembers.push_back( GTLCore::Type::StructDataMember( "red", GTLCore::Type::Float32 ) );
+  regionDataMembers.push_back( GTLCore::Type::StructDataMember( "green", GTLCore::Type::Float32) );
+  regionDataMembers.push_back( GTLCore::Type::StructDataMember( "blue", GTLCore::Type::Float32 ) );
+  regionDataMembers.push_back( GTLCore::Type::StructDataMember( "opacity", GTLCore::Type::Float32 ) );
+  const GTLCore::Type* type = _typesManager->d->createStructure( "color", regionDataMembers);
+  
+  return type;
+}
+
+
+void Wrapper::addFunctionFromModuleToType(const GTLCore::Type* type, GTLFragment::Library* library, const GTLCore::ScopedName& name)
+{
+  const std::list<GTLCore::Function*>* functions = library->data()->function(name);
+  GTL_ASSERT(functions);
+  foreach(GTLCore::Function* function, *functions)
+  {
+    GTLCore::Function* newFunction = GTLCore::Function::Private::createExternalFunction( moduleData(), llvmModule(), llvmModule()->getContext(), function );
+    type->d->addFunctionMember( GTLCore::Type::StructFunctionMember(newFunction) );
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Wrapper_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Wrapper_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Wrapper_p.h.95a8c6853b97	2012-01-10 11:12:02.140249196 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/Wrapper_p.h	2012-01-10 11:12:02.140249196 -0500
@@ -0,0 +1,64 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GTLFRAGMENT_WRAPPER_P_H_
+#define _GTLFRAGMENT_WRAPPER_P_H_
+
+#include <GTLFragment/Export.h>
+#include <GTLFragment/WhichStdLibrary_p.h>
+
+namespace llvm {
+  class Module;
+}
+
+namespace GTLCore {
+  class ConvertCenter;
+  class ModuleData;
+  class Type;
+  class TypesManager;
+  class ScopedName;
+}
+
+namespace GTLFragment {
+  class Library;
+  /**
+   * @internal
+   * @ingroup GTLFragment
+   */
+  class GTLFRAGMENT_EXPORT Wrapper {
+      GTL_NO_COPY(Wrapper);
+    public:
+      Wrapper(GTLCore::ModuleData* _moduleData, llvm::Module* _llvmModule, int _channels);
+      virtual ~Wrapper();
+      virtual void fillTypesManager( GTLCore::TypesManager*, GTLCore::ConvertCenter*) = 0;
+    protected:
+      GTLCore::ModuleData* moduleData() const;
+      llvm::Module* llvmModule();
+      int channels() const;
+    public:
+      static const GTLCore::Type* createColorType(GTLCore::TypesManager* _typesManager, GTLCore::ConvertCenter* _convertCenter);
+    protected:
+      void addFunctionFromModuleToType(const GTLCore::Type* type, GTLFragment::Library* library, const GTLCore::ScopedName& name);
+    private:
+      struct Private;
+      Private* const d;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/wrappers/ColorWrap_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/wrappers/ColorWrap_p.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/wrappers/ColorWrap_p.cpp.95a8c6853b97	2012-01-10 11:12:02.140249196 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/wrappers/ColorWrap_p.cpp	2012-01-10 11:12:02.140249196 -0500
@@ -0,0 +1,54 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "ColorWrap_p.h"
+
+#include <GTLCore/wrappers/Allocate.h>
+#include <GTLCore/AbstractColorConverter.h>
+#include <GTLCore/ColorConverters.h>
+#include <GTLCore/Debug.h>
+#include <GTLCore/Type.h>
+
+void wrapColor(ColorWrap& color, float red, float green, float blue, float opacity)
+{
+  color.red = red;
+  color.green = green;
+  color.blue = blue;
+  color.opacity = opacity;
+}
+
+GTLCore::Color colorWrapToGTLCoreColor(const ColorWrap& wrap)
+{
+  return GTLCore::Color(wrap.red, wrap.green, wrap.blue, wrap.opacity);
+}
+
+extern "C" {
+  void wrapConvertPixelToColor(const GTLCore::AbstractColorConverter* _acc, const float* _pixel, GTLCore::RgbaF* _rgba, gtl_int32 _nbChannels)
+  {
+    if(not _acc) _acc = GTLCore::ColorConverters::instance()->guess(GTLCore::Type::Float32, _nbChannels);
+    GTL_ASSERT(_acc);
+    _acc->vectorToRgba(_pixel, _rgba);
+  }
+  void wrapConvertColorToPixel(const GTLCore::AbstractColorConverter* _acc, const GTLCore::RgbaF* _rgba, float* _pixel, gtl_int32 _nbChannels)
+  {
+    _acc = GTLCore::ColorConverters::instance()->guess(GTLCore::Type::Float32, _nbChannels);
+    GTL_ASSERT(_acc);
+    _acc->rgbaToVector(_rgba, _pixel);
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLFragment/wrappers/ColorWrap_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLFragment/wrappers/ColorWrap_p.h
--- OpenGTL-0.9.15.2/OpenGTL/GTLFragment/wrappers/ColorWrap_p.h.95a8c6853b97	2012-01-10 11:12:02.140249196 -0500
+++ OpenGTL-0.9.15.2/OpenGTL/GTLFragment/wrappers/ColorWrap_p.h	2012-01-10 11:12:02.140249196 -0500
@@ -0,0 +1,69 @@
+
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _COLOR_WRAP_P_H_
+#define _COLOR_WRAP_P_H_
+
+#include <GTLCore/Color.h>
+#include "GTLCore/wrappers/StructWrap.h"
+#include "GTLFragment/Export.h"
+#include <GTLCore/StdTypes.h>
+
+namespace GTLCore {
+  class AbstractColorConverter;
+}
+
+//---------------------- WARNING ----------------------//
+// Whenever the following structure is edited,         //
+// its llvm declaration must be changed too in         //
+// Wrapper::createColorType !                          //
+//---------------------- WARNING ----------------------//
+struct ColorWrap {
+  STRUCT_HEADER
+  float red, green, blue, opacity;
+  /**
+   * Enum used to access an element
+   */
+  enum ColorIndexes {
+    INDEX_RED = 0,
+    INDEX_GREEN = 1,
+    INDEX_BLUE = 2,
+    INDEX_OPACITY = 3
+  };
+  /**
+   * Position of an element in the structure memory
+   */
+  enum ColorPoses {
+    POS_RED = STRUCT_FIRST_ELEMENT + INDEX_RED,
+    POS_GREEN = STRUCT_FIRST_ELEMENT + INDEX_GREEN,
+    POS_BLUE = STRUCT_FIRST_ELEMENT + INDEX_BLUE,
+    POS_OPACITY = STRUCT_FIRST_ELEMENT + INDEX_OPACITY
+  };
+};
+
+GTLFRAGMENT_EXPORT void wrapColor(ColorWrap& color, float red, float green, float blue, float opacity);
+GTLFRAGMENT_EXPORT GTLCore::Color colorWrapToGTLCoreColor(const ColorWrap& wrap);
+
+extern "C" {
+  GTLFRAGMENT_EXPORT void wrapConvertPixelToColor(const GTLCore::AbstractColorConverter* _acc, const float* _pixel, GTLCore::RgbaF* _rgba, gtl_int32 _nbChannels);
+  GTLFRAGMENT_EXPORT void wrapConvertColorToPixel(const GTLCore::AbstractColorConverter* _acc, const GTLCore::RgbaF* _rgba, float* _pixel, gtl_int32 _nbChannels);
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLImageIO.doxy.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLImageIO.doxy
--- OpenGTL-0.9.15.2/OpenGTL/GTLImageIO.doxy.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLImageIO.doxy	2012-01-10 11:12:02.140249196 -0500
@@ -1,5 +1,5 @@
 /**
  * @addtogroup GTLImageIO GTLImage Input/Output Library
- * @version 0.9.15
+ * @version 0.9.16
  * @author Cyrille Berger
  */
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLImageIO/ImageDCRegistry.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLImageIO/ImageDCRegistry.cpp
--- OpenGTL-0.9.15.2/OpenGTL/GTLImageIO/ImageDCRegistry.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLImageIO/ImageDCRegistry.cpp	2012-01-10 11:12:02.140249196 -0500
@@ -52,10 +52,13 @@ void ImageDCRegistry::Private::loadExten
     for( std::set<llvm::sys::Path>::iterator it = paths.begin();
          it != paths.end(); ++it)
     {
-      GTL_DEBUG("Loading: " << it->str() );
-      if( llvm::sys::DynamicLibrary::LoadLibraryPermanently( it->c_str(), &errMsg ) )
+      if( it->getSuffix() == "so" or it->getSuffix() == "dll" or it->getSuffix() == "dylib")
       {
-        GTL_ERROR("Can't load " << it->str() << " : " << errMsg );
+        GTL_DEBUG("Loading: " << it->str() );
+        if( llvm::sys::DynamicLibrary::LoadLibraryPermanently( it->c_str(), &errMsg ) )
+        {
+          GTL_ERROR("Can't load " << it->str() << " : " << errMsg );
+        }
       }
     }
   }
diff -up OpenGTL-0.9.15.2/OpenGTL/GTLTest.doxy.95a8c6853b97 OpenGTL-0.9.15.2/OpenGTL/GTLTest.doxy
--- OpenGTL-0.9.15.2/OpenGTL/GTLTest.doxy.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenGTL/GTLTest.doxy	2012-01-10 11:12:02.140249196 -0500
@@ -1,7 +1,7 @@
 /**
  * @internal
  * @addtogroup GTLTest GTLTest Library
- * @version 0.9.15
+ * @version 0.9.16
  * @author Cyrille Berger
  *
  * This library contains the base classes and functionnalities to create unit
diff -up OpenGTL-0.9.15.2/OpenRijn/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenRijn/CMakeLists.txt.95a8c6853b97	2012-01-10 11:12:02.141249188 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/CMakeLists.txt	2012-01-10 11:12:02.141249188 -0500
@@ -0,0 +1,17 @@
+include_directories( ${CMAKE_CURRENT_SOURCE_DIR} )
+
+add_definitions( ${OPENGTL_BUILD_DEFINITION} )
+
+set(RIJNC "${CMAKE_CURRENT_BINARY_DIR}/tools/compiler/rijnc")
+set(SHIVAI "${CMAKE_CURRENT_BINARY_DIR}/tools/interpreter/rijn")
+set(RIJNTESTER "${CMAKE_CURRENT_BINARY_DIR}/tools/tester/rijntester")
+
+set(OPENRIJN_VERSION ${OPENGTL_VERSION})
+set(OPENRIJN_LIB_VERSION ${OPENGTL_LIB_VERSION})
+set(OPENRIJN_LIB_SOVERSION ${OPENGTL_LIB_SOVERSION})
+
+add_subdirectory(OpenRijn)
+if(OPENGTL_BUILD_TESTS)
+  add_subdirectory(tests)
+endif(OPENGTL_BUILD_TESTS)
+add_subdirectory(tools)
\ No newline at end of file
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractBrush.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractBrush.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractBrush.cpp.95a8c6853b97	2012-01-10 11:12:02.141249188 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractBrush.cpp	2012-01-10 11:12:02.141249188 -0500
@@ -0,0 +1,164 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "AbstractBrush.h"
+
+#include <cmath>
+
+#include <GTLCore/Color.h>
+#include <GTLCore/Debug.h>
+
+#include "DrawingPoint.h"
+#include "DistanceInformation.h"
+
+using namespace OpenRijn;
+
+struct AbstractBrush::Private {
+  bool supportDrawPoint;
+  GTLCore::Color color;
+};
+
+AbstractBrush::AbstractBrush() : d(new Private)
+{
+  d->supportDrawPoint = true;
+}
+
+AbstractBrush::~AbstractBrush()
+{
+  delete d;
+}
+
+struct Vector {
+  inline Vector(float _x, float _y) : x(_x), y(_y) {}
+  float x, y;
+  inline float norm() const {
+    return sqrt(x*x + y*y);
+  }
+  inline void normalize() {
+    float n = norm();
+    x /= n;
+    y /= n;
+  }
+};
+inline Vector operator-(const Vector& v1, const Vector& v2)
+{
+  return Vector(v1.x - v2.x, v1.y - v2.y);
+}
+inline Vector operator+(const Vector& v1, const Vector& v2)
+{
+  return Vector(v1.x + v2.x, v1.y + v2.y);
+}
+inline Vector operator*(float v1, const Vector& v2)
+{
+  return Vector(v1 * v2.x, v1 * v2.y);
+}
+inline Vector operator*(const Vector& v1, float v2)
+{
+  return v2 * v1;
+}
+
+inline float angle(const Vector& v1, const Vector& v2)
+{
+  return acos( (v1.x * v2.x + v1.y * v2.y) / (v1.norm() * v2.norm()));
+}
+
+DrawingPoint mixDrawingPoint(Vector p, float t, const DrawingPoint& pt1, const DrawingPoint& pt2)
+{
+  return DrawingPoint(p.x, p.y, t * pt2.t + (1-t) * pt1.t, t * pt2.angle + (1-t) * pt1.angle);
+}
+
+DistanceInformation AbstractBrush::drawLine(AbstractCanvas* canvas, const DrawingPoint& pt1, const DrawingPoint& pt2, const DistanceInformation& information)
+{
+  Vector end(pt2.x, pt2.y);
+  Vector start(pt1.x, pt1.y);
+
+  Vector dragVec = end - start;
+
+  GTL_ASSERT(information.distance >= 0);
+
+  float endDist = dragVec.norm();
+  float currentDist = information.distance;
+
+    dragVec.normalize();
+    Vector step(0, 0);
+
+    float sp = information.spacing;
+    while (currentDist < endDist) {
+
+        Vector p = start +  currentDist * dragVec;
+
+        float t = currentDist / endDist;
+
+        sp = drawPoint(canvas, mixDrawingPoint(p, t, pt1, pt2));
+        currentDist += sp;
+    }
+
+    return DistanceInformation(currentDist - endDist, sp);
+}
+
+#define BEZIER_FLATNESS_ANGLE 0.01
+
+DistanceInformation AbstractBrush::drawCurve(AbstractCanvas* canvas, const OpenRijn::DrawingPoint& pt1, float x1, float y1, float x2, float y2, const OpenRijn::DrawingPoint& pt2, const OpenRijn::DistanceInformation& information)
+{
+    DistanceInformation newDistance;
+    Vector control1(x1,y1);
+    Vector control2(x2,y2);
+    Vector pt1v(pt1.x, pt1.y);
+    Vector pt2v(pt2.x, pt2.y);
+    Vector d12 = pt2v - pt1v;
+    
+    if ((angle(d12, control1 - pt1v) < BEZIER_FLATNESS_ANGLE && angle(d12, control2 - pt2v) < BEZIER_FLATNESS_ANGLE) ) {
+        newDistance = drawLine(canvas, pt1, pt2, information);
+    } else {
+        // Midpoint subdivision. See Foley & Van Dam Computer Graphics P.508
+        Vector l2 = (pt1v + control1) * 0.5;
+        Vector h = (control1 + control2) * 0.5;
+        Vector l3 = (l2 + h) * 0.5;
+        Vector r3 = (control2 + pt2v) * 0.5;
+        Vector r2 = (h + r3) * 0.5;
+        Vector l4 = (l3 + r2) * 0.5;
+
+        DrawingPoint middlePI = mixDrawingPoint(l4, 0.5, pt1, pt2);
+        
+        newDistance = drawCurve(canvas, pt1, l2.x, l2.y, l3.x, l3.y, middlePI, information);
+        newDistance = drawCurve(canvas, middlePI, r2.x, l2.y, r3.x, r3.y, pt2, newDistance);
+    }
+
+    return newDistance;
+}
+
+void AbstractBrush::setPaintColor(const GTLCore::Color& color)
+{
+  d->color = color;
+}
+
+GTLCore::Color AbstractBrush::paintColor() const
+{
+  return d->color;
+}
+
+bool AbstractBrush::supportDrawPoint() const
+{
+  return d->supportDrawPoint;
+}
+
+void AbstractBrush::setSupportDrawPoint(bool value)
+{
+  d->supportDrawPoint = value;
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractBrush.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractBrush.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractBrush.h.95a8c6853b97	2012-01-10 11:12:02.141249188 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractBrush.h	2012-01-10 11:12:02.141249188 -0500
@@ -0,0 +1,82 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_ABSTRACT_BRUSH_H_
+#define _OPENRIJN_ABSTRACT_BRUSH_H_
+
+#include <OpenRijn/Export.h>
+
+namespace GTLCore {
+  class Color;
+}
+
+namespace OpenRijn {
+  class AbstractCanvas;
+  struct DrawingPoint;
+  struct DistanceInformation;
+  /**
+   * @ingroup OpenRijn
+   *
+   * Represent a brush that move around lines and curves to draw.
+   */
+  class OPENRIJN_EXPORT AbstractBrush {
+      GTL_NO_COPY(AbstractBrush)
+    public:
+      AbstractBrush();
+      virtual ~AbstractBrush();
+      /**
+       * @return true if this brush can paint a single point
+       */
+      bool supportDrawPoint() const;
+      /**
+       * @return paint a single point, and return the spacing to the next point on a line.
+       */
+      virtual float drawPoint( AbstractCanvas*, const DrawingPoint&) = 0;
+      /**
+       * Paint a line, the default implementation will make multiple call to @p paintAt seperated
+       * by the spacing return by @p paintAt
+       */
+      virtual DistanceInformation drawLine( OpenRijn::AbstractCanvas* canvas, const OpenRijn::DrawingPoint& pt1, const OpenRijn::DrawingPoint& pt2, const OpenRijn::DistanceInformation& information);
+      /**
+       * Paint following a bezier curve, the default implementation will make multiple call
+       * to @p paintAt seperated by the spacing return by @p paintAt
+       */
+      virtual DistanceInformation drawCurve(  OpenRijn::AbstractCanvas* canvas, const OpenRijn::DrawingPoint& pt1, float x1, float y1, float x2, float y2, const OpenRijn::DrawingPoint& pt2, const OpenRijn::DistanceInformation& information);
+    public:
+      /**
+       * Set the color for this brush
+       */
+      void setPaintColor(const GTLCore::Color& color);
+      /**
+       * @return the color used for this brush
+       */
+      GTLCore::Color paintColor() const;
+    protected:
+      /**
+       * Call this with the @p value set to false if this brush does not work with to draw a single
+       * point.
+       */
+      void setSupportDrawPoint(bool value);
+    private:
+      struct Private;
+      Private* const d;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractCanvas.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractCanvas.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractCanvas.cpp.95a8c6853b97	2012-01-10 11:12:02.141249188 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractCanvas.cpp	2012-01-10 11:12:02.141249188 -0500
@@ -0,0 +1,32 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "AbstractCanvas_p.h"
+
+using namespace OpenRijn;
+
+AbstractCanvas::AbstractCanvas() : d(new Private)
+{
+}
+
+AbstractCanvas::~AbstractCanvas()
+{
+  delete d;
+}
+
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractCanvas.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractCanvas.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractCanvas.h.95a8c6853b97	2012-01-10 11:12:02.141249188 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractCanvas.h	2012-01-10 11:12:02.141249188 -0500
@@ -0,0 +1,40 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_ABSTRACT_CANVAS_H_
+#define _OPENRIJN_ABSTRACT_CANVAS_H_
+
+#include <OpenRijn/Export.h>
+
+namespace OpenRijn {
+  /**
+   * @ingroup OpenRijn
+   */
+  class OPENRIJN_EXPORT AbstractCanvas {
+    GTL_NO_COPY(AbstractCanvas)
+    public:
+      AbstractCanvas();
+      virtual ~AbstractCanvas();
+    public:
+      struct Private;
+      Private* const d;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractCanvas_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractCanvas_p.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractCanvas_p.h.95a8c6853b97	2012-01-10 11:12:02.141249188 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractCanvas_p.h	2012-01-10 11:12:02.141249188 -0500
@@ -0,0 +1,29 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "AbstractCanvas.h"
+#include "DrawingPoint.h"
+#include "DistanceInformation.h"
+
+namespace OpenRijn {
+  struct AbstractCanvas::Private {
+    DrawingPoint lastPt;
+    DistanceInformation lastInfo;
+  };
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractFiller.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractFiller.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractFiller.cpp.95a8c6853b97	2012-01-10 11:12:02.141249188 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractFiller.cpp	2012-01-10 11:12:02.141249188 -0500
@@ -0,0 +1,170 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "AbstractFiller.h"
+
+#include <cstring>
+
+#include <GTLCore/Math.h>
+#include <GTLCore/Region.h>
+
+#include "AbstractBrush.h"
+#include "DrawingPoint.h"
+#include "Path.h"
+#include "DistanceInformation.h"
+
+using namespace OpenRijn;
+
+AbstractFiller::AbstractFiller() : d(0)
+{
+}
+
+AbstractFiller::~AbstractFiller()
+{
+//   delete d;
+}
+
+void AbstractFiller::fillRegion(const GTLCore::RegionI& _region, float _opacity )
+{
+  for (int y = _region.top(); y <= _region.bottom(); ++y)
+  {
+    for (int x = _region.left(); x <= _region.right(); ++x)
+    {
+      fillAt(DrawingPoint(x, y, 1.0, 0.0), _opacity);
+    }
+  }
+}
+
+void AbstractFiller::fillRegion(const GTLCore::RegionF& _region, float _opacity )
+{
+  GTLCore::RegionI reg = _region.toRegionI();
+  for (int y = reg.top(); y <= reg.bottom(); ++y)
+  {
+    float opacity_y = _opacity;
+    if (y == reg.top()) {
+      opacity_y = (1.0 - (_region.top() -y)) * _opacity;
+    }
+    if (y == reg.bottom()) {
+      opacity_y = (1.0 - (y - _region.bottom())) * _opacity;
+    }
+    for (int x = reg.left(); x <= reg.right(); ++x)
+    {
+      float opacity_x = opacity_y;
+      if (x == reg.left()) {
+        opacity_x = (1.0 - (_region.left() -y)) * opacity_x;
+      }
+      if (y == reg.right()) {
+        opacity_x = (1.0 - (y - _region.right())) * opacity_x;
+      }
+      fillAt(DrawingPoint(x, y, 1.0, 0.0), opacity_x);
+    }
+  }
+}
+
+class FillPathBrush : public AbstractBrush {
+  public:
+    FillPathBrush(float** img, int offsetX, int offsetY) : m_image(img), m_offsetX(offsetX), m_offsetY(offsetY) {}
+    virtual ~FillPathBrush() {}
+    virtual bool canPaintAt() const { return true; }
+    virtual float drawPoint(AbstractCanvas* , const DrawingPoint& dp)
+    {
+      int x = dp.x;
+      int y = dp.y;
+      
+      float dx = dp.x - x;
+      float dy = dp.y - y;
+      float idx = 1.0 - dx;
+      float idy = 1.0 - dy;
+      m_image[y][x] += idx * idy;
+      m_image[y+1][x] += idx * dy;
+      m_image[y+1][x+1] += dx * dy;
+      m_image[y][x+1] += dx * idy;
+      return 1.0;
+    }
+
+    void paintPath(const Path& _polyLine)
+    {
+      if( _polyLine.elementCount() == 0 ) return;
+      DistanceInformation information;
+      DrawingPoint lastPoint;
+      std::size_t idx = 0;
+      if( _polyLine.elementAt(0)->type == Path::MoveToElement)
+      {
+        lastPoint.x = _polyLine.elementAt(0)->point.x;
+        lastPoint.y = _polyLine.elementAt(0)->point.y;
+        ++idx;
+      }
+      DrawingPoint firstPoint = lastPoint;
+      for(; idx < _polyLine.elementCount(); ++idx)
+      {
+          const Path::Element* elt = _polyLine.elementAt(idx);
+          switch(elt->type)
+          {
+            case Path::CurveToElement:
+            {
+              const Path::CurveElement* celt = static_cast<const Path::CurveElement*>(elt);
+              information = drawCurve( 0, lastPoint, celt->x1, celt->y1, celt->x2, celt->y2, elt->point, information);
+              break;
+            }
+            case Path::MoveToElement:
+            case Path::LineToElement:
+              information = drawLine( 0, lastPoint, elt->point, information);
+              break;
+          }
+          lastPoint = elt->point;
+      }
+      drawLine(0, lastPoint, firstPoint, information); // Close the loop
+    }
+  private:
+    float** m_image;
+    int m_offsetX, m_offsetY;
+};
+
+void AbstractFiller::fillPath(const Path& _polyLine, float _opacity )
+{
+  GTLCore::RegionI reg = _polyLine.boundingRegion().toRegionI();
+  float** m_image = new float*[reg.rows()];
+  for(int y = 0; y < reg.rows(); ++y)
+  {
+    m_image[y] = new float[reg.columns()];
+    memset(m_image[y], 0, sizeof(float) * reg.columns());
+  }
+  FillPathBrush fpb(m_image, reg.left(), reg.top());
+  fpb.paintPath(_polyLine);
+  for(int y = 0; y < reg.rows(); ++y)
+  {
+    float count = 0.0;
+    for(int x = 0; x < reg.columns(); ++x)
+    {
+      count += m_image[y][x];
+      int countI = round(count);
+      float d = std::fabs(countI - count);
+      if( d < 0.01 )
+      {
+        if( (countI & 1) == 1)
+        {
+          fillAt(DrawingPoint(x, y, 1.0, 0.0));
+        }
+      } else {
+        fillAt(DrawingPoint(x, y, 1.0, 0.0), d);
+      }
+      
+    }
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractFiller.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractFiller.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractFiller.h.95a8c6853b97	2012-01-10 11:12:02.141249188 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractFiller.h	2012-01-10 11:12:02.141249188 -0500
@@ -0,0 +1,53 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_ABSTRACT_FILLER_H_
+#define _OPENRIJN_ABSTRACT_FILLER_H_
+
+#include <OpenRijn/Export.h>
+
+namespace GTLCore {
+  class RegionI;
+  class RegionF;
+}
+
+namespace OpenRijn {
+  class DrawingPoint;
+  class Path;
+  /**
+   * @ingroup OpenRijn
+   *
+   * This represent algorithm to fill the inside of a polygon
+   */
+  class OPENRIJN_EXPORT AbstractFiller {
+      GTL_NO_COPY(AbstractFiller)
+    public:
+      AbstractFiller();
+      virtual ~AbstractFiller();
+      virtual void fillAt(const DrawingPoint&, float _opacity = 1.0) = 0;
+      virtual void fillRegion(const GTLCore::RegionI& _region, float _opacity = 1.0 );
+      virtual void fillRegion(const GTLCore::RegionF& _region, float _opacity = 1.0 );
+      virtual void fillPath(const Path& _polyLine, float _opacity = 1.0 );
+    private:
+      struct Private;
+      Private* const d;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractPalette.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractPalette.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractPalette.cpp.95a8c6853b97	2012-01-10 11:12:02.141249188 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractPalette.cpp	2012-01-10 11:12:02.141249188 -0500
@@ -0,0 +1,35 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "AbstractPalette.h"
+
+using namespace OpenRijn;
+
+struct AbstractPalette::Private {
+};
+
+AbstractPalette::AbstractPalette() : d(0)
+{
+}
+
+AbstractPalette::~AbstractPalette()
+{
+  delete d;
+}
+
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractPalette.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractPalette.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractPalette.h.95a8c6853b97	2012-01-10 11:12:02.142249179 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/AbstractPalette.h	2012-01-10 11:12:02.142249179 -0500
@@ -0,0 +1,46 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_ABSTRACT_PAINT_FACTORy_H_
+#define _OPENRIJN_ABSTRACT_PAINT_FACTORy_H_
+
+#include <OpenRijn/Export.h>
+
+namespace OpenRijn {
+  class AbstractBrush;
+  /**
+   * @ingroup OpenRijn
+   *
+   * This use to create @ref AbstractFiller and @ref AbstractBrush for use by
+   * sketches.
+   */
+  class OPENRIJN_EXPORT AbstractPalette {
+      GTL_NO_COPY(AbstractPalette)
+    protected:
+      AbstractPalette();
+      virtual ~AbstractPalette();
+    public:
+      virtual AbstractBrush* createCircleBrush(float _size, float _hardness = 0.5) const = 0;
+    private:
+      struct Private;
+      Private* const d;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/CMakeLists.txt.95a8c6853b97	2012-01-10 11:12:02.142249179 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/CMakeLists.txt	2012-01-10 11:12:02.142249179 -0500
@@ -0,0 +1,74 @@
+
+include_directories( ${LLVM_INCLUDE_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/  ${CMAKE_CURRENT_BINARY_DIR} )
+
+# List of files 
+set(OpenRijn_SRCS
+  AbstractCanvas.cpp
+  AbstractBrush.cpp
+  AbstractFiller.cpp
+  AbstractPalette.cpp
+  Library.cpp
+  LibrariesManager.cpp
+  Path.cpp
+  Sketch.cpp
+  Source.cpp
+  SourcesCollection.cpp
+  Version.cpp
+# ImageEngine
+  ImageEngine/Canvas.cpp
+  ImageEngine/Palette.cpp
+  ImageEngine/ShapeBrush.cpp
+  ImageEngine/ShapeGenerator.cpp
+# Internal files
+  LightParser_p.cpp
+  Wrapper.cpp
+  wrappers/BrushWrap_p.cpp
+  wrappers/PaletteWrap_p.cpp
+    )
+
+# Add the OpenRIJN library for build
+add_library(OpenRijn SHARED ${OpenRijn_SRCS})
+target_link_libraries(OpenRijn GTLCore GTLFragment)
+
+# __STDC_LIMIT_MACROS is needed by LLVM's DataTypes.h
+add_definitions( "-D__STDC_LIMIT_MACROS" )
+add_definitions( "-D__STDC_CONSTANT_MACROS" )
+add_definitions( -DCOUMPONENT_NAME="OpenRijn" )
+
+add_definitions( -D_OPENRIJN_LIB_="libOpenRijn.so.${OPENGTL_VERSION}")
+add_definitions( -D_OPENRIJN_RIJN_STD_LIB_SRC_DIR_="${CMAKE_CURRENT_SOURCE_DIR}")
+add_definitions( -D_OPENRIJN_RIJN_LIBRARIES_DIR_="${SHARE_INSTALL_DIR}/rijn/libraries" )
+add_definitions( -D_OPENRIJN_RIJN_KERNELS_DIR_="${SHARE_INSTALL_DIR}/rijn/sketches" )
+
+
+# Set the ABI version of the library
+set_target_properties(OpenRijn PROPERTIES VERSION ${OPENRIJN_LIB_VERSION} SOVERSION ${OPENRIJN_LIB_SOVERSION} )
+
+# Install target
+install(TARGETS OpenRijn ${INSTALL_TARGETS_DEFAULT_ARGS} )
+install( FILES
+  AbstractBrush.h
+  AbstractCanvas.h
+  AbstractFiller.h
+  AbstractPalette.h
+  DistanceInformation.h
+  DrawingPoint.h
+  Export.h
+  Sketch.h
+  Library.h
+  Source.h
+  SourcesCollection.h
+  Version.h
+  DESTINATION ${INCLUDE_INSTALL_DIR}/OpenRijn )
+install( FILES
+  ImageEngine/Canvas.h
+  ImageEngine/Palette.h
+  DESTINATION ${INCLUDE_INSTALL_DIR}/OpenRijn/ImageEngine )
+
+# Create and install pc file
+configure_file("OpenRijn.pc.cmake" "${CMAKE_CURRENT_BINARY_DIR}/OpenRijn.pc" @ONLY)
+
+install(FILES ${CMAKE_CURRENT_BINARY_DIR}/OpenRijn.pc DESTINATION ${LIB_INSTALL_DIR}/pkgconfig)
+
+# Install standard library
+install(FILES rijnstdlib.rijn rijnwrappers.rijn DESTINATION ${SHARE_INSTALL_DIR}/rijn/libraries )
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/DistanceInformation.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/DistanceInformation.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/DistanceInformation.h.95a8c6853b97	2012-01-10 11:12:02.142249179 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/DistanceInformation.h	2012-01-10 11:12:02.142249179 -0500
@@ -0,0 +1,38 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_DISTANCE_INFORMATION_H_
+#define _OPENRIJN_DISTANCE_INFORMATION_H_
+
+namespace OpenRijn {
+  /**
+   * @ingroup OpenRijn
+   *
+   * This function is used as return of paintLine to contains information that need
+   * to be passed for the next call.
+   */
+  struct DistanceInformation {
+      DistanceInformation() : distance(0), spacing(0) {}
+      DistanceInformation(float _distance, float _spacing) : distance(_distance), spacing(_spacing) {}
+      float distance;
+      float spacing;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn.doxy.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn.doxy
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn.doxy.95a8c6853b97	2012-01-10 11:12:02.145249154 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn.doxy	2012-01-10 11:12:02.145249154 -0500
@@ -0,0 +1,6 @@
+/**
+ * @addtogroup OpenRijn OpenRijn Library
+ * @version 0.9.16
+ * @author Cyrille Berger
+ * 
+ */
\ No newline at end of file
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/DrawingPoint.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/DrawingPoint.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/DrawingPoint.h.95a8c6853b97	2012-01-10 11:12:02.142249179 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/DrawingPoint.h	2012-01-10 11:12:02.142249179 -0500
@@ -0,0 +1,43 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_DRAWING_POINT_H_
+#define _OPENRIJN_DRAWING_POINT_H_
+
+namespace OpenRijn {
+  /**
+   * @ingroup OpenRijn
+   *
+   * Represent the information used to draw.
+   */
+  struct DrawingPoint {
+    DrawingPoint() : x(0), y(0), t(0), angle(0)
+    {
+    }
+    DrawingPoint(float _x, float _y, float _t, float _angle) : x(_x), y(_y), t(_t), angle(_angle)
+    {
+    }
+    float x; ///< x-coordinate
+    float y; ///< y-coordinate
+    float t; ///< time
+    float angle; ///< angle on the point
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Export.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Export.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Export.h.95a8c6853b97	2012-01-10 11:12:02.142249179 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Export.h	2012-01-10 11:12:02.142249179 -0500
@@ -0,0 +1,52 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2009 Cyrille Berger <cberger@cberger.net>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef OPENRIJN_EXPORT_H
+#define OPENRIJN_EXPORT_H
+
+/* needed for GTL_EXPORT and GTL_IMPORT macros */
+#include <GTLCore/Macros.h>
+
+#ifndef OPENRIJN_EXPORT
+# if defined(OpenRijn_EXPORTS)
+   /* We are building this library */ 
+#  define OPENRIJN_EXPORT GTL_EXPORT
+# else
+   /* We are using this library */ 
+#  define OPENRIJN_EXPORT GTL_IMPORT
+# endif
+#endif
+
+# ifndef OPENRIJN_EXPORT_DEPRECATED
+#  define OPENRIJN_EXPORT_DEPRECATED GTL_DEPRECATED OPENRIJN_EXPORT
+# endif
+
+# ifdef OPENGTL_ENABLE_TESTS
+#  define OPENRIJN_TESTS_EXPORT OPENRIJN_EXPORT
+# else
+#  define OPENRIJN_TESTS_EXPORT
+# endif
+
+#ifdef OPENGTL_ENABLE_DEBUG_OUTPUT
+#  define OPENRIJN_DEBUG_EXPORT OPENRIJN_EXPORT
+# else
+#  define OPENRIJN_DEBUG_EXPORT
+# endif
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/Canvas.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/Canvas.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/Canvas.cpp.95a8c6853b97	2012-01-10 11:12:02.142249179 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/Canvas.cpp	2012-01-10 11:12:02.142249179 -0500
@@ -0,0 +1,41 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Canvas.h"
+
+using namespace OpenRijn::ImageEngine;
+
+struct Canvas::Private {
+  GTLCore::AbstractImage* image;
+};
+
+Canvas::Canvas(GTLCore::AbstractImage* _image) : d(new Private)
+{
+  d->image = _image;
+}
+
+Canvas::~Canvas()
+{
+  delete d;
+}
+
+GTLCore::AbstractImage* Canvas::image()
+{
+  return d->image;
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/Canvas.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/Canvas.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/Canvas.h.95a8c6853b97	2012-01-10 11:12:02.142249179 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/Canvas.h	2012-01-10 11:12:02.142249179 -0500
@@ -0,0 +1,45 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_IMAGEENGINE_CANVAS_H_
+#define _OPENRIJN_IMAGEENGINE_CANVAS_H_
+
+#include <OpenRijn/Export.h>
+#include <OpenRijn/AbstractCanvas.h>
+
+namespace GTLCore {
+  class AbstractImage;
+}
+
+namespace OpenRijn {
+  namespace ImageEngine {
+    class OPENRIJN_EXPORT Canvas : public ::OpenRijn::AbstractCanvas {
+        GTL_NO_COPY(Canvas)
+      public:
+        Canvas(GTLCore::AbstractImage* _image);
+        ~Canvas();
+        GTLCore::AbstractImage* image();
+      private:
+        struct Private;
+        Private* const d;
+    };
+  }
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/Palette.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/Palette.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/Palette.cpp.95a8c6853b97	2012-01-10 11:12:02.142249179 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/Palette.cpp	2012-01-10 11:12:02.142249179 -0500
@@ -0,0 +1,42 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Palette.h"
+#include "ShapeBrush_p.h"
+#include "ShapeGenerator_p.h"
+
+using namespace OpenRijn;
+using namespace OpenRijn::ImageEngine;
+
+struct Palette::Private {
+};
+
+Palette::Palette() : d(new Private)
+{
+}
+
+Palette::~Palette()
+{
+  delete d;
+}
+
+AbstractBrush* Palette::createCircleBrush(float _size, float _hardness ) const
+{
+  return new ShapeBrush(new CircleShapeGenerator(_size, 1.0, _hardness, _hardness, 2));
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/Palette.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/Palette.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/Palette.h.95a8c6853b97	2012-01-10 11:12:02.142249179 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/Palette.h	2012-01-10 11:12:02.142249179 -0500
@@ -0,0 +1,41 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_IMAGEENGINE_PALETTE_H_
+#define _OPENRIJN_IMAGEENGINE_PALETTE_H_
+
+#include <OpenRijn/Export.h>
+#include <OpenRijn/AbstractPalette.h>
+
+namespace OpenRijn {
+  namespace ImageEngine {
+    class OPENRIJN_EXPORT Palette : public ::OpenRijn::AbstractPalette {
+        GTL_NO_COPY(Palette)
+      public:
+        Palette();
+        ~Palette();
+        virtual AbstractBrush* createCircleBrush(float _size, float _hardness = 0.5) const;
+      private:
+        struct Private;
+        Private* const d;
+    };
+  }
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/ShapeBrush.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/ShapeBrush.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/ShapeBrush.cpp.95a8c6853b97	2012-01-10 11:12:02.142249179 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/ShapeBrush.cpp	2012-01-10 11:12:02.142249179 -0500
@@ -0,0 +1,91 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "ShapeBrush_p.h"
+
+#include <cmath>
+
+#include <GTLCore/AbstractImage.h>
+#include <GTLCore/Color.h>
+#include <GTLCore/Debug.h>
+
+#include <OpenRijn/DrawingPoint.h>
+
+#include "Canvas.h"
+#include "ShapeGenerator_p.h"
+
+using namespace OpenRijn;
+using namespace OpenRijn::ImageEngine;
+
+struct ShapeBrush::Private {
+  AbstractShapeGenerator* generator;
+};
+
+ShapeBrush::ShapeBrush(AbstractShapeGenerator* _generator) : d(new Private)
+{
+  d->generator = _generator;
+}
+
+ShapeBrush::~ShapeBrush()
+{
+  delete d;
+}
+
+float ShapeBrush::drawPoint( AbstractCanvas* _canvas, const DrawingPoint& pt)
+{
+  // Read the color
+  float color[3];
+  color[0] = paintColor().red();
+  color[1] = paintColor().green();
+  color[2] = paintColor().blue();
+  float opacity = paintColor().alpha();
+  
+  // Init the drawing
+  Canvas* canvas = static_cast<Canvas*>(_canvas);
+  
+  int radius = int(floor(d->generator->radius()));
+  
+  int x_i = pt.x;
+  int y_i = pt.y;
+  float x_f_r = - pt.x;
+  float y_f_r = - pt.y;
+  
+  // Draw
+  for(int x = x_i - radius; x < x_i + radius; ++x)
+  {
+    for(int y = y_i - radius; y < y_i + radius; ++y)
+    {
+      float coef = d->generator->valueAt(x + x_f_r, y + y_f_r);
+      if(coef != 0.0)
+      {
+        float* pixel = canvas->image()->data<float>(x, y);
+        float colorOpacity = coef * opacity;
+        float newAlpha = pixel[3] * (1.0 - colorOpacity) + colorOpacity;
+        float blend = colorOpacity / newAlpha;
+        for(int k = 0; k < 3; ++k)
+        {
+          pixel[k] += (color[k] - pixel[k]) * blend;
+        }
+        pixel[3] = newAlpha;
+      }
+    }
+  }
+  
+  return 0.1 * d->generator->radius();
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/ShapeBrush_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/ShapeBrush_p.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/ShapeBrush_p.h.95a8c6853b97	2012-01-10 11:12:02.142249179 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/ShapeBrush_p.h	2012-01-10 11:12:02.142249179 -0500
@@ -0,0 +1,41 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_IMAGEENGINE_CIRCLEBRUSH_H_
+#define _OPENRIJN_IMAGEENGINE_CIRCLEBRUSH_H_
+
+#include <OpenRijn/AbstractBrush.h>
+
+namespace OpenRijn {
+  namespace ImageEngine {
+    class AbstractShapeGenerator;
+    class ShapeBrush : public OpenRijn::AbstractBrush {
+        GTL_NO_COPY(ShapeBrush)
+      public:
+        ShapeBrush(AbstractShapeGenerator* _generator);
+        ~ShapeBrush();
+        virtual float drawPoint( AbstractCanvas*, const DrawingPoint&);
+      private:
+        struct Private;
+        Private* const d;
+    };
+  }
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/ShapeGenerator.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/ShapeGenerator.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/ShapeGenerator.cpp.95a8c6853b97	2012-01-10 11:12:02.143249171 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/ShapeGenerator.cpp	2012-01-10 11:12:02.143249171 -0500
@@ -0,0 +1,140 @@
+/*
+ *  Copyright (c) 2004,2007,2008,2009,2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "ShapeGenerator_p.h"
+
+#include <GTLCore/Debug.h>
+#include <GTLCore/Math.h>
+
+using namespace OpenRijn::ImageEngine;
+
+AbstractShapeGenerator::AbstractShapeGenerator(float radius, float ratio, float fh, float fv, int spikes)
+        : m_radius(radius), m_ratio(ratio), m_fh(fh), m_fv(fv), m_spikes(spikes)
+{
+  m_cs = cos(- 2 * M_PI / m_spikes);
+  m_ss = sin(- 2 * M_PI / m_spikes);
+  m_empty = (m_ratio == 0.0 or m_radius == 0.0);
+}
+
+AbstractShapeGenerator::~AbstractShapeGenerator()
+{
+}
+
+float AbstractShapeGenerator::radius() const
+{
+  return m_radius;
+}
+
+CircleShapeGenerator::CircleShapeGenerator(float radius, float ratio, float fh, float fv, int spikes)
+        : AbstractShapeGenerator(radius, ratio, fh, fv, spikes)
+{
+    m_xcoef = 2.0 / m_radius;
+    m_ycoef = 2.0 / (m_ratio * m_radius);
+    m_xfadecoef = (m_fh == 0) ? 1 : (2.0 / (m_fh * m_radius));
+    m_yfadecoef = (m_fv == 0) ? 1 : (2.0 / (m_fv * m_ratio * m_radius));
+    m_cachedSpikesAngle = M_PI / m_spikes;
+}
+
+CircleShapeGenerator::~CircleShapeGenerator()
+{
+}
+
+inline float norme(float a, float b) {
+    return a*a + b * b;
+}
+
+float CircleShapeGenerator::valueAt(float x, float y) const
+{
+    if (m_empty) return 1.0;
+    double xr = (x /*- m_xcenter*/);
+    double yr = fabs(y /*- m_ycenter*/);
+
+    if (m_spikes > 2) {
+        double angle = atan2(yr, xr);
+
+        while (angle > m_cachedSpikesAngle ){
+            double sx = xr, sy = yr;
+
+            xr = m_cs * sx - m_ss * sy;
+            yr = m_ss * sx + m_cs * sy;
+
+            angle -= 2 * m_cachedSpikesAngle;
+        }
+    }
+
+    double n = norme(xr * m_xcoef, yr * m_ycoef);
+
+    if (n > 1) {
+        return 0.0;
+    } else {
+        double normeFade = norme(xr * m_xfadecoef, yr * m_yfadecoef);
+        if (normeFade > 1) {
+            double xle, yle;
+            // xle stands for x-coordinate limit exterior
+            // yle stands for y-coordinate limit exterior
+            // we are computing the coordinate on the external ellipse in order to compute
+            // the fade value
+            if (xr == 0) {
+                xle = 0;
+                yle = yr > 0 ? 1 / m_ycoef : -1 / m_ycoef;
+            } else {
+                double c = yr / (double)xr;
+                xle = sqrt(1 / norme(m_xcoef, c * m_ycoef));
+                xle = xr > 0 ? xle : -xle;
+                yle = xle * c;
+            }
+            // On the internal limit of the fade area, normeFade is equal to 1
+            double normeFadeLimitE = norme(xle * m_xfadecoef, yle * m_yfadecoef);
+            return 1.0 - (normeFade - 1) / (normeFadeLimitE - 1);
+        } else {
+            return 1.0;
+        }
+    }
+}
+
+RectangleShapeGenerator::RectangleShapeGenerator(float radius, float ratio, float fh, float fv, int spikes) : AbstractShapeGenerator(radius, ratio, fh, fv, spikes)
+{
+    if (m_fv == 0 and m_fh == 0) {
+        m_c = 0;
+    } else {
+        m_c = (m_fv / m_fh);
+        GTL_ASSERT(not isnan(m_c));
+    }
+}
+
+RectangleShapeGenerator::~RectangleShapeGenerator()
+{
+}
+
+float RectangleShapeGenerator::valueAt(float x, float y) const
+{
+
+    if (m_empty) return 0.0;
+    double xr = std::fabs(x /*- m_xcenter*/) / m_radius;
+    double yr = std::fabs(y /*- m_ycenter*/) / m_ratio * m_radius;
+    if (xr > m_fh || yr > m_fv) {
+        if (yr <= ((xr - m_fh) * m_c + m_fv)) {
+            return 1.0 - (xr - 0.5 * m_fh) / (1.0 - 0.5 * m_fh);
+        } else {
+            return 1.0 - (yr - 0.5 * m_fv) / (1.0 - 0.5 * m_fv);
+        }
+    } else {
+        return 1.0;
+    }
+}
\ No newline at end of file
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/ShapeGenerator_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/ShapeGenerator_p.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/ShapeGenerator_p.h.95a8c6853b97	2012-01-10 11:12:02.143249171 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/ImageEngine/ShapeGenerator_p.h	2012-01-10 11:12:02.143249171 -0500
@@ -0,0 +1,62 @@
+/*
+ *  Copyright (c) 2004,2007,2008,2009,2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_IMAGEENGINE_SHAPE_GENERATOR_H_
+#define _OPENRIJN_IMAGEENGINE_SHAPE_GENERATOR_H_
+
+#include <GTLCore/Macros.h>
+
+namespace OpenRijn {
+  namespace ImageEngine {
+    class AbstractShapeGenerator {
+      GTL_NO_COPY(AbstractShapeGenerator)
+      protected:
+        AbstractShapeGenerator(float radius, float ratio, float fh, float fv, int spikes);
+      public:
+        virtual ~AbstractShapeGenerator();
+        virtual float valueAt(float x, float y) const = 0;
+        float radius() const;
+      protected:
+        float m_radius, m_ratio, m_fh, m_fv, m_spikes, m_cs, m_ss;
+        bool m_empty;
+    };
+    class CircleShapeGenerator : public AbstractShapeGenerator {
+      GTL_NO_COPY(CircleShapeGenerator)
+      public:
+        CircleShapeGenerator(float radius, float ratio, float fh, float fv, int spikes);
+        virtual ~CircleShapeGenerator();
+        virtual float valueAt(float x, float y) const;
+      private:
+        float m_xcoef, m_ycoef;
+        float m_xfadecoef, m_yfadecoef;
+        float m_cachedSpikesAngle;
+    };
+    class RectangleShapeGenerator : public AbstractShapeGenerator {
+      GTL_NO_COPY(RectangleShapeGenerator)
+      public:
+        RectangleShapeGenerator(float radius, float ratio, float fh, float fv, int spikes);
+        virtual ~RectangleShapeGenerator();
+        virtual float valueAt(float x, float y) const;
+      private:
+        float m_c;
+    };
+  }
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/LibrariesManager.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/LibrariesManager.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/LibrariesManager.cpp.95a8c6853b97	2012-01-10 11:12:02.143249171 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/LibrariesManager.cpp	2012-01-10 11:12:02.143249171 -0500
@@ -0,0 +1,131 @@
+/*
+ *  Copyright (c) 2008, 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "LibrariesManager.h"
+
+#include <map>
+
+// LLVM
+#ifdef LLVM_27_OR_28
+#include <llvm/System/Mutex.h>
+#include <llvm/Support/MutexGuard.h>
+#include <llvm/System/Path.h>
+#else
+#include <llvm/Support/Mutex.h>
+#include <llvm/Support/MutexGuard.h>
+#include <llvm/Support/Path.h>
+#endif
+
+#include "GTLCore/Debug.h"
+#include "Library.h"
+
+#include <GTLCore/Macros_p.h>
+#include <GTLFragment/LibrariesManager.h>
+
+using namespace OpenRijn;
+
+struct LibrariesManager::Private {
+  std::map<GTLCore::String, Library*> libraries;
+  std::list<GTLCore::String> directories;
+  llvm::sys::Mutex mutex;
+};
+
+STATIC_POINTER(LibrariesManager, s_instance);
+
+LibrariesManager::LibrariesManager() : d(new Private)
+{
+  addDirectory( "." );
+  addDirectory( _OPENRIJN_RIJN_STD_LIB_SRC_DIR_ );
+  addDirectory( _OPENRIJN_RIJN_LIBRARIES_DIR_ );
+  GTLFragment::LibrariesManager::instance()->registerLibrariesManager(this);
+}
+
+LibrariesManager::~LibrariesManager()
+{
+  for(std::map<GTLCore::String, Library*>::iterator it = d->libraries.begin();
+      it != d->libraries.end(); ++it)
+  {
+    delete it->second;
+  }
+  delete d;
+}
+
+void LibrariesManager::addDirectory(const GTLCore::String& directory)
+{
+  d->directories.push_back( directory );
+}
+
+GTLFragment::Library* LibrariesManager::library(const GTLCore::String& name, int _channelsNb)
+{
+  GTL_ASSERT(_channelsNb == -1);
+  std::map<GTLCore::String, Library*>::iterator it = d->libraries.find(name);
+  if( it == d->libraries.end())
+  {
+    return 0;
+  }
+  return it->second;
+}
+
+
+GTLFragment::Library* LibrariesManager::loadLibrary( const GTLCore::String& name, int _channelsNb)
+{
+  llvm::MutexGuard mg(d->mutex);
+  GTL_ASSERT(_channelsNb == -1);
+  GTLFragment::Library* l = library( name, _channelsNb );
+  if(not l )
+  {
+    GTLCore::String sourceName = name + ".rijn";
+    for( std::list<GTLCore::String>::iterator it = d->directories.begin();
+        it != d->directories.end(); ++it )
+    {
+      llvm::sys::Path path( (const std::string&)*it );
+      path.appendComponent( (const std::string&)sourceName);
+      GTL_DEBUG("try " << path.c_str() );
+      if(path.exists() and path.canRead())
+      {
+        Library* osl = new Library( Library::RIJN_LIBRARY );
+        registerLibrary( name, osl );
+        osl->loadFromFile( path.c_str());
+        l = osl;
+        break;
+      }
+    }
+  }
+  return l;
+}
+
+void LibrariesManager::registerLibrary(const GTLCore::String& name, Library* l)
+{
+  llvm::MutexGuard mg(d->mutex);
+  d->libraries[ name ] = l;
+}
+
+LibrariesManager* LibrariesManager::instance()
+{
+  if( not s_instance )
+  {
+    s_instance = new LibrariesManager;
+  }
+  return s_instance;
+}
+
+Library::Type LibrariesManager::libraryType() const
+{
+  return Library::RIJN_LIBRARY;
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/LibrariesManager.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/LibrariesManager.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/LibrariesManager.h.95a8c6853b97	2012-01-10 11:12:02.143249171 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/LibrariesManager.h	2012-01-10 11:12:02.143249171 -0500
@@ -0,0 +1,72 @@
+/*
+ *  Copyright (c) 2008, 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_LIBRARY_MANAGER_H_
+#define _OPENRIJN_LIBRARY_MANAGER_H_
+
+#include <GTLCore/String.h>
+#include <OpenRijn/Export.h>
+#include <GTLFragment/AbstractLibrariesManager.h>
+
+namespace {
+  class StaticPointerLibrariesManager;
+}
+
+namespace OpenRijn {
+  class Library;
+  /**
+   * @ingroup OpenRijn
+   *
+   * Manage the different @ref Library that are used by the kernels.
+   */
+  class OPENRIJN_EXPORT LibrariesManager : public GTLFragment::AbstractLibrariesManager {
+      friend class ::StaticPointerLibrariesManager;
+    private:
+      LibrariesManager();
+      ~LibrariesManager();
+      GTL_NO_COPY(LibrariesManager);
+    public:
+      /**
+       * @return a library if it's already loaded or return 0
+       */
+      GTLFragment::Library* library(const GTLCore::String& name, int _channelsNb);
+      /**
+       * Add a directory to the list of directory that get searched for library.
+       * This function is not thread-safe.
+       */
+      void addDirectory(const GTLCore::String& directory);
+      void registerLibrary(const GTLCore::String& name, Library* );
+      /**
+       * Load a library with the given name.
+       */
+      GTLFragment::Library* loadLibrary( const GTLCore::String& filename, int _channelsNb);
+      virtual GTLFragment::Library::Type libraryType() const;
+    public:
+      /**
+       * @return the instance to the singleton \ref LibraryManager
+       */
+      static LibrariesManager* instance();
+    private:
+      struct Private;
+      Private* const d;
+  };
+  
+};
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Library.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Library.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Library.cpp.95a8c6853b97	2012-01-10 11:12:02.143249171 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Library.cpp	2012-01-10 11:12:02.143249171 -0500
@@ -0,0 +1,38 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Library_p.h"
+
+#include <GTLFragment/Library_p.h>
+#include "LibrariesManager.h"
+
+using namespace OpenRijn;
+
+Library::Library(GTLFragment::Library::Type _type) : GTLFragment::Library(_type, -1), d(new Private)
+{
+  LibrariesManager::instance(); // This make sure the libraries manager is created whne compiling libraries
+  GTLFragment::Library::d->libraryCompilation = d;
+}
+
+Library::~Library()
+{
+  cleanup();
+  GTLFragment::Library::d->libraryCompilation = 0;
+  delete d;
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Library.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Library.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Library.h.95a8c6853b97	2012-01-10 11:12:02.143249171 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Library.h	2012-01-10 11:12:02.143249171 -0500
@@ -0,0 +1,46 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_LIBRARY_H_
+#define _OPENRIJN_LIBRARY_H_
+
+#include <GTLFragment/Library.h>
+#include <OpenRijn/Export.h>
+
+namespace OpenRijn {
+  /**
+   * @ingroup OpenRijn
+   *
+   * Hold the code of either a Sketch or a Library.
+   */
+  class OPENRIJN_EXPORT Library : public GTLFragment::Library {
+      friend class Sketch;
+      friend class KernelPrivate;
+      friend class LibrariesManager;
+      Library(GTLFragment::Library::Type _type);
+      ~Library();
+      GTL_NO_COPY(Library);
+    private:
+      struct Private;
+      Private* const d;
+  };
+}
+
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Library_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Library_p.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Library_p.h.95a8c6853b97	2012-01-10 11:12:02.143249171 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Library_p.h	2012-01-10 11:12:02.143249171 -0500
@@ -0,0 +1,64 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Library.h"
+
+#ifdef LLVM_27_OR_28
+#include <llvm/System/DynamicLibrary.h>
+#else
+#include <llvm/Support/DynamicLibrary.h>
+#endif
+
+#include <GTLFragment/LibraryCompilation_p.h>
+#include "Wrapper_p.h"
+
+namespace OpenRijn {
+  
+  struct Library::Private : GTLFragment::LibraryCompilation {
+      GTL_NO_COPY(Private)
+    public:
+      Private() : libraryCompilation(0), m_wrapper(0) {}
+      ~Private() { delete m_wrapper; }
+      virtual void preCompilation() {
+        if(libraryCompilation) libraryCompilation->preCompilation();
+      }
+      virtual void cleanup() {
+        if(libraryCompilation) libraryCompilation->cleanup();
+      }
+      virtual void postCompilation() {
+        if(libraryCompilation) libraryCompilation->postCompilation();
+        llvm::sys::DynamicLibrary::LoadLibraryPermanently( _OPENRIJN_LIB_, 0 ); // This needed because when OpenShiva is used in a plugins, OpenShiva symbols aren't loaded globally and then llvm can't find them (FIXME move that somewhere else)
+      }
+      virtual void createWrapper(GTLCore::ModuleData* _moduleData, llvm::Module* module, int _channels, GTLFragment::WhichStdLibrary _library)
+      {
+        delete m_wrapper;
+        if(libraryCompilation) {
+          libraryCompilation->createWrapper(_moduleData, module, _channels, _library);
+        } else {
+          m_wrapper = new Wrapper(_moduleData, module, _library != GTLFragment::RijnWrappersLibrary );
+        }
+      }
+      virtual void addOperatorOverloads(GTLCore::OperatorOverloadCenter*) {}
+      virtual GTLFragment::Wrapper* wrapper() {
+        return m_wrapper;
+      }
+      LibraryCompilation* libraryCompilation;
+      Wrapper* m_wrapper;
+  };
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/LightParser_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/LightParser_p.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/LightParser_p.cpp.95a8c6853b97	2012-01-10 11:12:02.143249171 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/LightParser_p.cpp	2012-01-10 11:12:02.143249171 -0500
@@ -0,0 +1,155 @@
+/*
+ *  Copyright (c) 2009,2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "LightParser_p.h"
+
+#include "GTLCore/Debug.h"
+#include "GTLFragment/Lexer_p.h"
+
+using namespace OpenRijn;
+
+struct LightParser::Private {
+  GTLFragment::Lexer* lexer;
+  GTLCore::String name;
+  Source::SourceType sourceType;
+};
+
+LightParser::LightParser( GTLFragment::Lexer* lexer ) : ParserBase(0, lexer), d(new Private)
+{
+  d->lexer = lexer;
+}
+
+LightParser::~LightParser()
+{
+  
+}
+
+GTLCore::AST::Tree* LightParser::parse()
+{
+  d->name = "";
+  
+  getNextToken();
+  // Start by ingoring metadata if any
+  if( currentToken().type == GTLCore::Token::INFERIOR )
+  {
+    eatLoopOf( GTLCore::Token::INFERIOR, GTLCore::Token::SUPPERIOR );
+    if( isOfType( currentToken(), GTLCore::Token::SEMI ) )
+    {
+      getNextToken();
+    }
+  }
+  
+  // Parse "import"
+  while( currentToken().type == GTLCore::Token::IMPORT )
+  {
+    getNextToken();
+    if( isOfType( currentToken(), GTLCore::Token::STRING_CONSTANT ) )
+    {
+    }
+    checkNextTokenIsSemi();
+    getNextToken();
+  }
+  
+  GTL_DEBUG("Parse body");
+  bool isKernel = false;
+  if( currentToken().type == GTLCore::Token::LIBRARY ) {
+    d->sourceType = Source::Library;
+  } else {
+    isKernel = true;
+  }
+  getNextToken();
+  if( isOfType( currentToken(), GTLCore::Token::IDENTIFIER ) )
+  {
+    d->name = currentToken().string;
+  }
+  
+  getNextToken();
+  if( isOfType( currentToken(), GTLCore::Token::STARTBRACE ) )
+  {
+    getNextToken();
+    while(true)
+    {
+      switch(currentToken().type)
+      {
+        case GTLCore::Token::END_OF_FILE:
+        case GTLCore::Token::ENDBRACE:
+          return 0;
+        case GTLCore::Token::DEPENDENT:
+        case GTLCore::Token::CONST:
+          eatUntil(GTLCore::Token::SEMI, GTLCore::Token::SEMI);
+          getNextToken(); // eath the ';'
+          break;
+        case GTLCore::Token::STRUCT:
+          eatUntil(GTLCore::Token::ENDBRACE, GTLCore::Token::ENDBRACE);
+          getNextToken(); // eat the '}'
+          getNextToken(); // eat the ';'
+          break;
+        default:
+        {
+          getNextToken(); // Return type
+          if( currentToken().type == GTLCore::Token::IDENTIFIER )
+          {
+            GTL_DEBUG(currentToken().string);
+            getNextToken();
+            eatUntil( GTLCore::Token::ENDBRACKET, GTLCore::Token::ENDBRACKET );
+            getNextToken(); // eath the ')'
+            eatLoopOf( GTLCore::Token::STARTBRACE, GTLCore::Token::ENDBRACE );
+          }
+        }
+      }
+      
+    }
+  }
+  
+  return 0;
+}
+
+void LightParser::eatUntil( GTLCore::Token::Type type1,  GTLCore::Token::Type type2)
+{
+  while( currentToken().type != type1 and currentToken().type != type2 and currentToken().type != GTLCore::Token::END_OF_FILE )
+  {
+//     GTL_DEBUG( currentToken().type << " " << GTLCore::Token::typeToString(currentToken().type));
+    getNextToken();
+  }
+}
+
+void LightParser::eatLoopOf( GTLCore::Token::Type start, GTLCore::Token::Type end)
+{
+  int count = 0;
+  do
+  {
+    if( currentToken().type == start )
+    {
+      ++count;
+    } else if( currentToken().type == end ) {
+      --count;
+    }
+    getNextToken();
+  } while( count > 0 and currentToken().type != GTLCore::Token::END_OF_FILE  );
+}
+
+GTLCore::String LightParser::name() const
+{
+  return d->name;
+}
+
+Source::SourceType LightParser::sourceType() const
+{
+  return d->sourceType;
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/LightParser_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/LightParser_p.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/LightParser_p.h.95a8c6853b97	2012-01-10 11:12:02.143249171 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/LightParser_p.h	2012-01-10 11:12:02.143249171 -0500
@@ -0,0 +1,61 @@
+/*
+ *  Copyright (c) 2009,2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_LIGHT_PARSER_H_
+#define _OPENRIJN_LIGHT_PARSER_H_
+
+#include "GTLCore/ParserBase_p.h"
+
+#include "Source.h"
+
+namespace GTLCore {
+  class String;
+};
+
+namespace GTLFragment {
+  class Lexer;
+}
+
+namespace OpenRijn {
+  /**
+   * @internal
+   * @ingroup OpenRijn
+   *
+   * This is a light parser that is only used to extract a few information from a
+   * kernel. Such as the parameters of the evaluatePixel function.
+   */
+  class LightParser : public GTLCore::ParserBase {
+    public:
+      LightParser( GTLFragment::Lexer* );
+      ~LightParser();
+      GTLCore::AST::Tree* parse();
+      virtual GTLCore::AST::Tree* tree() { return 0; }
+      virtual GTLCore::AST::Statement* parseStatement() { return 0; }
+      Source::SourceType sourceType() const;
+      GTLCore::String name() const;
+    private:
+      void eatUntil( GTLCore::Token::Type type1,  GTLCore::Token::Type type2);
+      void eatLoopOf( GTLCore::Token::Type start, GTLCore::Token::Type end);
+    private:
+      struct Private;
+      Private* const d;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/OpenRijn.pc.cmake.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/OpenRijn.pc.cmake
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/OpenRijn.pc.cmake.95a8c6853b97	2012-01-10 11:12:02.143249171 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/OpenRijn.pc.cmake	2012-01-10 11:12:02.143249171 -0500
@@ -0,0 +1,11 @@
+prefix=@CMAKE_INSTALL_PREFIX@
+exec_prefix=@CMAKE_INSTALL_PREFIX@
+libdir=@LIB_INSTALL_DIR@
+includedir=@INCLUDE_INSTALL_DIR@
+
+Name: OpenShiva
+Description: Sketch interpreter library
+Version: @OPENRIJN_VERSION@
+Requires:
+Libs: -L${libdir} -lOpenRijn -lGTLCore
+Cflags: -I${includedir}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Path.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Path.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Path.cpp.95a8c6853b97	2012-01-10 11:12:02.144249162 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Path.cpp	2012-01-10 11:12:02.144249162 -0500
@@ -0,0 +1,141 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Path.h"
+
+#include <GTLCore/Debug.h>
+#include <GTLCore/Macros_p.h>
+#include <GTLCore/SharedPointer.h>
+#include <GTLCore/Region.h>
+
+using namespace OpenRijn;
+
+struct Path::Private : public GTLCore::SharedPointerData
+{
+  Private() {
+  }
+  Private(const Private& _rhs) : GTLCore::SharedPointerData() {
+    foreach(Element* elt, _rhs.elements)
+    {
+      switch(elt->type)
+      {
+        case Path::MoveToElement:
+        case Path::LineToElement:
+          elements.push_back(new Element(*elt));
+          break;
+        case Path::CurveToElement:
+          elements.push_back(new CurveElement(*static_cast<CurveElement*>(elt)));
+          break;
+      }
+    }
+  }
+  std::vector<Element*> elements;
+};
+
+Path::Path() : d(new Private)
+{
+  d->ref();
+}
+
+GTL_SHARED_DATA(Path)
+
+void Path::moveTo(const DrawingPoint& pt)
+{
+  deref();
+  Element* elt = new Element;
+  elt->type = MoveToElement;
+  elt->point = pt;
+  d->elements.push_back(elt);
+}
+
+void Path::lineTo(const DrawingPoint& pt)
+{
+  deref();
+  Element* elt = new Element;
+  elt->type = LineToElement;
+  elt->point = pt;
+  d->elements.push_back(elt);
+}
+
+void Path::curveTo(float x1, float y1, float x2, float y2, const DrawingPoint& pt2)
+{
+  deref();
+  CurveElement* elt = new CurveElement;
+  elt->type = CurveToElement;
+  elt->point = pt2;
+  elt->x1 = x1;
+  elt->y1 = y1;
+  elt->x2 = x2;
+  elt->y2 = y2;
+  d->elements.push_back(elt);
+}
+
+std::size_t Path::elementCount() const
+{
+  return d->elements.size();
+}
+
+const Path::Element* Path::elementAt(int idx) const
+{
+  GTL_ASSERT(std::size_t(idx) < d->elements.size());
+  return d->elements[idx];
+}
+
+inline void includeCoordinate(float x, float y, GTLCore::RegionF& r)
+{
+  if( x < r.left() ) r.setLeft(x);
+  if( y > r.right() ) r.setRight(y);
+  if( y < r.top() ) r.setTop(y);
+  if( y > r.bottom() ) r.setBottom(y);
+}
+
+GTLCore::RegionF Path::boundingRegion() const
+{
+  if( d->elements.size() == 0 ) return GTLCore::RegionF();
+  
+  float xs = 0, ys = 0;
+  std::size_t idx = 0;
+  if( d->elements[0]->type == MoveToElement)
+  {
+    xs = d->elements[0]->point.x;
+    ys = d->elements[0]->point.y;
+    ++idx;
+  }
+  GTLCore::RegionF r(xs, ys, 0, 0);
+  
+  for(; idx < d->elements.size(); ++idx)
+  {
+      Element* elt = d->elements[idx];
+      switch(elt->type)
+      {
+        case Path::CurveToElement:
+        {
+          CurveElement* celt = static_cast<CurveElement*>(elt);
+          includeCoordinate(celt->x1, celt->y1, r);
+          includeCoordinate(celt->x2, celt->y2, r);
+        }
+        case Path::MoveToElement:
+        case Path::LineToElement:
+          includeCoordinate(elt->point.x, elt->point.y, r);
+          break;
+      }
+  }
+  
+  return r;
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Path.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Path.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Path.h.95a8c6853b97	2012-01-10 11:12:02.144249162 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Path.h	2012-01-10 11:12:02.144249162 -0500
@@ -0,0 +1,72 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_PATH_H_
+#define _OPENRIJN_PATH_H_
+
+#include <cstddef>
+
+#include <OpenRijn/DrawingPoint.h>
+#include <OpenRijn/Export.h>
+
+namespace GTLCore {
+  class RegionF;
+}
+
+namespace OpenRijn {
+  /**
+   * @ingroup OpenRijn
+   *
+   * Define a path, a set of lines and curves.
+   */
+  class OPENRIJN_EXPORT Path {
+    public:
+      enum ElementType {
+        MoveToElement,
+        LineToElement,
+        CurveToElement
+      };
+      struct Element {
+        ElementType type;
+        DrawingPoint point;
+      };
+      struct CurveElement : public Element {
+        float x1, y1, x2, y2;
+      };
+    public:
+      Path();
+      Path(const Path&);
+      Path& operator=(const Path& );
+      ~Path();
+    public:
+      void moveTo(const DrawingPoint&);
+      void lineTo(const DrawingPoint&);
+      void curveTo(float x1, float y1, float x2, float y2, const DrawingPoint& pt2);
+      std::size_t elementCount() const;
+      const Element* elementAt(int idx) const;
+      GTLCore::RegionF boundingRegion() const;
+    private:
+      inline void deref();
+    private:
+      struct Private;
+      Private* d;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/rijnstdlib.rijn.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/rijnstdlib.rijn
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/rijnstdlib.rijn.95a8c6853b97	2012-01-10 11:12:02.144249162 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/rijnstdlib.rijn	2012-01-10 11:12:02.144249162 -0500
@@ -0,0 +1,27 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * version 2 of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+library stdlib
+{
+  const color black = { 0.0, 0.0, 0.0, 1.0 };
+  const color white = { 1.0, 1.0, 1.0, 1.0 };
+  const color red =   { 1.0, 0.0, 0.0, 1.0 };
+  const color green = { 0.0, 1.0, 0.0, 1.0 };
+  const color blue =  { 0.0, 0.0, 1.0, 1.0 };
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/rijnwrappers.rijn.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/rijnwrappers.rijn
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/rijnwrappers.rijn.95a8c6853b97	2012-01-10 11:12:02.144249162 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/rijnwrappers.rijn	2012-01-10 11:12:02.144249162 -0500
@@ -0,0 +1,34 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * version 2 of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+library wrappers
+{
+  void drawPoint(brush b, output canvas c, float2 p)
+  {
+    b.drawPoint(c, p.x, p.y);
+  }
+  void drawLine(brush b, output canvas c, float2 p, float2 p2)
+  {
+    b.drawLine(c, p.x, p.y, 1.0, p2.x, p2.y, 1.0);
+  }
+  void drawLineTo(brush b, output canvas c, float2 p)
+  {
+    b.drawLineTo(c, p.x, p.y);
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Sketch.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Sketch.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Sketch.cpp.95a8c6853b97	2012-01-10 11:12:02.144249162 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Sketch.cpp	2012-01-10 11:12:02.144249162 -0500
@@ -0,0 +1,80 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Sketch.h"
+
+#include <GTLCore/Debug.h>
+#include <GTLCore/Function.h>
+#include <GTLCore/Function_p.h>
+#include <GTLCore/VirtualMachine_p.h>
+
+#include "wrappers/CanvasWrap_p.h"
+#include "wrappers/PaletteWrap_p.h"
+#include <GTLFragment/Library_p.h>
+#include <GTLCore/ModuleData_p.h>
+
+using namespace OpenRijn;
+
+Sketch::Sketch() : Library( GTLFragment::Library::RIJN_SKETCH)
+{
+}
+
+Sketch::~Sketch()
+{
+}
+
+void Sketch::draw(AbstractCanvas* _canvas, AbstractPalette* _palette)
+{
+  TEST_GUARD_READ(GTLFragment::Library::d)
+  CanvasWrap cw;
+  cw.canvas = _canvas;
+  cw.count = 1;
+  PaletteWrap pw;
+  pw.data = _palette;
+  pw.count = 1;
+  
+  const std::list<GTLCore::Function*>* drawFuncs = GTLFragment::Library::d->m_moduleData->function( name(), "draw");
+  GTL_ASSERT(drawFuncs);
+  GTL_ASSERT(drawFuncs->size() == 1);
+  GTLCore::Function* function = *drawFuncs->begin();
+  
+  void (*func)(CanvasWrap*, PaletteWrap*)
+        = ( void(*)(CanvasWrap*, PaletteWrap* ))
+        GTLCore::VirtualMachine::instance()->getPointerToFunction( function->d->data->function());
+
+  GTL_ASSERT(func);
+  (*func)(&cw, &pw);
+}
+
+int Sketch::runTest() const
+{
+  TEST_GUARD_READ(GTLFragment::Library::d)
+  GTL_ASSERT( isCompiled() );
+  const std::list<GTLCore::Function*>* fs = GTLFragment::Library::d->m_moduleData->function( name(), "runTest");
+  GTL_ASSERT( fs );
+  GTLCore::Function* f = fs->front();
+  GTLCore::Value v = f->call( std::vector< GTLCore::Value >() );
+  return v.asInt32();
+}
+
+bool Sketch::hasTestFunction() const
+{
+  TEST_GUARD_READ(GTLFragment::Library::d)
+  return GTLFragment::Library::d->m_moduleData->function( name(), "runTest");
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Sketch.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Sketch.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Sketch.h.95a8c6853b97	2012-01-10 11:12:02.144249162 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Sketch.h	2012-01-10 11:12:02.144249162 -0500
@@ -0,0 +1,53 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_KERNEL_H_
+#define _OPENRIJN_KERNEL_H_
+
+#include <OpenRijn/Library.h>
+
+namespace OpenRijn {
+  class AbstractCanvas;
+  class AbstractPalette;
+  /**
+   * @ingroup OpenRijn
+   *
+   * Represent a Rijn Sketch
+   */
+  class OPENRIJN_EXPORT Sketch : public Library {
+      GTL_NO_COPY(Sketch);
+    public:
+      Sketch();
+      ~Sketch();
+      /**
+      * Call the draw function of the sketch on the @p _canvas using the @p _palette
+      */
+      void draw(AbstractCanvas* _canvas, AbstractPalette* _palette);
+      /**
+      * Run the function called "int runTest()" in the Kernel.
+      */
+      int runTest() const;
+      /**
+      * @return true if the test function is available
+      */
+      bool hasTestFunction() const;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Source.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Source.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Source.cpp.95a8c6853b97	2012-01-10 11:12:02.144249162 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Source.cpp	2012-01-10 11:12:02.144249162 -0500
@@ -0,0 +1,67 @@
+/*
+ *  Copyright (c) 2009,2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Source.h"
+
+using namespace OpenRijn;
+
+#include <GTLCore/Debug.h>
+
+#include "LightParser_p.h"
+#include <GTLFragment/Source_p.h>
+#include <GTLFragment/Lexer_p.h>
+
+struct Source::Private : public GTLFragment::Source::Private
+{
+  Private() : sourceType(InvalidSource) {}
+  Private(const Private& _rhs) : GTLFragment::Source::Private(_rhs), sourceType(InvalidSource) {}
+  
+  Private* clone() { return new Private(*this); }
+  void specificUpdate(const GTLCore::String& _source, GTLCore::String& name);
+
+  SourceType sourceType;
+};
+
+void Source::Private::specificUpdate(const GTLCore::String& _source, GTLCore::String& name)
+{
+  std::istringstream iss(_source);
+  GTLFragment::Lexer lexer( &iss, GTLFragment::Library::RIJN_SKETCH );
+  LightParser parser(&lexer);
+  parser.parse();
+  name = parser.name();
+  sourceType = parser.sourceType();
+}
+
+// ---- Library::Private ---- //
+
+const Source::Private* Source::d_func() const
+{
+  return static_cast<Source::Private*>(d);
+}
+
+Source::Source() : GTLFragment::Source(new Private)
+{
+}
+
+GTL_INHERITED_SHARED_DATA(Source, GTLFragment::Source)
+
+Source::SourceType Source::sourceType() const
+{
+  return d_func()->sourceType;
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Source.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Source.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Source.h.95a8c6853b97	2012-01-10 11:12:02.144249162 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Source.h	2012-01-10 11:12:02.144249162 -0500
@@ -0,0 +1,56 @@
+/*
+ *  Copyright (c) 2009,2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_KERNEL_SOURCE_H_
+#define _OPENRIJN_KERNEL_SOURCE_H_
+
+#include <OpenRijn/Export.h>
+#include <GTLFragment/Source.h>
+
+namespace OpenRijn {
+  class Metadata;
+  /**
+   * @ingroup OpenRijn
+   * 
+   * Define the source code of a Sketch. Allow to access to information like the metadata,
+   * or the source code.
+   */
+  class OPENRIJN_EXPORT Source : public GTLFragment::Source {
+    public:
+      Source();
+      Source(const Source& );
+      Source& operator=(const Source& );
+      ~Source();
+    public:
+      enum SourceType {
+        InvalidSource, ///< Not a valid Rijn source code
+        Library, ///< \ref Library
+        Sketch, ///< A \ref Kernel with only an output image
+      };
+      /**
+       * @return the type of the Kernel/Library
+       */
+      SourceType sourceType() const;
+    private:
+      struct Private;
+      inline const Private* d_func() const;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/SourcesCollection.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/SourcesCollection.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/SourcesCollection.cpp.95a8c6853b97	2012-01-10 11:12:02.144249162 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/SourcesCollection.cpp	2012-01-10 11:12:02.144249162 -0500
@@ -0,0 +1,99 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "SourcesCollection.h"
+
+// LLVM
+#ifdef LLVM_27_OR_28
+#include <llvm/System/Path.h>
+#else
+#include <llvm/Support/Path.h>
+#endif
+
+#include "GTLCore/String.h"
+#include "GTLCore/Macros_p.h"
+#include "GTLCore/Utils_p.h"
+
+#include "GTLCore/Debug.h"
+#include "Source.h"
+
+using namespace OpenRijn;
+
+struct SourcesCollection::Private {
+  std::list< Source > kernels;
+  void addDirectory( const llvm::sys::Path& path );
+};
+
+
+void SourcesCollection::Private::addDirectory( const llvm::sys::Path& path )
+{
+  std::set< llvm::sys::Path > content;
+  path.getDirectoryContents( content, 0 );
+  GTL_DEBUG( "Looking for kernel in: " << path.c_str() );
+  foreach( const llvm::sys::Path& path, content )
+  {
+    GTL_DEBUG( "Kernel: " << path.c_str() << "?" );
+    if( GTLCore::String( path.getSuffix() ).toLower() == "rijn" )
+    {
+      GTL_DEBUG("Loading: " << path.c_str() );
+      Source kernel;
+      kernel.loadFromFile( path.c_str() );
+      kernels.push_back( kernel );
+    }
+  }
+}
+
+SourcesCollection::SourcesCollection() : d(new Private)
+{
+  addDirectory( _OPENRIJN_RIJN_KERNELS_DIR_ );
+  addDirectory( llvm::sys::Path::GetUserHomeDirectory().str() + "/.OpenGTL/rijn/sketches" );
+}
+
+SourcesCollection::~SourcesCollection()
+{
+  delete d;
+}
+
+void SourcesCollection::addDirectory(const GTLCore::String& directory)
+{
+  d->addDirectory( llvm::sys::Path( (const std::string&)directory ) );
+}
+
+void SourcesCollection::registerSource( const Source& kernel )
+{
+  d->kernels.push_back( kernel );
+}
+
+std::list< Source> SourcesCollection::sources() const
+{
+  return d->kernels;
+}
+
+
+Source SourcesCollection::source(const GTLCore::String& _string) const
+{
+  foreach(Source source,d->kernels)
+  {
+    if(source.name() == _string)
+    {
+      return source;
+    }
+  }
+  return Source();
+}
\ No newline at end of file
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/SourcesCollection.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/SourcesCollection.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/SourcesCollection.h.95a8c6853b97	2012-01-10 11:12:02.144249162 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/SourcesCollection.h	2012-01-10 11:12:02.144249162 -0500
@@ -0,0 +1,67 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_KERNELS_COLLECTION_H_
+#define _OPENRIJN_KERNELS_COLLECTION_H_
+
+#include <list>
+#include <OpenRijn/Source.h>
+
+namespace GTLCore {
+  class String;
+}
+
+namespace OpenRijn {
+  /**
+   * @ingroup OpenRijn
+   * 
+   * This class allows to access to the list of sketches installed in the system.
+   * 
+   * The collection will look for .rijn files in:
+   * ${PREFIX}/share/OpenGTL/rijn/sketches
+   * ${HOME}/.OpenGTL/rijn/sketches
+   */
+  class OPENRIJN_EXPORT SourcesCollection {
+      GTL_NO_COPY(SourcesCollection);
+    public:
+      SourcesCollection( );
+      ~SourcesCollection();
+      /**
+       * Add custom directories
+       */
+      void addDirectory(const GTLCore::String& directory);
+      /**
+       * Manually register a Kernel in the collection. And takes ownership
+       */
+      void registerSource( const Source& );
+      /**
+       * @return the list of kernels in the collection
+       */
+      std::list< Source > sources() const;
+      /**
+       * @return a kernel by the name of @p _string or null if no such kernel exists
+       */
+      Source source(const GTLCore::String& _string) const;
+    private:
+      struct Private;
+      Private* const d;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Version.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Version.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Version.cpp.95a8c6853b97	2012-01-10 11:12:02.144249162 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Version.cpp	2012-01-10 11:12:02.144249162 -0500
@@ -0,0 +1,51 @@
+/*
+ *  Copyright (c) 2009 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Version.h"
+
+
+namespace OpenRijn {
+  GTLCore::String LibraryShortName() { return "OpenRijn"; }
+  GTLCore::String LibraryName() { return "OpenRijn Kernel Transformation Language"; }
+  GTLCore::String LibraryCopyright() { return "Copyright (c) 2010 Cyrille Berger (cberger@cberger.net)"; }
+  GTLCore::String LibraryLicence() { return "GNU Lesser General Public License Version 2, or later"; }
+  GTLCore::String LibraryVersionString() { return GTLCore::String::number( OPENRIJN_VERSION_MAJOR ) + "." + GTLCore::String::number( OPENRIJN_VERSION_MAJOR ) + "." + GTLCore::String::number( OPENRIJN_VERSION_MAJOR ); }
+  int LibraryVersionMajor()
+  {
+      return OPENRIJN_VERSION_MAJOR;
+  }
+  int LibraryVersionMinor()
+  {
+      return OPENRIJN_VERSION_MAJOR;
+  }
+  int LibraryVersionRevision()
+  {
+      return OPENRIJN_VERSION_MAJOR;
+  }
+  int LanguageVersion()
+  {
+      return 0;
+  }
+  int LanguageVersionRevision()
+  {
+      return 0;
+  }
+  
+}
+
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Version.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Version.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Version.h.95a8c6853b97	2012-01-10 11:12:02.145249154 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Version.h	2012-01-10 11:12:02.145249154 -0500
@@ -0,0 +1,46 @@
+/*
+ *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_VERSION_H_
+#define _OPENRIJN_VERSION_H_
+
+#include <GTLCore/Version.h>
+#include <OpenRijn/Export.h>
+
+#define OPENRIJN_VERSION_MAJOR GTL_CORE_VERSION_MAJOR
+#define OPENRIJN_VERSION_MINOR GTL_CORE_VERSION_MINOR
+#define OPENRIJN_VERSION_REVISION GTL_CORE_VERSION_REVISION
+
+namespace OpenRijn {
+  OPENRIJN_EXPORT GTLCore::String LibraryShortName();
+  OPENRIJN_EXPORT GTLCore::String LibraryName();
+  OPENRIJN_EXPORT GTLCore::String LibraryCopyright();
+  OPENRIJN_EXPORT GTLCore::String LibraryLicence();
+  OPENRIJN_EXPORT GTLCore::String LibraryVersionString();;
+  OPENRIJN_EXPORT int LibraryVersionMajor();
+  OPENRIJN_EXPORT int LibraryVersionMinor();
+  OPENRIJN_EXPORT int LibraryVersionRevision();
+  /**
+   * Give the latest version of the Rijn language supported by this library.
+   */
+  OPENRIJN_EXPORT int LanguageVersion();
+  OPENRIJN_EXPORT int LanguageVersionRevision();
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Wrapper.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Wrapper.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Wrapper.cpp.95a8c6853b97	2012-01-10 11:12:02.145249154 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Wrapper.cpp	2012-01-10 11:12:02.145249154 -0500
@@ -0,0 +1,158 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Wrapper_p.h"
+
+#include <llvm/LLVMContext.h>
+#include <llvm/Module.h>
+
+#include <GTLCore/CompilationMessages.h>
+#include <GTLCore/Debug.h>
+#include <GTLCore/Function_p.h>
+#include <GTLCore/Macros_p.h>
+#include <GTLCore/ModuleData_p.h>
+#include <GTLCore/Type_p.h>
+#include <GTLCore/TypesManager.h>
+#include <GTLCore/TypesManager_p.h>
+#include <GTLCore/Value.h>
+
+#include <GTLFragment/Library.h>
+
+#include <OpenRijn/LibrariesManager.h>
+
+using namespace OpenRijn;
+
+struct Wrapper::Private {
+  bool loadRijnWrapperLibrary;
+};
+
+Wrapper::Wrapper(GTLCore::ModuleData* _moduleData, llvm::Module* module, bool loadRijnWrapperLibrary) : GTLFragment::Wrapper(_moduleData, module, -1), d(new Private)
+{
+  d->loadRijnWrapperLibrary = loadRijnWrapperLibrary;
+}
+
+void Wrapper::fillTypesManager( GTLCore::TypesManager* _typesManager, GTLCore::ConvertCenter* _convertCenter)
+{
+  const GTLCore::Type* colorType = createColorType(_typesManager, _convertCenter);
+  const GTLCore::Type* canvasType = createCanvasType(_typesManager, _convertCenter);
+  const GTLCore::Type* brushType = createBrushType(_typesManager, _convertCenter, colorType, canvasType);
+  createPaletteType(_typesManager, _convertCenter, brushType);
+
+  if(d->loadRijnWrapperLibrary)
+  {
+    GTLFragment::Library* library = OpenRijn::LibrariesManager::instance()->loadLibrary( "rijnwrappers", -1);
+    GTL_ASSERT( library );
+    if(not library->isCompiled())
+    {
+      library->compile();
+      if(not library->isCompiled())
+      {
+        GTL_ABORT("rijnwrappers.rijn compilation failed, " << library->compilationMessages().toString());
+        return;
+      }
+    }
+    moduleData()->linkWith( library->data() );
+    addFunctionFromModuleToType(brushType, library, GTLCore::ScopedName("wrappers", "drawPoint"));
+    addFunctionFromModuleToType(brushType, library, GTLCore::ScopedName("wrappers", "drawLine"));
+    addFunctionFromModuleToType(brushType, library, GTLCore::ScopedName("wrappers", "drawLineTo"));
+  }
+}
+
+const GTLCore::Type* Wrapper::createCanvasType(GTLCore::TypesManager* _typesManager, GTLCore::ConvertCenter* _convertCenter)
+{
+  //---------------------- WARNING ----------------------//
+  // Whenever the following structure is edited,         //
+  // it's llvm declaration must be changed too in        //
+  // struct CanvasWrap !                                 //
+  //---------------------- WARNING ----------------------//
+//   llvm::LLVMContext& context = d->moduleData->llvmModule()->getContext();
+  
+  std::vector<GTLCore::Type::StructDataMember> painterDataMembers;
+  const GTLCore::Type* type = _typesManager->d->createStructure( "canvas", painterDataMembers );
+  
+  return type;
+}
+
+#define NULL_P (void*)0
+
+const GTLCore::Type* Wrapper::createBrushType(GTLCore::TypesManager* _typesManager, GTLCore::ConvertCenter* _convertCenter, const GTLCore::Type* _colorType, const GTLCore::Type* _canvasType)
+{
+  //---------------------- WARNING ----------------------//
+  // Whenever the following structure is edited,         //
+  // it's llvm declaration must be changed too in        //
+  // struct BrushWrap !                                  //
+  //---------------------- WARNING ----------------------//
+  llvm::LLVMContext& context = moduleData()->llvmModule()->getContext();
+  
+  std::vector<GTLCore::Type::StructDataMember> brushDataMembers;
+  brushDataMembers.push_back( GTLCore::Type::StructDataMember( "data", GTLCore::Type::Pointer ) );
+  brushDataMembers.push_back( GTLCore::Type::StructDataMember( "paintColor", _colorType ) );
+  const GTLCore::Type* type = _typesManager->d->createStructure( "brush", brushDataMembers );
+  
+  type->d->addFunctionMember( GTLCore::Type::StructFunctionMember(
+          GTLCore::Function::Private::createExternalFunction(
+                moduleData(), llvmModule(), context, "drawPoint", "brush_wrap_draw_point", GTLCore::Type::Void,
+                GTLCore::Function::Private::EFP_TYPE_AND_DEFAULT, 6,
+                type, NULL_P, _canvasType, NULL_P,
+                GTLCore::Type::Float32, NULL_P,
+                GTLCore::Type::Float32, NULL_P,
+                GTLCore::Type::Float32, new GTLCore::Value(1.0f),
+                GTLCore::Type::Float32, new GTLCore::Value(0.0f) ) ) );
+  
+  type->d->addFunctionMember( GTLCore::Type::StructFunctionMember(
+          GTLCore::Function::Private::createExternalFunction(
+                moduleData(), llvmModule(), context, "drawLine", "brush_wrap_draw_line", GTLCore::Type::Void,
+                GTLCore::Function::Private::EFP_ONLY_TYPE, 8,
+                type, _canvasType,
+                GTLCore::Type::Float32, GTLCore::Type::Float32, // x1, y1
+                GTLCore::Type::Float32, GTLCore::Type::Float32, // t1, x2
+                GTLCore::Type::Float32, GTLCore::Type::Float32 ) ) ); // y2, t2
+  
+  type->d->addFunctionMember( GTLCore::Type::StructFunctionMember(
+          GTLCore::Function::Private::createExternalFunction(
+                moduleData(), llvmModule(), context, "drawLineTo", "brush_wrap_draw_line_to", GTLCore::Type::Void,
+                GTLCore::Function::Private::EFP_TYPE_AND_DEFAULT, 6,
+                type, NULL_P, _canvasType, NULL_P,
+                GTLCore::Type::Float32, NULL_P,
+                GTLCore::Type::Float32, NULL_P,
+                GTLCore::Type::Float32, new GTLCore::Value(1.0f),
+                GTLCore::Type::Float32, new GTLCore::Value(0.0f) ) ) );
+  
+  return type;
+}
+
+const GTLCore::Type* Wrapper::createPaletteType(GTLCore::TypesManager* _typesManager, GTLCore::ConvertCenter* _convertCenter, const GTLCore::Type* _brushType)
+{
+  //---------------------- WARNING ----------------------//
+  // Whenever the following structure is edited,         //
+  // it's llvm declaration must be changed too in        //
+  // struct PaletteWrap !                                  //
+  //---------------------- WARNING ----------------------//
+  llvm::LLVMContext& context = moduleData()->llvmModule()->getContext();
+  
+  std::vector<GTLCore::Type::StructDataMember> paletteDataMembers;
+  paletteDataMembers.push_back( GTLCore::Type::StructDataMember( "data", GTLCore::Type::Pointer ) );
+  const GTLCore::Type* type = _typesManager->d->createStructure( "palette", paletteDataMembers );
+  type->d->addFunctionMember( GTLCore::Type::StructFunctionMember(
+          GTLCore::Function::Private::createExternalFunction(
+                moduleData(), llvmModule(), context, "createCircleBrush", "palette_wrap_create_circle_brush", _brushType,
+                GTLCore::Function::Private::EFP_TYPE_AND_DEFAULT, 3,
+                type, NULL_P, GTLCore::Type::Float32, NULL_P, GTLCore::Type::Float32, new GTLCore::Value(0.5f) ) ) );
+  return type;
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Wrapper_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Wrapper_p.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Wrapper_p.h.95a8c6853b97	2012-01-10 11:12:02.145249154 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/Wrapper_p.h	2012-01-10 11:12:02.145249154 -0500
@@ -0,0 +1,46 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_WRAPPER_P_H_
+#define _OPENRIJN_WRAPPER_P_H_
+
+#include <GTLFragment/Wrapper_p.h>
+
+namespace OpenRijn {
+  /**
+   * @internal
+   * @ingroup OpenRijn
+   *
+   * Wrapper of functions for Rijn.
+   */
+  class Wrapper : public GTLFragment::Wrapper {
+    public:
+      Wrapper(GTLCore::ModuleData* _moduleData, llvm::Module* module, bool loadRijnWrapperLibrary);
+      virtual void fillTypesManager( GTLCore::TypesManager* _typesManager, GTLCore::ConvertCenter* _convertCenter);
+    private:
+      const GTLCore::Type* createBrushType(GTLCore::TypesManager* _typesManager, GTLCore::ConvertCenter* _convertCenter, const GTLCore::Type* _colorType, const GTLCore::Type* _canvasType);
+      const GTLCore::Type* createPaletteType(GTLCore::TypesManager* _typesManager, GTLCore::ConvertCenter* _convertCenter, const GTLCore::Type* _brushType);
+      const GTLCore::Type* createCanvasType(GTLCore::TypesManager* _typesManager, GTLCore::ConvertCenter* _convertCenter);
+    private:
+      struct Private;
+      Private* const d;
+  };
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/BrushWrap_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/BrushWrap_p.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/BrushWrap_p.cpp.95a8c6853b97	2012-01-10 11:12:02.145249154 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/BrushWrap_p.cpp	2012-01-10 11:12:02.145249154 -0500
@@ -0,0 +1,84 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "BrushWrap_p.h"
+
+#include <cmath>
+
+#include <GTLCore/wrappers/Allocate.h>
+#include <GTLFragment/wrappers/ColorWrap_p.h>
+
+#include <OpenRijn/AbstractBrush.h>
+#include <OpenRijn/AbstractCanvas.h>
+
+#include "CanvasWrap_p.h"
+#include <DrawingPoint.h>
+#include <AbstractCanvas_p.h>
+
+BrushWrap* wrapBrush(OpenRijn::AbstractBrush* brush)
+{
+  BrushWrap* b = gtlAllocate<BrushWrap>();
+  b->brush = brush;
+  wrapColor(b->paintColor, 0,0,0,1);
+  brush->setPaintColor(colorWrapToGTLCoreColor(b->paintColor));
+  return b;
+}
+#include<iostream>
+inline void sync_brush(BrushWrap* brush)
+{
+  brush->brush->setPaintColor(colorWrapToGTLCoreColor(brush->paintColor));
+}
+
+extern "C" {
+void brush_wrap_draw_point(BrushWrap* brush, CanvasWrap* canvas, float x, float y, float t1, float angle)
+{
+  sync_brush(brush);
+  OpenRijn::AbstractCanvas::Private* c_d = canvas->canvas->d;
+  OpenRijn::DrawingPoint pt(x, y, t1, angle);
+  float sp = brush->brush->drawPoint(canvas->canvas, pt);
+  c_d->lastInfo.distance = 0.0;
+  c_d->lastInfo.spacing = sp;
+  c_d->lastPt = pt;
+}
+
+void brush_wrap_draw_line(BrushWrap* brush, CanvasWrap* canvas, float x1, float y1, float t1, float x2, float y2, float t2)
+{
+  sync_brush(brush);
+  OpenRijn::AbstractCanvas::Private* c_d = canvas->canvas->d;
+  OpenRijn::DistanceInformation info;
+  if( std::fabs(x1 - c_d->lastPt.x) < 0.01 and std::fabs(y1 - c_d->lastPt.y) < 0.01)
+  {
+    info = c_d->lastInfo;
+  }
+  OpenRijn::DrawingPoint pt2(x2, y2, t2, 0.0);
+  c_d->lastInfo = brush->brush->drawLine(canvas->canvas, OpenRijn::DrawingPoint(x1, y1, t1, 0.0), pt2, info);
+  c_d->lastPt = pt2;
+}
+
+void brush_wrap_draw_line_to(BrushWrap* brush, CanvasWrap* canvas, float x2, float y2, float t2)
+{
+  sync_brush(brush);
+  OpenRijn::AbstractCanvas::Private* c_d = canvas->canvas->d;
+  OpenRijn::DistanceInformation info = c_d->lastInfo;
+  OpenRijn::DrawingPoint pt2(x2, y2, t2, 0.0);
+  c_d->lastInfo = brush->brush->drawLine(canvas->canvas, c_d->lastPt, pt2, info);
+  c_d->lastPt = pt2;
+}
+
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/BrushWrap_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/BrushWrap_p.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/BrushWrap_p.h.95a8c6853b97	2012-01-10 11:12:02.145249154 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/BrushWrap_p.h	2012-01-10 11:12:02.145249154 -0500
@@ -0,0 +1,52 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_BRUSH_WRAP_P_H_
+#define _OPENRIJN_BRUSH_WRAP_P_H_
+
+#include <GTLCore/wrappers/StructWrap.h>
+#include <OpenRijn/Export.h>
+#include <GTLFragment/wrappers/ColorWrap_p.h>
+
+struct CanvasWrap;
+
+namespace OpenRijn {
+  class AbstractBrush;
+}
+
+//---------------------- WARNING ----------------------//
+// Whenever the following structure is edited,         //
+// it's llvm declaration must be changed too in        //
+// Wrapper::createBrushType !                          //
+//---------------------- WARNING ----------------------//
+struct BrushWrap {
+  STRUCT_HEADER
+  OpenRijn::AbstractBrush* brush;
+  ColorWrap paintColor;
+};
+
+BrushWrap* wrapBrush(OpenRijn::AbstractBrush* brush);
+
+extern "C" {
+OPENRIJN_EXPORT void brush_wrap_draw_point(BrushWrap* brush, CanvasWrap* canvas, float x, float y, float t1, float angle);
+OPENRIJN_EXPORT void brush_wrap_draw_line(BrushWrap* brush, CanvasWrap* canvas, float x1, float y1, float t1, float x2, float y2, float t2);
+OPENRIJN_EXPORT void brush_wrap_draw_line_to(BrushWrap* brush, CanvasWrap* canvas, float x2, float y2, float t2);
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/CanvasWrap_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/CanvasWrap_p.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/CanvasWrap_p.h.95a8c6853b97	2012-01-10 11:12:02.145249154 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/CanvasWrap_p.h	2012-01-10 11:12:02.145249154 -0500
@@ -0,0 +1,39 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_CANVAS_WRAP_P_H_
+#define _OPENRIJN_CANVAS_WRAP_P_H_
+
+#include "BrushWrap_p.h"
+
+namespace OpenRijn {
+  class AbstractCanvas;
+}
+
+//---------------------- WARNING ----------------------//
+// Whenever the following structure is edited,         //
+// it's llvm declaration must be changed too in        //
+// Wrapper::createPainterType !                        //
+//---------------------- WARNING ----------------------//
+struct CanvasWrap {
+  STRUCT_HEADER
+  OpenRijn::AbstractCanvas* canvas;
+};
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/PaletteWrap_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/PaletteWrap_p.cpp
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/PaletteWrap_p.cpp.95a8c6853b97	2012-01-10 11:12:02.145249154 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/PaletteWrap_p.cpp	2012-01-10 11:12:02.145249154 -0500
@@ -0,0 +1,32 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "PaletteWrap_p.h"
+
+#include "BrushWrap_p.h"
+#include "../AbstractPalette.h"
+
+extern "C" {
+
+BrushWrap* palette_wrap_create_circle_brush(PaletteWrap* wrap, float size, float hardness)
+{
+  return wrapBrush(wrap->data->createCircleBrush(size, hardness));
+}
+
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/PaletteWrap_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/PaletteWrap_p.h
--- OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/PaletteWrap_p.h.95a8c6853b97	2012-01-10 11:12:02.145249154 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/OpenRijn/wrappers/PaletteWrap_p.h	2012-01-10 11:12:02.145249154 -0500
@@ -0,0 +1,48 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _OPENRIJN_PALETTE_WRAP_P_H_
+#define _OPENRIJN_PALETTE_WRAP_P_H_
+
+#include <GTLCore/wrappers/StructWrap.h>
+#include <OpenRijn/Export.h>
+
+namespace OpenRijn {
+  class AbstractPalette;
+}
+
+struct BrushWrap;
+
+//---------------------- WARNING ----------------------//
+// Whenever the following structure is edited,         //
+// it's llvm declaration must be changed too in        //
+// Wrapper::createPaletteType !                        //
+//---------------------- WARNING ----------------------//
+struct PaletteWrap {
+  STRUCT_HEADER
+  OpenRijn::AbstractPalette* data;
+};
+
+extern "C" {
+
+OPENRIJN_EXPORT BrushWrap* palette_wrap_create_circle_brush(PaletteWrap* wrap, float size, float hardness);
+
+}
+
+#endif
diff -up OpenGTL-0.9.15.2/OpenRijn/tests/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tests/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenRijn/tests/CMakeLists.txt.95a8c6853b97	2012-01-10 11:12:02.145249154 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tests/CMakeLists.txt	2012-01-10 11:12:02.145249154 -0500
@@ -0,0 +1,3 @@
+add_subdirectory(parse)
+add_subdirectory(points)
+add_subdirectory(lines)
diff -up OpenGTL-0.9.15.2/OpenRijn/tests/lines/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tests/lines/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenRijn/tests/lines/CMakeLists.txt.95a8c6853b97	2012-01-10 11:12:02.145249154 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tests/lines/CMakeLists.txt	2012-01-10 11:12:02.145249154 -0500
@@ -0,0 +1,11 @@
+
+set( TESTS_FILES
+  linessimple.rijn
+  linesdouble.rijn
+  )
+
+FOREACH( TEST_FILE ${TESTS_FILES} )
+  ADD_TEST(${TEST_FILE} ${RIJNTESTER} -c ${CMAKE_CURRENT_SOURCE_DIR}/${TEST_FILE} ${OPENGTL_TESTS_DATA}/${OPENGTL_TESTS_DATA_RESULTS_DIR}/${TEST_FILE}.png)
+ENDFOREACH( TEST_FILE )
+
+
diff -up OpenGTL-0.9.15.2/OpenRijn/tests/lines/linesdouble.rijn.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tests/lines/linesdouble.rijn
--- OpenGTL-0.9.15.2/OpenRijn/tests/lines/linesdouble.rijn.95a8c6853b97	2012-01-10 11:12:02.146249145 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tests/lines/linesdouble.rijn	2012-01-10 11:12:02.146249145 -0500
@@ -0,0 +1,14 @@
+sketch Simple
+{
+  void draw(output canvas c, input palette p)
+  {
+    brush b = p.createCircleBrush(5.0);
+    b.paintColor = white;
+    b.paintColor.green = 0.0;
+    b.paintColor.opacity = 0.5;
+    b.drawLine(c, float2(0,0), float2(800,600));
+    b.paintColor = black;
+    b.paintColor.opacity = 0.5;
+    b.drawLine(c, float2(800,0), float2(0,600));
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/tests/lines/linessimple.rijn.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tests/lines/linessimple.rijn
--- OpenGTL-0.9.15.2/OpenRijn/tests/lines/linessimple.rijn.95a8c6853b97	2012-01-10 11:12:02.146249145 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tests/lines/linessimple.rijn	2012-01-10 11:12:02.146249145 -0500
@@ -0,0 +1,11 @@
+sketch Simple
+{
+  void draw(output canvas c, input palette p)
+  {
+    brush b = p.createCircleBrush(5.0);
+    b.paintColor = white;
+    b.paintColor.green = 0.0;
+    b.paintColor.opacity = 0.5;
+    b.drawLine(c, float2(0,0), float2(800,600));
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/tests/parse/brush.rijn.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tests/parse/brush.rijn
--- OpenGTL-0.9.15.2/OpenRijn/tests/parse/brush.rijn.95a8c6853b97	2012-01-10 11:12:02.146249145 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tests/parse/brush.rijn	2012-01-10 11:12:02.146249145 -0500
@@ -0,0 +1,9 @@
+sketch MySketch
+{
+  void draw(output canvas c, input palette p)
+  {
+    brush b = p.createCircleBrush(1.0);
+    b.paintColor = black;
+    b.paintColor.opacity = 0.8;
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/tests/parse/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tests/parse/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenRijn/tests/parse/CMakeLists.txt.95a8c6853b97	2012-01-10 11:12:02.146249145 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tests/parse/CMakeLists.txt	2012-01-10 11:12:02.146249145 -0500
@@ -0,0 +1,21 @@
+
+set( TESTS_FILES
+  brush.rijn
+  color.rijn
+  line.rijn
+  lineto.rijn
+  point.rijn
+  sketch.rijn
+  )
+
+FOREACH( TEST_FILE ${TESTS_FILES} )
+  ADD_TEST(${TEST_FILE} ${RIJNC} -L ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/${TEST_FILE})
+ENDFOREACH( TEST_FILE )
+
+# set( TESTS_FAIL_FILES
+#   )
+# 
+# FOREACH( TEST_FILE ${TESTS_FAIL_FILES} )
+#   ADD_TEST(${TEST_FILE} ${CMAKE_CURRENT_SOURCE_DIR}/../../../sdk/invertresult.sh ${RIJNC} ${CMAKE_CURRENT_SOURCE_DIR}/${TEST_FILE})
+# ENDFOREACH( TEST_FILE )
+# 
diff -up OpenGTL-0.9.15.2/OpenRijn/tests/parse/color.rijn.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tests/parse/color.rijn
--- OpenGTL-0.9.15.2/OpenRijn/tests/parse/color.rijn.95a8c6853b97	2012-01-10 11:12:02.146249145 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tests/parse/color.rijn	2012-01-10 11:12:02.146249145 -0500
@@ -0,0 +1,8 @@
+sketch MySketch
+{
+  void draw(output canvas c, input palette p)
+  {
+    color co = black;
+    co.opacity = 0.5;
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/tests/parse/line.rijn.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tests/parse/line.rijn
--- OpenGTL-0.9.15.2/OpenRijn/tests/parse/line.rijn.95a8c6853b97	2012-01-10 11:12:02.146249145 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tests/parse/line.rijn	2012-01-10 11:12:02.146249145 -0500
@@ -0,0 +1,10 @@
+sketch MySketch
+{
+  void draw(output canvas c, input palette p)
+  {
+    brush b = p.createCircleBrush(1.0);
+    b.paintColor = white;
+    b.paintColor.opacity = 0.8;
+    b.drawLine(c, float2(3,3), float2(5,5));
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/tests/parse/lineto.rijn.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tests/parse/lineto.rijn
--- OpenGTL-0.9.15.2/OpenRijn/tests/parse/lineto.rijn.95a8c6853b97	2012-01-10 11:12:02.146249145 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tests/parse/lineto.rijn	2012-01-10 11:12:02.146249145 -0500
@@ -0,0 +1,10 @@
+sketch MySketch
+{
+  void draw(output canvas c, input palette p)
+  {
+    brush b = p.createCircleBrush(1.0);
+    b.paintColor = black;
+    b.paintColor.opacity = 0.8;
+    b.drawLineTo(c, float2(5,5));
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/tests/parse/point.rijn.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tests/parse/point.rijn
--- OpenGTL-0.9.15.2/OpenRijn/tests/parse/point.rijn.95a8c6853b97	2012-01-10 11:12:02.146249145 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tests/parse/point.rijn	2012-01-10 11:12:02.146249145 -0500
@@ -0,0 +1,10 @@
+sketch MySketch
+{
+  void draw(output canvas c, input palette p)
+  {
+    brush b = p.createCircleBrush(1.0);
+    b.paintColor = black;
+    b.paintColor.opacity = 0.8;
+    b.drawPoint(c, float2(3,3));
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/tests/parse/sketch.rijn.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tests/parse/sketch.rijn
--- OpenGTL-0.9.15.2/OpenRijn/tests/parse/sketch.rijn.95a8c6853b97	2012-01-10 11:12:02.146249145 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tests/parse/sketch.rijn	2012-01-10 11:12:02.146249145 -0500
@@ -0,0 +1,7 @@
+sketch MySketch
+{
+  void draw(output canvas c, input palette p)
+  {
+    
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/tests/points/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tests/points/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenRijn/tests/points/CMakeLists.txt.95a8c6853b97	2012-01-10 11:12:02.146249145 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tests/points/CMakeLists.txt	2012-01-10 11:12:02.146249145 -0500
@@ -0,0 +1,10 @@
+
+set( TESTS_FILES
+  pointssimple.rijn
+  pointsdouble.rijn
+  )
+
+FOREACH( TEST_FILE ${TESTS_FILES} )
+  ADD_TEST(${TEST_FILE} ${RIJNTESTER} -c ${CMAKE_CURRENT_SOURCE_DIR}/${TEST_FILE} ${OPENGTL_TESTS_DATA}/${OPENGTL_TESTS_DATA_RESULTS_DIR}/${TEST_FILE}.png)
+ENDFOREACH( TEST_FILE )
+
diff -up OpenGTL-0.9.15.2/OpenRijn/tests/points/pointsdouble.rijn.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tests/points/pointsdouble.rijn
--- OpenGTL-0.9.15.2/OpenRijn/tests/points/pointsdouble.rijn.95a8c6853b97	2012-01-10 11:12:02.146249145 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tests/points/pointsdouble.rijn	2012-01-10 11:12:02.146249145 -0500
@@ -0,0 +1,13 @@
+sketch MySketch
+{
+  void draw(output canvas c, input palette p)
+  {
+    brush b = p.createCircleBrush(100);
+    b.paintColor = blue;
+    b.paintColor.opacity = 0.8;
+    b.drawPoint(c, float2(400,300));
+    b.paintColor = red;
+    b.paintColor.opacity = 0.8;
+    b.drawPoint(c, float2(400,300));
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/tests/points/pointssimple.rijn.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tests/points/pointssimple.rijn
--- OpenGTL-0.9.15.2/OpenRijn/tests/points/pointssimple.rijn.95a8c6853b97	2012-01-10 11:12:02.146249145 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tests/points/pointssimple.rijn	2012-01-10 11:12:02.146249145 -0500
@@ -0,0 +1,10 @@
+sketch MySketch
+{
+  void draw(output canvas c, input palette p)
+  {
+    brush b = p.createCircleBrush(100);
+    b.paintColor = black;
+    b.paintColor.opacity = 0.8;
+    b.drawPoint(c, float2(400,300));
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/tools/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tools/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenRijn/tools/CMakeLists.txt.95a8c6853b97	2012-01-10 11:12:02.146249145 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tools/CMakeLists.txt	2012-01-10 11:12:02.146249145 -0500
@@ -0,0 +1,3 @@
+add_subdirectory(compiler)
+add_subdirectory(interpreter)
+add_subdirectory(tester)
\ No newline at end of file
diff -up OpenGTL-0.9.15.2/OpenRijn/tools/compiler/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tools/compiler/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenRijn/tools/compiler/CMakeLists.txt.95a8c6853b97	2012-01-10 11:12:02.147249137 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tools/compiler/CMakeLists.txt	2012-01-10 11:12:02.146249145 -0500
@@ -0,0 +1,9 @@
+include_directories( ${CMAKE_SOURCE_DIR} )
+
+set(rijnc_SRCS
+  RijnC.cpp
+    )
+
+add_executable(rijnc ${rijnc_SRCS})
+target_link_libraries(rijnc OpenRijn )
+install( TARGETS rijnc ${INSTALL_TARGETS_DEFAULT_ARGS} )
diff -up OpenGTL-0.9.15.2/OpenRijn/tools/compiler/RijnC.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tools/compiler/RijnC.cpp
--- OpenGTL-0.9.15.2/OpenRijn/tools/compiler/RijnC.cpp.95a8c6853b97	2012-01-10 11:12:02.147249137 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tools/compiler/RijnC.cpp	2012-01-10 11:12:02.147249137 -0500
@@ -0,0 +1,132 @@
+/*
+ *  Copyright (c) 2008,2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+// C++ Headers
+#include <iostream>
+#include <fstream>
+#include <cstdlib>
+
+#include <GTLCore/CompilationMessages.h>
+#include <GTLCore/Type.h>
+
+// OpenRijn Headers
+#include <OpenRijn/Sketch.h>
+#include <OpenRijn/Version.h>
+#include <GTLFragment/LibrariesManager.h>
+#include <OpenRijn/LibrariesManager.h>
+
+void printVersion()
+{
+  std::cout << OpenRijn::LibraryShortName() << " - " << OpenRijn::LibraryName() << " - " << OpenRijn::LibraryVersionString() << std::endl;
+  std::cout << OpenRijn::LibraryCopyright() << std::endl;
+  std::cout << "Rijn Version : " << OpenRijn::LanguageVersion() << std::endl;
+}
+void printHelp()
+{
+  std::cout << "Usage : shivac [option] fileName.shiva" << std::endl;
+  std::cout << std::endl;
+  std::cout << "Options : " << std::endl;
+  std::cout << "  -S --asm-source         print the assembly source code generated" << std::endl;
+  std::cout << "  -o --output [filename]  save the output to a file" << std::endl;
+  //   std::cout << "  -L --module-dir   add a location where to find modules" << std::endl;
+  std::cout << std::endl;
+  std::cout << "  -h --help               print this message" << std::endl;
+  std::cout << "  -v --version            print the version information" << std::endl;
+}
+#define ARG_IS(a,b) argv[ai] == GTLCore::String(a) or argv[ai] == GTLCore::String(b)
+
+int main(int argc, char** argv)
+{
+  GTLCore::String fileName = "";
+  GTLCore::String output = "";
+  bool showAssembly = false;
+  for(int ai = 1; ai < argc; ai++)
+  {
+    if(ARG_IS("-h","--help"))
+    {
+      printHelp();
+      return EXIT_SUCCESS;
+    } else if(ARG_IS("-v","--version"))
+    {
+      printVersion();
+      return EXIT_SUCCESS;
+    } else if(ARG_IS("-S","--asm-source")) {
+      showAssembly = true;
+    } else if(ARG_IS("-o","--output")) {
+      if( ai == argc )
+      {
+        std::cerr << "Expected file name after -o or --output." << std::endl;
+        return EXIT_FAILURE;
+      } else {
+        ++ai;
+        output = argv[ai];
+      }
+    } else if(ARG_IS("-L", "--module-dir")) {
+      if( ai == argc )
+      {
+        std::cerr << "Expected directory after -L --module-dir." << std::endl;
+        return EXIT_FAILURE;
+      } else {
+        ++ai;
+        GTLFragment::LibrariesManager::instance()->addDirectory(argv[ai]);
+        OpenRijn::LibrariesManager::instance()->addDirectory(argv[ai]);
+      }
+    } else {
+      if( ai != argc - 1)
+      {
+        std::cerr << "Invalid command line parameters." << std::endl;
+      } else {
+        fileName = argv[ai];
+      }
+    }
+  }
+  if( fileName == "")
+  {
+    printHelp();
+  } else {
+    GTLCore::String source;
+    std::ifstream in;
+    in.open(fileName.c_str() );
+    if(not in)
+    {
+      std::cerr << "Impossible to open file " << fileName << std::endl;
+      return EXIT_FAILURE;
+    }
+    std::string str;
+    std::getline(in,str);
+    while ( in ) {
+      source += str;
+      source += "\n";
+      std::getline(in,str);
+    }
+    OpenRijn::Sketch p;
+    p.setSource( source );
+    p.compile();
+    if(not p.isCompiled())
+    {
+      std::cout << "Error: " << std::endl << p.compilationMessages().toString() << std::endl;
+      return EXIT_FAILURE;
+    }
+    if( showAssembly )
+    {
+      std::cout << p.asmSourceCode();
+    }
+  }
+  return EXIT_SUCCESS;
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/tools/interpreter/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tools/interpreter/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenRijn/tools/interpreter/CMakeLists.txt.95a8c6853b97	2012-01-10 11:12:02.147249137 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tools/interpreter/CMakeLists.txt	2012-01-10 11:12:02.147249137 -0500
@@ -0,0 +1,10 @@
+include_directories( ${CMAKE_SOURCE_DIR} )
+
+set(rijn_SRCS
+  Rijn.cpp
+    )
+
+add_executable(rijn ${rijn_SRCS})
+target_link_libraries(rijn OpenRijn GTLImageIO )
+install( TARGETS rijn ${INSTALL_TARGETS_DEFAULT_ARGS} )
+
diff -up OpenGTL-0.9.15.2/OpenRijn/tools/interpreter/Rijn.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tools/interpreter/Rijn.cpp
--- OpenGTL-0.9.15.2/OpenRijn/tools/interpreter/Rijn.cpp.95a8c6853b97	2012-01-10 11:12:02.147249137 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tools/interpreter/Rijn.cpp	2012-01-10 11:12:02.147249137 -0500
@@ -0,0 +1,182 @@
+/*
+ *  Copyright (c) 2008,2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+// C++ Headers
+#include <iostream>
+#include <fstream>
+#include <cstdlib>
+#include <cstring>
+
+// GTLCore
+#include <GTLCore/CompilationMessages.h>
+#include <GTLCore/Image.h>
+#include <GTLCore/PixelDescription.h>
+#include <GTLCore/StdTypes.h>
+#include <GTLCore/Type.h>
+
+// GTLImageIO Headers
+#include <GTLImageIO/ImageDC.h>
+#include <GTLImageIO/ImageDCRegistry.h>
+
+// GTLFragment Headers
+#include <GTLFragment/LibrariesManager.h>
+
+// OpenRijn Headers
+#include <OpenRijn/Sketch.h>
+#include <OpenRijn/Version.h>
+#include <OpenRijn/LibrariesManager.h>
+#include <OpenRijn/ImageEngine/Canvas.h>
+#include <OpenRijn/ImageEngine/Palette.h>
+
+void printVersion()
+{
+  std::cout << OpenRijn::LibraryShortName() << " - " << OpenRijn::LibraryName() << " - " << OpenRijn::LibraryVersionString() << std::endl;
+  std::cout << OpenRijn::LibraryCopyright() << std::endl;
+  std::cout << "Rijn Version : " << OpenRijn::LanguageVersion() << std::endl;
+}
+void printHelp()
+{
+  std::cout << "Usage : shivac [option] fileName.shiva" << std::endl;
+  std::cout << std::endl;
+  std::cout << "Options : " << std::endl;
+  std::cout << "  -L --module-dir   add a location where to find modules" << std::endl;
+  std::cout << "  -w --width [w]          define the width of the output" << std::endl;
+  std::cout << "  -h --height [h]         define the height of the output" << std::endl;
+  std::cout << std::endl;
+  std::cout << "  -h --help               print this message" << std::endl;
+  std::cout << "  -v --version            print the version information" << std::endl;
+}
+#define ARG_IS(a,b) argv[ai] == GTLCore::String(a) or argv[ai] == GTLCore::String(b)
+
+int main(int argc, char** argv)
+{
+  GTLCore::String fileName = "";
+  GTLCore::String outputFileName = "";
+  std::list< GTLCore::String > fileNames;
+  int width = 800;
+  int height = 600;
+  for(int ai = 1; ai < argc; ai++)
+  {
+    if(ARG_IS("-h","--help"))
+    {
+      printHelp();
+      return EXIT_SUCCESS;
+    } else if(ARG_IS("-v","--version"))
+    {
+      printVersion();
+      return EXIT_SUCCESS;
+    } else if(ARG_IS("-w", "--width")) {
+      if( ai == argc )
+      {
+        std::cerr << "Expected width after -w --width." << std::endl;
+        return EXIT_FAILURE;
+      } else {
+        ++ai;
+        width = GTLCore::String( argv[ai] ).toInt();
+      }
+    } else if(ARG_IS("-h", "--height")) {
+      if( ai == argc )
+      {
+        std::cerr << "Expected height after -h --height." << std::endl;
+        return EXIT_FAILURE;
+      } else {
+        ++ai;
+        height = GTLCore::String( argv[ai] ).toInt();
+      }
+    } else if(ARG_IS("-L", "--module-dir")) {
+      if( ai == argc )
+      {
+        std::cerr << "Expected directory after -L --module-dir." << std::endl;
+        return EXIT_FAILURE;
+      } else {
+        ++ai;
+        GTLFragment::LibrariesManager::instance()->addDirectory(argv[ai]);
+        OpenRijn::LibrariesManager::instance()->addDirectory(argv[ai]);
+      }
+    } else {
+      fileNames.push_back( argv[ai] );
+    }
+  }
+  if( fileNames.size() != 2)
+  {
+    printHelp();
+  } else {
+    fileName = *( fileNames.begin() );
+    outputFileName = *( --fileNames.end() );
+    
+    GTLCore::String source;
+    std::ifstream in;
+    in.open(fileName.c_str() );
+    if(not in)
+    {
+      std::cerr << "Impossible to open file " << fileName << std::endl;
+      return EXIT_FAILURE;
+    }
+    std::string str;
+    std::getline(in,str);
+    while ( in ) {
+      source += str;
+      source += "\n";
+      std::getline(in,str);
+    }
+    
+    // Compile
+    OpenRijn::Sketch sketch;
+    sketch.setSource( source );
+    sketch.compile();
+    if(not sketch.isCompiled())
+    {
+      std::cout << "Error: " << std::endl << sketch.compilationMessages().toString() << std::endl;
+      return EXIT_FAILURE;
+    }
+    
+    // Draw on the image
+    GTLCore::Image image(width, height, GTLCore::PixelDescription(GTLCore::Type::Float32, 4, 3));
+    std::memset(image.rawData(0,0),0, width * height * sizeof(float));
+    OpenRijn::ImageEngine::Canvas c(&image);
+    OpenRijn::ImageEngine::Palette p;
+    sketch.draw(&c, &p);
+    
+    GTLCore::Image image2(width, height, GTLCore::PixelDescription(GTLCore::Type::UnsignedInteger16, 4, 3));
+    for(int x = 0; x < width; ++x)
+    {
+      for(int y = 0; y < height; ++y)
+      {
+        for(int k = 0; k < 4; ++k)
+        {
+          image2.data<gtl_uint16>(x, y)[k] = 65535 * image.data<float>(x, y)[k];
+        }
+      }
+    }
+    // Save the image
+    const GTLImageIO::ImageDC* encoder = GTLImageIO::ImageDCRegistry::instance()->encoder( outputFileName );
+    if( not encoder )
+    {
+      std::cerr << "Can't find encoder for " << outputFileName << std::endl;
+      return EXIT_FAILURE;
+    }
+    GTLCore::String errMsg;
+    if( not encoder->encode( &image2, image2.boundingBox(), outputFileName, 0, &errMsg ) )
+    {
+      std::cerr << "Can't encode " << outputFileName << " : " << errMsg << std::endl;
+      return EXIT_FAILURE;
+    }
+  }
+  return EXIT_SUCCESS;
+}
diff -up OpenGTL-0.9.15.2/OpenRijn/tools/tester/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tools/tester/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenRijn/tools/tester/CMakeLists.txt.95a8c6853b97	2012-01-10 11:12:02.147249137 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tools/tester/CMakeLists.txt	2012-01-10 11:12:02.147249137 -0500
@@ -0,0 +1,12 @@
+include_directories( ${CMAKE_SOURCE_DIR} )
+
+set(rijntester_SRCS
+  RijnTester.cpp
+    )
+
+add_definitions( -DCOUMPONENT_NAME=\"\\\"RijnTester\\\"\" )
+
+add_executable(rijntester ${rijntester_SRCS})
+target_link_libraries(rijntester OpenRijn GTLImageIO )
+install( TARGETS rijntester ${INSTALL_TARGETS_DEFAULT_ARGS} )
+
diff -up OpenGTL-0.9.15.2/OpenRijn/tools/tester/RijnTester.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenRijn/tools/tester/RijnTester.cpp
--- OpenGTL-0.9.15.2/OpenRijn/tools/tester/RijnTester.cpp.95a8c6853b97	2012-01-10 11:12:02.147249137 -0500
+++ OpenGTL-0.9.15.2/OpenRijn/tools/tester/RijnTester.cpp	2012-01-10 11:12:02.147249137 -0500
@@ -0,0 +1,205 @@
+/*
+ *  Copyright (c) 2008,2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+// C++ Headers
+#include <iostream>
+#include <fstream>
+#include <cstdlib>
+#include <cstring>
+
+// GTLCore Headers
+#include <GTLCore/AbstractImage.h>
+#include <GTLCore/CompilationMessages.h>
+#include <GTLCore/Debug.h>
+#include <GTLCore/Image.h>
+#include <GTLCore/PixelDescription.h>
+#include <GTLCore/Region.h>
+#include <GTLCore/StdTypes.h>
+#include <GTLCore/Type.h>
+
+// GTLFragment Headers
+#include <GTLFragment/LibrariesManager.h>
+
+// OpenRijn Headers
+#include <OpenRijn/Sketch.h>
+#include <OpenRijn/Version.h>
+#include <OpenRijn/ImageEngine/Canvas.h>
+#include <OpenRijn/ImageEngine/Palette.h>
+
+// GTLImageIO Headers
+#include <GTLImageIO/ImageDC.h>
+#include <GTLImageIO/ImageDCRegistry.h>
+
+void printVersion()
+{
+  std::cout << OpenRijn::LibraryShortName() << " - " << OpenRijn::LibraryName() << " - " << OpenRijn::LibraryVersionString() << std::endl;
+  std::cout << OpenRijn::LibraryCopyright() << std::endl;
+  std::cout << "Rijn Version : " << OpenRijn::LanguageVersion() << std::endl;
+}
+void printHelp()
+{
+  std::cout << "Usage : rijntester [option] fileName.rijn" << std::endl;
+  std::cout << std::endl;
+  std::cout << "Options : " << std::endl;
+  std::cout << "  -r --run-test           run the function 'run-test'" << std::endl;
+  std::cout << "  -c --compare            compare the result of the program with a file stored on disk" << std::endl;
+//   std::cout << "  -L --module-dir   add a location where to find modules" << std::endl;
+  std::cout << std::endl;
+  std::cout << "  -h --help               print this message" << std::endl;
+  std::cout << "  -v --version            print the version information" << std::endl;
+}
+#define ARG_IS(a,b) argv[ai] == GTLCore::String(a) or argv[ai] == GTLCore::String(b)
+
+enum RijnTesterMode {
+  RTM_DEFAULT,
+  RTM_RUN_TEST,
+  RTM_COMPARE_RESULT
+};
+
+int main(int argc, char** argv)
+{
+  GTLCore::String fileName = "";
+  std::list< GTLCore::String > fileNames;
+  RijnTesterMode mode = RTM_DEFAULT;
+  for(int ai = 1; ai < argc; ai++)
+  {
+    if(ARG_IS("-h","--help"))
+    {
+      printHelp();
+      return EXIT_SUCCESS;
+    } else if(ARG_IS("-c","--compare") ) {
+      mode = RTM_COMPARE_RESULT;
+    } else if(ARG_IS("-v","--version"))
+    {
+      printVersion();
+      return EXIT_SUCCESS;
+    } else if(ARG_IS("-L", "--module-dir")) {
+      if( ai == argc )
+      {
+        std::cerr << "Expected directory after -L --module-dir." << std::endl;
+        return EXIT_FAILURE;
+      } else {
+        ++ai;
+        GTLFragment::LibrariesManager::instance()->addDirectory(argv[ai]);
+      }
+    } else {
+      fileNames.push_back( argv[ai] );
+    }
+  }
+  if( fileNames.size() > 0 )
+  {
+    fileName = *( fileNames.begin() );
+    fileNames.pop_front();
+  }
+  if( fileName == "" or (fileNames.size() < 1 and mode == RTM_COMPARE_RESULT) )
+  {
+    std::cerr << "Invalid command line parameters." << std::endl;
+    printHelp();
+  } else {
+    GTLCore::String source;
+    std::ifstream in;
+    in.open(fileName.c_str() );
+    if(not in)
+    {
+      std::cerr << "Impossible to open file " << fileName << std::endl;
+      return EXIT_FAILURE;
+    }
+    std::string str;
+    std::getline(in,str);
+    while ( in ) {
+      source += str;
+      source += "\n";
+      std::getline(in,str);
+    }
+    
+    GTLCore::String errMsg;
+    GTLCore::RegionI region;
+    GTLCore::AbstractImage* resultImage = 0;
+    if(mode == RTM_COMPARE_RESULT)
+    {
+      GTLCore::String resultFileName = *( --fileNames.end() );
+      fileNames.pop_back();
+      const GTLImageIO::ImageDC* decoder = GTLImageIO::ImageDCRegistry::instance()->decoder( resultFileName );
+      if( not decoder )
+      {
+        std::cerr << "Can't find decoder for " << resultFileName << std::endl;
+        return EXIT_FAILURE;
+      }
+      resultImage = decoder->decode( resultFileName, &region, &errMsg );
+      if(not resultImage)
+      {
+        std::cerr << "Can't open result file: " << resultFileName << std::endl;
+        return EXIT_FAILURE;
+      }
+    }
+    OpenRijn::Sketch sketch;
+    sketch.setSource( source );
+    sketch.compile();
+    if(not sketch.isCompiled())
+    {
+      std::cout << "Error: " << std::endl << sketch.compilationMessages().toString() << std::endl;
+      return EXIT_FAILURE;
+    }
+    switch( mode )
+    {
+      case RTM_COMPARE_RESULT:
+      {
+        GTL_ASSERT(resultImage);
+        int width = region.columns();
+        int height = region.rows();
+        std::cout << "Start evaluation..." << std::endl;
+        GTLCore::Image image(width, height, GTLCore::PixelDescription(GTLCore::Type::Float32, 4, 3));
+        std::memset(image.rawData(0,0),0, width * height * sizeof(float));
+        OpenRijn::ImageEngine::Canvas c(&image);
+        OpenRijn::ImageEngine::Palette p;
+        sketch.draw(&c, &p);
+        std::cout << "Start comparison..." << std::endl;
+        
+        GTLCore::Image image2(width, height, GTLCore::PixelDescription(GTLCore::Type::UnsignedInteger16, 4, 3));
+        for(int x = 0; x < width; ++x)
+        {
+          for(int y = 0; y < height; ++y)
+          {
+            for(int k = 0; k < 4; ++k)
+            {
+              image2.data<gtl_uint16>(x, y)[k] = 65535 * image.data<float>(x, y)[k];
+            }
+          }
+        }
+        int errorCount = image2.compare( resultImage, region );
+        if( errorCount != 0 )
+        {
+          std::cout << errorCount << " different pixels" << std::endl;
+          return EXIT_FAILURE;
+        }
+        break;
+      }
+      case RTM_RUN_TEST:
+      case RTM_DEFAULT:
+        if( sketch.hasTestFunction() )
+        {
+          return sketch.runTest();
+        } else {
+          std::cout << "No test function" << std::endl;
+          return EXIT_FAILURE;
+        }
+    }
+  }
+  return EXIT_SUCCESS;
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenShiva/CMakeLists.txt.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/CMakeLists.txt	2012-01-10 11:12:02.147249137 -0500
@@ -3,7 +3,7 @@ include_directories( ${CMAKE_CURRENT_SOU
 add_definitions( ${OPENGTL_BUILD_DEFINITION} )
 
 set(SHIVAC "${CMAKE_CURRENT_BINARY_DIR}/tools/compiler/shivac")
-set(SHIVAI "${CMAKE_CURRENT_BINARY_DIR}/tools/interpreter/shivai")
+set(SHIVA "${CMAKE_CURRENT_BINARY_DIR}/tools/interpreter/shiva")
 set(SHIVATESTER "${CMAKE_CURRENT_BINARY_DIR}/tools/tester/shivatester")
 
 
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/CMakeLists.txt.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/CMakeLists.txt	2012-01-10 11:12:02.147249137 -0500
@@ -4,26 +4,19 @@ include_directories( ${LLVM_INCLUDE_DIR}
 # List of files 
 set(OpenShiva_SRCS
   Kernel.cpp
+  Library.cpp
+  LibrariesManager.cpp
   Source.cpp
   SourcesCollection.cpp
   Version.cpp
 # Internal files
-  Compiler_p.cpp
-  CodeGenerator_p.cpp
-  Lexer_p.cpp
   LightParser_p.cpp
-  Parser_p.cpp
+  CodeGenerator_p.cpp
+  ColorToPixelOverloadOperatorFactory_p.cpp
   Wrapper_p.cpp
   PixelVisitor_p.cpp
   PixelConvertExpressionFactory_p.cpp
   Kernel_p.cpp
-  Library.cpp
-  LibraryCompilation_p.cpp
-  LibrariesManager.cpp
-# Metadata
-  MetadataLexer_p.cpp
-  MetadataParser_p.cpp
-  Metadata.cpp
 # Wrap
   wrappers/ImageWrap_p.cpp
   wrappers/PixelWrap_p.cpp
@@ -33,14 +26,14 @@ set(OpenShiva_SRCS
 
 # Add the OpenSHIVA library for build
 add_library(OpenShiva SHARED ${OpenShiva_SRCS})
-target_link_libraries(OpenShiva GTLCore )
+target_link_libraries(OpenShiva GTLCore GTLFragment)
 
 # __STDC_LIMIT_MACROS is needed by LLVM's DataTypes.h
 add_definitions( "-D__STDC_LIMIT_MACROS" )
 add_definitions( "-D__STDC_CONSTANT_MACROS" )
 add_definitions( -DCOUMPONENT_NAME="OpenShiva" )
 
-add_definitions( -D_OPENSHIVA_LIB_="${CMAKE_INSTALL_PREFIX}/lib/libOpenShiva.so.${OPENGTL_VERSION}")
+add_definitions( -D_OPENSHIVA_LIB_="libOpenShiva.so.${OPENGTL_VERSION}")
 add_definitions( -D_OPENSHIVA_SHIVA_STD_LIB_SRC_DIR_="${CMAKE_CURRENT_SOURCE_DIR}")
 add_definitions( -D_OPENSHIVA_SHIVA_LIBRARIES_DIR_="${SHARE_INSTALL_DIR}/shiva/libraries" )
 add_definitions( -D_OPENSHIVA_SHIVA_KERNELS_DIR_="${SHARE_INSTALL_DIR}/shiva/kernels" )
@@ -55,8 +48,6 @@ install( FILES
   Export.h
   Kernel.h
   Library.h
-  LibrariesManager.h
-  Metadata.h
   Source.h
   SourcesCollection.h
   Version.h
@@ -65,7 +56,7 @@ install( FILES
 # Create and install pc file
 configure_file("OpenShiva.pc.cmake" "${CMAKE_CURRENT_BINARY_DIR}/OpenShiva.pc" @ONLY)
 
-install(FILES ${CMAKE_CURRENT_BINARY_DIR}/OpenShiva.pc DESTINATION ${LIB_INSTALL_DIR}/pkgconfig)  
+install(FILES ${CMAKE_CURRENT_BINARY_DIR}/OpenShiva.pc DESTINATION ${LIB_INSTALL_DIR}/pkgconfig)
 
 # Install standard library
-install(FILES shivastdlib.shiva DESTINATION ${SHARE_INSTALL_DIR}/shiva/libraries )
+install(FILES shivawrappers.shiva DESTINATION ${SHARE_INSTALL_DIR}/shiva/libraries )
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/CodeGenerator_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/CodeGenerator_p.cpp
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/CodeGenerator_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/CodeGenerator_p.cpp	2012-01-10 11:12:02.148249129 -0500
@@ -57,7 +57,7 @@ int CodeGenerator::s_evaluatePixelsId =
 llvm::Function* CodeGenerator::createMemCpyFunction( llvm::Module* _module )
 {
   // TODO that stuff was copied from a llvmgcc output, can't we use memcpy intrinsinc ?
-  std::vector<const llvm::Type*> memcpyTyArgs;
+  std::vector<llvm::Type*> memcpyTyArgs;
   memcpyTyArgs.push_back(llvm::PointerType::get(llvm::Type::getInt8Ty(_module->getContext()), 0));
   memcpyTyArgs.push_back(llvm::PointerType::get(llvm::Type::getInt8Ty(_module->getContext()), 0));
   memcpyTyArgs.push_back(llvm::Type::getInt32Ty(_module->getContext()));
@@ -86,7 +86,7 @@ llvm::Value* CodeGenerator::accessPixelA
   std::vector<llvm::Value*> indexes;
   indexes.push_back( _gc.codeGenerator()->integerToConstant(_gc.llvmContext(), INT32_C(0)));
   indexes.push_back( _gc.codeGenerator()->integerToConstant(_gc.llvmContext(), gtl_int32(PixelWrap::POS_ALPHAPOS) ));
-  return llvm::GetElementPtrInst::Create( _pixel, indexes.begin(), indexes.end(), "", _currentBlock );
+  return llvm::GetElementPtrInst::Create( _pixel, indexes, "", _currentBlock );
 }
 
 llvm::Value* CodeGenerator::accessPixelDataPtr( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, llvm::Value* _pixel)
@@ -95,7 +95,16 @@ llvm::Value* CodeGenerator::accessPixelD
   std::vector<llvm::Value*> indexes;
   indexes.push_back( _gc.codeGenerator()->integerToConstant(_gc.llvmContext(), INT32_C(0)));
   indexes.push_back( _gc.codeGenerator()->integerToConstant(_gc.llvmContext(), gtl_int32(PixelWrap::POS_DATA) ));
-  return llvm::GetElementPtrInst::Create( _pixel, indexes.begin(), indexes.end(), "", _currentBlock );
+  return llvm::GetElementPtrInst::Create( _pixel, indexes, "", _currentBlock );
+}
+
+llvm::Value* CodeGenerator::accessColorConverterPtr( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, llvm::Value* _pixel)
+{
+  SHIVA_DEBUG( *_pixel );
+  std::vector<llvm::Value*> indexes;
+  indexes.push_back( _gc.codeGenerator()->integerToConstant(_gc.llvmContext(), INT32_C(0)));
+  indexes.push_back( _gc.codeGenerator()->integerToConstant(_gc.llvmContext(), gtl_int32(PixelWrap::POS_CONVERTER) ));
+  return llvm::GetElementPtrInst::Create( _pixel, indexes, "", _currentBlock );
 }
 
 llvm::Value* CodeGenerator::accessPixelDataAsU8Ptr( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, llvm::Value* _pixel)
@@ -126,13 +135,13 @@ llvm::Value* CodeGenerator::callMemcpy(
   memcpy_params.push_back( _n );
   memcpy_params.push_back( LLVMBackend::CodeGenerator::integerToConstant( _gc.llvmContext(), INT32_C(1) ) );
   llvm::CallInst* callMemCpy = llvm::CallInst::Create(
-                  func_llvm_memcpy_i32, memcpy_params.begin(), memcpy_params.end(), "", _currentBlock);
+                  func_llvm_memcpy_i32, memcpy_params, "", _currentBlock);
   callMemCpy->setCallingConv(llvm::CallingConv::C);
   callMemCpy->setTailCall( false );
   return callMemCpy;
 }
 
-llvm::BasicBlock* CodeGenerator::memToPixel( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, llvm::Value* _dataPointer, llvm::Value* _pixel, llvm::Value* _image )
+llvm::BasicBlock* CodeGenerator::memToPixel( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, llvm::Value* _dataPointer, llvm::Value* _pixel, const GTLCore::Type* _imageType, llvm::Value* _image )
 {
   // Access to the data pointer for the _pixel
   llvm::Value* _pointerToPixelVector = accessPixelDataPtr( _gc, _currentBlock, _pixel );
@@ -141,6 +150,11 @@ llvm::BasicBlock* CodeGenerator::memToPi
   arguments.push_back( _pointerToPixelVector );
   arguments.push_back( _dataPointer );
   callVirtualMember( _gc, _currentBlock, _image, ImageWrap::INDEX_MEM_TO_VEC, arguments);
+
+  llvm::Value* _pointerToColorConverter = accessColorConverterPtr( _gc, _currentBlock, _pixel );
+  
+  new llvm::StoreInst(callImageColorConverter(_gc, _currentBlock, _imageType, _image), _pointerToColorConverter, "CodeGenerator::memToPixel", _currentBlock);
+  
   
   return _currentBlock;
 }
@@ -163,7 +177,7 @@ void CodeGenerator::setPixelCoordinates(
 {
   SHIVA_DEBUG("setPixelCoordinates");
   // Create the coord vector
-  llvm::Value* result = LLVMBackend::CodeGenerator::createVector( 2, LLVMBackend::CodeGenerator::floatToConstant( _gc.llvmContext(), 0.0 ),  GTLCore::Type::Float32 );
+  llvm::Value* result = LLVMBackend::CodeGenerator::createVector( 2, LLVMBackend::CodeGenerator::floatToConstant( _gc.llvmContext(), 0.0 ) );
   SHIVA_DEBUG(*result << " " << *_iVal << " " << *_jVal);
   result = llvm::InsertElementInst::Create( result, LLVMBackend::CodeGenerator::convertValueTo( _currentBlock, _iVal, _iValType, GTLCore::Type::Float32), LLVMBackend::CodeGenerator::integerToConstant(_gc.llvmContext(), INT32_C(0)), "", _currentBlock );
   result = llvm::InsertElementInst::Create( result, LLVMBackend::CodeGenerator::convertValueTo( _currentBlock, _jVal, _jValType, GTLCore::Type::Float32), LLVMBackend::CodeGenerator::integerToConstant(_gc.llvmContext(), INT32_C(1)), "", _currentBlock );
@@ -171,7 +185,7 @@ void CodeGenerator::setPixelCoordinates(
   std::vector<llvm::Value*> indexes;
   indexes.push_back( _gc.codeGenerator()->integerToConstant(_gc.llvmContext(), INT32_C(0)));
   indexes.push_back( _gc.codeGenerator()->integerToConstant(_gc.llvmContext(), gtl_int32(PixelWrap::POS_COORD) ));
-  llvm::Value* ptr = llvm::GetElementPtrInst::Create( _pixel, indexes.begin(), indexes.end(), "", _currentBlock );
+  llvm::Value* ptr = llvm::GetElementPtrInst::Create( _pixel, indexes, "", _currentBlock );
   SHIVA_DEBUG( *_pixel << " " << *ptr << " " << *result);
   new llvm::StoreInst( result, ptr, "", _currentBlock );
 }
@@ -185,7 +199,7 @@ void CodeGenerator::setPixelAlphaPos( LL
   std::vector<llvm::Value*> indexes;
   indexes.push_back( _gc.codeGenerator()->integerToConstant(_gc.llvmContext(), INT32_C(0)));
   indexes.push_back( _gc.codeGenerator()->integerToConstant(_gc.llvmContext(), gtl_int32(PixelWrap::POS_ALPHAPOS) ));
-  llvm::Value* ptr = llvm::GetElementPtrInst::Create( _pixel, indexes.begin(), indexes.end(), "", _currentBlock );
+  llvm::Value* ptr = llvm::GetElementPtrInst::Create( _pixel, indexes, "", _currentBlock );
   
   // Store the alpha position
   new llvm::StoreInst( alphaPos, ptr, "", _currentBlock );
@@ -233,7 +247,7 @@ llvm::Function* CodeGenerator::generateE
   llvm::LLVMContext& context = moduleData->llvmModule()->getContext();
   
   // Create the function
-  std::vector<const llvm::Type*> params;
+  std::vector<llvm::Type*> params;
   params.push_back( llvm::Type::getInt32Ty(context) ); // int x
   params.push_back( llvm::Type::getInt32Ty(context) ); // int y
   params.push_back( llvm::Type::getInt32Ty(context) ); // int width
@@ -286,6 +300,11 @@ llvm::Function* CodeGenerator::generateE
   // Create the pixel
     GTLCore::VariableNG* resultVar = new GTLCore::VariableNG( _kernel->d->outputPixelType(), false, false );
     resultVar->initialise( generationContext, initialBlock, LLVMBackend::ExpressionResult(), std::list<llvm::Value*>());
+    llvm::Value* _pointerToColorConverter = accessColorConverterPtr( generationContext, initialBlock, resultVar->pointer(initialBlock) );
+  
+    new llvm::StoreInst(callImageColorConverter(generationContext, initialBlock, _kernel->d->outputImageType(), arg_result), _pointerToColorConverter, "CodeGenerator::memToPixel", initialBlock);
+  
+  
   // Get the evaluatePixel function
     const std::list<GTLCore::Function*>* ePFunctions = moduleData->function( _kernel->name(), "evaluatePixel" );
     SHIVA_ASSERT( ePFunctions );
@@ -336,7 +355,7 @@ llvm::Function* CodeGenerator::generateE
         llvm::Value* iVal_transformed = LLVMBackend::CodeGenerator::convertValueTo(firstBlockILoop,
                                                 iVal_int, GTLCore::Type::Integer32, GTLCore::Type::Float32 );
         
-        std::vector<const llvm::Type*> transfoArgs;
+        std::vector<llvm::Type*> transfoArgs;
         transfoArgs.push_back(llvm::PointerType::get(llvm::Type::getInt8Ty(context), 0));
         transfoArgs.push_back(llvm::Type::getFloatTy(context));
         transfoArgs.push_back(llvm::Type::getFloatTy(context));
@@ -354,7 +373,7 @@ llvm::Function* CodeGenerator::generateE
         transfo_params.push_back( jVal_transformed );
         transfo_params.push_back( iValBuffer );
         transfo_params.push_back( jValBuffer );
-        llvm::CallInst *CallFunc = llvm::CallInst::Create(func_transform_map, transfo_params.begin(), transfo_params.end(), "", firstBlockILoop);
+        llvm::CallInst *CallFunc = llvm::CallInst::Create(func_transform_map, transfo_params, "", firstBlockILoop);
         CallFunc->setTailCall(false);
         
         iVal_transformed = new llvm::LoadInst(iValBuffer, "", firstBlockILoop);
@@ -382,7 +401,7 @@ llvm::Function* CodeGenerator::generateE
         SHIVA_ASSERT( llvmEPFunction );
         SHIVA_DEBUG( evaluatePixel_params.size() );
         GTL_COMPARE_FUNCTION_PARAMETERS( llvmEPFunction, evaluatePixel_params );
-        llvm::CallInst::Create( llvmEPFunction, evaluatePixel_params.begin(), evaluatePixel_params.end(), "", firstBlockILoop );
+        llvm::CallInst::Create( llvmEPFunction, evaluatePixel_params, "", firstBlockILoop );
         
         // Synchronize the output pixel with input
         // Call image_wrap_data on the result to get the pointer on destination data
@@ -674,10 +693,10 @@ llvm::Value* CodeGenerator::callVirtualM
   indexes.push_back( _gc.codeGenerator()->integerToConstant( _gc.llvmContext(), gtl_int32(_member_index + STRUCT_FIRST_ELEMENT)));
   GTL_DEBUG( "Call " << _member_index << " on " << *_pointer );
   
-  llvm::Value* funcPtr = new llvm::LoadInst( llvm::GetElementPtrInst::Create( _pointer, indexes.begin(), indexes.end(), "", _currentBlock ), "" , _currentBlock);
+  llvm::Value* funcPtr = new llvm::LoadInst( llvm::GetElementPtrInst::Create( _pointer, indexes, "", _currentBlock ), "" , _currentBlock);
   GTL_DEBUG( *funcPtr );
   GTL_COMPARE_FUNCTION_PARAMETERS( funcPtr, _arguments );
-  return llvm::CallInst::Create( funcPtr, _arguments.begin(), _arguments.end(), "", _currentBlock );
+  return llvm::CallInst::Create( funcPtr, _arguments, "", _currentBlock );
 }
 
 llvm::Value* CodeGenerator::callImageWrapData( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, const GTLCore::Type* _imageType, llvm::Value* _imageWrap, llvm::Value* _x, llvm::Value* _y, bool callConst )
@@ -701,7 +720,7 @@ llvm::Value* CodeGenerator::callImageWra
   GTL_COMPARE_FUNCTION_PARAMETERS( func, image_wrap_data_params );
   
   return llvm::CallInst::Create(
-      func, image_wrap_data_params.begin(), image_wrap_data_params.end(), "", _currentBlock );
+      func, image_wrap_data_params, "", _currentBlock );
 }
 
 llvm::Value* CodeGenerator::callImageAlphaPos( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, const GTLCore::Type* _imageType, llvm::Value* _imageWrap )
@@ -715,7 +734,20 @@ llvm::Value* CodeGenerator::callImageAlp
   GTL_COMPARE_FUNCTION_PARAMETERS( func, image_wrap_data_params );
   
   return llvm::CallInst::Create(
-      func, image_wrap_data_params.begin(), image_wrap_data_params.end(), "", _currentBlock );
+      func, image_wrap_data_params, "", _currentBlock );
+}
+
+llvm::Value* CodeGenerator::callImageColorConverter( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, const GTLCore::Type* _imageType, llvm::Value* _imageWrap )
+{
+  GTL_ASSERT(_imageType);
+  std::vector<llvm::Value*> params;
+  params.push_back(_imageWrap);
+  
+  llvm::Function* func = Wrapper::image_color_converter( _gc.llvmModule(), _imageType );
+  GTL_COMPARE_FUNCTION_PARAMETERS( func, params );
+  
+  return llvm::CallInst::Create(
+      func, params, "", _currentBlock );  
 }
 
 int imageSampleNearestId = 0;
@@ -764,7 +796,7 @@ llvm::Function* CodeGenerator::generateI
   //    memToPixel( image, px, image_wrap_data(self, x, y ) );
     currentBlock = memToPixel( generationContext, currentBlock,
                                callImageWrapData( generationContext, currentBlock, _imageType, arg_self, x_i, y_i, true ),
-                               px_var, arg_self );
+                               px_var, _imageType, arg_self );
     setPixelCoordinates( generationContext, currentBlock, px_var, x_f, GTLCore::Type::Float32, y_f, GTLCore::Type::Float32 );
     setPixelAlphaPos( generationContext, currentBlock, px_var, arg_self, _imageType );
     llvm::ReturnInst::Create( context, px_var, currentBlock);
@@ -882,3 +914,35 @@ llvm::Function* CodeGenerator::generateP
     LLVMBackend::CodeGenerator::createIfStatement(firstBlock, compar, GTLCore::Type::Boolean, noAlphaPosBlock, noAlphaPosBlock, alphaPosBlock);
   return func;
 }
+
+llvm::Function* CodeGenerator::createWrapConvertColorToPixelFunction( LLVMBackend::GenerationContext& _gc, llvm::Type* _pixelType )
+{
+  std::vector<llvm::Type*> tyArgs;
+  tyArgs.push_back( GTLCore::Type::Pointer->d->type(_gc.llvmContext()) );
+  tyArgs.push_back( GTLCore::Type::Float32->d->pointerType(_gc.llvmContext()) );
+  tyArgs.push_back( _pixelType );
+  tyArgs.push_back( GTLCore::Type::Integer32->d->type(_gc.llvmContext()) );
+    
+  llvm::FunctionType* ty = llvm::FunctionType::get( llvm::Type::getVoidTy(_gc.llvmContext()), tyArgs, false);
+  
+  llvm::Function* func = (llvm::Function*)_gc.llvmModule()->getOrInsertFunction(
+      "wrapConvertColorToPixel", ty); // (external, no body)
+  func->setCallingConv(llvm::CallingConv::C);
+  return func;
+}
+
+llvm::Function* CodeGenerator::createWrapConvertPixelToColorFunction( LLVMBackend::GenerationContext& _gc, llvm::Type* _pixelType )
+{
+  std::vector<llvm::Type*> tyArgs;
+  tyArgs.push_back( GTLCore::Type::Pointer->d->type(_gc.llvmContext()) );
+  tyArgs.push_back( _pixelType );
+  tyArgs.push_back( GTLCore::Type::Float32->d->pointerType(_gc.llvmContext()) );
+  tyArgs.push_back( GTLCore::Type::Integer32->d->type(_gc.llvmContext()) );
+    
+  llvm::FunctionType* ty = llvm::FunctionType::get( llvm::Type::getVoidTy(_gc.llvmContext()), tyArgs, false);
+  
+  llvm::Function* func = (llvm::Function*)_gc.llvmModule()->getOrInsertFunction(
+      "wrapConvertPixelToColor", ty); // (external, no body)
+  func->setCallingConv(llvm::CallingConv::C);
+  return func;
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/CodeGenerator_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/CodeGenerator_p.h
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/CodeGenerator_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/CodeGenerator_p.h	2012-01-10 11:12:02.148249129 -0500
@@ -28,6 +28,7 @@ namespace llvm {
   class Function;
   class Module;
   class Value;
+  class Type;
 }
 
 namespace GTLCore {
@@ -53,9 +54,9 @@ namespace OpenShiva {
       /**
        * Copy a pixel from memory to the vector.
        */
-      static llvm::BasicBlock* memToPixel( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, llvm::Value* _dataPointer, llvm::Value* _pixel, llvm::Value* _image );
+      static llvm::BasicBlock* memToPixel( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, llvm::Value* _dataPointer, llvm::Value* _pixel, const GTLCore::Type* _imageType, llvm::Value* _image );
       static llvm::BasicBlock* pixelToMem( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, llvm::Value* _pixel, llvm::Value* _dataPointer, llvm::Value* _image, llvm::Value* channelsFlags );
-      static llvm::Function* generateEvaluatePixels( Kernel* _kernel, llvm::Module* _module, int _channels );
+      static llvm::Function* generateEvaluatePixels( OpenShiva::Kernel* _kernel, llvm::Module* _module, int _channels );
       static llvm::Function* generateMemToVec( GTLCore::ModuleData* _moduleData, llvm::Module* _module, const GTLCore::PixelDescription& _pixelDescription );
       static llvm::Function* generateVecToMem( GTLCore::ModuleData* _moduleData, llvm::Module* _module, const GTLCore::PixelDescription& _pixelDescription );
       /**
@@ -75,9 +76,16 @@ namespace OpenShiva {
        */
       static llvm::Value* accessPixelDataPtr( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, llvm::Value* _pixel);
       /**
+       * @return a pointer to the data pointer of a pixel (as a pointer to a vector of float)
+       */
+      static llvm::Value* accessColorConverterPtr( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, llvm::Value* _pixel);
+      /**
        * @return a pointer to the data pointer of a pixel cast to a (float*)
        */
       static llvm::Value* accessPixelDataAsF32Ptr( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, llvm::Value* _pixel);
+    public:
+      static llvm::Function* createWrapConvertColorToPixelFunction( LLVMBackend::GenerationContext& _gc, llvm::Type* _pixelType );
+      static llvm::Function* createWrapConvertPixelToColorFunction( LLVMBackend::GenerationContext& _gc, llvm::Type* _pixelType );
     private:
       static llvm::Value* accessPixelAlphaPos( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, llvm::Value* _pixel);
       static llvm::Function* createMemCpyFunction( llvm::Module* _module );
@@ -95,6 +103,7 @@ namespace OpenShiva {
        */
       static llvm::Value* callImageWrapData( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, const GTLCore::Type* _imageType, llvm::Value* _imageWrap, llvm::Value* _x, llvm::Value* _y, bool callConst);
       static llvm::Value* callImageAlphaPos( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, const GTLCore::Type* _imageType, llvm::Value* _imageWrap);
+      static llvm::Value* callImageColorConverter( LLVMBackend::GenerationContext& _gc, llvm::BasicBlock* _currentBlock, const GTLCore::Type* _imageType, llvm::Value* _imageWrap );
     private:
       static int s_evaluatePixelsId;
   };
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/ColorToPixelOverloadOperatorFactory_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/ColorToPixelOverloadOperatorFactory_p.cpp
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/ColorToPixelOverloadOperatorFactory_p.cpp.95a8c6853b97	2012-01-10 11:12:02.148249129 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/ColorToPixelOverloadOperatorFactory_p.cpp	2012-01-10 11:12:02.148249129 -0500
@@ -0,0 +1,107 @@
+/*
+ *  Copyright (c) 2011 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "ColorToPixelOverloadOperatorFactory_p.h"
+
+#include <GTLCore/AST/BinaryExpression.h>
+#include <GTLCore/LLVMBackend/ExpressionResult_p.h>
+#include <GTLCore/Macros_p.h>
+#include <GTLCore/Type.h>
+
+#include "Debug.h"
+#include "CodeGenerator_p.h"
+#include <GTLFragment/wrappers/ColorWrap_p.h>
+#include <GTLCore/Type_p.h>
+#include <llvm/Value.h>
+#include <llvm/DerivedTypes.h>
+#include <llvm/CallingConv.h>
+#include <llvm/Module.h>
+#include <GTLCore/LLVMBackend/ExpressionGenerationContext_p.h>
+#include <GTLCore/LLVMBackend/CodeGenerator_p.h>
+#include <llvm/Instructions.h>
+#include <GTLCore/TypesManager.h>
+
+using namespace OpenShiva;
+
+class ColorToPixelOverloadOperator : public GTLCore::AST::BinaryExpression {
+public:
+  ColorToPixelOverloadOperator(Expression* lhs, Expression* rhs);
+  virtual LLVMBackend::ExpressionResult generateValue( LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc ) const;
+  virtual GTLCore::AST::ExpressionResultSP generateValue( GTLCore::AST::GenerationVisitor* _generationVisitor) const;
+};
+
+ColorToPixelOverloadOperator::ColorToPixelOverloadOperator(Expression* lhs, Expression* rhs) : BinaryExpression(lhs, rhs)
+{
+}
+
+LLVMBackend::ExpressionResult ColorToPixelOverloadOperator::generateValue( LLVMBackend::GenerationContext& _gc, LLVMBackend::ExpressionGenerationContext& _egc ) const
+{
+  llvm::Value* pixelPtr = leftHandSide()->generateValue( _gc, _egc).value();
+  llvm::Value* pixelDataPtr = OpenShiva::CodeGenerator::accessPixelDataPtr( _gc, _egc.currentBasicBlock(), pixelPtr);
+  llvm::Value* converterDataPtr = OpenShiva::CodeGenerator::accessColorConverterPtr( _gc, _egc.currentBasicBlock(), pixelPtr);
+  
+  llvm::Value* color = rightHandSide()->generateValue( _gc, _egc).value();
+
+  std::vector<llvm::Value*> indexes;
+  indexes.push_back( _gc.codeGenerator()->integerToConstant(_gc.llvmContext(), INT32_C(0)));
+  indexes.push_back( _gc.codeGenerator()->integerToConstant(_gc.llvmContext(), gtl_int32(ColorWrap::POS_RED) ));
+  llvm::Value* colorPtr = llvm::GetElementPtrInst::Create( color, indexes, "", _egc.currentBasicBlock() );
+
+  //Parameters are AbstractColorConverter*, ptrToColor, ptrTopixeldata, number of channels
+  std::vector<llvm::Value*> parameters;
+  parameters.push_back( new llvm::LoadInst( converterDataPtr, "ColorToPixelOverloadOperator::generateValue", _egc.currentBasicBlock() ));
+  parameters.push_back(colorPtr);
+  parameters.push_back(pixelDataPtr);
+  parameters.push_back(LLVMBackend::CodeGenerator::integerToConstant( _gc.llvmContext(), llvm::cast<llvm::VectorType>(pixelDataPtr->getType()->getContainedType(0))->getNumElements() ) );
+
+  llvm::Function* func = CodeGenerator::createWrapConvertColorToPixelFunction(_gc, pixelDataPtr->getType());
+  GTL_COMPARE_FUNCTION_PARAMETERS( func, parameters );
+  
+  llvm::CallInst *CallFunc = llvm::CallInst::Create(func, parameters, "", _egc.currentBasicBlock());
+  CallFunc->setTailCall(false);
+  
+  return LLVMBackend::ExpressionResult(pixelPtr, leftHandSide()->type());
+}
+
+GTLCore::AST::ExpressionResultSP ColorToPixelOverloadOperator::generateValue( GTLCore::AST::GenerationVisitor* _generationVisitor) const
+{
+  GTL_ABORT("Unimplemented");
+  return 0;
+}
+
+ColorToPixelOverloadOperatorFactory::ColorToPixelOverloadOperatorFactory()
+{
+}
+
+ColorToPixelOverloadOperatorFactory::~ColorToPixelOverloadOperatorFactory()
+{
+}
+
+GTLCore::AST::BinaryExpression* ColorToPixelOverloadOperatorFactory::create( GTLCore::AST::Expression* value1, GTLCore::AST::Expression* value2, GTLCore::Operator::Type type ) const
+{
+  GTL_ASSERT(canOverload(value1->type(), value2->type(), type) );
+  
+  return new ColorToPixelOverloadOperator(value1, value2);
+}
+
+bool ColorToPixelOverloadOperatorFactory::canOverload( const GTLCore::Type* srcType, const GTLCore::Type* dstType, GTLCore::Operator::Type type ) const
+{
+  return (srcType->dataType() == GTLCore::Type::STRUCTURE and srcType->structName().startWith( "pixel" ) and
+          dstType->dataType() == GTLCore::Type::STRUCTURE and dstType->structName().startWith( "color" ) );
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/ColorToPixelOverloadOperatorFactory_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/ColorToPixelOverloadOperatorFactory_p.h
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/ColorToPixelOverloadOperatorFactory_p.h.95a8c6853b97	2012-01-10 11:12:02.148249129 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/ColorToPixelOverloadOperatorFactory_p.h	2012-01-10 11:12:02.148249129 -0500
@@ -0,0 +1,31 @@
+/*
+ *  Copyright (c) 2011 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include <GTLCore/OperatorOverloadCenter_p.h>
+
+namespace OpenShiva {
+  class ColorToPixelOverloadOperatorFactory : public GTLCore::OperatorOverloadExpressionFactory
+  {
+  public:
+    ColorToPixelOverloadOperatorFactory();
+    virtual ~ColorToPixelOverloadOperatorFactory();
+    virtual GTLCore::AST::BinaryExpression* create( GTLCore::AST::Expression* value1, GTLCore::AST::Expression* value2, GTLCore::Operator::Type type ) const ;
+    virtual bool canOverload( const GTLCore::Type* srcType, const GTLCore::Type* dstType, GTLCore::Operator::Type type ) const;
+  };
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva.doxy.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva.doxy
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva.doxy.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva.doxy	2012-01-10 11:12:02.153249085 -0500
@@ -1,6 +1,6 @@
 /**
  * @addtogroup OpenShiva OpenShiva Library
- * @version 0.9.15
+ * @version 0.9.16
  * @author Cyrille Berger
  * 
- */
\ No newline at end of file
+ */
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Kernel.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Kernel.cpp
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Kernel.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Kernel.cpp	2012-01-10 11:12:02.148249129 -0500
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *  Copyright (c) 2008,2009,2010 Cyrille Berger <cberger@cberger.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -33,25 +33,28 @@
 #include "GTLCore/Type.h"
 #include "GTLCore/TypesManager.h"
 #include "GTLCore/Value.h"
+#include "GTLCore/Value_p.h"
 #include "GTLCore/VirtualMachine_p.h"
 #include "GTLCore/wrappers/Allocate.h"
 
+#include "GTLFragment/Library_p.h"
+
 #include "Debug.h"
-#include "Compiler_p.h"
 #include "Library_p.h"
 
 #include "Kernel_p.h"
 #include "Wrapper_p.h"
 #include "wrappers/ImageWrap_p.h"
 #include "wrappers/RegionWrap_p.h"
+#include <GTLCore/AST/Tree.h>
+#include <llvm/DerivedTypes.h>
 
 using namespace OpenShiva;
 
-Kernel::Kernel(int _channelsNb ) : Library( true, _channelsNb), d(new KernelPrivate )
+Kernel::Kernel(int _channelsNb ) : Library( GTLFragment::Library::SHIVA_KERNEL, _channelsNb), d(new KernelPrivate )
 {
   d->self = this;
   d->evaluatePixelsFunction = 0;
-  d->wrapper = 0;
   Library::d->libraryCompilation = d;
 }
 
@@ -64,21 +67,22 @@ Kernel::~Kernel()
 
 void Kernel::evaluatePixels( const GTLCore::RegionI& _region, const std::list< const GTLCore::AbstractImage* >& _inputImages, GTLCore::AbstractImage* _outputImage, GTLCore::ProgressReport* report, const GTLCore::Transform& transfo, const GTLCore::ChannelsFlags& flags) const
 {
+  d->runEvaluateDependentsIfNeeded();
   SHIVA_DEBUG( _region.x() << " " << _region.y() << " " << _region.columns() << " " << _region.rows());
   SHIVA_ASSERT( d->evaluatePixelsFunction );
   
   // Wrap input images
-  SHIVA_ASSERT( d->wrapper );
+  SHIVA_ASSERT( Library::d->m_wrapper );
   const void** inputImages = new const void*[ _inputImages.size() ];
   int i = 0;
   for( std::list< const GTLCore::AbstractImage* >::const_iterator it = _inputImages.begin();
        it != _inputImages.end(); ++it)
   {
-    inputImages[i] = (const void*)d->wrapper->wrapImage( const_cast<GTLCore::AbstractImage*>( *it ) ); // TODO no const_cast
+    inputImages[i] = (const void*)Library::d->m_wrapper->wrapImage( const_cast<GTLCore::AbstractImage*>( *it ) ); // TODO no const_cast
   }
   
   // Wrap output image
-  ImageWrap* owrap = d->wrapper->wrapImage( _outputImage );
+  ImageWrap* owrap = Library::d->m_wrapper->wrapImage( _outputImage );
   
   // Call function
   SHIVA_DEBUG("Call function");
@@ -98,8 +102,9 @@ void Kernel::evaluatePixels( const GTLCo
 
 int Kernel::runTest() const
 {
+  d->runEvaluateDependentsIfNeeded();
   SHIVA_ASSERT( isCompiled() );
-  const std::list<GTLCore::Function*>* fs = Library::d->m_moduleData->function( name(), "runTest");
+  const std::list<GTLCore::Function*>* fs = GTLFragment::Library::d->m_moduleData->function( name(), "runTest");
   SHIVA_ASSERT( fs );
   GTLCore::Function* f = fs->front();
   GTLCore::Value v = f->call( std::vector< GTLCore::Value >() );
@@ -108,12 +113,13 @@ int Kernel::runTest() const
 
 bool Kernel::hasTestFunction() const
 {
-  return Library::d->m_moduleData->function( name(), "runTest");
+  return GTLFragment::Library::d->m_moduleData->function( name(), "runTest");
 }
 
 GTLCore::RegionF Kernel::needed( GTLCore::RegionI output_region, int input_index, const std::list< GTLCore::RegionI>& input_DOD, const GTLCore::Transform& transfo)
 {
-  const std::list<GTLCore::Function*>* neededFunctions = Library::d->m_moduleData->function( name(),"needed");
+  d->runEvaluateDependentsIfNeeded();
+  const std::list<GTLCore::Function*>* neededFunctions = GTLFragment::Library::d->m_moduleData->function( name(),"needed");
   GTL_ASSERT( neededFunctions );
   GTLCore::Function* neededFunction = neededFunctions->front();
   RegionWrap* (*func)( RegionWrap*, int, ArrayWrap* ) = ( RegionWrap* (*)( RegionWrap*, int, ArrayWrap* ) )GTLCore::VirtualMachine::instance()->getPointerToFunction( neededFunction);
@@ -126,12 +132,14 @@ GTLCore::RegionF Kernel::needed( GTLCore
 
 bool Kernel::hasNeededFunction() const
 {
-  return Library::d->m_moduleData->function( name(), "needed");
+  return GTLFragment::Library::d->m_moduleData->function( name(), "needed");
 }
 
 GTLCore::RegionF Kernel::changed( GTLCore::RegionI changed_input_region, int input_index, const std::list< GTLCore::RegionI>& input_DOD, const GTLCore::Transform& transfo)
 {
-  const std::list<GTLCore::Function*>* changedFunctions = Library::d->m_moduleData->function( name(), "changed");
+  TEST_GUARD_READ(GTLFragment::Library::d)
+  d->runEvaluateDependentsIfNeeded();
+  const std::list<GTLCore::Function*>* changedFunctions = GTLFragment::Library::d->m_moduleData->function( name(), "changed");
   GTL_ASSERT(changedFunctions);
   GTLCore::Function* changedFunction = changedFunctions->front();
   RegionWrap* (*func)( RegionWrap*, int, ArrayWrap* ) = ( RegionWrap* (*)( RegionWrap*, int, ArrayWrap* ) )GTLCore::VirtualMachine::instance()->getPointerToFunction( changedFunction);
@@ -146,12 +154,15 @@ GTLCore::RegionF Kernel::changed( GTLCor
 
 bool Kernel::hasChangedFunction() const
 {
-  return Library::d->m_moduleData->function( name(), "changed");
+  TEST_GUARD_READ(GTLFragment::Library::d)
+  return GTLFragment::Library::d->m_moduleData->function( name(), "changed");
 }
 
 GTLCore::RegionF Kernel::generated(const GTLCore::Transform& transfo)
 {
-  const std::list<GTLCore::Function*>*  fs = Library::d->m_moduleData->function( name(), "generated");
+  TEST_GUARD_READ(GTLFragment::Library::d)
+  d->runEvaluateDependentsIfNeeded();
+  const std::list<GTLCore::Function*>*  fs = GTLFragment::Library::d->m_moduleData->function( name(), "generated");
   SHIVA_ASSERT( fs );
   GTLCore::Function* f = fs->front();
 
@@ -165,7 +176,7 @@ GTLCore::RegionF Kernel::generated(const
 
 bool Kernel::hasGeneratedFunction() const
 {
-  return Library::d->m_moduleData->function( name(), "generated");
+  return GTLFragment::Library::d->m_moduleData->function( name(), "generated");
 }
 
 void Kernel::setParameter( StandardParameter _hint, const GTLCore::Value& _value)
@@ -187,10 +198,39 @@ void Kernel::setParameter( StandardParam
   }
 }
 
+
 void Kernel::setParameter( const GTLCore::String& _name, const GTLCore::Value& _value )
 {
+  std::map< GTLCore::String, int >::iterator it = GTLFragment::Library::d->parameters_name2id.find(_name);
+  if(it == GTLFragment::Library::d->parameters_name2id.end())
+  {
+    setParameter(GTLFragment::Library::d->createParameter(_name, _value), _value);
+  } else {
+    setParameter(it->second, _value);
+  }
+}
+
+void Kernel::setParameter( std::size_t _id, const GTLCore::Value& _value)
+{
+  TEST_GUARD_WRITE(GTLFragment::Library::d)
   GTL_ASSERT(_value.isValid());
-  Library::d->parameters[ _name ] = _value;
+  GTLFragment::ParameterInfo& pi = GTLFragment::Library::d->parameters_info[ _id ];
+  pi.value = _value;
+  if(isCompiled())
+  {
+    GTLCore::String symbol = GTLCore::AST::GlobalConstantDeclaration::nameToSymbol(GTLCore::ScopedName(name(), pi.name));
+    llvm::GlobalVariable* variable = d->moduleData()->llvmLinkedModule()->getGlobalVariable((std::string)symbol);
+    GTL_ASSERT(variable);
+    void* ptr = GTLCore::VirtualMachine::instance()->getGlobalVariablePointer(variable);
+    GTL_ASSERT(ptr);
+    GTLCore::copyValueToPtr(_value, variable->getType()->getElementType(), d->moduleData()->llvmModule()->getContext(), ptr);
+    d->needRunEvealuateDependents = true;
+  }
+}
+
+std::size_t Kernel::parameterId( const GTLCore::String& _name )
+{
+  return GTLFragment::Library::d->parameters_name2id[_name];
 }
 
 void Kernel::setParameters( const std::map< GTLCore::String, GTLCore::Value>&  _values )
@@ -198,6 +238,6 @@ void Kernel::setParameters( const std::m
   for( std::map< GTLCore::String, GTLCore::Value>::const_iterator it = _values.begin();
        it != _values.end(); ++it)
   {
-    Library::d->parameters[ it->first ] = it->second;
+    setParameter(it->first, it->second);
   }
 }
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Kernel.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Kernel.h
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Kernel.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Kernel.h	2012-01-10 11:12:02.149249120 -0500
@@ -82,6 +82,14 @@ namespace OpenShiva {
        */
       void setParameter( const GTLCore::String& _name, const GTLCore::Value& );
       /**
+       * Set a given parameter to a given value
+       */
+      void setParameter( size_t _id, const GTLCore::Value& _value );
+      /**
+       * @return the id of a parameter
+       */
+      std::size_t parameterId( const GTLCore::String& _name );
+      /**
        * Set a list of parameters
        */
       void setParameters( const std::map< GTLCore::String, GTLCore::Value>&  );
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Kernel_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Kernel_p.cpp
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Kernel_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Kernel_p.cpp	2012-01-10 11:12:02.149249120 -0500
@@ -28,6 +28,10 @@
 #include "GTLCore/TypesManager.h"
 #include "GTLCore/VirtualMachine_p.h"
 
+#include "GTLCore/AST/Tree.h"
+
+#include "GTLFragment/Library_p.h"
+
 #include "Debug.h"
 
 #include "CodeGenerator_p.h"
@@ -42,22 +46,21 @@ KernelPrivate::KernelPrivate()
 
 KernelPrivate::~KernelPrivate()
 {
-  delete wrapper;
 }
 
 void KernelPrivate::preCompilation()
 {
-  if (self->Library::d->parameters.find("IMAGE_WIDTH") == self->Library::d->parameters.end())
+  if (self->GTLFragment::Library::d->parameters_name2id.find("IMAGE_WIDTH") == self->GTLFragment::Library::d->parameters_name2id.end())
   {
     self->setParameter( Kernel::IMAGE_WIDTH, 800.0f );
   }
-  if (self->Library::d->parameters.find("IMAGE_HEIGHT") == self->Library::d->parameters.end())
+  if (self->GTLFragment::Library::d->parameters_name2id.find("IMAGE_HEIGHT") == self->GTLFragment::Library::d->parameters_name2id.end())
   {
     self->setParameter( Kernel::IMAGE_HEIGHT, 600.0f );
   }
   std::vector<GTLCore::Value> values;
-  values.push_back( self->Library::d->parameters["IMAGE_WIDTH"]);
-  values.push_back( self->Library::d->parameters["IMAGE_HEIGHT"]);
+  values.push_back( self->GTLFragment::Library::d->parameters_info[ self->parameterId("IMAGE_WIDTH")].value);
+  values.push_back( self->GTLFragment::Library::d->parameters_info[ self->parameterId("IMAGE_HEIGHT")].value);
   self->setParameter( "IMAGE_SIZE", GTLCore::Value(values, GTLCore::TypesManager::getVector(GTLCore::Type::Float32, 2) ) );
 }
 
@@ -68,13 +71,37 @@ void KernelPrivate::cleanup()
 
 void KernelPrivate::postCompilation()
 {
+  std::list<GTLCore::String> keepVisible;
+  
+  // Functions
+  keepVisible.push_back("evaluateDependents");
+  keepVisible.push_back("evaluatePixels");
+  keepVisible.push_back("runTest");
+  keepVisible.push_back("changed");
+  keepVisible.push_back("needed");
+  keepVisible.push_back("generated");
+  
+  // Parmeters
+  foreach(const GTLFragment::ParameterInfo& pi, self->GTLFragment::Library::d->parameters_info)
+  {
+    GTLCore::String symbol = GTLCore::AST::GlobalConstantDeclaration::nameToSymbol(GTLCore::ScopedName(self->name(), pi.name));
+    keepVisible.push_back(symbol);
+  }
+  self->GTLFragment::Library::d->m_moduleData->hideAllSymbolsBut(keepVisible);
+  
   // Create a wrapper
-  wrapper = new Wrapper(self, self->Library::d->m_moduleData, self->Library::d->m_llvmModule);
   determineTypes();
   // Create the generateEvaluatePixels LLVM function
-  evaluatePixelsFunction = CodeGenerator::generateEvaluatePixels( self, self->Library::d->m_llvmModule, self->Library::d->count_channels_generic );
+  evaluatePixelsFunction = CodeGenerator::generateEvaluatePixels( self, self->GTLFragment::Library::d->m_moduleData->llvmLinkedModule(), self->GTLFragment::Library::d->count_channels_generic );
+  needRunEvealuateDependents = true;
+  runEvaluateDependentsIfNeeded();
+}
+
+void KernelPrivate::runEvaluateDependentsIfNeeded()
+{
+  if(not needRunEvealuateDependents) return;
   // Call evaluateDepends as needed
-  const std::list<GTLCore::Function*>* evaluateDependentsFuncs = self->Library::d->m_moduleData->function( self->name(), "evaluateDependents");
+  const std::list<GTLCore::Function*>* evaluateDependentsFuncs = self->GTLFragment::Library::d->m_moduleData->function( self->name(), "evaluateDependents");
   if( evaluateDependentsFuncs )
   {
     GTLCore::Function* evaluateDependentsFunc = evaluateDependentsFuncs->front();
@@ -85,13 +112,13 @@ void KernelPrivate::postCompilation()
 
 GTLCore::ModuleData* KernelPrivate::moduleData()
 {
-  return self->Library::d->m_moduleData;
+  return self->GTLFragment::Library::d->m_moduleData;
 }
 
 void KernelPrivate::determineTypes()
 {
   m_inputsTypes.clear();
-  const std::list<GTLCore::Function*>*  ePFunctions = self->Library::d->m_moduleData->function( self->name(), "evaluatePixel" );
+  const std::list<GTLCore::Function*>*  ePFunctions = self->GTLFragment::Library::d->m_moduleData->function( self->name(), "evaluatePixel" );
   GTL_ASSERT(ePFunctions);
   GTLCore::Function* ePFunction = ePFunctions->front();
   bool hasOutput = false;
@@ -106,9 +133,9 @@ void KernelPrivate::determineTypes()
       SHIVA_ASSERT( m_outputPixelType->structName().head( 5 ) == "pixel" );
       if(  m_outputPixelType->structName() == "pixel" )
       {
-        m_outputImageType = self->Library::d->m_moduleData->typesManager()->getStructure( "image" );
+        m_outputImageType = self->GTLFragment::Library::d->m_moduleData->typesManager()->getStructure( "image" );
       } else {
-        m_outputImageType = self->Library::d->m_moduleData->typesManager()->getStructure( "image" + m_outputPixelType->structName().tail(1) );
+        m_outputImageType = self->GTLFragment::Library::d->m_moduleData->typesManager()->getStructure( "image" + m_outputPixelType->structName().tail(1) );
       }
       GTL_ASSERT( m_outputImageType );
     } else {
@@ -134,3 +161,18 @@ const GTLCore::Type* KernelPrivate::outp
 {
   return m_outputImageType;
 }
+
+void KernelPrivate::createWrapper(GTLCore::ModuleData* _moduleData, llvm::Module* module, int _channels, GTLFragment::WhichStdLibrary _library)
+{
+  self->Library::d->m_wrapper = new Wrapper(self, _moduleData, module, _channels, _library != GTLFragment::ShivaWrappersLibrary);
+}
+
+GTLFragment::Wrapper* KernelPrivate::wrapper()
+{
+  GTL_ABORT("should not happen");
+}
+
+void KernelPrivate::addOperatorOverloads(GTLCore::OperatorOverloadCenter* _center)
+{
+  GTL_ABORT("should not happen");
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Kernel_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Kernel_p.h
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Kernel_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Kernel_p.h	2012-01-10 11:12:02.149249120 -0500
@@ -25,7 +25,7 @@
 #include "GTLCore/Value.h"
 
 #include <list>
-#include "LibraryCompilation_p.h"
+#include "GTLFragment/LibraryCompilation_p.h"
 
 namespace llvm {
   class Function;
@@ -43,7 +43,7 @@ namespace OpenShiva {
    *
    * Internal data of @ref Kernel
    */
-  class KernelPrivate : public LibraryCompilation {
+  class KernelPrivate : public GTLFragment::LibraryCompilation {
     friend class Kernel;
       KernelPrivate();
       virtual ~KernelPrivate();
@@ -51,6 +51,9 @@ namespace OpenShiva {
       virtual void preCompilation();
       virtual void cleanup();
       virtual void postCompilation();
+      virtual void createWrapper(GTLCore::ModuleData* _moduleData, llvm::Module* module, int _channels, GTLFragment::WhichStdLibrary _library);
+      virtual GTLFragment::Wrapper* wrapper();
+      virtual void addOperatorOverloads(GTLCore::OperatorOverloadCenter* _center);
     public:
       const std::list< const GTLCore::Type* >& inputsTypes();
       const GTLCore::Type* outputPixelType();
@@ -61,9 +64,10 @@ namespace OpenShiva {
        * Determines output and input types.
        */
       void determineTypes();
+      void runEvaluateDependentsIfNeeded();
+      bool needRunEvealuateDependents;
       Kernel* self;
       llvm::Function* evaluatePixelsFunction;
-      Wrapper* wrapper;
       std::list< const GTLCore::Type* > m_inputsTypes;
       const GTLCore::Type* m_outputPixelType;
       const GTLCore::Type* m_outputImageType;
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/LibrariesManager.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/LibrariesManager.cpp
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/LibrariesManager.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/LibrariesManager.cpp	2012-01-10 11:12:02.149249120 -0500
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *  Copyright (c) 2008, 2010 Cyrille Berger <cberger@cberger.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -22,22 +22,27 @@
 #include <map>
 
 // LLVM
+#include <llvm/Support/MutexGuard.h>
 #ifdef LLVM_27_OR_28
+#include <llvm/System/Mutex.h>
 #include <llvm/System/Path.h>
 #else
+#include <llvm/Support/Mutex.h>
 #include <llvm/Support/Path.h>
 #endif
 
-#include "Debug.h"
+#include "GTLCore/Debug.h"
 #include "Library.h"
 
 #include <GTLCore/Macros_p.h>
+#include <GTLFragment/LibrariesManager.h>
 
 using namespace OpenShiva;
 
 struct LibrariesManager::Private {
   std::map<GTLCore::String, Library*> libraries;
   std::list<GTLCore::String> directories;
+  llvm::sys::Mutex mutex;
 };
 
 STATIC_POINTER(LibrariesManager, s_instance);
@@ -47,6 +52,7 @@ LibrariesManager::LibrariesManager() : d
   addDirectory( "." );
   addDirectory( _OPENSHIVA_SHIVA_STD_LIB_SRC_DIR_ );
   addDirectory( _OPENSHIVA_SHIVA_LIBRARIES_DIR_ );
+  GTLFragment::LibrariesManager::instance()->registerLibrariesManager(this);
 }
 
 LibrariesManager::~LibrariesManager()
@@ -64,7 +70,7 @@ void LibrariesManager::addDirectory(cons
   d->directories.push_back( directory );
 }
 
-Library* LibrariesManager::library(const GTLCore::String& name, int _channelsNb)
+GTLFragment::Library* LibrariesManager::library(const GTLCore::String& name, int _channelsNb)
 {
   std::map<GTLCore::String, Library*>::iterator it = d->libraries.find(name);
   if( it == d->libraries.end())
@@ -75,9 +81,10 @@ Library* LibrariesManager::library(const
 }
 
 
-Library* LibrariesManager::loadLibrary( const GTLCore::String& name, int _channelsNb)
+GTLFragment::Library* LibrariesManager::loadLibrary( const GTLCore::String& name, int _channelsNb)
 {
-  Library* l = library( name, _channelsNb );
+  llvm::MutexGuard mg(d->mutex);
+  GTLFragment::Library* l = library( name, _channelsNb );
   if(not l )
   {
     GTLCore::String sourceName = name + ".shiva";
@@ -86,12 +93,13 @@ Library* LibrariesManager::loadLibrary(
     {
       llvm::sys::Path path( (const std::string&)*it );
       path.appendComponent( (const std::string&)sourceName);
-      SHIVA_DEBUG("try " << path.c_str() );
+      GTL_DEBUG("try " << path.c_str() );
       if(path.exists() and path.canRead())
       {
-        l = new Library( false, _channelsNb );
-        registerLibrary( name, l );
-        l->loadFromFile( path.c_str());
+        Library* osl = new Library( Library::SHIVA_LIBRARY, _channelsNb );
+        registerLibrary( name, osl );
+        osl->loadFromFile( path.c_str());
+        l = osl;
         break;
       }
     }
@@ -101,6 +109,7 @@ Library* LibrariesManager::loadLibrary(
 
 void LibrariesManager::registerLibrary(const GTLCore::String& name, Library* l)
 {
+  llvm::MutexGuard mg(d->mutex);
   d->libraries[ name ] = l;
 }
 
@@ -112,3 +121,8 @@ LibrariesManager* LibrariesManager::inst
   }
   return s_instance;
 }
+
+Library::Type LibrariesManager::libraryType() const
+{
+  return Library::SHIVA_LIBRARY;
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/LibrariesManager.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/LibrariesManager.h
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/LibrariesManager.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/LibrariesManager.h	2012-01-10 11:12:02.149249120 -0500
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *  Copyright (c) 2008, 2010 Cyrille Berger <cberger@cberger.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -22,6 +22,7 @@
 
 #include <GTLCore/String.h>
 #include <OpenShiva/Export.h>
+#include <GTLFragment/AbstractLibrariesManager.h>
 
 namespace {
   class StaticPointerLibrariesManager;
@@ -34,7 +35,7 @@ namespace OpenShiva {
    *
    * Manage the different @ref Library that are used by the kernels.
    */
-  class OPENSHIVA_EXPORT LibrariesManager {
+  class OPENSHIVA_EXPORT LibrariesManager : public GTLFragment::AbstractLibrariesManager {
       friend class ::StaticPointerLibrariesManager;
     private:
       LibrariesManager();
@@ -44,16 +45,18 @@ namespace OpenShiva {
       /**
        * @return a library if it's already loaded or return 0
        */
-      Library* library(const GTLCore::String& name, int _channelsNb);
+      GTLFragment::Library* library(const GTLCore::String& name, int _channelsNb);
       /**
        * Add a directory to the list of directory that get searched for library.
+       * This function is not thread-safe.
        */
       void addDirectory(const GTLCore::String& directory);
       void registerLibrary(const GTLCore::String& name, Library* );
       /**
        * Load a library with the given name.
        */
-      Library* loadLibrary( const GTLCore::String& filename, int _channelsNb);
+      GTLFragment::Library* loadLibrary( const GTLCore::String& filename, int _channelsNb);
+      virtual GTLFragment::Library::Type libraryType() const;
     public:
       /**
        * @return the instance to the singleton \ref LibraryManager
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Library.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Library.cpp
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Library.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Library.cpp	2012-01-10 11:12:02.150249111 -0500
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -17,208 +17,26 @@
  * Boston, MA 02110-1301, USA.
  */
 
-#include "Library.h"
 #include "Library_p.h"
 
-#include <sstream>
+#include <GTLCore/Debug.h>
+#include <GTLFragment/Library_p.h>
 
-#include <llvm/Module.h>
-#ifdef LLVM_27_OR_28
-#include <llvm/System/DynamicLibrary.h>
-#else
-#include <llvm/Support/DynamicLibrary.h>
-#endif
-#include <llvm/LLVMContext.h>
-
-#include "GTLCore/CompilationMessage.h"
-#include "GTLCore/Function.h"
-#include "GTLCore/ModuleData_p.h"
-#include "GTLCore/PixelDescription.h"
-#include "GTLCore/Region.h"
-#include "GTLCore/Type.h"
-#include "GTLCore/Macros_p.h"
-#include "GTLCore/TypesManager.h"
-#include "GTLCore/Value.h"
-#include "GTLCore/VirtualMachine_p.h"
-#include "GTLCore/wrappers/Allocate.h"
-#include "GTLCore/Metadata/Group.h"
-#include "GTLCore/Metadata/ParameterEntry.h"
-#include "Metadata.h"
-#include "GTLCore/Metadata/Factory_p.h"
-
-#include "Debug.h"
-#include "CodeGenerator_p.h"
-#include "Compiler_p.h"
-#include "Wrapper_p.h"
-#include "wrappers/ImageWrap_p.h"
-#include "wrappers/RegionWrap_p.h"
-
-
-#include "Kernel_p.h"
-#include "LibraryCompilation_p.h"
+#include "LibrariesManager.h"
 
 using namespace OpenShiva;
 
-void Library::Private::metadataToParameters( const GTLCore::Metadata::Group* group)
-{
-  SHIVA_ASSERT( group );
-  foreach( const GTLCore::Metadata::Entry* entry, group->entries() )
-  {
-    if( const GTLCore::Metadata::ParameterEntry* pe = entry->asParameterEntry() )
-    {
-      parameters[ pe->name() ] = pe->defaultValue();
-    } else if( const GTLCore::Metadata::Group* ge = entry->asGroup() )
-    {
-      metadataToParameters( ge );
-    }
-  }
-}
-
-void Library::Private::initparameters()
-{
-  const Metadata* metadata = source.metadata();
-  parameters.clear();
-  if( metadata and metadata->parameters() )
-  {
-    metadataToParameters( metadata->parameters() );
-  }
-}
-
-// -------- Library -------- //
-
-Library::Library( bool _isKernel , int _channelsNb) : d(new Private)
+Library::Library(GTLFragment::Library::Type _type, int _channelsNb) : GTLFragment::Library(_type, _channelsNb), d(new Private)
 {
   GTL_ASSERT(_channelsNb > 0);
-  d->name = "";
-  d->compiled = false;
-  d->m_llvmModule = 0;
-  d->m_moduleData = 0;
-  d->count_channels_generic = _channelsNb;
-  d->isKernel = _isKernel;
-  d->isStandardLibrary = false;
+  LibrariesManager::instance(); // This make sure the libraries manager is created whne compiling libraries
+  GTLFragment::Library::d->libraryCompilation = d;
+
 }
 
 Library::~Library()
 {
   cleanup();
+  GTLFragment::Library::d->libraryCompilation = 0;
   delete d;
 }
-
-void Library::cleanup()
-{
-  if(d->m_moduleData and d->m_moduleData->llvmLinkedModule())
-  {
-    GTLCore::VirtualMachine::instance()->unregisterModule( d->m_moduleData->llvmLinkedModule());
-  }
-  delete d->m_moduleData;
-  d->m_llvmModule = 0;
-  d->m_moduleData = 0;
-  if( d->libraryCompilation )
-  {
-    d->libraryCompilation->cleanup();
-  }
-}
-
-
-GTLCore::String Library::name() const
-{
-  return d->name;
-}
-
-void Library::setSource(const GTLCore::String& _source )
-{
-  d->source.setSource(_source);
-  d->initparameters();
-}
-
-void Library::setSource(const Source& source)
-{
-    d->source = source;
-    d->initparameters();
-}
-
-Source Library::source() const
-{
-    return d->source;
-}
-
-void Library::loadFromFile(const GTLCore::String& _fileName)
-{
-  d->isStandardLibrary = _fileName.endWith( "shivastdlib.shiva" );
-  d->source.loadFromFile(_fileName);
-  d->initparameters();
-}
-
-void Library::compile()
-{
-  if( d->libraryCompilation )
-  {
-    d->libraryCompilation->preCompilation();
-  }
-  if(not d->source.metadata() )
-  {
-    d->compilationErrors = d->source.metadataCompilationMessages();
-    return;
-  }
-  if(d->source.source().isEmpty()) return;
-  cleanup();
-  llvm::LLVMContext& context = llvm::getGlobalContext(); // TODO someday (llvm 2.7 ?) use own context
-  d->m_llvmModule = new llvm::Module((const std::string&)d->name, context);
-  d->m_moduleData = new GTLCore::ModuleData(d->m_llvmModule);
-  Compiler c( d->isKernel,  d->count_channels_generic );
-  Wrapper::fillTypesManager( d->m_moduleData, d->m_llvmModule, d->m_moduleData->typesManager(), c.convertCenter() , d->count_channels_generic );
-  GTLCore::String nameSpace;
-  bool result = c.compile( d->isStandardLibrary, d->source.source(), d->name, d->m_moduleData, d->m_llvmModule, nameSpace, d->parameters );
-
-  if(result)
-  {
-    d->compiled = true;
-    // Register the compiled module in the virtual machine
-    llvm::sys::DynamicLibrary::LoadLibraryPermanently( _OPENSHIVA_LIB_, 0 ); // This needed because when OpenShiva is used in a plugins, OpenShiva symbols aren't loaded globally and then llvm can't find them (FIXME move that somewhere else)
-    d->m_moduleData->doLink();
-    GTLCore::VirtualMachine::instance()->registerModule( d->m_moduleData->llvmLinkedModule() );
-    d->name = nameSpace;
-    if( d->libraryCompilation )
-    {
-      d->libraryCompilation->postCompilation();
-    }
-    SHIVA_ASSERT( d->isStandardLibrary or d->name != "" );
-  } else {
-    d->compiled = false;
-    cleanup();
-    d->compilationErrors = c.errorMessages();
-  }
-  
-}
-
-bool Library::isCompiled() const
-{
-  return d->compiled;
-}
-
-const GTLCore::CompilationMessages& Library::compilationMessages() const
-{
-  return d->compilationErrors;
-}
-
-GTLCore::String Library::asmSourceCode() const
-{
-  std::ostringstream os;
-  os << *d->m_moduleData->llvmModule() << std::endl;
-  return os.str();
-}
-
-const GTLCore::ModuleData* Library::data() const
-{
-  return d->m_moduleData;
-}
-
-std::list<GTLCore::Function*> Library::functions()
-{
-  return d->m_moduleData->functions();
-}
-
-const Metadata* Library::metadata() const
-{
-  return d->source.metadata();
-}
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Library.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Library.h
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Library.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Library.h	2012-01-10 11:12:02.150249111 -0500
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -20,84 +20,23 @@
 #ifndef _OPENSHIVA_LIBRARY_H_
 #define _OPENSHIVA_LIBRARY_H_
 
-#include <GTLCore/String.h>
+#include <GTLFragment/Library.h>
 #include <OpenShiva/Export.h>
-#include <map>
-
-namespace GTLCore {
-  class CompilationMessage;
-  class CompilationMessages;
-  class ModuleData;
-  class Function;
-  class Value;
-}
 
 namespace OpenShiva {
-  class Source;
-  class Metadata;
-  /**
-   * @ingroup OpenShiva
-   *
-   * Represent a Shiva Library, it is also the base class for kernels.<
-   */
-  class OPENSHIVA_EXPORT Library {
-    friend class Kernel;
-    friend struct KernelPrivate;
-    friend class LibrariesManager;
-      Library( bool _isKernel, int _channelsNb );
+  class Kernel;
+  class OPENSHIVA_EXPORT Library : public GTLFragment::Library {
+      friend class Kernel;
+      friend class KernelPrivate;
+      friend class LibrariesManager;
+      Library(GTLFragment::Library::Type _type, int _channelsNb);
       ~Library();
       GTL_NO_COPY(Library);
-    public:
-      /**
-       * @return the name of the kernel
-       */
-      GTLCore::String name() const;
-      /**
-       * Set the code source of the module.
-       */
-      void setSource(const GTLCore::String& source);
-      void setSource(const Source& source);
-      Source source() const;
-      /**
-       * Load the module from the given file name.
-       */
-      void loadFromFile(const GTLCore::String& fileName);
-      /**
-       * Start the compilation of the module.
-       */
-      void compile();
-      /**
-       * @return true if the module was successfully compiled.
-       */
-      bool isCompiled() const;
-      /**
-       * @return a string with the content of the compilation error.
-       */
-      const GTLCore::CompilationMessages& compilationMessages() const;
-      /**
-       * @return the assembly source code, it's mostly usefull for testing purpose
-       */
-      GTLCore::String asmSourceCode() const;
-      /**
-       * @return a pointer to the internal Data of this module (the class Module::Data
-       *         is not part of the public API and therefore there is no reason
-       *         to use this function).
-       */
-      const GTLCore::ModuleData* data() const;
-      /**
-       * @return the list of functions available in this module.
-       */
-      std::list<GTLCore::Function*> functions();
-      /**
-       * @return the metadata for this kernel.
-       */
-      const Metadata* metadata() const;
-    private:
-      void cleanup();
     private:
       struct Private;
       Private* const d;
   };
 }
 
+
 #endif
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Library_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Library_p.h
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Library_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Library_p.h	2012-01-10 11:12:02.150249111 -0500
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2008 Cyrille Berger <cberger@cberger.net>
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -17,57 +17,50 @@
  * Boston, MA 02110-1301, USA.
  */
 
-#ifndef _OPENSHIVA_LIBRARY_P_H_
-#define _OPENSHIVA_LIBRARY_P_H_
-
 #include "Library.h"
 
-#include <GTLCore/CompilationMessages.h>
-#include <GTLCore/String.h>
-#include <GTLCore/Value.h>
-
-#include "Source.h"
+#include <llvm/ADT/StringRef.h>
+#include <llvm/Support/DynamicLibrary.h>
 
-#include <map>
-
-namespace llvm {
-  class Function;
-  class Module;
-}
-
-namespace GTLCore {
-  class ModuleData;
-  namespace Metadata {
-    class Group;
-  }
-}
+#include <GTLFragment/LibraryCompilation_p.h>
+#include "Wrapper_p.h"
+#include <GTLCore/OperatorOverloadCenter_p.h>
+#include "ColorToPixelOverloadOperatorFactory_p.h"
 
 namespace OpenShiva {
-  class LibraryCompilation;
-  /**
-   * @internal
-   * @ingroup OpenShiva
-   * Private structure for a @ref Library
-   */
-  struct Library::Private {
-    Private() : m_moduleData(0), libraryCompilation(0)
-    {
-    }
-    void metadataToParameters( const GTLCore::Metadata::Group* );
-    void initparameters();
-    
-    GTLCore::String name;
-    Source source;
-    bool compiled;
-    llvm::Module* m_llvmModule;
-    GTLCore::ModuleData* m_moduleData;
-    int count_channels_generic;
-    bool isKernel;
-    bool isStandardLibrary;
-    std::map< GTLCore::String, GTLCore::Value > parameters;
-    GTLCore::CompilationMessages compilationErrors;
-    LibraryCompilation* libraryCompilation;
+  
+  struct Library::Private : GTLFragment::LibraryCompilation {
+      GTL_NO_COPY(Private)
+    public:
+      Private() : libraryCompilation(0), m_wrapper(0) {}
+      ~Private() { delete m_wrapper; }
+      virtual void preCompilation() {
+        if(libraryCompilation) libraryCompilation->preCompilation();
+      }
+      virtual void cleanup() {
+        if(libraryCompilation) libraryCompilation->cleanup();
+      }
+      virtual void postCompilation() {
+        if(libraryCompilation) libraryCompilation->postCompilation();
+        llvm::sys::DynamicLibrary::LoadLibraryPermanently( _OPENSHIVA_LIB_, 0 ); // This needed because when OpenShiva is used in a plugins, OpenShiva symbols aren't loaded globally and then llvm can't find them (FIXME move that somewhere else)
+      }
+      virtual void createWrapper(GTLCore::ModuleData* _moduleData, llvm::Module* module, int _channels, GTLFragment::WhichStdLibrary _library)
+      {
+        delete m_wrapper;
+        if(libraryCompilation) {
+          libraryCompilation->createWrapper(_moduleData, module, _channels, _library);
+        } else {
+          m_wrapper = new Wrapper(0, _moduleData, module, _channels, _library != GTLFragment::ShivaWrappersLibrary);
+        }
+      }
+      virtual void addOperatorOverloads(GTLCore::OperatorOverloadCenter* _center)
+      {
+        _center->addOperatorOverloadExpressionFactory(new ColorToPixelOverloadOperatorFactory);
+      }
+      virtual Wrapper* wrapper() {
+        return m_wrapper;
+      }
+      LibraryCompilation* libraryCompilation;
+      Wrapper* m_wrapper;
   };
 }
-
-#endif
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/LightParser_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/LightParser_p.cpp
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/LightParser_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/LightParser_p.cpp	2012-01-10 11:12:02.150249111 -0500
@@ -20,19 +20,19 @@
 #include "LightParser_p.h"
 
 #include "Debug.h"
-#include "Lexer_p.h"
+#include "GTLFragment/Lexer_p.h"
 
 using namespace OpenShiva;
 
 struct LightParser::Private {
-  Lexer* lexer;
+  GTLFragment::Lexer* lexer;
   GTLCore::String name;
   Source::SourceType sourceType;
   Source::ImageType outputImageType;
   std::vector<Source::ImageType> inputImageTypes;
 };
 
-LightParser::LightParser( Lexer* lexer ) : ParserBase(0, lexer), d(new Private)
+LightParser::LightParser( GTLFragment::Lexer* lexer ) : ParserBase(0, lexer), d(new Private)
 {
   d->lexer = lexer;
 }
@@ -210,7 +210,7 @@ void LightParser::eatLoopOf( GTLCore::To
   } while( count > 0 and currentToken().type != GTLCore::Token::END_OF_FILE  );
 }
 
-const GTLCore::String& LightParser::name() const
+GTLCore::String LightParser::name() const
 {
   return d->name;
 }
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/LightParser_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/LightParser_p.h
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/LightParser_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/LightParser_p.h	2012-01-10 11:12:02.150249111 -0500
@@ -28,8 +28,11 @@ namespace GTLCore {
   class String;
 };
 
-namespace OpenShiva {
+namespace GTLFragment {
   class Lexer;
+}
+
+namespace OpenShiva {
   /**
    * @internal
    * @ingroup OpenShiva
@@ -39,13 +42,13 @@ namespace OpenShiva {
    */
   class LightParser : public GTLCore::ParserBase {
     public:
-      LightParser( Lexer* );
+      LightParser( GTLFragment::Lexer* );
       ~LightParser();
       GTLCore::AST::Tree* parse();
       virtual GTLCore::AST::Tree* tree() { return 0; }
       virtual GTLCore::AST::Statement* parseStatement() { return 0; }
       Source::SourceType sourceType() const;
-      const GTLCore::String& name() const;
+      GTLCore::String name() const;
       Source::ImageType outputImageType() const;
       const std::vector<Source::ImageType>& inputImageTypes() const;
     private:
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/OpenShiva.pc.cmake.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/OpenShiva.pc.cmake
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/OpenShiva.pc.cmake.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/OpenShiva.pc.cmake	2012-01-10 11:12:02.150249111 -0500
@@ -7,5 +7,5 @@ Name: OpenShiva
 Description: Kernel Transformation Language interpreter library
 Version: @OPENSHIVA_VERSION@
 Requires:
-Libs: -L${libdir} -lOpenShiva -lGTLCore
+Libs: -L${libdir} -lOpenShiva -lGTLCore -lGTLFragment
 Cflags: -I${includedir}
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/PixelConvertExpressionFactory_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/PixelConvertExpressionFactory_p.cpp
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/PixelConvertExpressionFactory_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/PixelConvertExpressionFactory_p.cpp	2012-01-10 11:12:02.151249102 -0500
@@ -30,6 +30,12 @@
 #include "CodeGenerator_p.h"
 #include "Debug.h"
 #include "wrappers/PixelWrap_p.h"
+#include <GTLCore/LLVMBackend/CodeGenerator_p.h>
+#include <GTLCore/VariableNG_p.h>
+#include <GTLCore/LLVMBackend/Visitor_p.h>
+#include <GTLFragment/wrappers/ColorWrap_p.h>
+#include <llvm/Function.h>
+#include <GTLCore/Type_p.h>
 
 using namespace OpenShiva;
 
@@ -46,9 +52,45 @@ namespace OpenShiva {
         if( value()->type()->dataType() == GTLCore::Type::STRUCTURE )
         {
           llvm::Value* pixelPtr = value()->generateValue( _gc, _egc).value();
-        
           llvm::Value* pixelDataPtr = OpenShiva::CodeGenerator::accessPixelDataPtr( _gc, _egc.currentBasicBlock(), pixelPtr);
-          return LLVMBackend::ExpressionResult( new llvm::LoadInst( pixelDataPtr, "", _egc.currentBasicBlock() ) , m_dstType );
+          if(type()->dataType() == GTLCore::Type::STRUCTURE)
+          {
+            GTL_ASSERT(type()->structName() == "color");
+            llvm::Value* converterDataPtr = OpenShiva::CodeGenerator::accessColorConverterPtr( _gc, _egc.currentBasicBlock(), pixelPtr);
+
+            // Allocate the memory for color structure
+            llvm::Value* colorPtr = LLVMBackend::CodeGenerator::allocateMemory(_gc, type()->d->type(_gc.llvmContext()), LLVMBackend::CodeGenerator::integerToConstant(_gc.llvmContext(), INT32_C(1)), _egc.currentBasicBlock());
+      
+            // Initialize the structure
+            const LLVMBackend::Visitor* visitor = LLVMBackend::Visitor::getVisitorFor(type());
+            _egc.setCurrentBasicBlock(visitor->initialise( _gc, _egc.currentBasicBlock(), colorPtr, type(), std::list<llvm::Value*>()));
+
+            std::vector<llvm::Value*> indexes;
+            indexes.push_back( _gc.codeGenerator()->integerToConstant(_gc.llvmContext(), INT32_C(0)));
+            indexes.push_back( _gc.codeGenerator()->integerToConstant(_gc.llvmContext(), gtl_int32(ColorWrap::POS_RED) ));
+            llvm::Value* rgbPtr = llvm::GetElementPtrInst::Create( colorPtr, indexes, "", _egc.currentBasicBlock() );
+            
+            //Parameters are AbstractColorConverter*, ptrToColor, ptrTopixeldata, number of channels
+            std::vector<llvm::Value*> parameters;
+            parameters.push_back( new llvm::LoadInst( converterDataPtr, "PixelConvertExpression::generateValue", _egc.currentBasicBlock() ));
+            parameters.push_back(pixelDataPtr);
+            parameters.push_back(rgbPtr);
+            parameters.push_back(LLVMBackend::CodeGenerator::integerToConstant( _gc.llvmContext(), llvm::cast<llvm::VectorType>(pixelDataPtr->getType()->getContainedType(0))->getNumElements() ) );
+
+            llvm::Function* func = CodeGenerator::createWrapConvertPixelToColorFunction(_gc, pixelDataPtr->getType());
+            GTL_COMPARE_FUNCTION_PARAMETERS( func, parameters );
+            
+            llvm::CallInst *CallFunc = llvm::CallInst::Create(func, parameters, "", _egc.currentBasicBlock());
+            CallFunc->setTailCall(false);
+            _egc.setCurrentBasicBlock( LLVMBackend::Visitor::getVisitorFor(type())->mark( _gc, _egc.currentBasicBlock(), colorPtr, type(), LLVMBackend::CodeGenerator::integerToConstant( _gc.llvmContext(), INT32_C(-1) ) ) );
+
+            // Mark the color structure for deletion
+            _egc.setCurrentBasicBlock(visitor->mark(_gc, _egc.currentBasicBlock(), colorPtr, type(), LLVMBackend::CodeGenerator::integerToConstant(_gc.llvmContext(), -1)));
+            
+            return LLVMBackend::ExpressionResult(colorPtr, type(), true);
+          } else {
+            return LLVMBackend::ExpressionResult( new llvm::LoadInst( pixelDataPtr, "", _egc.currentBasicBlock() ) , m_dstType );
+          }
         } else {
           return value()->generateValue( _gc, _egc);
         }
@@ -78,8 +120,15 @@ GTLCore::AST::ConvertExpression* PixelCo
 
 bool PixelConvertExpressionFactory::canConvertBetween( const GTLCore::Type* srcType, const GTLCore::Type* dstType) const
 {
-  return (srcType->dataType() == GTLCore::Type::STRUCTURE and srcType->structName().startWith( "pixel" ) and srcType->structDataMember(PixelWrap::INDEX_DATA).type() == dstType )
-      or (dstType->dataType() == GTLCore::Type::STRUCTURE and dstType->structName().startWith( "pixel" ) and dstType->structDataMember(PixelWrap::INDEX_DATA).type() == srcType );
+  if(srcType->dataType() == GTLCore::Type::STRUCTURE and srcType->structName().startWith( "pixel" ))
+  {
+    return srcType->structDataMember(PixelWrap::INDEX_DATA).type() == dstType
+           or (dstType->dataType() == GTLCore::Type::STRUCTURE and dstType->structName() == "color");
+  } else if(dstType->dataType() == GTLCore::Type::STRUCTURE and dstType->structName().startWith( "pixel" ))
+  {
+    return dstType->structDataMember(PixelWrap::INDEX_DATA).type() == srcType;
+  }
+  return false;
 }
 
 GTLCore::ConvertCenter::ConversionQuality PixelConvertExpressionFactory::conversionQuality( const GTLCore::Type* _srcType, const GTLCore::Type* _dstType ) const
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/PixelVisitor_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/PixelVisitor_p.cpp
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/PixelVisitor_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/PixelVisitor_p.cpp	2012-01-10 11:12:02.151249102 -0500
@@ -21,6 +21,7 @@
 
 // LLVM
 #include <llvm/Constant.h>
+#include <llvm/Constants.h>
 #include <llvm/BasicBlock.h>
 #include <llvm/Instructions.h>
 #include <llvm/Function.h>
@@ -35,6 +36,7 @@
 #include "Debug.h"
 #include "CodeGenerator_p.h"
 #include "wrappers/PixelWrap_p.h"
+#include <GTLCore/Type_p.h>
 
 using namespace OpenShiva;
 
@@ -67,6 +69,12 @@ const GTLCore::Type* PixelVisitor::point
 llvm::Value* PixelVisitor::pointerToIndex( LLVMBackend::GenerationContext& _generationContext, LLVMBackend::ExpressionGenerationContext& _expressionGenerationContext, llvm::Value* _pointer, const GTLCore::Type* _type, llvm::Value* _index) const
 {
   llvm::Value* ptr = CodeGenerator::accessPixelDataAsF32Ptr( _generationContext, _expressionGenerationContext.currentBasicBlock(), _pointer );
+  llvm::Value* min = LLVMBackend::CodeGenerator::integerToConstant(_generationContext.llvmContext(), gtl_uint32(0));
+  llvm::Value* max = LLVMBackend::CodeGenerator::integerToConstant(_generationContext.llvmContext(), gtl_uint32(
+    llvm::cast<llvm::VectorType>(_pointer->getType()->getContainedType(0)->getContainedType(PixelWrap::POS_DATA))->getNumElements() - 1 ));
+  
+  _index = LLVMBackend::CodeGenerator::clampValue(_generationContext, _expressionGenerationContext, _index, min, max);
+  
   return llvm::GetElementPtrInst::Create( ptr, _index, "", _expressionGenerationContext.currentBasicBlock());
 }
 
@@ -84,7 +92,7 @@ LLVMBackend::ExpressionResult PixelVisit
   return LLVMBackend::ExpressionResult(_pointer, _pointerType);
 }
 
-llvm::BasicBlock* PixelVisitor::set( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _value, const GTLCore::Type* _valueType, bool _allocatedInMemory) const
+llvm::BasicBlock* PixelVisitor::set( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _value, const GTLCore::Type* _valueType) const
 {
   SHIVA_DEBUG( "Pointer Type = " << *_pointerType << " Value Type = " << *_valueType );
   SHIVA_DEBUG( "Pointer = " << *_pointer << " Value = " << *_value );
@@ -101,13 +109,18 @@ llvm::BasicBlock* PixelVisitor::set( LLV
   return _currentBlock;
 }
 
-llvm::BasicBlock* PixelVisitor::initialise( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, const std::list< llvm::Value*>& _sizes, bool _allocatedInMemorys) const
+llvm::BasicBlock* PixelVisitor::initialise( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, const std::list< llvm::Value*>& _sizes) const
 {
-  // Don't do nothing
+  // Set the ColorConverter to 0
+  llvm::Value* ptrToColorConverter = CodeGenerator::accessColorConverterPtr(_generationContext, _currentBlock, _pointer);
+  new llvm::StoreInst( llvm::ConstantPointerNull::get( llvm::cast<llvm::PointerType>(GTLCore::Type::Pointer->d->type(_generationContext.llvmContext()))) , ptrToColorConverter, "PixelVisitor::initialise", _currentBlock);
+  
+  
+  // Don't do nothing else
   return _currentBlock;
 }
 
-llvm::BasicBlock* PixelVisitor::cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _donttouch, bool _allocatedInMemory, bool _ignoreCount, bool _deletePointer ) const
+llvm::BasicBlock* PixelVisitor::cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _donttouch, bool _ignoreCount, bool _deletePointer ) const
 {
   
   if( _deletePointer )
@@ -118,10 +131,7 @@ llvm::BasicBlock* PixelVisitor::cleanUp(
     _generationContext.llvmFunction()->getBasicBlockList().push_back( firstIfBlock);
     llvm::BasicBlock* afterIfBlock = llvm::BasicBlock::Create(_generationContext.llvmContext(), "afterIfBlockStructureVisitorCleanUp");
     _generationContext.llvmFunction()->getBasicBlockList().push_back( afterIfBlock);
-    if( _allocatedInMemory )
-    {
-      LLVMBackend::CodeGenerator::freeMemory( _generationContext, _pointer, firstIfBlock );
-    }
+    LLVMBackend::CodeGenerator::freeMemory( _generationContext, _pointer, firstIfBlock );
     LLVMBackend::CodeGenerator::createIfStatement( _currentBlock, test, GTLCore::Type::Boolean, firstIfBlock, firstIfBlock, afterIfBlock );
     return afterIfBlock;
   }
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/PixelVisitor_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/PixelVisitor_p.h
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/PixelVisitor_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/PixelVisitor_p.h	2012-01-10 11:12:02.151249102 -0500
@@ -41,9 +41,9 @@ namespace OpenShiva {
       virtual const GTLCore::Type* pointerToIndexType( const GTLCore::Type* _type ) const;
       virtual llvm::Value* pointerToIndex( LLVMBackend::GenerationContext& _generationContext, LLVMBackend::ExpressionGenerationContext& _expressionGenerationContext, llvm::Value* _pointer, const GTLCore::Type* _type, llvm::Value* _index) const;
       virtual LLVMBackend::ExpressionResult get(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* currentBlock, llvm::Value* pointer, const GTLCore::Type* _pointerType) const;
-      virtual llvm::BasicBlock* set(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _value, const GTLCore::Type* _valueType, bool _allocatedInMemory) const;
-      virtual llvm::BasicBlock* initialise(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, const std::list< llvm::Value*>& _sizes, bool _allocatedInMemory) const;
-      virtual llvm::BasicBlock* cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _donttouch, bool _allocatedInMemory, bool _ignoreCount, bool _deletePointer ) const;
+      virtual llvm::BasicBlock* set(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _value, const GTLCore::Type* _valueType) const;
+      virtual llvm::BasicBlock* initialise(LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, const std::list< llvm::Value*>& _sizes) const;
+      virtual llvm::BasicBlock* cleanUp( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* _donttouch, bool _ignoreCount, bool _deletePointer ) const;
       virtual llvm::BasicBlock* mark( LLVMBackend::GenerationContext& _generationContext, llvm::BasicBlock* _currentBlock, llvm::Value* _pointer, const GTLCore::Type* _pointerType, llvm::Value* increment ) const;
       virtual llvm::Constant* createStaticVariable( llvm::Module* _module, const GTLCore::Type* type, const std::list< int>& _sizes ) const;
   };
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/shivawrappers.shiva.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/shivawrappers.shiva
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/shivawrappers.shiva.95a8c6853b97	2012-01-10 11:12:02.151249102 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/shivawrappers.shiva	2012-01-10 11:12:02.151249102 -0500
@@ -0,0 +1,34 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * version 2 of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+library wrappers
+{
+  void translate(output region self, float x, float y)
+  {
+    self.x += x;
+    self.y += y;
+  }
+  region translated(region self, float x, float y)
+  {
+    region r = self;
+    translate(r, x, y);
+    return r;
+  }
+  
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Source.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Source.cpp
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Source.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Source.cpp	2012-01-10 11:12:02.151249102 -0500
@@ -21,73 +21,36 @@
 
 using namespace OpenShiva;
 
-#include <fstream>
+#include <GTLCore/Debug.h>
 
-#include <GTLCore/String.h>
-
-#include "Debug.h"
-#include "Lexer_p.h"
 #include "LightParser_p.h"
-#include "MetadataLexer_p.h"
-#include "MetadataParser_p.h"
-#include "Metadata.h"
-#include "GTLCore/CompilationMessage.h"
-
-#include "GTLCore/Metadata/Factory_p.h"
-#include <GTLCore/CompilationMessages.h>
-#include <GTLCore/SharedPointer.h>
+#include <GTLFragment/Source_p.h>
+#include <GTLFragment/Lexer_p.h>
 
-struct Source::Private : public GTLCore::SharedPointerData
+struct Source::Private : public GTLFragment::Source::Private
 {
-  Private() : metadata(0), metadataCompilationFailed(false), uptodate(false), type( InvalidSource ) {}
-  Private(const Private& _rhs) : SharedPointerData(), name(_rhs.name), source(_rhs.source), metadata(0), metadataCompilationFailed(false), uptodate(false), type( InvalidSource ) {}
+  Private() : type( InvalidSource ) {}
+  Private(const Private& _rhs) : GTLFragment::Source::Private(_rhs), type( InvalidSource ) {}
   
-  void compileMetaData();
-  void update();
-  GTLCore::String name;
-  GTLCore::String source;
-  Metadata* metadata;
-  bool metadataCompilationFailed;
-  GTLCore::CompilationMessages compilationErrors;
-  bool uptodate; ///< Hold wether name and type have been extracted from source
+  Private* clone() { return new Private(*this); }
+  void specificUpdate(const GTLCore::String& _source, GTLCore::String& name);
+
   SourceType type;
   ImageType outputImageType;
   std::vector<ImageType> inputImageTypes;
 };
 
-
-// ---- Library::Private ---- //
-
-void Source::Private::compileMetaData()
+void Source::Private::specificUpdate(const GTLCore::String& _source, GTLCore::String& name)
 {
-  metadata = 0;
-  std::istringstream iss(source);
-  MetadataLexer* lexer = new MetadataLexer(&iss);
-  MetadataParser parser( lexer, "" );
-  metadata = parser.parse();
-  compilationErrors = parser.errorMessages();
-  metadataCompilationFailed = not compilationErrors.errors().empty();
-  GTL_DEBUG( compilationErrors.errors().size() );
-  GTL_DEBUG( parser.errorMessages().errors().size() );
-  if( compilationErrors.errors().size() != 0 )
-  {
-    GTLCore::Metadata::Factory::deleteEntry( metadata );
-    metadata = 0;
-  }
-}
-
-void Source::Private::update()
-{
-  if(uptodate) return;
-  std::istringstream iss(source);
-  Lexer lexer( &iss );
+  std::istringstream iss(_source);
+  GTLFragment::Lexer lexer( &iss, GTLFragment::Library::SHIVA_LIBRARY );
   LightParser parser(&lexer);
   parser.parse();
   name = parser.name();
   type = parser.sourceType();
   outputImageType = parser.outputImageType();
   inputImageTypes = parser.inputImageTypes();
-  if( type != Library)
+  if( type != Library and outputImageType != InvalidImage )
   {
     switch( inputImageTypes.size() )
     {
@@ -102,92 +65,48 @@ void Source::Private::update()
         break;
     }
   }
-  uptodate = true;
-}
-
-Source::Source() : d(new Private)
-{
-  d->ref();
-}
-
-GTL_SHARED_DATA(Source)
-
-GTLCore::String Source::name() const
-{
-  d->update();
-  return d->name;
 }
 
-GTLCore::String Source::source() const
-{
-  return d->source;
-}
 
-void Source::setSource( const GTLCore::String& _source)
-{
-  deref();
-  GTLCore::Metadata::Factory::deleteEntry( d->metadata );
-  d->metadata = 0;
-  d->metadataCompilationFailed = false;
-  d->uptodate = false;
-  d->source = _source;
-}
+// ---- Library::Private ---- //
 
-void Source::loadFromFile(const GTLCore::String& _fileName)
+const Source::Private* Source::d_func() const
 {
-  GTLCore::String source = "";
-  std::ifstream in;
-  in.open(_fileName.c_str() );
-  if(not in)
-  {
-    SHIVA_DEBUG( "Impossible to open file " << _fileName );
-    return;
-  }
-  std::string str;
-  std::getline(in,str);
-  while ( in ) {
-    source += str;
-    source += "\n";
-    std::getline(in,str);
-  }
-  setSource(source);
+  return static_cast<const Source::Private*>(d);
 }
 
-const Metadata* Source::metadata() const
+Source::Source() : GTLFragment::Source(d = new Private)
 {
-  if(not d->metadata and not d->metadataCompilationFailed)
-  {
-    d->compileMetaData();
-  }
-  return d->metadata;
 }
 
-GTLCore::CompilationMessages Source::metadataCompilationMessages() const
-{
-  return d->compilationErrors;
-}
+GTL_INHERITED_SHARED_DATA(Source, GTLFragment::Source)
 
 Source::SourceType Source::sourceType() const
 {
   d->update();
-  return d->type;
+  return d_func()->type;
 }
 
 Source::ImageType Source::outputImageType() const
 {
-  return d->outputImageType;
+  d->update();
+  return d_func()->outputImageType;
 }
 
 Source::ImageType Source::inputImageType(int idx) const
 {
-  if( idx >= 0 and (std::size_t)idx < d->inputImageTypes.size())
+  d->update();
+  if (std::size_t(idx) < d_func()->inputImageTypes.size())
   {
-    return d->inputImageTypes[idx];
+    return d_func()->inputImageTypes[idx];
+  } else {
+    return OpenShiva::Source::InvalidImage;
   }
-  return InvalidImage;
 }
 
 int Source::countInputImages() const
 {
-  return d->inputImageTypes.size();
+  d->update();
+  return d_func()->inputImageTypes.size();
 }
+
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Source.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Source.h
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Source.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Source.h	2012-01-10 11:12:02.151249102 -0500
@@ -20,13 +20,8 @@
 #ifndef _OPENSHIVA_KERNEL_SOURCE_H_
 #define _OPENSHIVA_KERNEL_SOURCE_H_
 
-#include <list>
 #include <OpenShiva/Export.h>
-
-namespace GTLCore {
-  class CompilationMessages;
-  class String;
-}
+#include <GTLFragment/Source.h>
 
 namespace OpenShiva {
   class Metadata;
@@ -36,21 +31,12 @@ namespace OpenShiva {
    * Define the source code of a Kernel. Allow to access to information like the metadata,
    * or the source code, or the parameters of the evaluateParam function.
    */
-  class OPENSHIVA_EXPORT Source {
+  class OPENSHIVA_EXPORT Source : public GTLFragment::Source {
     public:
       Source();
       Source(const Source& );
       Source& operator=(const Source& );
       ~Source();
-      GTLCore::String name() const;
-      GTLCore::String source() const;
-      void setSource( const GTLCore::String& );
-      void loadFromFile(const GTLCore::String& _fileName);
-      /**
-       * @return the metadata for this kernel.
-       */
-      const Metadata* metadata() const;
-      GTLCore::CompilationMessages metadataCompilationMessages() const;
     public:
       enum SourceType {
         InvalidSource, ///< Not a valid Shiva source code
@@ -85,10 +71,8 @@ namespace OpenShiva {
        */
       int countInputImages() const;
     private:
-      inline void deref();
-    private:
       struct Private;
-      Private* d;
+      inline const Private* d_func() const;
   };
 }
 
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/SourcesCollection.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/SourcesCollection.cpp
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/SourcesCollection.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/SourcesCollection.cpp	2012-01-10 11:12:02.151249102 -0500
@@ -97,3 +97,15 @@ std::list< Source > SourcesCollection::s
   }
   return sources;
 }
+
+Source SourcesCollection::source(const GTLCore::String& _string) const
+{
+  foreach(Source source,d->kernels)
+  {
+    if(source.name() == _string)
+    {
+      return source;
+    }
+  }
+  return Source();
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/SourcesCollection.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/SourcesCollection.h
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/SourcesCollection.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/SourcesCollection.h	2012-01-10 11:12:02.152249093 -0500
@@ -58,6 +58,10 @@ namespace OpenShiva {
        * @return the list of sources in the collection that have the type given in argument.
        */
       std::list< Source > sources(Source::SourceType _source) const;
+      /**
+       * @return a kernel by the name of @p _string or null if no such kernel exists
+       */
+      Source source(const GTLCore::String& _string) const;
     private:
       struct Private;
       Private* const d;
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Wrapper_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Wrapper_p.cpp
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Wrapper_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Wrapper_p.cpp	2012-01-10 11:12:02.152249093 -0500
@@ -46,6 +46,8 @@
 #include "PixelConvertExpressionFactory_p.h"
 
 #include "wrappers/ImageWrap_p.h"
+#include "LibrariesManager.h"
+#include <GTLCore/CompilationMessages.h>
 
 using namespace OpenShiva;
 
@@ -61,15 +63,14 @@ typedef pdToWF::const_iterator pdToWF_ci
 struct Wrapper::Private {
   pdToWF imageFunctions;
   Kernel* kernel;
-  GTLCore::ModuleData* moduleData;
-  llvm::Module* module;
+  bool loadShivaWrapper;
 };
 
-Wrapper::Wrapper(Kernel* _kernel, GTLCore::ModuleData* _moduleData, llvm::Module* module) : d(new Private)
+Wrapper::Wrapper(Kernel* _kernel, GTLCore::ModuleData* _moduleData, llvm::Module* module, int channels, bool loadShivaWrapper) : GTLFragment::Wrapper(_moduleData, module, channels), d(new Private)
 {
+  d->loadShivaWrapper = loadShivaWrapper;
+  GTL_ASSERT( channels > 0 );
   d->kernel = _kernel;
-  d->moduleData = _moduleData;
-  d->module = module;
 }
 
 Wrapper::~Wrapper()
@@ -88,9 +89,9 @@ ImageWrap* Wrapper::wrapImage(GTLCore::A
     // Wrap functions doesn't exist yet, generate them
     WrappedFunctions wf;
     wf.memToVec = GTLCore::VirtualMachine::instance()->getPointerToFunction(
-        CodeGenerator::generateMemToVec( d->moduleData, d->module, _abstractImage->pixelDescription()  ) );
+        CodeGenerator::generateMemToVec( moduleData(), llvmModule(), _abstractImage->pixelDescription()  ) );
     wf.vecToMem = GTLCore::VirtualMachine::instance()->getPointerToFunction(
-        CodeGenerator::generateVecToMem( d->moduleData, d->module, _abstractImage->pixelDescription()  ) );
+        CodeGenerator::generateVecToMem( moduleData(), llvmModule(), _abstractImage->pixelDescription()  ) );
     d->imageFunctions[ _abstractImage->pixelDescription() ] = wf;
     owrap->memToVec = wf.memToVec;
     owrap->vecToMem = wf.vecToMem;
@@ -103,27 +104,44 @@ ImageWrap* Wrapper::wrapImage(GTLCore::A
   return owrap;
 }
 
-void Wrapper::fillTypesManager( GTLCore::ModuleData* _module, llvm::Module* llvmModule, GTLCore::TypesManager* _typesManager, GTLCore::ConvertCenter* _convertCenter, int _channels )
+void Wrapper::fillTypesManager( GTLCore::TypesManager* _typesManager, GTLCore::ConvertCenter* _convertCenter )
 {
-  GTL_ASSERT(_channels > 0 );
-  GTL_ASSERT( _module->llvmModule() == llvmModule );
   SHIVA_DEBUG("fillTypesManager");
+  /*const GTLCore::Type* colorType = */createColorType(_typesManager, _convertCenter);
   _convertCenter->addConvertExpressionFactory(new PixelConvertExpressionFactory);
   for( int i = 1; i <= 5; ++i)
   {
     // Create Image type
-    const GTLCore::Type* pixelType = createPixelType( _module, llvmModule, _typesManager, _convertCenter, GTLCore::String::number( i ), i );
-    createImageType( _module, llvmModule, _typesManager, GTLCore::String::number( i ), i, pixelType );
+    const GTLCore::Type* pixelType = createPixelType( moduleData(), llvmModule(), _typesManager, _convertCenter, GTLCore::String::number( i ), i );
+    createImageType( moduleData(), llvmModule(), _typesManager, GTLCore::String::number( i ), i, pixelType );
+  }
+  const GTLCore::Type* pixelType = createPixelType( moduleData(), llvmModule(), _typesManager, _convertCenter, "", channels() );
+  createImageType( moduleData(), llvmModule(), _typesManager, "", channels(), pixelType );
+  const GTLCore::Type* regionType = createRegionType( moduleData(), llvmModule(), _typesManager );
+
+  if(d->loadShivaWrapper)
+  {
+    GTLFragment::Library* library = OpenShiva::LibrariesManager::instance()->loadLibrary( "shivawrappers", channels());
+    GTL_ASSERT( library );
+    if(not library->isCompiled())
+    {
+      library->compile();
+      if(not library->isCompiled())
+      {
+        GTL_ABORT("shivawrappers.shiva compilation failed, " << library->compilationMessages().toString());
+        return;
+      }
+    }
+    moduleData()->linkWith( library->data() );
+    addFunctionFromModuleToType(regionType, library, GTLCore::ScopedName("wrappers", "translate"));
+    addFunctionFromModuleToType(regionType, library, GTLCore::ScopedName("wrappers", "translated"));
   }
-  const GTLCore::Type* pixelType = createPixelType( _module, llvmModule, _typesManager, _convertCenter, "", _channels );
-  createImageType( _module, llvmModule, _typesManager, "", _channels, pixelType );
-  createRegionType( _module, llvmModule, _typesManager );
 }
 
 
 llvm::FunctionType* Wrapper::pixel_wrap_set_alpha_type(llvm::LLVMContext& context, GTLCore::TypesManager* _typesManager, const GTLCore::Type* _pixelType)
 {
-  std::vector<const llvm::Type*> functionArgs;
+  std::vector<llvm::Type*> functionArgs;
   functionArgs.push_back( _pixelType->d->pointerType(context) );
   functionArgs.push_back( llvm::Type::getFloatTy(context) );
   return llvm::FunctionType::get( llvm::Type::getVoidTy(context), functionArgs, false);
@@ -131,7 +149,7 @@ llvm::FunctionType* Wrapper::pixel_wrap_
 
 llvm::FunctionType* Wrapper::pixel_wrap_alpha_type( llvm::LLVMContext& context, GTLCore::TypesManager* _typesManager, const GTLCore::Type* _pixelType)
 {
-  std::vector<const llvm::Type*> functionArgs;
+  std::vector<llvm::Type*> functionArgs;
   functionArgs.push_back( _pixelType->d->pointerType(context) );
   return llvm::FunctionType::get( llvm::Type::getFloatTy(context), functionArgs, false);
 }
@@ -140,7 +158,7 @@ const GTLCore::Type* Wrapper::createPixe
 {
   //---------------------- WARNING ----------------------//
   // Whenever the following structure is edited,         //
-  // it's llvm declaration must be changed too in        //
+  // its C++ declaration must be changed too in          //
   // struct PixelWrap !                                  //
   //---------------------- WARNING ----------------------//
   
@@ -148,11 +166,12 @@ const GTLCore::Type* Wrapper::createPixe
   
   const GTLCore::Type* vecType = vectorType( _typesManager, _channels );
   std::vector<GTLCore::Type::StructDataMember> pixelDataMembers;
-  pixelDataMembers.push_back( GTLCore::Type::StructDataMember( "data", vecType ) );
+  pixelDataMembers.push_back( GTLCore::Type::StructDataMember( "", GTLCore::Type::Pointer ) ); // AbstractColorConverter*
+  pixelDataMembers.push_back( GTLCore::Type::StructDataMember( "", GTLCore::Type::Integer32 ) ); // alphapos
   
   pixelDataMembers.push_back( GTLCore::Type::StructDataMember( "coord", _typesManager->getVector( GTLCore::Type::Float32, 2 ) ) );
-  pixelDataMembers.push_back( GTLCore::Type::StructDataMember( "", GTLCore::Type::Integer32 ) );
   
+  pixelDataMembers.push_back( GTLCore::Type::StructDataMember( "data", vecType ) );
   
   
   const GTLCore::Type* type = _typesManager->d->createStructure( "pixel" + _suffix, pixelDataMembers );
@@ -160,15 +179,15 @@ const GTLCore::Type* Wrapper::createPixe
   
   type->d->addFunctionMember( GTLCore::Type::StructFunctionMember(
           GTLCore::Function::Private::createInternalFunction(
-                _module, context, "setAlpha",
+                _module, context, "setOpacity",
                 CodeGenerator::generatePixelSetAlpha( _module, llvmModule, type, _channels ),
-                GTLCore::Type::Void, 2,
+                GTLCore::Type::Void, GTLCore::Function::Private::EFP_ONLY_TYPE, 2,
                 type, GTLCore::Type::Float32 ) ) );
   type->d->addFunctionMember( GTLCore::Type::StructFunctionMember(
           GTLCore::Function::Private::createInternalFunction(
-                _module, context, "alpha",
+                _module, context, "opacity",
                 CodeGenerator::generatePixelAlpha( _module, llvmModule, type, _channels ),
-                GTLCore::Type::Float32, 1,
+                GTLCore::Type::Float32, GTLCore::Function::Private::EFP_ONLY_TYPE, 1,
                 type ) ) );
 
   _convertCenter->addAutoConversion( type, vecType );
@@ -176,11 +195,11 @@ const GTLCore::Type* Wrapper::createPixe
   return type;
 }
 
-void Wrapper::createRegionType( GTLCore::ModuleData* _module, llvm::Module* _llvmModule, GTLCore::TypesManager* _typesManager )
+const GTLCore::Type* Wrapper::createRegionType( GTLCore::ModuleData* _module, llvm::Module* _llvmModule, GTLCore::TypesManager* _typesManager )
 {
   //---------------------- WARNING ----------------------//
   // Whenever the following structure is edited,         //
-  // it's llvm declaration must be changed too in        //
+  // its C++ declaration must be changed too in          //
   // struct RegionWrap !                                 //
   //---------------------- WARNING ----------------------//
   
@@ -194,36 +213,45 @@ void Wrapper::createRegionType( GTLCore:
   const GTLCore::Type* type = _typesManager->d->createStructure( "region", regionDataMembers);
   type->d->addFunctionMember( GTLCore::Type::StructFunctionMember(
           GTLCore::Function::Private::createExternalFunction(
-                _module, _llvmModule, context, "left", "region_wrap_left", GTLCore::Type::Float32, 1,
+                _module, _llvmModule, context, "left", "region_wrap_left", GTLCore::Type::Float32,
+                GTLCore::Function::Private::EFP_ONLY_TYPE, 1,
                 type ) ) );
   type->d->addFunctionMember( GTLCore::Type::StructFunctionMember(
           GTLCore::Function::Private::createExternalFunction(
-                _module, _llvmModule, context, "right", "region_wrap_right", GTLCore::Type::Float32, 1,
+                _module, _llvmModule, context, "right", "region_wrap_right", GTLCore::Type::Float32,
+                GTLCore::Function::Private::EFP_ONLY_TYPE, 1,
                 type ) ) );
   type->d->addFunctionMember( GTLCore::Type::StructFunctionMember(
           GTLCore::Function::Private::createExternalFunction(
-                _module, _llvmModule, context, "bottom", "region_wrap_bottom", GTLCore::Type::Float32, 1,
+                _module, _llvmModule, context, "bottom", "region_wrap_bottom", GTLCore::Type::Float32,
+                GTLCore::Function::Private::EFP_ONLY_TYPE, 1,
                 type ) ) );
   type->d->addFunctionMember( GTLCore::Type::StructFunctionMember(
           GTLCore::Function::Private::createExternalFunction(
-                _module, _llvmModule, context, "top", "region_wrap_top", GTLCore::Type::Float32, 1,
+                _module, _llvmModule, context, "top", "region_wrap_top", GTLCore::Type::Float32,
+                GTLCore::Function::Private::EFP_ONLY_TYPE, 1,
                 type ) ) );
   type->d->addFunctionMember( GTLCore::Type::StructFunctionMember(
           GTLCore::Function::Private::createExternalFunction(
-                _module, _llvmModule, context, "intersect", "region_wrap_intersect", GTLCore::Type::Void, 2,
+                _module, _llvmModule, context, "intersect", "region_wrap_intersect", GTLCore::Type::Void,
+                GTLCore::Function::Private::EFP_ONLY_TYPE, 2,
                 type, type ) ) );
   type->d->addFunctionMember( GTLCore::Type::StructFunctionMember(
           GTLCore::Function::Private::createExternalFunction(
-                _module, _llvmModule, context, "union", "region_wrap_union", GTLCore::Type::Void, 2,
+                _module, _llvmModule, context, "union", "region_wrap_union", GTLCore::Type::Void,
+                GTLCore::Function::Private::EFP_ONLY_TYPE, 2,
                 type, type ) ) );
   type->d->addFunctionMember( GTLCore::Type::StructFunctionMember(
           GTLCore::Function::Private::createExternalFunction(
-                _module, _llvmModule, context, "outset", "region_wrap_outset", GTLCore::Type::Void, 2,
+                _module, _llvmModule, context, "outset", "region_wrap_outset", GTLCore::Type::Void,
+                GTLCore::Function::Private::EFP_ONLY_TYPE, 2,
                 type, GTLCore::Type::Float32 ) ) );
   type->d->addFunctionMember( GTLCore::Type::StructFunctionMember(
           GTLCore::Function::Private::createExternalFunction(
-                _module, _llvmModule, context, "inset", "region_wrap_inset", GTLCore::Type::Void, 2,
+                _module, _llvmModule, context, "inset", "region_wrap_inset", GTLCore::Type::Void,
+                GTLCore::Function::Private::EFP_ONLY_TYPE, 2,
                 type, GTLCore::Type::Float32 ) ) );
+  return type;
 }
 
 llvm::Function* Wrapper::image_wrap_dataFunction( llvm::Module* _module, const GTLCore::Type* _imageType )
@@ -232,7 +260,7 @@ llvm::Function* Wrapper::image_wrap_data
   
   llvm::LLVMContext& context = _module->getContext();
   
-  std::vector<const llvm::Type*> functionArgs;
+  std::vector<llvm::Type*> functionArgs;
   functionArgs.push_back(llvm::PointerType::get( _imageType->d->type(context), 0));
   functionArgs.push_back(llvm::Type::getInt32Ty(context));
   functionArgs.push_back(llvm::Type::getInt32Ty(context));
@@ -243,7 +271,7 @@ llvm::Function* Wrapper::image_wrap_data
 llvm::Function* Wrapper::image_wrap_const_dataFunction( llvm::Module* _module, const GTLCore::Type* _imageType )
 {
   GTL_ASSERT( _imageType );
-  std::vector<const llvm::Type*> functionArgs;
+  std::vector<llvm::Type*> functionArgs;
   functionArgs.push_back(llvm::PointerType::get( _imageType->d->type(_module->getContext()), 0));
   functionArgs.push_back(llvm::IntegerType::get(_module->getContext(), 32));
   functionArgs.push_back(llvm::IntegerType::get(_module->getContext(), 32));
@@ -258,15 +286,27 @@ llvm::Function* Wrapper::image_alpha_pos
   
   llvm::LLVMContext& context = _module->getContext();
   
-  std::vector<const llvm::Type*> functionArgs;
+  std::vector<llvm::Type*> functionArgs;
   functionArgs.push_back(llvm::PointerType::get( _imageType->d->type(context), 0));
   llvm::FunctionType* functionTy = llvm::FunctionType::get(llvm::IntegerType::getInt32Ty(context), functionArgs, false);
   return (llvm::Function*)_module->getOrInsertFunction( "image_alpha_pos", functionTy);
 }
 
+llvm::Function* Wrapper::image_color_converter( llvm::Module* _module, const GTLCore::Type* _imageType )
+{
+  GTL_ASSERT( _imageType );
+  
+  llvm::LLVMContext& context = _module->getContext();
+  
+  std::vector<llvm::Type*> functionArgs;
+  functionArgs.push_back(llvm::PointerType::get( _imageType->d->type(context), 0));
+  llvm::FunctionType* functionTy = llvm::FunctionType::get(GTLCore::Type::Pointer->d->type(_module->getContext()), functionArgs, false);
+  return (llvm::Function*)_module->getOrInsertFunction( "image_color_converter", functionTy);
+}
+
 llvm::FunctionType* Wrapper::image_wrap_sample_nearest_type( llvm::LLVMContext& context, GTLCore::TypesManager* _typesManager, const GTLCore::Type* _imageType, const GTLCore::Type* _pixelType )
 {
-  std::vector<const llvm::Type*> functionArgs;
+  std::vector<llvm::Type*> functionArgs;
   functionArgs.push_back( _imageType->d->pointerType(context) );
   functionArgs.push_back( _typesManager->getVector( GTLCore::Type::Float32, 2 )->d->type(context) );
   return llvm::FunctionType::get( _pixelType->d->pointerType(context) , functionArgs, false);
@@ -274,7 +314,7 @@ llvm::FunctionType* Wrapper::image_wrap_
 
 llvm::FunctionType* Wrapper::image_wrap_mem_to_vec_float_type( llvm::LLVMContext& context, GTLCore::TypesManager* _typesManager, int _channels )
 {
-  std::vector<const llvm::Type*> functionArgs;
+  std::vector<llvm::Type*> functionArgs;
   functionArgs.push_back( llvm::PointerType::get( vectorType( _typesManager, _channels)->d->type(context), 0) );
   functionArgs.push_back( llvm::PointerType::get( llvm::Type::getInt8Ty(context), 0));
   return llvm::FunctionType::get( llvm::Type::getVoidTy(context), functionArgs, false);
@@ -282,7 +322,7 @@ llvm::FunctionType* Wrapper::image_wrap_
 
 llvm::FunctionType* Wrapper::image_wrap_vec_float_to_mem_type( llvm::LLVMContext& context, GTLCore::TypesManager* _typesManager, int _channels )
 {
-  std::vector<const llvm::Type*> functionArgs;
+  std::vector<llvm::Type*> functionArgs;
   functionArgs.push_back( llvm::PointerType::get( llvm::IntegerType::getInt8Ty(context), 0));
   functionArgs.push_back( llvm::PointerType::get( vectorType( _typesManager, _channels)->d->type(context), 0) );
   functionArgs.push_back( llvm::Type::getInt64Ty(context) ); // gtl_uint64 _channelFlags
@@ -323,7 +363,7 @@ void Wrapper::createImageType( GTLCore::
 {
   //---------------------- WARNING ----------------------//
   // Whenever the following structure is edited,         //
-  // it's llvm declaration must be changed too in        //
+  // its C++ declaration must be changed too in          //
   // struct ImageWrap !                                  //
   //---------------------- WARNING ----------------------//
   std::vector<GTLCore::Type::StructDataMember> imageDataMembers;
@@ -340,7 +380,7 @@ void Wrapper::createImageType( GTLCore::
           GTLCore::Function::Private::createInternalFunction(
                 _moduleData, _moduleData->llvmModule()->getContext(), "sampleNearest",
                 CodeGenerator::generateImageSampleNearest( _moduleData, _llvmModule, type, _pixelType ),
-                _pixelType, 2,
+                _pixelType, GTLCore::Function::Private::EFP_ONLY_TYPE, 2,
                 type, _moduleData->typesManager()->getVector( GTLCore::Type::Float32, 2 ) ) ) );
 }
 
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Wrapper_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Wrapper_p.h
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Wrapper_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/Wrapper_p.h	2012-01-10 11:12:02.152249093 -0500
@@ -21,6 +21,7 @@
 #define _OPENSHIVA_WRAPPER_P_H_
 
 #include "GTLCore/Type_p.h"
+#include <GTLFragment/Wrapper_p.h>
 
 struct ImageWrap;
 
@@ -47,21 +48,23 @@ namespace OpenShiva {
    * region.
    * @ingroup OpenShiva
    */
-  class Wrapper {
+  class Wrapper : public GTLFragment::Wrapper {
       class Mem2VecFloatTypeAribtraryTypeFactory;
       class VecFloat2MemTypeAribtraryTypeFactory;
+      GTL_NO_COPY(Wrapper)
     public:
-      Wrapper(Kernel* _kernel, GTLCore::ModuleData* _moduleData, llvm::Module* module);
+      Wrapper(Kernel* _kernel, GTLCore::ModuleData* _moduleData, llvm::Module* module, int _channels, bool loadShivaWrapper);
       ~Wrapper();
       ImageWrap* wrapImage(GTLCore::AbstractImage* _abstractImage);
     private:
       struct Private;
       Private* const d;
     public:
-      static void fillTypesManager( GTLCore::ModuleData* _module, llvm::Module* llvmModule, GTLCore::TypesManager*, GTLCore::ConvertCenter*, int _channels );
+      virtual void fillTypesManager( GTLCore::TypesManager*, GTLCore::ConvertCenter*);
       static llvm::Function* image_wrap_dataFunction( llvm::Module* _module, const GTLCore::Type* _imageType );
       static llvm::Function* image_wrap_const_dataFunction( llvm::Module* _module, const GTLCore::Type* _imageType );
       static llvm::Function* image_alpha_posFunction( llvm::Module* _module, const GTLCore::Type* _imageType );
+      static llvm::Function* image_color_converter( llvm::Module* _module, const GTLCore::Type* _imageType );
       static llvm::FunctionType* image_wrap_sample_nearest_type( llvm::LLVMContext& context, GTLCore::TypesManager* _typesManager, const GTLCore::Type* _imageType, const GTLCore::Type* _pixelType );
       static llvm::FunctionType* image_wrap_mem_to_vec_float_type( llvm::LLVMContext& context, GTLCore::TypesManager* _typesManager, int _channels );
       static llvm::FunctionType* image_wrap_vec_float_to_mem_type( llvm::LLVMContext& context, GTLCore::TypesManager* _typesManager, int _channels );
@@ -72,7 +75,7 @@ namespace OpenShiva {
        */
       static const GTLCore::Type* vectorType( GTLCore::TypesManager* _typesManager, int _channels );
     private:
-      static void createRegionType( GTLCore::ModuleData* _module, llvm::Module* _llvmModule, GTLCore::TypesManager* _typesManager );
+      static const GTLCore::Type* createRegionType( GTLCore::ModuleData* _module, llvm::Module* _llvmModule, GTLCore::TypesManager* _typesManager );
       static const GTLCore::Type* createPixelType( GTLCore::ModuleData* _module, llvm::Module* llvmModule, GTLCore::TypesManager* _typesManager, GTLCore::ConvertCenter* _convertCenter, const GTLCore::String& _suffix, int _channels );
       static void createImageType( GTLCore::ModuleData* _moduleData, llvm::Module* _llvmModule, GTLCore::TypesManager* _typesManager, const GTLCore::String& _suffix, int _channels, const GTLCore::Type* _pixelType );
   };
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/wrappers/ImageWrap_p.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/wrappers/ImageWrap_p.cpp
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/wrappers/ImageWrap_p.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/wrappers/ImageWrap_p.cpp	2012-01-10 11:12:02.152249093 -0500
@@ -48,4 +48,11 @@ int image_alpha_pos( ImageWrap* _imageWr
   return _imageWrap->image->pixelDescription().alphaPos();
 }
 
+const GTLCore::AbstractColorConverter* image_color_converter( ImageWrap* _imageWrap )
+{
+  SHIVA_ASSERT( _imageWrap );
+  SHIVA_ASSERT( _imageWrap->image );
+  return _imageWrap->image->colorConverter();
+}
+
 }
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/wrappers/ImageWrap_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/wrappers/ImageWrap_p.h
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/wrappers/ImageWrap_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/wrappers/ImageWrap_p.h	2012-01-10 11:12:02.152249093 -0500
@@ -24,6 +24,7 @@
 #include "OpenShiva/Export.h"
 
 namespace GTLCore {
+  class AbstractColorConverter;
   class AbstractImage;
 }
 
@@ -75,6 +76,12 @@ extern "C" {
    * @return the alpha position of an image
    */
   OPENSHIVA_EXPORT int image_alpha_pos( ImageWrap* _imageWrap );
+  /**
+   * @internal
+   * @ingroup OpenShiva
+   * @return the color converter of an image
+   */
+  OPENSHIVA_EXPORT const GTLCore::AbstractColorConverter* image_color_converter( ImageWrap* _imageWrap );
 }
 
 #endif
diff -up OpenGTL-0.9.15.2/OpenShiva/OpenShiva/wrappers/PixelWrap_p.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/OpenShiva/wrappers/PixelWrap_p.h
--- OpenGTL-0.9.15.2/OpenShiva/OpenShiva/wrappers/PixelWrap_p.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/OpenShiva/wrappers/PixelWrap_p.h	2012-01-10 11:12:02.153249085 -0500
@@ -22,6 +22,10 @@
 
 #include "GTLCore/wrappers/StructWrap.h"
 
+namespace GTLCore {
+  class AbstractColorConverter;
+}
+
 //---------------------- WARNING ----------------------//
 // Whenever the following structure is edited,         //
 // it's llvm declaration must be changed too in        //
@@ -34,24 +38,27 @@
  */
 struct PixelWrap {
   STRUCT_HEADER
-  void* data; ///< pointer to the vector of data (do not access)
-  void* coord; ///< pointer to the vector of coordinates (do not access)
+  GTLCore::AbstractColorConverter* colorConverter;
   int alphapos; ///< position of the alpha channel
+  void* coord; ///< pointer to the vector of coordinates (do not access)
+  void* data; ///< pointer to the vector of data (do not access)
   /**
    * Enum used to access an element
    */
   enum PixelIndexes {
-    INDEX_DATA = 0,
-    INDEX_COORD = 1,
-    INDEX_ALPHAPOS = 2
+    INDEX_CONVERTER = 0,
+    INDEX_ALPHAPOS = 1,
+    INDEX_COORD = 2,
+    INDEX_DATA = 3
   };
   /**
    * Position of an element in the structure memory
    */
   enum PixelPoses {
-    POS_DATA = STRUCT_FIRST_ELEMENT + INDEX_DATA,
+    POS_CONVERTER = STRUCT_FIRST_ELEMENT + INDEX_CONVERTER,
+    POS_ALPHAPOS = STRUCT_FIRST_ELEMENT + INDEX_ALPHAPOS,
     POS_COORD = STRUCT_FIRST_ELEMENT + INDEX_COORD,
-    POS_ALPHAPOS = STRUCT_FIRST_ELEMENT + INDEX_ALPHAPOS
+    POS_DATA = STRUCT_FIRST_ELEMENT + INDEX_DATA
   };
 };
 
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenShiva/tests/CMakeLists.txt.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/CMakeLists.txt	2012-01-10 11:12:02.153249085 -0500
@@ -8,3 +8,4 @@ add_subdirectory( vectors )
 add_subdirectory( imagegenerators )
 add_subdirectory( convolution )
 add_subdirectory( raw )
+add_subdirectory( color )
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/color/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/color/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenShiva/tests/color/CMakeLists.txt.95a8c6853b97	2012-01-10 11:12:02.153249085 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tests/color/CMakeLists.txt	2012-01-10 11:12:02.153249085 -0500
@@ -0,0 +1,9 @@
+
+set( TESTS_FILES
+  grayscaliser.shiva
+  )
+
+FOREACH( TEST_FILE ${TESTS_FILES} )
+  ADD_TEST(${TEST_FILE} ${SHIVATESTER} -c ${CMAKE_CURRENT_SOURCE_DIR}/${TEST_FILE} ${OPENGTL_TESTS_DATA}/sources/fontromeu.png ${OPENGTL_TESTS_DATA}/${OPENGTL_TESTS_DATA_RESULTS_DIR}/${TEST_FILE}.png)
+ENDFOREACH( TEST_FILE )
+
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/color/grayscaliser.shiva.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/color/grayscaliser.shiva
--- OpenGTL-0.9.15.2/OpenShiva/tests/color/grayscaliser.shiva.95a8c6853b97	2012-01-10 11:12:02.153249085 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tests/color/grayscaliser.shiva	2012-01-10 11:12:02.153249085 -0500
@@ -0,0 +1,12 @@
+kernel Grayscaliser
+{
+  void evaluatePixel(image img, out pixel result)
+  {
+    color c = img.sampleNearest( result.coord );
+    float g = (c.red + c.green + c.blue) / 3.0;
+    c.red = g;
+    c.green = g;
+    c.blue = g;
+    result = c;
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/imagegenerators/Gradient.shiva.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/imagegenerators/Gradient.shiva
--- OpenGTL-0.9.15.2/OpenShiva/tests/imagegenerators/Gradient.shiva.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/imagegenerators/Gradient.shiva	2012-01-10 11:12:02.153249085 -0500
@@ -1,6 +1,6 @@
 <
   parameters: <
-    color: <
+    col: <
       type: color;
       defaultValue: { 0.5, 0.0, 0.0 };
     >;
@@ -11,11 +11,11 @@ kernel Gradient
   void evaluatePixel(out pixel result)
   {
     float coef = ( result.coord[0] / 800 + result.coord[1] / 600 );
-    float4 v = color * coef;
+    float4 v = float4(col.red, col.green, col.blue, col.opacity) * coef;
     result[0] = v[0];
     result[1] = v[1];
     result[2] = v[2];
-    result[3] = 1.0;
+    result.setOpacity(1.0);
   }
   region generated()
   {
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/imagegenerators/Noise.shiva.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/imagegenerators/Noise.shiva
--- OpenGTL-0.9.15.2/OpenShiva/tests/imagegenerators/Noise.shiva.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/imagegenerators/Noise.shiva	2012-01-10 11:12:02.153249085 -0500
@@ -8,6 +8,6 @@ kernel Noise
     {
       result[i] = frand(x, y, 32);
     }
-    result.setAlpha( 1.0);
+    result.setOpacity( 1.0);
   }
 }
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/imagegenerators/PerlinNoise.shiva.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/imagegenerators/PerlinNoise.shiva
--- OpenGTL-0.9.15.2/OpenShiva/tests/imagegenerators/PerlinNoise.shiva.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/imagegenerators/PerlinNoise.shiva	2012-01-10 11:12:02.154249077 -0500
@@ -32,23 +32,11 @@
       defaultValue: 2;
       maxValue:10;
     >;
-    width: <
-      label: "Image width";
-      type: int;
-      defaultValue: 800;
-      maxValue:10000;
-    >;
-    height: <
-      label: "Image height";
-      type: int;
-      defaultValue: 600;
-      maxValue:10000;
-    >;
   >;
 >;
 kernel PerlinNoise
 {
-  const int RAND_MAX = 2147483647;
+  const int RAND_MAX  = 2147483647;
 
   dependent float grad_x[64];
   dependent float grad_y[64];
@@ -62,12 +50,12 @@ kernel PerlinNoise
   // Pregenerate grad_x, grad_y and permuation
   void evaluateDependents()
   {
-    int seed = 42;
     // Init permutations
     for(int i = 0; i < 64; ++i)
     {
        permutation[i] = i;
     }
+    int seed = 1252;
     for (int i = 0; i < 1000; ++i) {
       int j = rand(seed) % 64;
       int k = rand(seed) % 64;
@@ -78,8 +66,8 @@ kernel PerlinNoise
     // Initialize the gradient table
     for(int i = 0; i < 64; ++i)
     {
-      grad_x[i] = frand(seed) - 0.5;
-      grad_y[i] = frand(seed) - 0.5;
+      grad_x[i] = rand(seed) / float(RAND_MAX) - 0.5;
+      grad_y[i] = rand(seed) / float(RAND_MAX) - 0.5;
       float norm = 1.0 / sqrt(grad_x[i] * grad_x[i] + grad_y[i] * grad_y[i]);
       grad_x[i] *= norm;
       grad_y[i] *= norm;
@@ -90,8 +78,8 @@ kernel PerlinNoise
   {
     float total = 0.0;
     int frequency = 1;
-    float x = (result.coord.x ) / float(width);
-    float y = (result.coord.y ) / float(height);
+    float x = (result.coord.x ) / IMAGE_WIDTH;
+    float y = (result.coord.y ) / IMAGE_HEIGHT;
     x *= xscale;
     y *= yscale;
     for(int oct = 0; oct < octaves; ++oct)
@@ -122,9 +110,4 @@ kernel PerlinNoise
     result = float4(total,total,total,1.0);
   }
   
-  region generated()
-  {
-    region reg1 = { 0, 0, 800, 600 };
-    return reg1;
-  }
 }
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/imagegenerators/PlainGenerator.shiva.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/imagegenerators/PlainGenerator.shiva
--- OpenGTL-0.9.15.2/OpenShiva/tests/imagegenerators/PlainGenerator.shiva.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/imagegenerators/PlainGenerator.shiva	2012-01-10 11:12:02.154249077 -0500
@@ -1,6 +1,6 @@
 <
   parameters: <
-    color: <
+    col: <
       type: color;
       defaultValue: { 0.2, 0.1, 0.3 };
     >;
@@ -10,8 +10,6 @@ kernel PlainGenerator
 {
   void evaluatePixel(out pixel result)
   {
-    result[0] = color[0];
-    result[1] = color[1];
-    result[2] = color[2];
+    result = col;
   }
 }
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/library/TestKernelChannel.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/library/TestKernelChannel.h
--- OpenGTL-0.9.15.2/OpenShiva/tests/library/TestKernelChannel.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/library/TestKernelChannel.h	2012-01-10 11:12:02.154249077 -0500
@@ -19,6 +19,7 @@
 
 #include "OpenShiva/Kernel.h"
 #include "GTLCore/Image.h"
+#include "GTLCore/Type.h"
 
 class TestKernelChannel : public GTLTest::Case {
   public:
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/library/TestKernelProgressReport.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/library/TestKernelProgressReport.h
--- OpenGTL-0.9.15.2/OpenShiva/tests/library/TestKernelProgressReport.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/library/TestKernelProgressReport.h	2012-01-10 11:12:02.154249077 -0500
@@ -18,16 +18,18 @@
  */
 
 #include "GTLCore/ProgressReport.h"
+#include "GTLCore/Type.h"
 
 class TestProgressReport : public GTLCore::ProgressReport {
   public:
-    TestProgressReport() : m_row(0), m_pixel(0)
+    TestProgressReport(bool interrupted) : m_row(0), m_pixel(0), m_interrupted(interrupted)
     {
     }
     void nextRow() { ++m_row; }
     void nextPixel() { ++m_pixel; }
-    bool interrupted() const { return false; }
+    bool interrupted() const { return m_interrupted; }
     int m_row, m_pixel;
+    bool m_interrupted;
 };
 
 class TestKernelProgressReport : public GTLTest::Case {
@@ -47,10 +49,14 @@ class TestKernelProgressReport : public
 }" );
       k.compile();
       GTLTEST_CHECK_REQUIRED(k.isCompiled());
-      TestProgressReport tpr;
+      TestProgressReport tpr(false);
       GTLCore::Image img(100, 50, GTLCore::PixelDescription(GTLCore::Type::Integer8, 4));
       k.evaluatePixels( GTLCore::RegionI(0,0,100,50), std::list< const GTLCore::AbstractImage* >(), &img, &tpr);
       GTLTEST_CHECK_EQUAL(tpr.m_pixel, 5000);
       GTLTEST_CHECK_EQUAL(tpr.m_row, 50);
+      TestProgressReport tpr2(true);
+      k.evaluatePixels( GTLCore::RegionI(0,0,100,50), std::list< const GTLCore::AbstractImage* >(), &img, &tpr2);
+      GTLTEST_CHECK_EQUAL(tpr2.m_pixel, 1);
+      GTLTEST_CHECK_EQUAL(tpr2.m_row, 0);
     }
 };
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/library/TestKernelThreading.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/library/TestKernelThreading.h
--- OpenGTL-0.9.15.2/OpenShiva/tests/library/TestKernelThreading.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/library/TestKernelThreading.h	2012-01-10 11:12:02.154249077 -0500
@@ -19,6 +19,7 @@
 
 #include "GTLTest/Thread.h"
 #include "GTLCore/Image.h"
+#include "GTLCore/Type.h"
 
 #ifdef GTLTEST_HAVE_THREAD
 
@@ -75,6 +76,7 @@ class TestKernelThreading : public GTLTe
       
       MyThreadTCTLKT thread1(&k, &img, &img2, GTLCore::RegionI(0,0,50,50));
       thread1.start();
+      sleep(1);
       MyThreadTCTLKT thread2(&k, &img, &img2, GTLCore::RegionI(0,50,50,50));
       thread2.start();
       MyThreadTCTLKT thread3(&k, &img, &img2, GTLCore::RegionI(50,0,50,50));
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/library/TestOpenShiva.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/library/TestOpenShiva.cpp
--- OpenGTL-0.9.15.2/OpenShiva/tests/library/TestOpenShiva.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/library/TestOpenShiva.cpp	2012-01-10 11:12:02.154249077 -0500
@@ -24,9 +24,6 @@
 
 using namespace GTLCore;
 
-#include "TestLexer.h"
-#include "TestMetadataLexer.h"
-#include "TestMetadataParser.h"
 #include "TestSource.h"
 #include "TestWrapper.h"
 #include "TestKernelThreading.h"
@@ -34,9 +31,6 @@ using namespace GTLCore;
 #include "TestKernelChannel.h"
 
 GTLTEST_MAIN_BEGIN(TestOpenShiva)
-GTLTEST_MAIN_ADD_CASE(TestLexer)
-GTLTEST_MAIN_ADD_CASE(TestMetadataLexer )
-GTLTEST_MAIN_ADD_CASE(TestMetadataParser)
 GTLTEST_MAIN_ADD_CASE(TestSource)
 GTLTEST_MAIN_ADD_CASE(TestWrapper)
 #ifdef GTLTEST_HAVE_THREAD
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/library/TestSource.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/library/TestSource.h
--- OpenGTL-0.9.15.2/OpenShiva/tests/library/TestSource.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/library/TestSource.h	2012-01-10 11:12:02.154249077 -0500
@@ -25,6 +25,14 @@ class TestSource : public GTLTest::Case
     virtual void runTest()
     {
       {
+        OpenShiva::Source source;
+        GTLTEST_CHECK_EQUAL( source.source(), "" );
+        GTLTEST_CHECK_EQUAL( source.name(), "" );
+        GTLTEST_CHECK_EQUAL( source.metadataCompilationMessages().errors().size(), 0 );
+        GTLTEST_CHECK_EQUAL( source.sourceType(), OpenShiva::Source::InvalidSource );
+        GTLTEST_CHECK_EQUAL( source.outputImageType(), OpenShiva::Source::InvalidImage );        
+      }
+      {
         GTLCore::String sourceCodeGenerator = "\
   kernel myGenerator { \
     void evaluatePixel(out pixel result) \
@@ -39,6 +47,14 @@ class TestSource : public GTLTest::Case
         GTLTEST_CHECK_EQUAL( sourceGenerator.outputImageType(), OpenShiva::Source::Image );
         GTLTEST_CHECK_EQUAL( sourceGenerator.countInputImages(), 0 );
         GTLTEST_CHECK_EQUAL( sourceGenerator.inputImageType(0), OpenShiva::Source::InvalidImage );
+        OpenShiva::Source copy(sourceGenerator);
+        GTLTEST_CHECK_EQUAL( copy.source(), sourceCodeGenerator );
+        GTLTEST_CHECK_EQUAL( copy.name(), "myGenerator" );
+        GTLTEST_CHECK_EQUAL( copy.metadataCompilationMessages().errors().size(), 0 );
+        GTLTEST_CHECK_EQUAL( copy.sourceType(), OpenShiva::Source::GeneratorKernel );
+        GTLTEST_CHECK_EQUAL( copy.outputImageType(), OpenShiva::Source::Image );
+        GTLTEST_CHECK_EQUAL( copy.countInputImages(), 0 );
+        GTLTEST_CHECK_EQUAL( copy.inputImageType(0), OpenShiva::Source::InvalidImage );
       }
       {
         GTLCore::String sourceCodeFilter = "\
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/library/TestWrapper.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/library/TestWrapper.h
--- OpenGTL-0.9.15.2/OpenShiva/tests/library/TestWrapper.h.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/library/TestWrapper.h	2012-01-10 11:12:02.155249069 -0500
@@ -21,6 +21,7 @@
 #include <GTLCore/PixelDescription.h>
 #include <GTLCore/Region.h>
 #include <OpenShiva/Kernel.h>
+#include "GTLCore/Type.h"
 
 class TestCallConstData : public GTLTest::Case {
   public:
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/misc/clamp.shiva.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/misc/clamp.shiva
--- OpenGTL-0.9.15.2/OpenShiva/tests/misc/clamp.shiva.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/misc/clamp.shiva	2012-01-10 11:12:02.155249069 -0500
@@ -5,7 +5,6 @@ kernel Gradient
     result[0] = 1.5;
     result[1] = -0.5;
     result[2] = 127.0 / 255.0;
-    result[3] = 1.0;
   }
   region generated()
   {
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/misc/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/misc/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenShiva/tests/misc/CMakeLists.txt.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/misc/CMakeLists.txt	2012-01-10 11:12:02.155249069 -0500
@@ -7,4 +7,10 @@ FOREACH( TEST_FILE ${TESTS_FILES} )
   ADD_TEST(${TEST_FILE} ${SHIVATESTER} -c ${CMAKE_CURRENT_SOURCE_DIR}/${TEST_FILE} ${OPENGTL_TESTS_DATA}/${OPENGTL_TESTS_DATA_RESULTS_DIR}/${TEST_FILE}.png)
 ENDFOREACH( TEST_FILE )
 
+set( TESTS_FILES
+  overideconstant.shiva
+  )
 
+FOREACH( TEST_FILE ${TESTS_FILES} )
+  ADD_TEST(${TEST_FILE} ${SHIVATESTER} ${CMAKE_CURRENT_SOURCE_DIR}/${TEST_FILE})
+ENDFOREACH( TEST_FILE )
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/misc/overideconstant.shiva.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/misc/overideconstant.shiva
--- OpenGTL-0.9.15.2/OpenShiva/tests/misc/overideconstant.shiva.95a8c6853b97	2012-01-10 11:12:02.155249069 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tests/misc/overideconstant.shiva	2012-01-10 11:12:02.155249069 -0500
@@ -0,0 +1,13 @@
+kernel OverideConstant
+{
+  const float PI = 0.1;
+  void evaluatePixel(out pixel result)
+  {
+  }
+  int runTest()
+  {
+    if( abs(PI - 3.14) <= 0.1 ) return 2;
+    if( PI != 0.1 ) return 1;
+    return 0;
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/parse/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/parse/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenShiva/tests/parse/CMakeLists.txt.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/parse/CMakeLists.txt	2012-01-10 11:12:02.155249069 -0500
@@ -10,6 +10,7 @@ set( TESTS_FILES
   cstyleconvertinexpressions.shiva
   hints.shiva
   minimwidthheight.shiva
+  externalconstant.shiva
   )
 
 FOREACH( TEST_FILE ${TESTS_FILES} )
@@ -20,7 +21,10 @@ set( TESTS_FAIL_FILES
   samefunctionsignature.shiva
   dependentpixel.shiva
   constpixel.shiva
+  constvalueparam.shiva
+  constvaluedependent.shiva
   metadatargb.shiva
+  float2_three_init.shiva
   )
 
 FOREACH( TEST_FILE ${TESTS_FAIL_FILES} )
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/parse/constvaluedependent.shiva.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/parse/constvaluedependent.shiva
--- OpenGTL-0.9.15.2/OpenShiva/tests/parse/constvaluedependent.shiva.95a8c6853b97	2012-01-10 11:12:02.155249069 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tests/parse/constvaluedependent.shiva	2012-01-10 11:12:02.155249069 -0500
@@ -0,0 +1,7 @@
+kernel shouldFail {
+  dependent float value;
+  const float val = value * 0.5;
+  void evaluatePixel(output pixel p) {
+    p = p * val;
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/parse/constvalueparam.shiva.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/parse/constvalueparam.shiva
--- OpenGTL-0.9.15.2/OpenShiva/tests/parse/constvalueparam.shiva.95a8c6853b97	2012-01-10 11:12:02.155249069 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tests/parse/constvalueparam.shiva	2012-01-10 11:12:02.155249069 -0500
@@ -0,0 +1,15 @@
+<
+  parameters: <
+    value: <
+      type: float;
+      defaultValue: 1.0;
+    >;
+  >;
+>;
+
+kernel shouldFail {
+  const float val = value * 0.5;
+  void evaluatePixel(output pixel p) {
+    p = p * val;
+  }
+}
\ No newline at end of file
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/parse/externalconstant.shiva.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/parse/externalconstant.shiva
--- OpenGTL-0.9.15.2/OpenShiva/tests/parse/externalconstant.shiva.95a8c6853b97	2012-01-10 11:12:02.155249069 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tests/parse/externalconstant.shiva	2012-01-10 11:12:02.155249069 -0500
@@ -0,0 +1,7 @@
+kernel externalconstant
+{
+  const float PI2 = 2 * PI;
+  void evaluatePixel(output pixel result)
+  {
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/parse/float2_three_init.shiva.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/parse/float2_three_init.shiva
--- OpenGTL-0.9.15.2/OpenShiva/tests/parse/float2_three_init.shiva.95a8c6853b97	2012-01-10 11:12:02.155249069 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tests/parse/float2_three_init.shiva	2012-01-10 11:12:02.155249069 -0500
@@ -0,0 +1,7 @@
+kernel float2_three_init {
+    void evaluatePixel(output pixel p)
+    {
+        float2 origin = float2(1.0, 2.0, 3.0);
+    }
+
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/stdlib/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/stdlib/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenShiva/tests/stdlib/CMakeLists.txt.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/stdlib/CMakeLists.txt	2012-01-10 11:12:02.155249069 -0500
@@ -5,6 +5,8 @@ set( TESTS_FILES
   length.shiva
   ceil.shiva
   fract.shiva
+  constants.shiva
+  rand.shiva
   )
 
 FOREACH( TEST_FILE ${TESTS_FILES} )
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/stdlib/constants.shiva.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/stdlib/constants.shiva
--- OpenGTL-0.9.15.2/OpenShiva/tests/stdlib/constants.shiva.95a8c6853b97	2012-01-10 11:12:02.156249061 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tests/stdlib/constants.shiva	2012-01-10 11:12:02.156249061 -0500
@@ -0,0 +1,17 @@
+kernel LengthTestKernel
+{
+  void evaluatePixel(out pixel result)
+  {
+  }
+  bool nearlyEqual( float v1, float v2)
+  {
+    return abs(v1 - v2) < 1e-5;
+  }
+  int runTest()
+  {
+    int count = 0;
+    if( not nearlyEqual( PI, 3.14159265358979323846 ) ) ++count;
+    if( RAND_MAX != 16777215 ) ++count;
+    return count;
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/stdlib/rand.shiva.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/stdlib/rand.shiva
--- OpenGTL-0.9.15.2/OpenShiva/tests/stdlib/rand.shiva.95a8c6853b97	2012-01-10 11:12:02.156249061 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tests/stdlib/rand.shiva	2012-01-10 11:12:02.156249061 -0500
@@ -0,0 +1,17 @@
+kernel Rand
+{
+  void evaluatePixel(out pixel result)
+  {
+  }
+  int runTest()
+  {
+    int count = 0;
+    unsigned int seed = 1242;
+    if( rand(seed) != 1617191 ) ++count;
+    if( rand(seed) != 12400644 ) ++count;
+    if( rand(seed) != 634378 ) ++count;
+    if( rand(seed) != 15308103 ) ++count;
+    if( rand(seed) != 2297633 ) ++count;
+    return count;
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/structures/region.shiva.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/structures/region.shiva
--- OpenGTL-0.9.15.2/OpenShiva/tests/structures/region.shiva.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/structures/region.shiva	2012-01-10 11:12:02.156249061 -0500
@@ -67,6 +67,23 @@ kernel RegionTestKernel
       if( reg1.columns != 2 ) ++count;
       if( reg1.rows != 3 ) ++count;
     }
+    {
+      region reg1 = { 0, 1, 2, 3 };
+      reg1.translate(2,-1);
+      if( reg1.x != 2 ) ++count;
+      if( reg1.y != 0 ) ++count;
+      if( reg1.columns != 2 ) ++count;
+      if( reg1.rows != 3 ) ++count;
+      region reg2 = reg1.translated(2,-1);
+      if( reg1.x != 2 ) ++count;
+      if( reg1.y != 0 ) ++count;
+      if( reg1.columns != 2 ) ++count;
+      if( reg1.rows != 3 ) ++count;
+      if( reg2.x != 4 ) ++count;
+      if( reg2.y != -1 ) ++count;
+      if( reg2.columns != 2 ) ++count;
+      if( reg2.rows != 3 ) ++count;
+    }
     return count;
   }
 }
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/vectors/arraytovector.shiva.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/vectors/arraytovector.shiva
--- OpenGTL-0.9.15.2/OpenShiva/tests/vectors/arraytovector.shiva.95a8c6853b97	2012-01-10 11:12:02.156249061 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tests/vectors/arraytovector.shiva	2012-01-10 11:12:02.156249061 -0500
@@ -0,0 +1,20 @@
+kernel MyKernel
+{
+  void evaluatePixel(output pixel result)
+  {
+  }
+  int runTest()
+  {
+    int count = 0;
+    float arr[4] = {2.0, 1.0, 4.0, -12.0};
+    float4 v4 = arr;
+
+
+    if( v4[0] != 2.0 ) ++count;
+    if( v4[1] != 1.0 ) ++count;
+    if( v4[2] != 4.0 ) ++count;
+    if( v4[3] != -12.0 ) ++count;
+    
+    return count;
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/tests/vectors/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tests/vectors/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenShiva/tests/vectors/CMakeLists.txt.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tests/vectors/CMakeLists.txt	2012-01-10 11:12:02.156249061 -0500
@@ -1,5 +1,6 @@
 
 set( TESTS_FILES
+  arraytovector.shiva
   creation.shiva
   copy.shiva
   copy4.shiva
diff -up OpenGTL-0.9.15.2/OpenShiva/tools/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tools/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenShiva/tools/CMakeLists.txt.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tools/CMakeLists.txt	2012-01-10 11:12:02.156249061 -0500
@@ -1,5 +1,5 @@
 add_subdirectory(compiler)
 add_subdirectory(interpreter)
 add_subdirectory(tester)
-
-add_subdirectory(shivainfo)
\ No newline at end of file
+add_subdirectory(shivainfo)
+add_subdirectory(shivanimator)
diff -up OpenGTL-0.9.15.2/OpenShiva/tools/compiler/ShivaC.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tools/compiler/ShivaC.cpp
--- OpenGTL-0.9.15.2/OpenShiva/tools/compiler/ShivaC.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tools/compiler/ShivaC.cpp	2012-01-10 11:12:02.156249061 -0500
@@ -28,6 +28,7 @@
 // OpenShiva Headers
 #include <OpenShiva/Kernel.h>
 #include <OpenShiva/Version.h>
+#include <GTLFragment/LibrariesManager.h>
 #include <OpenShiva/LibrariesManager.h>
 
 void printVersion()
@@ -42,7 +43,6 @@ void printHelp()
   std::cout << std::endl;
   std::cout << "Options : " << std::endl;
   std::cout << "  -S --asm-source         print the assembly source code generated" << std::endl;
-  std::cout << "  -C --c-source           print the source code as C" << std::endl;
   std::cout << "  -o --output [filename]  save the output to a file" << std::endl;
   std::cout << "  -c --channels [count]   set the number of channels of the output" << std::endl;
   //   std::cout << "  -L --module-dir   add a location where to find modules" << std::endl;
@@ -86,6 +86,7 @@ int main(int argc, char** argv)
         return EXIT_FAILURE;
       } else {
         ++ai;
+        GTLFragment::LibrariesManager::instance()->addDirectory(argv[ai]);
         OpenShiva::LibrariesManager::instance()->addDirectory(argv[ai]);
       }
     } else if(ARG_IS("-c", "--channels")) {
diff -up OpenGTL-0.9.15.2/OpenShiva/tools/interpreter/Shiva.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tools/interpreter/Shiva.cpp
--- OpenGTL-0.9.15.2/OpenShiva/tools/interpreter/Shiva.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tools/interpreter/Shiva.cpp	2012-01-10 11:12:02.156249061 -0500
@@ -24,14 +24,15 @@
 #include <cstring>
 
 // GTLCore Headers
-#include <GTLCore/PixelDescription.h>
 #include <GTLCore/CompilationMessages.h>
 #include <GTLCore/Debug.h>
-#include <GTLCore/Value.h>
+#include <GTLCore/Image.h>
+#include <GTLCore/Macros_p.h>
+#include <GTLCore/PixelDescription.h>
 #include <GTLCore/Region.h>
 #include <GTLCore/Type.h>
-#include <GTLCore/Macros_p.h>
 #include <GTLCore/Utils_p.h>
+#include <GTLCore/Value.h>
 
 // GTLImageIO Headers
 #include <GTLImageIO/ImageDC.h>
@@ -39,10 +40,10 @@
 
 // OpenShiva Headers
 #include <OpenShiva/Debug.h>
-#include <GTLCore/Image.h>
 #include <OpenShiva/Kernel.h>
 #include <OpenShiva/Version.h>
-#include <OpenShiva/LibrariesManager.h>
+#include <GTLFragment/LibrariesManager.h>
+#include <GTLCore/ColorConverters.h>
 
 void printVersion()
 {
@@ -102,7 +103,7 @@ int main(int argc, char** argv)
         return EXIT_FAILURE;
       } else {
         ++ai;
-        OpenShiva::LibrariesManager::instance()->addDirectory(argv[ai]);
+        GTLFragment::LibrariesManager::instance()->addDirectory(argv[ai]);
       }
     } else if(ARG_IS("-a", "--alpha")) {
       if( ai == argc )
@@ -262,7 +263,6 @@ int main(int argc, char** argv)
     if(not p.isCompiled())
     {
       std::cerr << "Error: " << std::endl << p.compilationMessages().toString() << std::endl;
-      while(true) {}
       return EXIT_FAILURE;
     }
     
@@ -279,7 +279,7 @@ int main(int argc, char** argv)
         region += p.changed( *it, i, inputDOD );
       }
     }
-    GTLCore::Image image( region.columns(), region.rows(), pixel );
+    GTLCore::Image image( region.columns(), region.rows(), pixel, GTLCore::ColorConverters::instance()->guess(pixel) );
     p.evaluatePixels( region.toRegionI(), images, &image );
     if( showAssembly )
     {
diff -up OpenGTL-0.9.15.2/OpenShiva/tools/shivainfo/ShivaInfo.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tools/shivainfo/ShivaInfo.cpp
--- OpenGTL-0.9.15.2/OpenShiva/tools/shivainfo/ShivaInfo.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tools/shivainfo/ShivaInfo.cpp	2012-01-10 11:12:02.157249052 -0500
@@ -28,7 +28,7 @@
 // OpenShiva Headers
 #include <OpenShiva/Source.h>
 #include <OpenShiva/Version.h>
-#include <OpenShiva/Metadata.h>
+#include <GTLFragment/Metadata.h>
 
 #define ARG_IS(a,b) argv[ai] == GTLCore::String(a) or argv[ai] == GTLCore::String(b)
 
diff -up OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/CMakeLists.txt.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/CMakeLists.txt
--- OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/CMakeLists.txt.95a8c6853b97	2012-01-10 11:12:02.157249052 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/CMakeLists.txt	2012-01-10 11:12:02.157249052 -0500
@@ -0,0 +1,16 @@
+include_directories( ${LLVM_INCLUDE_DIR} ${CMAKE_SOURCE_DIR} )
+
+add_definitions( "-D__STDC_LIMIT_MACROS" )
+add_definitions( "-D__STDC_CONSTANT_MACROS" )
+
+set(shivanimator_SRCS
+  ShivAnimator.cpp
+  Parser.cpp
+  ProgressBar.cpp
+    )
+
+add_definitions( -DCOUMPONENT_NAME=\"\\\"ShivAnimator\\\"\" )
+
+add_executable(shivanimator ${shivanimator_SRCS})
+target_link_libraries(shivanimator OpenShiva GTLImageIO )
+install( TARGETS shivanimator ${INSTALL_TARGETS_DEFAULT_ARGS} )
diff -up OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/examples/moire.shivanimation.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/examples/moire.shivanimation
--- OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/examples/moire.shivanimation.95a8c6853b97	2012-01-10 11:12:02.157249052 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/examples/moire.shivanimation	2012-01-10 11:12:02.157249052 -0500
@@ -0,0 +1,10 @@
+# Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+# All use of this files is permited without any condition.
+Version = 0
+Kernel = Moire
+t = Linear 10.0 0
+xcenter = Sinusoidal 10.0 0.0
+ycenter = Sinusoidal 10.0 5.0
+Start = 0
+End = 10
+Framerate = 10
\ No newline at end of file
diff -up OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/examples/perlinnoise.shivanimation.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/examples/perlinnoise.shivanimation
--- OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/examples/perlinnoise.shivanimation.95a8c6853b97	2012-01-10 11:12:02.157249052 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/examples/perlinnoise.shivanimation	2012-01-10 11:12:02.157249052 -0500
@@ -0,0 +1,8 @@
+# Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+# All use of this files is permited without any condition.
+Version = 0
+Kernel = PerlinNoise
+factor = Linear 10.0 0
+Start = 0
+End = 10
+Framerate = 10
\ No newline at end of file
diff -up OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/Parser.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/Parser.cpp
--- OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/Parser.cpp.95a8c6853b97	2012-01-10 11:12:02.157249052 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/Parser.cpp	2012-01-10 11:12:02.157249052 -0500
@@ -0,0 +1,171 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "Parser.h"
+
+#include <fstream>
+
+#include <GTLCore/CompilationMessages.h>
+#include <GTLCore/Debug.h>
+#include <GTLCore/TimeController.h>
+#include <GTLCore/TimeMachine.h>
+
+#include <OpenShiva/Kernel.h>
+#include <GTLFragment/Metadata.h>
+#include <OpenShiva/SourcesCollection.h>
+
+using namespace shivanimator;
+
+Parser::Parser() : m_timeMachine(new GTLCore::TimeMachine), m_kernel(0), m_start(0), m_end(10), m_frameRate(20)
+{
+}
+
+Parser::~Parser()
+{
+  delete m_timeMachine;
+  delete m_kernel;
+}
+
+GTLCore::TimeMachine* Parser::timeMachine()
+{
+  return m_timeMachine;
+}
+
+OpenShiva::Kernel* Parser::kernel()
+{
+  return m_kernel;
+}
+
+#define CHECK_ELEMENTS_SIZE_EQUAL(_n) \
+  if(elements.size() != _n) \
+  { \
+    std::cerr << line << ": invalid number of elements for '" << elements[0] << "'" << std::endl; \
+    return false; \
+  }
+
+
+bool Parser::parse(const GTLCore::String& filename)
+{
+  std::ifstream in;
+  in.open(filename.c_str() );
+  if(not in.is_open())
+  {
+    std::cerr << "Failed to open file: " << filename << std::endl;
+    return false;
+  }
+  std::string str;
+  std::getline(in,str);
+  int line = 0;
+  while ( in ) {
+    ++line;
+    GTLCore::String line = str;
+    if(line[0] != '#')
+    {
+      std::vector<GTLCore::String> elements = line.split("= ");
+      GTL_DEBUG("There are " << elements.size() << " in" << str );
+      
+      GTLCore::String name = elements[0];
+      if(name == "Version")
+      { // Ignored for now
+      } else if(name == "Kernel") {
+        CHECK_ELEMENTS_SIZE_EQUAL(2);
+        OpenShiva::SourcesCollection collection;
+        OpenShiva::Source source = collection.source(elements[1]);
+        if(source.sourceType() == OpenShiva::Source::InvalidSource)
+        {
+          std::cerr << line << ": unknown kernel '" << elements[1] << "'" << std::endl;
+          return false;
+        }
+        m_kernel = new OpenShiva::Kernel(4);
+        m_kernel->setSource(source);
+        m_kernel->compile();
+        if(not m_kernel->isCompiled())
+        {
+          std::cerr << "Compilation failure in kernel '" << elements[1] << "'" << std::endl;
+          std::cerr << m_kernel->compilationMessages().toString() << std::endl;
+          return false;
+        }
+      } else if(name == "Start") {
+        CHECK_ELEMENTS_SIZE_EQUAL(2);
+        m_start = elements[1].toFloat();
+      } else if(name == "End") {
+        CHECK_ELEMENTS_SIZE_EQUAL(2);
+        m_end = elements[1].toFloat();
+      } else if(name == "Framerate") {
+        CHECK_ELEMENTS_SIZE_EQUAL(2);
+        m_frameRate = elements[1].toInt();
+      } else {
+        if(not m_kernel) {
+          std::cerr << line << ": no kernel defined" << std::endl;
+          return false;
+        }
+        if(elements.size() < 2)
+        {
+          std::cerr << line << ": invalid number of elements for '" << elements[0] << "'" << std::endl;
+          return false;
+        }
+        // Get the entry
+        const GTLCore::Metadata::ParameterEntry* entry = m_kernel->metadata()->parameter(elements[0]);
+        if(not entry)
+        {
+          std::cerr << line << ": no such parameter for kernel '" << m_kernel->name() << "'" << std::endl;
+          return false;
+        }
+        // Check the TimeController
+        const GTLCore::TimeController* controller = 0;
+        if(elements[1] == "Linear")
+        {
+          CHECK_ELEMENTS_SIZE_EQUAL(4);
+          controller = new GTLCore::LinearTimeController(elements[2].toFloat(), elements[3].toInt());
+        } else if(elements[1] == "Sinusoidal")
+        {
+          CHECK_ELEMENTS_SIZE_EQUAL(4);
+          controller = new GTLCore::SinusoidalTimeController(elements[2].toFloat(), elements[3].toFloat());
+        }
+        if(not controller)
+        {
+          std::cerr << line << ": unknow time controller '" << elements[1] << "'" << std::endl;
+          return false;
+        }
+        m_timeMachine->startControlling(entry, controller);
+      }
+    }
+    std::getline(in,str);
+  }
+  if(not m_kernel) {
+    std::cerr << line << ": no kernel defined" << std::endl;
+    return false;
+  }
+  return true;
+}
+
+double Parser::start() const
+{
+  return m_start;
+}
+
+double Parser::end() const
+{
+  return m_end;
+}
+
+int Parser::frameRate() const
+{
+  return m_frameRate;
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/Parser.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/Parser.h
--- OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/Parser.h.95a8c6853b97	2012-01-10 11:12:02.157249052 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/Parser.h	2012-01-10 11:12:02.157249052 -0500
@@ -0,0 +1,47 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include <GTLCore/String.h>
+
+namespace GTLCore {
+  class TimeMachine;
+}
+
+namespace OpenShiva {
+  class Kernel;
+}
+
+namespace shivanimator {
+  class Parser {
+    public:
+      Parser();
+      ~Parser();
+      GTLCore::TimeMachine* timeMachine();
+      OpenShiva::Kernel* kernel();
+      bool parse(const GTLCore::String& filename);
+      double start() const;
+      double end() const;
+      int frameRate() const;
+    private:
+      GTLCore::TimeMachine* m_timeMachine;
+      OpenShiva::Kernel* m_kernel;
+      double m_start, m_end;
+      int m_frameRate;
+  };
+}
\ No newline at end of file
diff -up OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/ProgressBar.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/ProgressBar.cpp
--- OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/ProgressBar.cpp.95a8c6853b97	2012-01-10 11:12:02.157249052 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/ProgressBar.cpp	2012-01-10 11:12:02.157249052 -0500
@@ -0,0 +1,77 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "ProgressBar.h"
+
+#include <iomanip>
+#include <iostream>
+#include <sstream>
+
+using namespace shivanimator;
+
+ProgressBar::ProgressBar(GTLCore::String title, unsigned int cptMax, unsigned int barWidth) :
+  m_barWidth(barWidth - title.length() - 1),
+  m_cpt(0),
+  m_cptMax(cptMax),
+  m_title(title),
+  m_time(llvm::sys::TimeValue::now())
+{
+  bar();
+}
+
+ProgressBar::~ProgressBar()
+{
+  std::cout << std::endl;
+}
+
+void ProgressBar::next()
+{
+  ++m_cpt;
+  bar();
+}
+
+void ProgressBar::bar()
+{
+  double d = double(m_cpt)/double(m_cptMax);
+
+  std::ostringstream buf;
+
+  buf << m_title << " " << std::setw(3) << int(100*d) << "%[";
+  unsigned int i = 0;
+  while (i < d*m_barWidth) {
+    buf << "=";
+    ++i;
+  }
+  if (i<m_barWidth) {
+    buf << ">";
+    ++i;
+  }
+  while (i<m_barWidth) {
+    buf << " ";
+    ++i;
+  }
+  buf << "] ";
+
+  llvm::sys::TimeValue now = llvm::sys::TimeValue::now();
+  now -= m_time;
+  buf << now.seconds() << " s";
+  
+  std::cout << "\r" << buf.str() << std::flush;
+
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/ProgressBar.h.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/ProgressBar.h
--- OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/ProgressBar.h.95a8c6853b97	2012-01-10 11:12:02.157249052 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/ProgressBar.h	2012-01-10 11:12:02.157249052 -0500
@@ -0,0 +1,48 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include <GTLCore/String.h>
+
+#ifdef LLVM_27_OR_28
+#include <llvm/System/TimeValue.h>
+#else
+#include <llvm/Support/TimeValue.h>
+#endif
+
+namespace shivanimator {
+  class ProgressBar {
+
+  public:
+
+    ProgressBar(GTLCore::String title, unsigned int cptMax, unsigned int barWidth = 60);
+    ~ProgressBar();
+
+    void next();
+
+  private:
+
+    unsigned int m_barWidth;
+    unsigned int m_cpt, m_cptMax;
+    GTLCore::String m_title;
+    llvm::sys::TimeValue m_time;
+
+    void bar();
+
+  }; // class ProgressBar
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/ShivAnimator.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/ShivAnimator.cpp
--- OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/ShivAnimator.cpp.95a8c6853b97	2012-01-10 11:12:02.157249052 -0500
+++ OpenGTL-0.9.15.2/OpenShiva/tools/shivanimator/ShivAnimator.cpp	2012-01-10 11:12:02.157249052 -0500
@@ -0,0 +1,141 @@
+/*
+ *  Copyright (c) 2010 Cyrille Berger <cberger@cberger.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation;
+ * either version 2, or (at your option) any later version of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+// C++ Headers
+#include <iostream>
+#include <fstream>
+#include <cstdlib>
+
+// GTLCore Headers
+#include <GTLCore/Debug.h>
+#include <GTLCore/Image.h>
+#include <GTLCore/PixelDescription.h>
+#include <GTLCore/TimeMachine.h>
+#include <GTLCore/Type.h>
+#include <GTLCore/Value.h>
+
+// GTLImageIO Headers
+#include <GTLImageIO/ImageDC.h>
+#include <GTLImageIO/ImageDCRegistry.h>
+
+// OpenShiva Headers
+#include <OpenShiva/Kernel.h>
+#include <OpenShiva/Version.h>
+
+// ShivAnimator Headers
+#include "Parser.h"
+#include "ProgressBar.h"
+
+void printVersion()
+{
+  std::cout << OpenShiva::LibraryShortName() << " - " << OpenShiva::LibraryName() << " - " << OpenShiva::LibraryVersionString() << std::endl;
+  std::cout << OpenShiva::LibraryCopyright() << std::endl;
+  std::cout << "Shiva Version : " << OpenShiva::LanguageVersion() << std::endl;
+}
+
+void printHelp()
+{
+  std::cout << "Usage : shivanimator [option] fileName.shivanimation output" << std::endl;
+  std::cout << "output must be a pattern of file that will be used to save the animation" << std::endl;
+  std::cout << "For instance: output%04d.png will save the animation in output0000.png, output0001.png..." << std::endl;
+  std::cout << std::endl;
+  std::cout << "Options : " << std::endl;
+  std::cout << std::endl;
+  std::cout << "  -h --help               print this message" << std::endl;
+  std::cout << "  -v --version            print the version information" << std::endl;
+}
+#define ARG_IS(a,b) argv[ai] == GTLCore::String(a) or argv[ai] == GTLCore::String(b)
+
+int main(int argc, char** argv)
+{
+  GTLCore::String input = "";
+  GTLCore::String output = "";
+  for(int ai = 1; ai < argc; ai++)
+  {
+    if(ARG_IS("-h","--help"))
+    {
+      printHelp();
+      return EXIT_SUCCESS;
+    } else if(ARG_IS("-v","--version"))
+    {
+      printVersion();
+      return EXIT_SUCCESS;
+    } else if(input.isEmpty()) {
+      input = argv[ai];
+    } else {
+      output = argv[ai];
+    }
+  }
+  if(input.isEmpty() or output.isEmpty())
+  {
+    printHelp();
+    return EXIT_SUCCESS;
+  }
+  
+  int width = 800;
+  int height = 600;
+  
+  shivanimator::Parser parser;
+  if(parser.parse(input))
+  {
+    OpenShiva::Kernel* kernel = parser.kernel();
+    GTL_ASSERT(kernel);
+    GTL_DEBUG("Animate from " << parser.start() << " to " << parser.end() << " at " << parser.frameRate() << " images/s");
+    double t = parser.start();
+    double inct = 1.0 / parser.frameRate();
+    int i = 0;
+    GTLCore::PixelDescription pixel( GTLCore::Type::UnsignedInteger8, 4 );
+    GTLCore::Image image( width, height, pixel );
+    shivanimator::ProgressBar* bar = new shivanimator::ProgressBar(kernel->name(), (parser.end() - parser.start())/inct + 1);
+    while(t < parser.end())
+    {
+      kernel->setParameters(parser.timeMachine()->parametersAt(t));
+      kernel->setParameter(OpenShiva::Kernel::IMAGE_WIDTH, GTLCore::Value((float)width));
+      kernel->setParameter(OpenShiva::Kernel::IMAGE_HEIGHT, GTLCore::Value((float)height));
+      
+      // Evaluate pixeles
+      kernel->evaluatePixels( GTLCore::RegionI(0,0,width, height), std::list<const GTLCore::AbstractImage*>(), &image );
+
+      // Generate output name
+      char buffer[255];
+      sprintf(buffer, output.c_str(), i);
+      GTLCore::String outputFileName(buffer);
+      
+      // Encode image
+      const GTLImageIO::ImageDC* encoder = GTLImageIO::ImageDCRegistry::instance()->encoder( outputFileName );
+      if( not encoder )
+      {
+        std::cerr << "Can't find encoder for " << outputFileName << std::endl;
+        return EXIT_FAILURE;
+      }
+      GTLCore::String errMsg;
+      if( not encoder->encode( &image, image.boundingBox(), outputFileName, 0, &errMsg ) )
+      {
+        std::cerr << "Can't encode " << outputFileName << " : " << errMsg << std::endl;
+        return EXIT_FAILURE;
+      }
+      ++i;
+      bar->next();
+      t += inct;
+    }
+    delete bar;
+  } else {
+    return EXIT_FAILURE;
+  }
+}
diff -up OpenGTL-0.9.15.2/OpenShiva/tools/tester/ShivaTester.cpp.95a8c6853b97 OpenGTL-0.9.15.2/OpenShiva/tools/tester/ShivaTester.cpp
--- OpenGTL-0.9.15.2/OpenShiva/tools/tester/ShivaTester.cpp.95a8c6853b97	2011-10-30 10:32:09.000000000 -0400
+++ OpenGTL-0.9.15.2/OpenShiva/tools/tester/ShivaTester.cpp	2012-01-10 11:12:02.158249043 -0500
@@ -37,7 +37,7 @@
 // GTLImageIO Headers
 #include <GTLImageIO/ImageDC.h>
 #include <GTLImageIO/ImageDCRegistry.h>
-#include <OpenShiva/LibrariesManager.h>
+#include <GTLFragment/LibrariesManager.h>
 #include <GTLCore/CompilationMessages.h>
 
 void printVersion()
@@ -90,7 +90,7 @@ int main(int argc, char** argv)
         return EXIT_FAILURE;
       } else {
         ++ai;
-        OpenShiva::LibrariesManager::instance()->addDirectory(argv[ai]);
+        GTLFragment::LibrariesManager::instance()->addDirectory(argv[ai]);
       }
     } else {
       fileNames.push_back( argv[ai] );
