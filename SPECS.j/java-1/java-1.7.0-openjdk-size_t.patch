diff -up openjdk/hotspot/src/share/vm/compiler/methodLiveness.cpp.sav openjdk/hotspot/src/share/vm/compiler/methodLiveness.cpp
--- openjdk/hotspot/src/share/vm/compiler/methodLiveness.cpp.sav	2012-02-14 16:11:12.000000000 -0500
+++ openjdk/hotspot/src/share/vm/compiler/methodLiveness.cpp	2012-03-09 14:48:08.223867826 -0500
@@ -572,15 +572,15 @@ void MethodLiveness::print_times() {
 
 
 MethodLiveness::BasicBlock::BasicBlock(MethodLiveness *analyzer, int start, int limit) :
-         _gen((size_t*)analyzer->arena()->Amalloc(BytesPerWord * analyzer->bit_map_size_words()),
+         _gen((BitMap::bm_word_t*)analyzer->arena()->Amalloc(BytesPerWord * analyzer->bit_map_size_words()),
                          analyzer->bit_map_size_bits()),
-         _kill((size_t*)analyzer->arena()->Amalloc(BytesPerWord * analyzer->bit_map_size_words()),
+         _kill((BitMap::bm_word_t*)analyzer->arena()->Amalloc(BytesPerWord * analyzer->bit_map_size_words()),
                          analyzer->bit_map_size_bits()),
-         _entry((size_t*)analyzer->arena()->Amalloc(BytesPerWord * analyzer->bit_map_size_words()),
+         _entry((BitMap::bm_word_t*)analyzer->arena()->Amalloc(BytesPerWord * analyzer->bit_map_size_words()),
                          analyzer->bit_map_size_bits()),
-         _normal_exit((size_t*)analyzer->arena()->Amalloc(BytesPerWord * analyzer->bit_map_size_words()),
+         _normal_exit((BitMap::bm_word_t*)analyzer->arena()->Amalloc(BytesPerWord * analyzer->bit_map_size_words()),
                          analyzer->bit_map_size_bits()),
-         _exception_exit((size_t*)analyzer->arena()->Amalloc(BytesPerWord * analyzer->bit_map_size_words()),
+         _exception_exit((BitMap::bm_word_t*)analyzer->arena()->Amalloc(BytesPerWord * analyzer->bit_map_size_words()),
                          analyzer->bit_map_size_bits()),
          _last_bci(-1) {
   _analyzer = analyzer;
@@ -998,7 +998,7 @@ bool MethodLiveness::BasicBlock::merge_e
 }
 
 MethodLivenessResult MethodLiveness::BasicBlock::get_liveness_at(ciMethod* method, int bci) {
-  MethodLivenessResult answer(NEW_RESOURCE_ARRAY(size_t, _analyzer->bit_map_size_words()),
+  MethodLivenessResult answer(NEW_RESOURCE_ARRAY(BitMap::bm_word_t, _analyzer->bit_map_size_words()),
                 _analyzer->bit_map_size_bits());
   answer.set_is_valid();
 
diff -up openjdk/hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/compactibleFreeListSpace.cpp.sav openjdk/hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/compactibleFreeListSpace.cpp
--- openjdk/hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/compactibleFreeListSpace.cpp.sav	2012-02-14 16:11:12.000000000 -0500
+++ openjdk/hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/compactibleFreeListSpace.cpp	2012-03-09 14:48:08.223867826 -0500
@@ -2656,7 +2656,7 @@ void CFLS_LAB::get_from_global_pool(size
   if (ResizeOldPLAB && CMSOldPLABResizeQuicker) {
     size_t multiple = _num_blocks[word_sz]/(CMSOldPLABToleranceFactor*CMSOldPLABNumRefills*n_blks);
     n_blks +=  CMSOldPLABReactivityFactor*multiple*n_blks;
-    n_blks = MIN2(n_blks, CMSOldPLABMax);
+    n_blks = MIN2(n_blks, (size_t)CMSOldPLABMax);
   }
   assert(n_blks > 0, "Error");
   _cfls->par_get_chunk_of_blocks(word_sz, n_blks, fl);
diff -up openjdk/hotspot/src/share/vm/gc_implementation/g1/concurrentMark.cpp.sav openjdk/hotspot/src/share/vm/gc_implementation/g1/concurrentMark.cpp
--- openjdk/hotspot/src/share/vm/gc_implementation/g1/concurrentMark.cpp.sav	2012-02-14 16:11:12.000000000 -0500
+++ openjdk/hotspot/src/share/vm/gc_implementation/g1/concurrentMark.cpp	2012-03-09 16:30:30.426921691 -0500
@@ -481,7 +481,7 @@ ConcurrentMark::ConcurrentMark(ReservedS
   _regionStack(),
   // _finger set in set_non_marking_state
 
-  _max_task_num(MAX2(ParallelGCThreads, (size_t)1)),
+  _max_task_num(MAX2((size_t)ParallelGCThreads, (size_t)1)),
   // _active_tasks set in set_non_marking_state
   // _tasks set inside the constructor
   _task_queues(new CMTaskQueueSet((int) _max_task_num)),
@@ -586,7 +586,7 @@ ConcurrentMark::ConcurrentMark(ReservedS
       _sleep_factor             = sleep_factor;
       _marking_task_overhead    = marking_task_overhead;
     } else {
-      _parallel_marking_threads = MAX2((ParallelGCThreads + 2) / 4, (size_t)1);
+      _parallel_marking_threads = MAX2((size_t)((ParallelGCThreads + 2) / 4), (size_t)1);
       _sleep_factor             = 0.0;
       _marking_task_overhead    = 1.0;
     }
@@ -1116,7 +1116,7 @@ void ConcurrentMark::markFromRoots() {
 
   _restart_for_overflow = false;
 
-  size_t active_workers = MAX2((size_t) 1, parallel_marking_threads());
+  size_t active_workers = MAX2((size_t) 1, (size_t)parallel_marking_threads());
   force_overflow_conc()->init();
   set_phase(active_workers, true /* concurrent */);
 
@@ -3689,7 +3689,7 @@ void CMTask::drain_local_queue(bool part
   // of things to do) or totally (at the very end).
   size_t target_size;
   if (partially) {
-    target_size = MIN2((size_t)_task_queue->max_elems()/3, GCDrainStackTargetSize);
+    target_size = MIN2((size_t)(_task_queue->max_elems()/3), (size_t) GCDrainStackTargetSize);
   } else {
     target_size = 0;
   }
@@ -4604,7 +4604,7 @@ size_t G1PrintRegionLivenessInfoClosure:
   // The > 0 check is to deal with the prev and next live bytes which
   // could be 0.
   if (*hum_bytes > 0) {
-    bytes = MIN2((size_t) HeapRegion::GrainBytes, *hum_bytes);
+    bytes = MIN2((size_t) HeapRegion::GrainBytes, (size_t)*hum_bytes);
     *hum_bytes -= bytes;
   }
   return bytes;
diff -up openjdk/hotspot/src/share/vm/gc_implementation/g1/g1CollectedHeap.cpp.sav openjdk/hotspot/src/share/vm/gc_implementation/g1/g1CollectedHeap.cpp
--- openjdk/hotspot/src/share/vm/gc_implementation/g1/g1CollectedHeap.cpp.sav	2012-02-14 16:11:12.000000000 -0500
+++ openjdk/hotspot/src/share/vm/gc_implementation/g1/g1CollectedHeap.cpp	2012-03-09 14:48:08.226867784 -0500
@@ -1615,7 +1615,7 @@ HeapWord* G1CollectedHeap::expand_and_al
 
   verify_region_sets_optional();
 
-  size_t expand_bytes = MAX2(word_size * HeapWordSize, MinHeapDeltaBytes);
+  size_t expand_bytes = MAX2(word_size * HeapWordSize, (size_t)MinHeapDeltaBytes);
   ergo_verbose1(ErgoHeapSizing,
                 "attempt heap expansion",
                 ergo_format_reason("allocation request failed")
diff -up openjdk/hotspot/src/share/vm/gc_implementation/g1/heapRegionRemSet.cpp.sav openjdk/hotspot/src/share/vm/gc_implementation/g1/heapRegionRemSet.cpp
--- openjdk/hotspot/src/share/vm/gc_implementation/g1/heapRegionRemSet.cpp.sav	2012-02-14 16:11:12.000000000 -0500
+++ openjdk/hotspot/src/share/vm/gc_implementation/g1/heapRegionRemSet.cpp	2012-03-09 14:48:08.226867784 -0500
@@ -1083,7 +1083,7 @@ OtherRegionsTable::do_cleanup_work(HRRSC
 // This can be done by either mutator threads together with the
 // concurrent refinement threads or GC threads.
 int HeapRegionRemSet::num_par_rem_sets() {
-  return (int)MAX2(DirtyCardQueueSet::num_par_ids() + ConcurrentG1Refine::thread_num(), ParallelGCThreads);
+  return (int)MAX2(DirtyCardQueueSet::num_par_ids() + ConcurrentG1Refine::thread_num(), (size_t)ParallelGCThreads);
 }
 
 HeapRegionRemSet::HeapRegionRemSet(G1BlockOffsetSharedArray* bosa,
diff -up openjdk/hotspot/src/share/vm/gc_implementation/parallelScavenge/parMarkBitMap.cpp.sav openjdk/hotspot/src/share/vm/gc_implementation/parallelScavenge/parMarkBitMap.cpp
--- openjdk/hotspot/src/share/vm/gc_implementation/parallelScavenge/parMarkBitMap.cpp.sav	2012-02-14 16:11:12.000000000 -0500
+++ openjdk/hotspot/src/share/vm/gc_implementation/parallelScavenge/parMarkBitMap.cpp	2012-03-09 14:48:08.226867784 -0500
@@ -62,7 +62,7 @@ ParMarkBitMap::initialize(MemRegion cove
   if (_virtual_space != NULL && _virtual_space->expand_by(bytes)) {
     _region_start = covered_region.start();
     _region_size = covered_region.word_size();
-    idx_t* map = (idx_t*)_virtual_space->reserved_low_addr();
+    BitMap::bm_word_t* map = (BitMap::bm_word_t*)_virtual_space->reserved_low_addr();
     _beg_bits.set_map(map);
     _beg_bits.set_size(bits / 2);
     _end_bits.set_map(map + words / 2);
diff -up openjdk/hotspot/src/share/vm/gc_implementation/parNew/parNewGeneration.cpp.sav openjdk/hotspot/src/share/vm/gc_implementation/parNew/parNewGeneration.cpp
--- openjdk/hotspot/src/share/vm/gc_implementation/parNew/parNewGeneration.cpp.sav	2012-02-14 16:11:12.000000000 -0500
+++ openjdk/hotspot/src/share/vm/gc_implementation/parNew/parNewGeneration.cpp	2012-03-09 14:48:08.227867766 -0500
@@ -188,7 +188,7 @@ bool ParScanThreadState::take_from_overf
   const size_t num_overflow_elems = of_stack->size();
   const size_t space_available = queue->max_elems() - queue->size();
   const size_t num_take_elems = MIN3(space_available / 4,
-                                     ParGCDesiredObjsFromOverflowList,
+                                     (size_t)ParGCDesiredObjsFromOverflowList,
                                      num_overflow_elems);
   // Transfer the most recent num_take_elems from the overflow
   // stack to our work queue.
diff -up openjdk/hotspot/src/share/vm/memory/collectorPolicy.cpp.sav openjdk/hotspot/src/share/vm/memory/collectorPolicy.cpp
--- openjdk/hotspot/src/share/vm/memory/collectorPolicy.cpp.sav	2012-02-14 16:11:12.000000000 -0500
+++ openjdk/hotspot/src/share/vm/memory/collectorPolicy.cpp	2012-03-09 14:48:08.227867766 -0500
@@ -354,7 +354,7 @@ void GenCollectorPolicy::initialize_size
       // generally small compared to the NewRatio calculation.
       _min_gen0_size = NewSize;
       desired_new_size = NewSize;
-      max_new_size = MAX2(max_new_size, NewSize);
+      max_new_size = MAX2(max_new_size, (size_t)NewSize);
     } else {
       // For the case where NewSize is the default, use NewRatio
       // to size the minimum and initial generation sizes.
@@ -362,10 +362,10 @@ void GenCollectorPolicy::initialize_size
       // NewRatio is overly large, the resulting sizes can be too
       // small.
       _min_gen0_size = MAX2(scale_by_NewRatio_aligned(min_heap_byte_size()),
-                          NewSize);
+                          (size_t)NewSize);
       desired_new_size =
         MAX2(scale_by_NewRatio_aligned(initial_heap_byte_size()),
-             NewSize);
+             (size_t)NewSize);
     }
 
     assert(_min_gen0_size > 0, "Sanity check");
@@ -420,14 +420,14 @@ bool TwoGenerationCollectorPolicy::adjus
       // Adjust gen0 down to accomodate OldSize
       *gen0_size_ptr = heap_size - min_gen0_size;
       *gen0_size_ptr =
-        MAX2((uintx)align_size_down(*gen0_size_ptr, min_alignment()),
+        MAX2((size_t)align_size_down(*gen0_size_ptr, min_alignment()),
              min_alignment());
       assert(*gen0_size_ptr > 0, "Min gen0 is too large");
       result = true;
     } else {
       *gen1_size_ptr = heap_size - *gen0_size_ptr;
       *gen1_size_ptr =
-        MAX2((uintx)align_size_down(*gen1_size_ptr, min_alignment()),
+        MAX2((size_t)align_size_down(*gen1_size_ptr, min_alignment()),
                        min_alignment());
     }
   }
@@ -451,7 +451,7 @@ void TwoGenerationCollectorPolicy::initi
   // for setting the gen1 maximum.
   _max_gen1_size = max_heap_byte_size() - _max_gen0_size;
   _max_gen1_size =
-    MAX2((uintx)align_size_down(_max_gen1_size, min_alignment()),
+    MAX2((size_t)align_size_down(_max_gen1_size, min_alignment()),
          min_alignment());
   // If no explicit command line flag has been set for the
   // gen1 size, use what is left for gen1.
@@ -465,11 +465,11 @@ void TwoGenerationCollectorPolicy::initi
       "gen0 has an unexpected minimum size");
     set_min_gen1_size(min_heap_byte_size() - min_gen0_size());
     set_min_gen1_size(
-      MAX2((uintx)align_size_down(_min_gen1_size, min_alignment()),
+      MAX2((size_t)align_size_down(_min_gen1_size, min_alignment()),
            min_alignment()));
     set_initial_gen1_size(initial_heap_byte_size() - initial_gen0_size());
     set_initial_gen1_size(
-      MAX2((uintx)align_size_down(_initial_gen1_size, min_alignment()),
+      MAX2((size_t)align_size_down(_initial_gen1_size, min_alignment()),
            min_alignment()));
 
   } else {
diff -up openjdk/hotspot/src/share/vm/oops/objArrayKlass.inline.hpp.sav openjdk/hotspot/src/share/vm/oops/objArrayKlass.inline.hpp
--- openjdk/hotspot/src/share/vm/oops/objArrayKlass.inline.hpp.sav	2012-02-14 16:11:12.000000000 -0500
+++ openjdk/hotspot/src/share/vm/oops/objArrayKlass.inline.hpp	2012-03-09 14:48:08.227867766 -0500
@@ -46,7 +46,7 @@ void objArrayKlass::objarray_follow_cont
   const size_t beg_index = size_t(index);
   assert(beg_index < len || len == 0, "index too large");
 
-  const size_t stride = MIN2(len - beg_index, ObjArrayMarkingStride);
+  const size_t stride = MIN2(len - beg_index, (size_t)ObjArrayMarkingStride);
   const size_t end_index = beg_index + stride;
   T* const base = (T*)a->base();
   T* const beg = base + beg_index;
@@ -80,7 +80,7 @@ void objArrayKlass::objarray_follow_cont
   const size_t beg_index = size_t(index);
   assert(beg_index < len || len == 0, "index too large");
 
-  const size_t stride = MIN2(len - beg_index, ObjArrayMarkingStride);
+  const size_t stride = MIN2(len - beg_index, (size_t)ObjArrayMarkingStride);
   const size_t end_index = beg_index + stride;
   T* const base = (T*)a->base();
   T* const beg = base + beg_index;
diff -up openjdk/hotspot/src/share/vm/runtime/arguments.cpp.sav openjdk/hotspot/src/share/vm/runtime/arguments.cpp
--- openjdk/hotspot/src/share/vm/runtime/arguments.cpp.sav	2012-02-14 16:11:12.000000000 -0500
+++ openjdk/hotspot/src/share/vm/runtime/arguments.cpp	2012-03-09 14:48:08.228867748 -0500
@@ -1179,7 +1179,7 @@ void Arguments::set_cms_and_parnew_gc_fl
       // so it's NewRatio x of NewSize.
       if (FLAG_IS_DEFAULT(OldSize)) {
         if (max_heap > NewSize) {
-          FLAG_SET_ERGO(uintx, OldSize, MIN2(NewRatio*NewSize, max_heap - NewSize));
+          FLAG_SET_ERGO(uintx, OldSize, MIN2((size_t)(NewRatio*NewSize), max_heap - NewSize));
           if (PrintGCDetails && Verbose) {
             // Too early to use gclog_or_tty
             tty->print_cr("CMS ergo set OldSize: " SIZE_FORMAT, OldSize);
