diff -Nru eclipselink-2.5.2/org/eclipse/persistence/dynamic/DynamicClassWriter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/dynamic/DynamicClassWriter.java
--- eclipselink-2.5.2/org/eclipse/persistence/dynamic/DynamicClassWriter.java	2014-03-19 07:47:20.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/dynamic/DynamicClassWriter.java	2015-11-01 14:16:15.851059642 +0100
@@ -25,41 +25,41 @@
 import org.eclipse.persistence.internal.dynamic.DynamicEntityImpl;
 import org.eclipse.persistence.internal.dynamic.DynamicPropertiesManager;
 import org.eclipse.persistence.internal.helper.Helper;
-import org.eclipse.persistence.internal.libraries.asm.ClassWriter;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Type;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Type;
 
 import static org.eclipse.persistence.internal.dynamic.DynamicPropertiesManager.PROPERTIES_MANAGER_FIELD;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.AASTORE;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ACC_ENUM;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ACC_FINAL;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ACC_PRIVATE;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ACC_PUBLIC;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ACC_STATIC;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ACC_SUPER;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ACC_SYNTHETIC;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ALOAD;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ANEWARRAY;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ARETURN;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.BIPUSH;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.SIPUSH;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.CHECKCAST;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.DUP;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.GETSTATIC;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ICONST_0;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ICONST_1;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ICONST_2;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ICONST_3;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ICONST_4;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ICONST_5;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ILOAD;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.INVOKESPECIAL;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.INVOKESTATIC;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.INVOKEVIRTUAL;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.NEW;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.PUTSTATIC;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.RETURN;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.V1_5;
+import static org.objectweb.asm.Opcodes.AASTORE;
+import static org.objectweb.asm.Opcodes.ACC_ENUM;
+import static org.objectweb.asm.Opcodes.ACC_FINAL;
+import static org.objectweb.asm.Opcodes.ACC_PRIVATE;
+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
+import static org.objectweb.asm.Opcodes.ACC_STATIC;
+import static org.objectweb.asm.Opcodes.ACC_SUPER;
+import static org.objectweb.asm.Opcodes.ACC_SYNTHETIC;
+import static org.objectweb.asm.Opcodes.ALOAD;
+import static org.objectweb.asm.Opcodes.ANEWARRAY;
+import static org.objectweb.asm.Opcodes.ARETURN;
+import static org.objectweb.asm.Opcodes.BIPUSH;
+import static org.objectweb.asm.Opcodes.SIPUSH;
+import static org.objectweb.asm.Opcodes.CHECKCAST;
+import static org.objectweb.asm.Opcodes.DUP;
+import static org.objectweb.asm.Opcodes.GETSTATIC;
+import static org.objectweb.asm.Opcodes.ICONST_0;
+import static org.objectweb.asm.Opcodes.ICONST_1;
+import static org.objectweb.asm.Opcodes.ICONST_2;
+import static org.objectweb.asm.Opcodes.ICONST_3;
+import static org.objectweb.asm.Opcodes.ICONST_4;
+import static org.objectweb.asm.Opcodes.ICONST_5;
+import static org.objectweb.asm.Opcodes.ILOAD;
+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;
+import static org.objectweb.asm.Opcodes.INVOKESTATIC;
+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
+import static org.objectweb.asm.Opcodes.NEW;
+import static org.objectweb.asm.Opcodes.PUTSTATIC;
+import static org.objectweb.asm.Opcodes.RETURN;
+import static org.objectweb.asm.Opcodes.V1_5;
 
 /**
  * Write the byte codes of a dynamic entity class. The class writer will create
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/dbws/SOAPResponseClassLoader.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/dbws/SOAPResponseClassLoader.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/dbws/SOAPResponseClassLoader.java	2014-03-19 07:46:38.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/dbws/SOAPResponseClassLoader.java	2015-11-01 14:16:15.852059589 +0100
@@ -18,14 +18,14 @@
 // Java extension imports
 
 // EclipseLink imports
-import org.eclipse.persistence.internal.libraries.asm.ClassWriter;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ACC_PUBLIC;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ACC_SUPER;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ALOAD;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.INVOKESPECIAL;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.RETURN;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.V1_5;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
+import static org.objectweb.asm.Opcodes.ACC_SUPER;
+import static org.objectweb.asm.Opcodes.ALOAD;
+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;
+import static org.objectweb.asm.Opcodes.RETURN;
+import static org.objectweb.asm.Opcodes.V1_5;
 
 /**
  * <p><b>INTERNAL</b>: A subclass of {@link ClassLoader} that exposes a build method to the hidden
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/metadata/accessors/objects/MetadataAsmFactory.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/metadata/accessors/objects/MetadataAsmFactory.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/metadata/accessors/objects/MetadataAsmFactory.java	2014-03-19 07:47:22.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/metadata/accessors/objects/MetadataAsmFactory.java	2015-11-01 14:16:15.854059483 +0100
@@ -28,14 +28,14 @@
 import org.eclipse.persistence.internal.helper.Helper;
 import org.eclipse.persistence.internal.jpa.metadata.MetadataDescriptor;
 import org.eclipse.persistence.internal.jpa.metadata.MetadataLogger;
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-import org.eclipse.persistence.internal.libraries.asm.ClassReader;
-import org.eclipse.persistence.internal.libraries.asm.ClassVisitor;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-import org.eclipse.persistence.internal.libraries.asm.commons.EmptyVisitor;
+import org.objectweb.asm.AnnotationVisitor;
+import org.objectweb.asm.Attribute;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.FieldVisitor;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Type;
+import org.objectweb.asm.commons.EmptyVisitor;
 
 /**
  * INTERNAL: A metadata factory that uses ASM technology and no reflection
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/metadata/accessors/objects/MetadataClass.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/metadata/accessors/objects/MetadataClass.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/metadata/accessors/objects/MetadataClass.java	2014-03-19 07:47:22.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/metadata/accessors/objects/MetadataClass.java	2015-11-01 14:16:15.856059378 +0100
@@ -34,7 +34,7 @@
 import java.util.Set;
 
 import org.eclipse.persistence.internal.helper.Helper;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
+import org.objectweb.asm.Opcodes;
 
 /**
  * INTERNAL:
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/metadata/MetadataDynamicClassWriter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/metadata/MetadataDynamicClassWriter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/metadata/MetadataDynamicClassWriter.java	2014-03-19 07:47:22.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/metadata/MetadataDynamicClassWriter.java	2015-11-01 14:16:15.852059589 +0100
@@ -13,20 +13,20 @@
  ******************************************************************************/
 package org.eclipse.persistence.internal.jpa.metadata;
 
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ACC_PUBLIC;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ALOAD;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ARETURN;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.CHECKCAST;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.INVOKESPECIAL;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.POP;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.RETURN;
+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
+import static org.objectweb.asm.Opcodes.ALOAD;
+import static org.objectweb.asm.Opcodes.ARETURN;
+import static org.objectweb.asm.Opcodes.CHECKCAST;
+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;
+import static org.objectweb.asm.Opcodes.POP;
+import static org.objectweb.asm.Opcodes.RETURN;
 
 import org.eclipse.persistence.dynamic.DynamicClassWriter;
 import org.eclipse.persistence.internal.helper.ClassConstants;
 import org.eclipse.persistence.internal.jpa.metadata.accessors.mappings.MappingAccessor;
-import org.eclipse.persistence.internal.libraries.asm.ClassWriter;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Type;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Type;
 
 /**
  * Custom {@link DynamicClassWriter} adding getter methods for virtual
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/parsing/jpql/antlr/JPQLLexer.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/parsing/jpql/antlr/JPQLLexer.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/parsing/jpql/antlr/JPQLLexer.java	2014-03-19 07:47:20.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/parsing/jpql/antlr/JPQLLexer.java	2015-11-01 14:16:15.901057004 +0100
@@ -5,7 +5,7 @@
     import org.eclipse.persistence.internal.jpa.parsing.jpql.InvalidIdentifierStartException;
 
 
-import org.eclipse.persistence.internal.libraries.antlr.runtime.*;
+import org.antlr.runtime.*;
 
 public class JPQLLexer extends Lexer {
     public static final int EXPONENT=116;
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/parsing/jpql/antlr/JPQLParserBuilder.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/parsing/jpql/antlr/JPQLParserBuilder.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/parsing/jpql/antlr/JPQLParserBuilder.java	2014-03-19 07:47:20.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/parsing/jpql/antlr/JPQLParserBuilder.java	2015-11-01 14:16:15.946054630 +0100
@@ -12,8 +12,8 @@
  ******************************************************************************/  
 package org.eclipse.persistence.internal.jpa.parsing.jpql.antlr;
 
-import org.eclipse.persistence.internal.libraries.antlr.runtime.*;
-//import org.eclipse.persistence.internal.libraries.antlr.TokenBuffer;
+import org.antlr.runtime.*;
+//import org.antlr.TokenBuffer;
 
 //eclipselink imports
 import org.eclipse.persistence.internal.jpa.parsing.jpql.CaseInsensitiveJPQLLexer;
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/parsing/jpql/antlr/JPQLParser.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/parsing/jpql/antlr/JPQLParser.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/parsing/jpql/antlr/JPQLParser.java	2014-03-19 07:47:20.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/parsing/jpql/antlr/JPQLParser.java	2015-11-01 14:16:15.945054683 +0100
@@ -9,7 +9,7 @@
     import org.eclipse.persistence.internal.jpa.parsing.jpql.InvalidIdentifierException;
 
 
-import org.eclipse.persistence.internal.libraries.antlr.runtime.*;
+import org.antlr.runtime.*;
 
 import java.util.Stack;
 /*******************************************************************************
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/parsing/jpql/CaseInsensitiveANTLRStringStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/parsing/jpql/CaseInsensitiveANTLRStringStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/parsing/jpql/CaseInsensitiveANTLRStringStream.java	2014-03-19 07:47:20.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/parsing/jpql/CaseInsensitiveANTLRStringStream.java	2015-11-01 14:16:15.889057637 +0100
@@ -12,7 +12,7 @@
  ******************************************************************************/  
 package org.eclipse.persistence.internal.jpa.parsing.jpql;
 
-import org.eclipse.persistence.internal.libraries.antlr.runtime.ANTLRStringStream;
+import org.antlr.runtime.ANTLRStringStream;
 
 /**
  * This Stream is used when tokenizing JPQL queries
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/parsing/jpql/CaseInsensitiveJPQLLexer.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/parsing/jpql/CaseInsensitiveJPQLLexer.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/parsing/jpql/CaseInsensitiveJPQLLexer.java	2014-03-19 07:47:20.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/parsing/jpql/CaseInsensitiveJPQLLexer.java	2015-11-01 14:16:15.889057637 +0100
@@ -12,7 +12,7 @@
  ******************************************************************************/  
 package org.eclipse.persistence.internal.jpa.parsing.jpql;
 
-import org.eclipse.persistence.internal.libraries.antlr.runtime.*;
+import org.antlr.runtime.*;
 import org.eclipse.persistence.internal.jpa.parsing.jpql.antlr.JPQLLexer;
 
 /*
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/parsing/jpql/InvalidIdentifierException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/parsing/jpql/InvalidIdentifierException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/parsing/jpql/InvalidIdentifierException.java	2014-03-19 07:47:20.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/parsing/jpql/InvalidIdentifierException.java	2015-11-01 14:16:15.890057584 +0100
@@ -12,8 +12,8 @@
  ******************************************************************************/  
 package org.eclipse.persistence.internal.jpa.parsing.jpql;
 
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognitionException;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
+import org.antlr.runtime.RecognitionException;
+import org.antlr.runtime.Token;
 
 /**
  * This is a custom Exception class that is thrown from ANTLR JPQL code when we 
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/parsing/jpql/InvalidIdentifierStartException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/parsing/jpql/InvalidIdentifierStartException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/parsing/jpql/InvalidIdentifierStartException.java	2014-03-19 07:47:20.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/parsing/jpql/InvalidIdentifierStartException.java	2015-11-01 14:16:15.890057584 +0100
@@ -12,7 +12,7 @@
  ******************************************************************************/  
 package org.eclipse.persistence.internal.jpa.parsing.jpql;
 
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognitionException;
+import org.antlr.runtime.RecognitionException;
 
 /*
  * This is a custom Exception class that is thrown from ANTLR JPQL code when we 
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/parsing/jpql/JPQLParser.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/parsing/jpql/JPQLParser.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/parsing/jpql/JPQLParser.java	2014-03-19 07:47:20.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/parsing/jpql/JPQLParser.java	2015-11-01 14:16:15.891057531 +0100
@@ -15,21 +15,21 @@
 import java.util.List;
 import java.util.ArrayList;
 
-import org.eclipse.persistence.internal.libraries.antlr.runtime.*;
+import org.antlr.runtime.*;
 // Third party (ANLTR) stuff
-/*import org.eclipse.persistence.internal.libraries.antlr.ANTLRException;
-import org.eclipse.persistence.internal.libraries.antlr.LLkParser;
-import org.eclipse.persistence.internal.libraries.antlr.MismatchedCharException;
-import org.eclipse.persistence.internal.libraries.antlr.MismatchedTokenException;
-import org.eclipse.persistence.internal.libraries.antlr.NoViableAltException;
-import org.eclipse.persistence.internal.libraries.antlr.NoViableAltForCharException;
-import org.eclipse.persistence.internal.libraries.antlr.ParserSharedInputState;
-import org.eclipse.persistence.internal.libraries.antlr.RecognitionException;
-import org.eclipse.persistence.internal.libraries.antlr.Token;
-import org.eclipse.persistence.internal.libraries.antlr.TokenBuffer;
-import org.eclipse.persistence.internal.libraries.antlr.TokenStream;
-import org.eclipse.persistence.internal.libraries.antlr.TokenStreamException;
-import org.eclipse.persistence.internal.libraries.antlr.TokenStreamRecognitionException;*/
+/*import org.antlr.ANTLRException;
+import org.antlr.LLkParser;
+import org.antlr.MismatchedCharException;
+import org.antlr.MismatchedTokenException;
+import org.antlr.NoViableAltException;
+import org.antlr.NoViableAltForCharException;
+import org.antlr.ParserSharedInputState;
+import org.antlr.RecognitionException;
+import org.antlr.Token;
+import org.antlr.TokenBuffer;
+import org.antlr.TokenStream;
+import org.antlr.TokenStreamException;
+import org.antlr.TokenStreamRecognitionException;*/
 
 //toplink imports
 import org.eclipse.persistence.exceptions.JPQLException;
@@ -41,7 +41,7 @@
 /**
  * EJBQLParser is the superclass of the ANTLR generated parser.
  */
-public abstract class JPQLParser extends org.eclipse.persistence.internal.libraries.antlr.runtime.Parser {
+public abstract class JPQLParser extends org.antlr.runtime.Parser {
 
     /** List of errors. */
     private List errors = new ArrayList();
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/weaving/AttributeDetails.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/weaving/AttributeDetails.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/weaving/AttributeDetails.java	2014-03-19 07:47:22.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/weaving/AttributeDetails.java	2015-11-01 14:16:15.857059325 +0100
@@ -12,7 +12,7 @@
  ******************************************************************************/  
 package org.eclipse.persistence.internal.jpa.weaving;
 
-import org.eclipse.persistence.internal.libraries.asm.Type;
+import org.objectweb.asm.Type;
 
 import org.eclipse.persistence.mappings.DatabaseMapping;
 
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/weaving/ClassWeaver.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/weaving/ClassWeaver.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/weaving/ClassWeaver.java	2014-03-19 07:47:22.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/weaving/ClassWeaver.java	2015-11-01 14:16:15.861059114 +0100
@@ -20,13 +20,13 @@
 import java.util.Iterator;
 
 import org.eclipse.persistence.internal.helper.Helper;
-import org.eclipse.persistence.internal.libraries.asm.ClassWriter;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-import org.eclipse.persistence.internal.libraries.asm.commons.SerialVersionUIDAdder;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.FieldVisitor;
+import org.objectweb.asm.Label;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
+import org.objectweb.asm.commons.SerialVersionUIDAdder;
 
 /**
  * INTERNAL: Weaves classes to allow them to support EclipseLink indirection.
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/weaving/ComputeClassWriter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/weaving/ComputeClassWriter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/weaving/ComputeClassWriter.java	2014-03-19 07:47:22.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/weaving/ComputeClassWriter.java	2015-11-01 14:16:15.862059061 +0100
@@ -33,9 +33,9 @@
 import java.io.IOException;
 import java.io.InputStream;
 
-import org.eclipse.persistence.internal.libraries.asm.ClassReader;
-import org.eclipse.persistence.internal.libraries.asm.ClassWriter;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.Opcodes;
 
 /**
  * A ClassWriter that computes the common super class of two classes without
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/weaving/MethodWeaver.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/weaving/MethodWeaver.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/weaving/MethodWeaver.java	2014-03-19 07:47:22.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/weaving/MethodWeaver.java	2015-11-01 14:16:15.863059009 +0100
@@ -14,7 +14,7 @@
 
 //ASM imports
 import org.eclipse.persistence.internal.descriptors.VirtualAttributeMethodInfo;
-import org.eclipse.persistence.internal.libraries.asm.*;
+import org.objectweb.asm.*;
 
 /**
  * Processes all the methods of a class to weave in persistence code such as,
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/weaving/PersistenceWeaver.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/weaving/PersistenceWeaver.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/weaving/PersistenceWeaver.java	2014-03-19 07:47:22.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/weaving/PersistenceWeaver.java	2015-11-01 14:16:15.864058956 +0100
@@ -21,8 +21,8 @@
 
 import org.eclipse.persistence.config.SystemProperties;
 import org.eclipse.persistence.internal.helper.Helper;
-import org.eclipse.persistence.internal.libraries.asm.ClassReader;
-import org.eclipse.persistence.internal.libraries.asm.ClassWriter;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassWriter;
 import org.eclipse.persistence.internal.sessions.AbstractSession;
 import org.eclipse.persistence.logging.SessionLog;
 import org.eclipse.persistence.sessions.Session;
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/weaving/RestAdapterClassWriter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/weaving/RestAdapterClassWriter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/weaving/RestAdapterClassWriter.java	2014-03-19 07:47:22.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/weaving/RestAdapterClassWriter.java	2015-11-01 14:16:15.864058956 +0100
@@ -14,9 +14,9 @@
 
 import org.eclipse.persistence.dynamic.DynamicClassLoader;
 import org.eclipse.persistence.dynamic.EclipseLinkClassWriter;
-import org.eclipse.persistence.internal.libraries.asm.ClassWriter;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
 
 public class RestAdapterClassWriter implements EclipseLinkClassWriter, Opcodes {
 
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/weaving/TransformerFactory.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/weaving/TransformerFactory.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/jpa/weaving/TransformerFactory.java	2014-03-19 07:47:22.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/jpa/weaving/TransformerFactory.java	2015-11-01 14:16:15.865058903 +0100
@@ -31,7 +31,7 @@
 import org.eclipse.persistence.internal.jpa.metadata.accessors.objects.MetadataClass;
 import org.eclipse.persistence.internal.jpa.metadata.accessors.objects.MetadataField;
 import org.eclipse.persistence.internal.jpa.metadata.accessors.objects.MetadataMethod;
-import org.eclipse.persistence.internal.libraries.asm.Type;
+import org.objectweb.asm.Type;
 import org.eclipse.persistence.internal.sessions.AbstractSession;
 import org.eclipse.persistence.internal.weaving.PersistenceWeavedChangeTracking;
 import org.eclipse.persistence.logging.SessionLog;
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/ANTLRFileStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/ANTLRFileStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/ANTLRFileStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/ANTLRFileStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,78 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-import java.io.*;
-
-/** This is a char buffer stream that is loaded from a file
- *  all at once when you construct the object.  This looks very
- *  much like an ANTLReader or ANTLRInputStream, but it's a special case
- *  since we know the exact size of the object to load.  We can avoid lots
- *  of data copying. 
- */
-public class ANTLRFileStream extends ANTLRStringStream {
-	protected String fileName;
-
-	public ANTLRFileStream(String fileName) throws IOException {
-		this(fileName, null);
-	}
-
-	public ANTLRFileStream(String fileName, String encoding) throws IOException {
-		this.fileName = fileName;
-		load(fileName, encoding);
-	}
-
-	public void load(String fileName, String encoding)
-		throws IOException
-	{
-		if ( fileName==null ) {
-			return;
-		}
-		File f = new File(fileName);
-		int size = (int)f.length();
-		InputStreamReader isr;
-		FileInputStream fis = new FileInputStream(fileName);
-		if ( encoding!=null ) {
-			isr = new InputStreamReader(fis, encoding);
-		}
-		else {
-			isr = new InputStreamReader(fis);
-		}
-		try {
-			data = new char[size];
-			super.n = isr.read(data);
-		}
-		finally {
-			isr.close();
-		}
-	}
-
-	public String getSourceName() {
-		return fileName;
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/ANTLRInputStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/ANTLRInputStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/ANTLRInputStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/ANTLRInputStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,70 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-import java.io.*;
-
-/** A kind of ReaderStream that pulls from an InputStream.
- *  Useful for reading from stdin and specifying file encodings etc...
-  */
-public class ANTLRInputStream extends ANTLRReaderStream {
-	public ANTLRInputStream() {
-	}
-
-	public ANTLRInputStream(InputStream input) throws IOException {
-		this(input, null);
-	}
-
-	public ANTLRInputStream(InputStream input, int size) throws IOException {
-		this(input, size, null);
-	}
-
-	public ANTLRInputStream(InputStream input, String encoding) throws IOException {
-		this(input, INITIAL_BUFFER_SIZE, encoding);
-	}
-
-	public ANTLRInputStream(InputStream input, int size, String encoding) throws IOException {
-		this(input, size, READ_BUFFER_SIZE, encoding);
-	}
-
-	public ANTLRInputStream(InputStream input,
-							int size,
-							int readBufferSize,
-							String encoding)
-		throws IOException
-	{
-		InputStreamReader isr;
-		if ( encoding!=null ) {
-			isr = new InputStreamReader(input, encoding);
-		}
-		else {
-			isr = new InputStreamReader(input);
-		}
-		load(isr, size, readBufferSize);
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/ANTLRReaderStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/ANTLRReaderStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/ANTLRReaderStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/ANTLRReaderStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,95 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-import java.io.*;
-
-/** Vacuum all input from a Reader and then treat it like a StringStream.
- *  Manage the buffer manually to avoid unnecessary data copying.
- *
- *  If you need encoding, use ANTLRInputStream.
- */
-public class ANTLRReaderStream extends ANTLRStringStream {
-	public static final int READ_BUFFER_SIZE = 1024;
-	public static final int INITIAL_BUFFER_SIZE = 1024;
-
-	public ANTLRReaderStream() {
-	}
-
-	public ANTLRReaderStream(Reader r) throws IOException {
-		this(r, INITIAL_BUFFER_SIZE, READ_BUFFER_SIZE);
-	}
-
-	public ANTLRReaderStream(Reader r, int size) throws IOException {
-		this(r, size, READ_BUFFER_SIZE);
-	}
-
-	public ANTLRReaderStream(Reader r, int size, int readChunkSize) throws IOException {
-		load(r, size, readChunkSize);
-	}
-
-	public void load(Reader r, int size, int readChunkSize)
-		throws IOException
-	{
-		if ( r==null ) {
-			return;
-		}
-		if ( size<=0 ) {
-			size = INITIAL_BUFFER_SIZE;
-		}
-		if ( readChunkSize<=0 ) {
-			readChunkSize = READ_BUFFER_SIZE;
-		}
-		// System.out.println("load "+size+" in chunks of "+readChunkSize);
-		try {
-			// alloc initial buffer size.
-			data = new char[size];
-			// read all the data in chunks of readChunkSize
-			int numRead=0;
-			int p = 0;
-			do {
-				if ( p+readChunkSize > data.length ) { // overflow?
-					// System.out.println("### overflow p="+p+", data.length="+data.length);
-					char[] newdata = new char[data.length*2]; // resize
-					System.arraycopy(data, 0, newdata, 0, data.length);
-					data = newdata;
-				}
-				numRead = r.read(data, p, readChunkSize);
-				// System.out.println("read "+numRead+" chars; p was "+p+" is now "+(p+numRead));
-				p += numRead;
-			} while (numRead!=-1); // while not EOF
-			// set the actual size of the data available;
-			// EOF subtracted one above in p+=numRead; add one back
-			super.n = p+1;
-			//System.out.println("n="+n);
-		}
-		finally {
-			r.close();
-		}
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/ANTLRStringStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/ANTLRStringStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/ANTLRStringStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/ANTLRStringStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,228 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/** A pretty quick CharStream that pulls all data from an array
- *  directly.  Every method call counts in the lexer.  Java's
- *  strings aren't very good so I'm avoiding.
- */
-public class ANTLRStringStream implements CharStream {
-	/** The data being scanned */
-	protected char[] data;
-
-	/** How many characters are actually in the buffer */
-	protected int n;
-
-	/** 0..n-1 index into string of next char */
-	protected int p=0;
-
-	/** line number 1..n within the input */
-	protected int line = 1;
-
-	/** The index of the character relative to the beginning of the line 0..n-1 */
-	protected int charPositionInLine = 0;
-
-	/** tracks how deep mark() calls are nested */
-	protected int markDepth = 0;
-
-	/** A list of CharStreamState objects that tracks the stream state
-	 *  values line, charPositionInLine, and p that can change as you
-	 *  move through the input stream.  Indexed from 1..markDepth.
-     *  A null is kept @ index 0.  Create upon first call to mark().
-	 */
-	protected List markers;
-
-	/** Track the last mark() call result value for use in rewind(). */
-	protected int lastMarker;
-
-	/** What is name or source of this char stream? */
-	public String name;
-
-	public ANTLRStringStream() {
-	}
-
-	/** Copy data in string to a local char array */
-	public ANTLRStringStream(String input) {
-		this();
-		this.data = input.toCharArray();
-		this.n = input.length();
-	}
-
-	/** This is the preferred constructor as no data is copied */
-	public ANTLRStringStream(char[] data, int numberOfActualCharsInArray) {
-		this();
-		this.data = data;
-		this.n = numberOfActualCharsInArray;
-	}
-
-	/** Reset the stream so that it's in the same state it was
-	 *  when the object was created *except* the data array is not
-	 *  touched.
-	 */
-	public void reset() {
-		p = 0;
-		line = 1;
-		charPositionInLine = 0;
-		markDepth = 0;
-	}
-
-    public void consume() {
-		//System.out.println("prev p="+p+", c="+(char)data[p]);
-        if ( p < n ) {
-			charPositionInLine++;
-			if ( data[p]=='\n' ) {
-				/*
-				System.out.println("newline char found on line: "+line+
-								   "@ pos="+charPositionInLine);
-				*/
-				line++;
-				charPositionInLine=0;
-			}
-            p++;
-			//System.out.println("p moves to "+p+" (c='"+(char)data[p]+"')");
-        }
-    }
-
-    public int LA(int i) {
-		if ( i==0 ) {
-			return 0; // undefined
-		}
-		if ( i<0 ) {
-			i++; // e.g., translate LA(-1) to use offset i=0; then data[p+0-1]
-			if ( (p+i-1) < 0 ) {
-				return CharStream.EOF; // invalid; no char before first char
-			}
-		}
-
-		if ( (p+i-1) >= n ) {
-            //System.out.println("char LA("+i+")=EOF; p="+p);
-            return CharStream.EOF;
-        }
-        //System.out.println("char LA("+i+")="+(char)data[p+i-1]+"; p="+p);
-		//System.out.println("LA("+i+"); p="+p+" n="+n+" data.length="+data.length);
-		return data[p+i-1];
-    }
-
-	public int LT(int i) {
-		return LA(i);
-	}
-
-	/** Return the current input symbol index 0..n where n indicates the
-     *  last symbol has been read.  The index is the index of char to
-	 *  be returned from LA(1).
-     */
-    public int index() {
-        return p;
-    }
-
-	public int size() {
-		return n;
-	}
-
-	public int mark() {
-        if ( markers==null ) {
-            markers = new ArrayList();
-            markers.add(null); // depth 0 means no backtracking, leave blank
-        }
-        markDepth++;
-		CharStreamState state = null;
-		if ( markDepth>=markers.size() ) {
-			state = new CharStreamState();
-			markers.add(state);
-		}
-		else {
-			state = (CharStreamState)markers.get(markDepth);
-		}
-		state.p = p;
-		state.line = line;
-		state.charPositionInLine = charPositionInLine;
-		lastMarker = markDepth;
-		return markDepth;
-    }
-
-    public void rewind(int m) {
-		CharStreamState state = (CharStreamState)markers.get(m);
-		// restore stream state
-		seek(state.p);
-		line = state.line;
-		charPositionInLine = state.charPositionInLine;
-		release(m);
-	}
-
-	public void rewind() {
-		rewind(lastMarker);
-	}
-
-	public void release(int marker) {
-		// unwind any other markers made after m and release m
-		markDepth = marker;
-		// release this marker
-		markDepth--;
-	}
-
-	/** consume() ahead until p==index; can't just set p=index as we must
-	 *  update line and charPositionInLine.
-	 */
-	public void seek(int index) {
-		if ( index<=p ) {
-			p = index; // just jump; don't update stream state (line, ...)
-			return;
-		}
-		// seek forward, consume until p hits index
-		while ( p<index ) {
-			consume();
-		}
-	}
-
-	public String substring(int start, int stop) {
-		return new String(data,start,stop-start+1);
-	}
-
-	public int getLine() {
-		return line;
-	}
-
-	public int getCharPositionInLine() {
-		return charPositionInLine;
-	}
-
-	public void setLine(int line) {
-		this.line = line;
-	}
-
-	public void setCharPositionInLine(int pos) {
-		this.charPositionInLine = pos;
-	}
-
-	public String getSourceName() {
-		return name;
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/BaseRecognizer.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/BaseRecognizer.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/BaseRecognizer.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/BaseRecognizer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,879 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/** A generic recognizer that can handle recognizers generated from
- *  lexer, parser, and tree grammars.  This is all the parsing
- *  support code essentially; most of it is error recovery stuff and
- *  backtracking.
- */
-public abstract class BaseRecognizer {
-	public static final int MEMO_RULE_FAILED = -2;
-	public static final int MEMO_RULE_UNKNOWN = -1;
-	public static final int INITIAL_FOLLOW_STACK_SIZE = 100;
-
-	// copies from Token object for convenience in actions
-	public static final int DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;
-	public static final int HIDDEN = Token.HIDDEN_CHANNEL;
-
-	public static final String NEXT_TOKEN_RULE_NAME = "nextToken";
-
-	/** State of a lexer, parser, or tree parser are collected into a state
-	 *  object so the state can be shared.  This sharing is needed to
-	 *  have one grammar import others and share same error variables
-	 *  and other state variables.  It's a kind of explicit multiple
-	 *  inheritance via delegation of methods and shared state.
-	 */
-	protected RecognizerSharedState state;
-
-	public BaseRecognizer() {
-		state = new RecognizerSharedState();
-	}
-
-	public BaseRecognizer(RecognizerSharedState state) {
-		if ( state==null ) {
-			state = new RecognizerSharedState();
-		}
-		this.state = state;
-	}
-
-	/** reset the parser's state; subclasses must rewinds the input stream */
-	public void reset() {
-		// wack everything related to error recovery
-		if ( state==null ) {
-			return; // no shared state work to do
-		}
-		state._fsp = -1;
-		state.errorRecovery = false;
-		state.lastErrorIndex = -1;
-		state.failed = false;
-		state.syntaxErrors = 0;
-		// wack everything related to backtracking and memoization
-		state.backtracking = 0;
-		for (int i = 0; state.ruleMemo!=null && i < state.ruleMemo.length; i++) { // wipe cache
-			state.ruleMemo[i] = null;
-		}
-	}
-
-
-	/** Match current input symbol against ttype.  Attempt
-	 *  single token insertion or deletion error recovery.  If
-	 *  that fails, throw MismatchedTokenException.
-	 *
-	 *  To turn off single token insertion or deletion error
-	 *  recovery, override recoverFromMismatchedToken() and have it
-     *  throw an exception. See TreeParser.recoverFromMismatchedToken().
-     *  This way any error in a rule will cause an exception and
-     *  immediate exit from rule.  Rule would recover by resynchronizing
-     *  to the set of symbols that can follow rule ref.
-	 */
-	public Object match(IntStream input, int ttype, BitSet follow)
-		throws RecognitionException
-	{
-		//System.out.println("match "+((TokenStream)input).LT(1));
-		Object matchedSymbol = getCurrentInputSymbol(input);
-		if ( input.LA(1)==ttype ) {
-			input.consume();
-			state.errorRecovery = false;
-			state.failed = false;
-			return matchedSymbol;
-		}
-		if ( state.backtracking>0 ) {
-			state.failed = true;
-			return matchedSymbol;
-		}
-		matchedSymbol = recoverFromMismatchedToken(input, ttype, follow);
-		return matchedSymbol;
-	}
-
-	/** Match the wildcard: in a symbol */
-	public void matchAny(IntStream input) {
-		state.errorRecovery = false;
-		state.failed = false;
-		input.consume();
-	}
-
-	public boolean mismatchIsUnwantedToken(IntStream input, int ttype) {
-		return input.LA(2)==ttype;
-	}
-
-	public boolean mismatchIsMissingToken(IntStream input, BitSet follow) {
-		if ( follow==null ) {
-			// we have no information about the follow; we can only consume
-			// a single token and hope for the best
-			return false;
-		}
-		// compute what can follow this grammar element reference
-		if ( follow.member(Token.EOR_TOKEN_TYPE) ) {
-			BitSet viableTokensFollowingThisRule = computeContextSensitiveRuleFOLLOW();
-			follow = follow.or(viableTokensFollowingThisRule);
-            if ( state._fsp>=0 ) { // remove EOR if we're not the start symbol
-                follow.remove(Token.EOR_TOKEN_TYPE);
-            }
-		}
-		// if current token is consistent with what could come after set
-		// then we know we're missing a token; error recovery is free to
-		// "insert" the missing token
-
-		//System.out.println("viable tokens="+follow.toString(getTokenNames()));
-		//System.out.println("LT(1)="+((TokenStream)input).LT(1));
-
-		// BitSet cannot handle negative numbers like -1 (EOF) so I leave EOR
-		// in follow set to indicate that the fall of the start symbol is
-		// in the set (EOF can follow).
-		if ( follow.member(input.LA(1)) || follow.member(Token.EOR_TOKEN_TYPE) ) {
-			//System.out.println("LT(1)=="+((TokenStream)input).LT(1)+" is consistent with what follows; inserting...");
-			return true;
-		}
-		return false;
-	}
-
-	/** Report a recognition problem.
-	 *
-	 *  This method sets errorRecovery to indicate the parser is recovering
-	 *  not parsing.  Once in recovery mode, no errors are generated.
-	 *  To get out of recovery mode, the parser must successfully match
-	 *  a token (after a resync).  So it will go:
-	 *
-	 * 		1. error occurs
-	 * 		2. enter recovery mode, report error
-	 * 		3. consume until token found in resynch set
-	 * 		4. try to resume parsing
-	 * 		5. next match() will reset errorRecovery mode
-	 *
-	 *  If you override, make sure to update syntaxErrors if you care about that.
-	 */
-	public void reportError(RecognitionException e) {
-		// if we've already reported an error and have not matched a token
-		// yet successfully, don't report any errors.
-		if ( state.errorRecovery ) {
-			//System.err.print("[SPURIOUS] ");
-			return;
-		}
-		state.syntaxErrors++; // don't count spurious
-		state.errorRecovery = true;
-
-		displayRecognitionError(this.getTokenNames(), e);
-	}
-
-	public void displayRecognitionError(String[] tokenNames,
-										RecognitionException e)
-	{
-		String hdr = getErrorHeader(e);
-		String msg = getErrorMessage(e, tokenNames);
-		emitErrorMessage(hdr+" "+msg);
-	}
-
-	/** What error message should be generated for the various
-	 *  exception types?
-	 *
-	 *  Not very object-oriented code, but I like having all error message
-	 *  generation within one method rather than spread among all of the
-	 *  exception classes. This also makes it much easier for the exception
-	 *  handling because the exception classes do not have to have pointers back
-	 *  to this object to access utility routines and so on. Also, changing
-	 *  the message for an exception type would be difficult because you
-	 *  would have to subclassing exception, but then somehow get ANTLR
-	 *  to make those kinds of exception objects instead of the default.
-	 *  This looks weird, but trust me--it makes the most sense in terms
-	 *  of flexibility.
-	 *
-	 *  For grammar debugging, you will want to override this to add
-	 *  more information such as the stack frame with
-	 *  getRuleInvocationStack(e, this.getClass().getName()) and,
-	 *  for no viable alts, the decision description and state etc...
-	 *
-	 *  Override this to change the message generated for one or more
-	 *  exception types.
-	 */
-	public String getErrorMessage(RecognitionException e, String[] tokenNames) {
-		String msg = e.getMessage();
-		if ( e instanceof UnwantedTokenException ) {
-			UnwantedTokenException ute = (UnwantedTokenException)e;
-			String tokenName="<unknown>";
-			if ( ute.expecting== Token.EOF ) {
-				tokenName = "EOF";
-			}
-			else {
-				tokenName = tokenNames[ute.expecting];
-			}
-			msg = "extraneous input "+getTokenErrorDisplay(ute.getUnexpectedToken())+
-				" expecting "+tokenName;
-		}
-		else if ( e instanceof MissingTokenException ) {
-			MissingTokenException mte = (MissingTokenException)e;
-			String tokenName="<unknown>";
-			if ( mte.expecting== Token.EOF ) {
-				tokenName = "EOF";
-			}
-			else {
-				tokenName = tokenNames[mte.expecting];
-			}
-			msg = "missing "+tokenName+" at "+getTokenErrorDisplay(e.token);
-		}
-		else if ( e instanceof MismatchedTokenException ) {
-			MismatchedTokenException mte = (MismatchedTokenException)e;
-			String tokenName="<unknown>";
-			if ( mte.expecting== Token.EOF ) {
-				tokenName = "EOF";
-			}
-			else {
-				tokenName = tokenNames[mte.expecting];
-			}
-			msg = "mismatched input "+getTokenErrorDisplay(e.token)+
-				" expecting "+tokenName;
-		}
-		else if ( e instanceof MismatchedTreeNodeException ) {
-			MismatchedTreeNodeException mtne = (MismatchedTreeNodeException)e;
-			String tokenName="<unknown>";
-			if ( mtne.expecting==Token.EOF ) {
-				tokenName = "EOF";
-			}
-			else {
-				tokenName = tokenNames[mtne.expecting];
-			}
-			msg = "mismatched tree node: "+mtne.node+
-				" expecting "+tokenName;
-		}
-		else if ( e instanceof NoViableAltException ) {
-			//NoViableAltException nvae = (NoViableAltException)e;
-			// for development, can add "decision=<<"+nvae.grammarDecisionDescription+">>"
-			// and "(decision="+nvae.decisionNumber+") and
-			// "state "+nvae.stateNumber
-			msg = "no viable alternative at input "+getTokenErrorDisplay(e.token);
-		}
-		else if ( e instanceof EarlyExitException ) {
-			//EarlyExitException eee = (EarlyExitException)e;
-			// for development, can add "(decision="+eee.decisionNumber+")"
-			msg = "required (...)+ loop did not match anything at input "+
-				getTokenErrorDisplay(e.token);
-		}
-		else if ( e instanceof MismatchedSetException ) {
-			MismatchedSetException mse = (MismatchedSetException)e;
-			msg = "mismatched input "+getTokenErrorDisplay(e.token)+
-				" expecting set "+mse.expecting;
-		}
-		else if ( e instanceof MismatchedNotSetException ) {
-			MismatchedNotSetException mse = (MismatchedNotSetException)e;
-			msg = "mismatched input "+getTokenErrorDisplay(e.token)+
-				" expecting set "+mse.expecting;
-		}
-		else if ( e instanceof FailedPredicateException ) {
-			FailedPredicateException fpe = (FailedPredicateException)e;
-			msg = "rule "+fpe.ruleName+" failed predicate: {"+
-				fpe.predicateText+"}?";
-		}
-		return msg;
-	}
-
-	/** Get number of recognition errors (lexer, parser, tree parser).  Each
-	 *  recognizer tracks its own number.  So parser and lexer each have
-	 *  separate count.  Does not count the spurious errors found between
-	 *  an error and next valid token match
-	 *
-	 *  See also reportError()
-	 */
-	public int getNumberOfSyntaxErrors() {
-		return state.syntaxErrors;
-	}
-
-	/** What is the error header, normally line/character position information? */
-	public String getErrorHeader(RecognitionException e) {
-		return "line "+e.line+":"+e.charPositionInLine;
-	}
-
-	/** How should a token be displayed in an error message? The default
-	 *  is to display just the text, but during development you might
-	 *  want to have a lot of information spit out.  Override in that case
-	 *  to use t.toString() (which, for CommonToken, dumps everything about
-	 *  the token). This is better than forcing you to override a method in
-	 *  your token objects because you don't have to go modify your lexer
-	 *  so that it creates a new Java type.
-	 */
-	public String getTokenErrorDisplay(Token t) {
-		String s = t.getText();
-		if ( s==null ) {
-			if ( t.getType()==Token.EOF ) {
-				s = "<EOF>";
-			}
-			else {
-				s = "<"+t.getType()+">";
-			}
-		}
-		s = s.replaceAll("\n","\\\\n");
-		s = s.replaceAll("\r","\\\\r");
-		s = s.replaceAll("\t","\\\\t");
-		return "'"+s+"'";
-	}
-
-	/** Override this method to change where error messages go */
-	public void emitErrorMessage(String msg) {
-		System.err.println(msg);
-	}
-
-	/** Recover from an error found on the input stream.  This is
-	 *  for NoViableAlt and mismatched symbol exceptions.  If you enable
-	 *  single token insertion and deletion, this will usually not
-	 *  handle mismatched symbol exceptions but there could be a mismatched
-	 *  token that the match() routine could not recover from.
-	 */
-	public void recover(IntStream input, RecognitionException re) {
-		if ( state.lastErrorIndex==input.index() ) {
-			// uh oh, another error at same token index; must be a case
-			// where LT(1) is in the recovery token set so nothing is
-			// consumed; consume a single token so at least to prevent
-			// an infinite loop; this is a failsafe.
-			input.consume();
-		}
-		state.lastErrorIndex = input.index();
-		BitSet followSet = computeErrorRecoverySet();
-		beginResync();
-		consumeUntil(input, followSet);
-		endResync();
-	}
-
-	/** A hook to listen in on the token consumption during error recovery.
-	 *  The DebugParser subclasses this to fire events to the listenter.
-	 */
-	public void beginResync() {
-	}
-
-	public void endResync() {
-	}
-
-	/*  Compute the error recovery set for the current rule.  During
-	 *  rule invocation, the parser pushes the set of tokens that can
-	 *  follow that rule reference on the stack; this amounts to
-	 *  computing FIRST of what follows the rule reference in the
-	 *  enclosing rule. This local follow set only includes tokens
-	 *  from within the rule; i.e., the FIRST computation done by
-	 *  ANTLR stops at the end of a rule.
-	 *
-	 *  EXAMPLE
-	 *
-	 *  When you find a "no viable alt exception", the input is not
-	 *  consistent with any of the alternatives for rule r.  The best
-	 *  thing to do is to consume tokens until you see something that
-	 *  can legally follow a call to r *or* any rule that called r.
-	 *  You don't want the exact set of viable next tokens because the
-	 *  input might just be missing a token--you might consume the
-	 *  rest of the input looking for one of the missing tokens.
-	 *
-	 *  Consider grammar:
-	 *
-	 *  a : '[' b ']'
-	 *    | '(' b ')'
-	 *    ;
-	 *  b : c '^' INT ;
-	 *  c : ID
-	 *    | INT
-	 *    ;
-	 *
-	 *  At each rule invocation, the set of tokens that could follow
-	 *  that rule is pushed on a stack.  Here are the various "local"
-	 *  follow sets:
-	 *
-	 *  FOLLOW(b1_in_a) = FIRST(']') = ']'
-	 *  FOLLOW(b2_in_a) = FIRST(')') = ')'
-	 *  FOLLOW(c_in_b) = FIRST('^') = '^'
-	 *
-	 *  Upon erroneous input "[]", the call chain is
-	 *
-	 *  a -> b -> c
-	 *
-	 *  and, hence, the follow context stack is:
-	 *
-	 *  depth  local follow set     after call to rule
-	 *    0         <EOF>                    a (from main())
-	 *    1          ']'                     b
-	 *    3          '^'                     c
-	 *
-	 *  Notice that ')' is not included, because b would have to have
-	 *  been called from a different context in rule a for ')' to be
-	 *  included.
-	 *
-	 *  For error recovery, we cannot consider FOLLOW(c)
-	 *  (context-sensitive or otherwise).  We need the combined set of
-	 *  all context-sensitive FOLLOW sets--the set of all tokens that
-	 *  could follow any reference in the call chain.  We need to
-	 *  resync to one of those tokens.  Note that FOLLOW(c)='^' and if
-	 *  we resync'd to that token, we'd consume until EOF.  We need to
-	 *  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
-	 *  In this case, for input "[]", LA(1) is in this set so we would
-	 *  not consume anything and after printing an error rule c would
-	 *  return normally.  It would not find the required '^' though.
-	 *  At this point, it gets a mismatched token error and throws an
-	 *  exception (since LA(1) is not in the viable following token
-	 *  set).  The rule exception handler tries to recover, but finds
-	 *  the same recovery set and doesn't consume anything.  Rule b
-	 *  exits normally returning to rule a.  Now it finds the ']' (and
-	 *  with the successful match exits errorRecovery mode).
-	 *
-	 *  So, you cna see that the parser walks up call chain looking
-	 *  for the token that was a member of the recovery set.
-	 *
-	 *  Errors are not generated in errorRecovery mode.
-	 *
-	 *  ANTLR's error recovery mechanism is based upon original ideas:
-	 *
-	 *  "Algorithms + Data Structures = Programs" by Niklaus Wirth
-	 *
-	 *  and
-	 *
-	 *  "A note on error recovery in recursive descent parsers":
-	 *  http://portal.acm.org/citation.cfm?id=947902.947905
-	 *
-	 *  Later, Josef Grosch had some good ideas:
-	 *
-	 *  "Efficient and Comfortable Error Recovery in Recursive Descent
-	 *  Parsers":
-	 *  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
-	 *
-	 *  Like Grosch I implemented local FOLLOW sets that are combined
-	 *  at run-time upon error to avoid overhead during parsing.
-	 */
-	protected BitSet computeErrorRecoverySet() {
-		return combineFollows(false);
-	}
-
-	/** Compute the context-sensitive FOLLOW set for current rule.
-	 *  This is set of token types that can follow a specific rule
-	 *  reference given a specific call chain.  You get the set of
-	 *  viable tokens that can possibly come next (lookahead depth 1)
-	 *  given the current call chain.  Contrast this with the
-	 *  definition of plain FOLLOW for rule r:
-	 *
-	 *   FOLLOW(r)={x | S=>*alpha r beta in G and x in FIRST(beta)}
-	 *
-	 *  where x in T* and alpha, beta in V*; T is set of terminals and
-	 *  V is the set of terminals and nonterminals.  In other words,
-	 *  FOLLOW(r) is the set of all tokens that can possibly follow
-	 *  references to r in *any* sentential form (context).  At
-	 *  runtime, however, we know precisely which context applies as
-	 *  we have the call chain.  We may compute the exact (rather
-	 *  than covering superset) set of following tokens.
-	 *
-	 *  For example, consider grammar:
-	 *
-	 *  stat : ID '=' expr ';'      // FOLLOW(stat)=={EOF}
-	 *       | "return" expr '.'
-	 *       ;
-	 *  expr : atom ('+' atom)* ;   // FOLLOW(expr)=={';','.',')'}
-	 *  atom : INT                  // FOLLOW(atom)=={'+',')',';','.'}
-	 *       | '(' expr ')'
-	 *       ;
-	 *
-	 *  The FOLLOW sets are all inclusive whereas context-sensitive
-	 *  FOLLOW sets are precisely what could follow a rule reference.
-	 *  For input input "i=(3);", here is the derivation:
-	 *
-	 *  stat => ID '=' expr ';'
-	 *       => ID '=' atom ('+' atom)* ';'
-	 *       => ID '=' '(' expr ')' ('+' atom)* ';'
-	 *       => ID '=' '(' atom ')' ('+' atom)* ';'
-	 *       => ID '=' '(' INT ')' ('+' atom)* ';'
-	 *       => ID '=' '(' INT ')' ';'
-	 *
-	 *  At the "3" token, you'd have a call chain of
-	 *
-	 *    stat -> expr -> atom -> expr -> atom
-	 *
-	 *  What can follow that specific nested ref to atom?  Exactly ')'
-	 *  as you can see by looking at the derivation of this specific
-	 *  input.  Contrast this with the FOLLOW(atom)={'+',')',';','.'}.
-	 *
-	 *  You want the exact viable token set when recovering from a
-	 *  token mismatch.  Upon token mismatch, if LA(1) is member of
-	 *  the viable next token set, then you know there is most likely
-	 *  a missing token in the input stream.  "Insert" one by just not
-	 *  throwing an exception.
-	 */
-	protected BitSet computeContextSensitiveRuleFOLLOW() {
-		return combineFollows(true);
-	}
-
-	protected BitSet combineFollows(boolean exact) {
-		int top = state._fsp;
-		BitSet followSet = new BitSet();
-		for (int i=top; i>=0; i--) {
-			BitSet localFollowSet = (BitSet)state.following[i];
-			/*
-			System.out.println("local follow depth "+i+"="+
-							   localFollowSet.toString(getTokenNames())+")");
-			 */
-			followSet.orInPlace(localFollowSet);
-			if ( exact ) {
-				// can we see end of rule?
-				if ( localFollowSet.member(Token.EOR_TOKEN_TYPE) ) {
-					// Only leave EOR in set if at top (start rule); this lets
-					// us know if have to include follow(start rule); i.e., EOF
-					if ( i>0 ) {
-						followSet.remove(Token.EOR_TOKEN_TYPE);
-					}
-				}
-				else { // can't see end of rule, quit
-					break;
-				}
-			}
-		}
-		return followSet;
-	}
-
-	/** Attempt to recover from a single missing or extra token.
-	 *
-	 *  EXTRA TOKEN
-	 *
-	 *  LA(1) is not what we are looking for.  If LA(2) has the right token,
-	 *  however, then assume LA(1) is some extra spurious token.  Delete it
-	 *  and LA(2) as if we were doing a normal match(), which advances the
-	 *  input.
-	 *
-	 *  MISSING TOKEN
-	 *
-	 *  If current token is consistent with what could come after
-	 *  ttype then it is ok to "insert" the missing token, else throw
-	 *  exception For example, Input "i=(3;" is clearly missing the
-	 *  ')'.  When the parser returns from the nested call to expr, it
-	 *  will have call chain:
-	 *
-	 *    stat -> expr -> atom
-	 *
-	 *  and it will be trying to match the ')' at this point in the
-	 *  derivation:
-	 *
-	 *       => ID '=' '(' INT ')' ('+' atom)* ';'
-	 *                          ^
-	 *  match() will see that ';' doesn't match ')' and report a
-	 *  mismatched token error.  To recover, it sees that LA(1)==';'
-	 *  is in the set of tokens that can follow the ')' token
-	 *  reference in rule atom.  It can assume that you forgot the ')'.
-	 */
-	protected Object recoverFromMismatchedToken(IntStream input, int ttype, BitSet follow)
-		throws RecognitionException
-	{
-		RecognitionException e = null;
-		// if next token is what we are looking for then "delete" this token
-		if ( mismatchIsUnwantedToken(input, ttype) ) {
-			e = new UnwantedTokenException(ttype, input);
-			/*
-			System.err.println("recoverFromMismatchedToken deleting "+
-							   ((TokenStream)input).LT(1)+
-							   " since "+((TokenStream)input).LT(2)+" is what we want");
-			 */
-			beginResync();
-			input.consume(); // simply delete extra token
-			endResync();
-			reportError(e);  // report after consuming so AW sees the token in the exception
-			// we want to return the token we're actually matching
-			Object matchedSymbol = getCurrentInputSymbol(input);
-			input.consume(); // move past ttype token as if all were ok
-			return matchedSymbol;
-		}
-		// can't recover with single token deletion, try insertion
-		if ( mismatchIsMissingToken(input, follow) ) {
-			Object inserted = getMissingSymbol(input, e, ttype, follow);
-			e = new MissingTokenException(ttype, input, inserted);
-			reportError(e);  // report after inserting so AW sees the token in the exception
-			return inserted;
-		}
-		// even that didn't work; must throw the exception
-		e = new MismatchedTokenException(ttype, input);
-		throw e;
-	}
-
-	/** Not currently used */
-	public Object recoverFromMismatchedSet(IntStream input,
-										   RecognitionException e,
-										   BitSet follow)
-		throws RecognitionException
-	{
-		if ( mismatchIsMissingToken(input, follow) ) {
-			// System.out.println("missing token");
-			reportError(e);
-			// we don't know how to conjure up a token for sets yet
-			return getMissingSymbol(input, e, Token.INVALID_TOKEN_TYPE, follow);
-		}
-		// TODO do single token deletion like above for Token mismatch
-		throw e;
-	}
-
-	/** Match needs to return the current input symbol, which gets put
-	 *  into the label for the associated token ref; e.g., x=ID.  Token
-	 *  and tree parsers need to return different objects. Rather than test
-	 *  for input stream type or change the IntStream interface, I use
-	 *  a simple method to ask the recognizer to tell me what the current
-	 *  input symbol is.
-	 * 
-	 *  This is ignored for lexers.
-	 */
-	protected Object getCurrentInputSymbol(IntStream input) { return null; }
-
-	/** Conjure up a missing token during error recovery.
-	 *
-	 *  The recognizer attempts to recover from single missing
-	 *  symbols. But, actions might refer to that missing symbol.
-	 *  For example, x=ID {f($x);}. The action clearly assumes
-	 *  that there has been an identifier matched previously and that
-	 *  $x points at that token. If that token is missing, but
-	 *  the next token in the stream is what we want we assume that
-	 *  this token is missing and we keep going. Because we
-	 *  have to return some token to replace the missing token,
-	 *  we have to conjure one up. This method gives the user control
-	 *  over the tokens returned for missing tokens. Mostly,
-	 *  you will want to create something special for identifier
-	 *  tokens. For literals such as '{' and ',', the default
-	 *  action in the parser or tree parser works. It simply creates
-	 *  a CommonToken of the appropriate type. The text will be the token.
-	 *  If you change what tokens must be created by the lexer,
-	 *  override this method to create the appropriate tokens.
-	 */
-	protected Object getMissingSymbol(IntStream input,
-									  RecognitionException e,
-									  int expectedTokenType,
-									  BitSet follow)
-	{
-		return null;
-	}
-
-	public void consumeUntil(IntStream input, int tokenType) {
-		//System.out.println("consumeUntil "+tokenType);
-		int ttype = input.LA(1);
-		while (ttype != Token.EOF && ttype != tokenType) {
-			input.consume();
-			ttype = input.LA(1);
-		}
-	}
-
-	/** Consume tokens until one matches the given token set */
-	public void consumeUntil(IntStream input, BitSet set) {
-		//System.out.println("consumeUntil("+set.toString(getTokenNames())+")");
-		int ttype = input.LA(1);
-		while (ttype != Token.EOF && !set.member(ttype) ) {
-			//System.out.println("consume during recover LA(1)="+getTokenNames()[input.LA(1)]);
-			input.consume();
-			ttype = input.LA(1);
-		}
-	}
-
-	/** Push a rule's follow set using our own hardcoded stack */
-	protected void pushFollow(BitSet fset) {
-		if ( (state._fsp +1)>=state.following.length ) {
-			BitSet[] f = new BitSet[state.following.length*2];
-			System.arraycopy(state.following, 0, f, 0, state.following.length);
-			state.following = f;
-		}
-		state.following[++state._fsp] = fset;
-	}
-
-	/** Return List<String> of the rules in your parser instance
-	 *  leading up to a call to this method.  You could override if
-	 *  you want more details such as the file/line info of where
-	 *  in the parser java code a rule is invoked.
-	 *
-	 *  This is very useful for error messages and for context-sensitive
-	 *  error recovery.
-	 */
-	public List getRuleInvocationStack() {
-		String parserClassName = getClass().getName();
-		return getRuleInvocationStack(new Throwable(), parserClassName);
-	}
-
-	/** A more general version of getRuleInvocationStack where you can
-	 *  pass in, for example, a RecognitionException to get it's rule
-	 *  stack trace.  This routine is shared with all recognizers, hence,
-	 *  static.
-	 *
-	 *  TODO: move to a utility class or something; weird having lexer call this
-	 */
-	public static List getRuleInvocationStack(Throwable e,
-											  String recognizerClassName)
-	{
-		List rules = new ArrayList();
-		StackTraceElement[] stack = e.getStackTrace();
-		int i = 0;
-		for (i=stack.length-1; i>=0; i--) {
-			StackTraceElement t = stack[i];
-			if ( t.getClassName().startsWith("org.eclipse.persistence.internal.libraries.antlr.runtime.") ) {
-				continue; // skip support code such as this method
-			}
-			if ( t.getMethodName().equals(NEXT_TOKEN_RULE_NAME) ) {
-				continue;
-			}
-			if ( !t.getClassName().equals(recognizerClassName) ) {
-				continue; // must not be part of this parser
-			}
-            rules.add(t.getMethodName());
-		}
-		return rules;
-	}
-
-    public int getBacktrackingLevel() { return state.backtracking; }
-
-    public void setBacktrackingLevel(int n) { state.backtracking = n; }
-
-    /** Return whether or not a backtracking attempt failed. */
-    public boolean failed() { return state.failed; }
-
-	/** Used to print out token names like ID during debugging and
-	 *  error reporting.  The generated parsers implement a method
-	 *  that overrides this to point to their String[] tokenNames.
-	 */
-	public String[] getTokenNames() {
-		return null;
-	}
-
-	/** For debugging and other purposes, might want the grammar name.
-	 *  Have ANTLR generate an implementation for this method.
-	 */
-	public String getGrammarFileName() {
-		return null;
-	}
-
-	public abstract String getSourceName();
-
-	/** A convenience method for use most often with template rewrites.
-	 *  Convert a List<Token> to List<String>
-	 */
-	public List toStrings(List tokens) {
-		if ( tokens==null ) return null;
-		List strings = new ArrayList(tokens.size());
-		for (int i=0; i<tokens.size(); i++) {
-			strings.add(((Token)tokens.get(i)).getText());
-		}
-		return strings;
-	}
-
-	/** Given a rule number and a start token index number, return
-	 *  MEMO_RULE_UNKNOWN if the rule has not parsed input starting from
-	 *  start index.  If this rule has parsed input starting from the
-	 *  start index before, then return where the rule stopped parsing.
-	 *  It returns the index of the last token matched by the rule.
-	 *
-	 *  For now we use a hashtable and just the slow Object-based one.
-	 *  Later, we can make a special one for ints and also one that
-	 *  tosses out data after we commit past input position i.
-	 */
-	public int getRuleMemoization(int ruleIndex, int ruleStartIndex) {
-		if ( state.ruleMemo[ruleIndex]==null ) {
-			state.ruleMemo[ruleIndex] = new HashMap();
-		}
-		Integer stopIndexI =
-			(Integer)state.ruleMemo[ruleIndex].get(new Integer(ruleStartIndex));
-		if ( stopIndexI==null ) {
-			return MEMO_RULE_UNKNOWN;
-		}
-		return stopIndexI.intValue();
-	}
-
-	/** Has this rule already parsed input at the current index in the
-	 *  input stream?  Return the stop token index or MEMO_RULE_UNKNOWN.
-	 *  If we attempted but failed to parse properly before, return
-	 *  MEMO_RULE_FAILED.
-	 *
-	 *  This method has a side-effect: if we have seen this input for
-	 *  this rule and successfully parsed before, then seek ahead to
-	 *  1 past the stop token matched for this rule last time.
-	 */
-	public boolean alreadyParsedRule(IntStream input, int ruleIndex) {
-		int stopIndex = getRuleMemoization(ruleIndex, input.index());
-		if ( stopIndex==MEMO_RULE_UNKNOWN ) {
-			return false;
-		}
-		if ( stopIndex==MEMO_RULE_FAILED ) {
-			//System.out.println("rule "+ruleIndex+" will never succeed");
-			state.failed=true;
-		}
-		else {
-			//System.out.println("seen rule "+ruleIndex+" before; skipping ahead to @"+(stopIndex+1)+" failed="+state.failed);
-			input.seek(stopIndex+1); // jump to one past stop token
-		}
-		return true;
-	}
-
-	/** Record whether or not this rule parsed the input at this position
-	 *  successfully.  Use a standard java hashtable for now.
-	 */
-	public void memoize(IntStream input,
-						int ruleIndex,
-						int ruleStartIndex)
-	{
-		int stopTokenIndex = state.failed?MEMO_RULE_FAILED:input.index()-1;
-		if ( state.ruleMemo==null ) {
-			System.err.println("!!!!!!!!! memo array is null for "+ getGrammarFileName());
-		}
-		if ( ruleIndex >= state.ruleMemo.length ) {
-			System.err.println("!!!!!!!!! memo size is "+state.ruleMemo.length+", but rule index is "+ruleIndex);
-		}
-		if ( state.ruleMemo[ruleIndex]!=null ) {
-			state.ruleMemo[ruleIndex].put(
-				new Integer(ruleStartIndex), new Integer(stopTokenIndex)
-			);
-		}
-	}
-
-	/** return how many rule/input-index pairs there are in total.
-	 *  TODO: this includes synpreds. :(
-	 */
-	public int getRuleMemoizationCacheSize() {
-		int n = 0;
-		for (int i = 0; state.ruleMemo!=null && i < state.ruleMemo.length; i++) {
-			Map ruleMap = state.ruleMemo[i];
-			if ( ruleMap!=null ) {
-				n += ruleMap.size(); // how many input indexes are recorded?
-			}
-		}
-		return n;
-	}
-
-	public void traceIn(String ruleName, int ruleIndex, Object inputSymbol)  {
-		System.out.print("enter "+ruleName+" "+inputSymbol);
-		if ( state.backtracking>0 ) {
-			System.out.print(" backtracking="+state.backtracking);
-		}
-		System.out.println();
-	}
-
-	public void traceOut(String ruleName,
-						 int ruleIndex,
-						 Object inputSymbol)
-	{
-		System.out.print("exit "+ruleName+" "+inputSymbol);
-		if ( state.backtracking>0 ) {
-            System.out.print(" backtracking="+state.backtracking);
-            if ( state.failed ) System.out.print(" failed");
-            else System.out.print(" succeeded");
-        }
-		System.out.println();
-	}
-
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/BitSet.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/BitSet.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/BitSet.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/BitSet.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,325 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-import java.util.List;
-
-/**A stripped-down version of org.antlr.misc.BitSet that is just
- * good enough to handle runtime requirements such as FOLLOW sets
- * for automatic error recovery.
- */
-public class BitSet implements Cloneable {
-    protected final static int BITS = 64;    // number of bits / long
-    protected final static int LOG_BITS = 6; // 2^6 == 64
-
-    /* We will often need to do a mod operator (i mod nbits).  Its
-     * turns out that, for powers of two, this mod operation is
-     * same as (i & (nbits-1)).  Since mod is slow, we use a
-     * precomputed mod mask to do the mod instead.
-     */
-    protected final static int MOD_MASK = BITS - 1;
-
-    /** The actual data bits */
-    protected long bits[];
-
-    /** Construct a bitset of size one word (64 bits) */
-    public BitSet() {
-        this(BITS);
-    }
-
-    /** Construction from a static array of longs */
-    public BitSet(long[] bits_) {
-        bits = bits_;
-    }
-
-	/** Construction from a list of integers */
-	public BitSet(List items) {
-		this();
-		for (int i = 0; i < items.size(); i++) {
-			Integer v = (Integer) items.get(i);
-			add(v.intValue());
-		}
-	}
-
-    /** Construct a bitset given the size
-     * @param nbits The size of the bitset in bits
-     */
-    public BitSet(int nbits) {
-        bits = new long[((nbits - 1) >> LOG_BITS) + 1];
-    }
-
-	public static BitSet of(int el) {
-		BitSet s = new BitSet(el + 1);
-		s.add(el);
-		return s;
-	}
-
-	public static BitSet of(int a, int b) {
-		BitSet s = new BitSet(Math.max(a,b)+1);
-		s.add(a);
-		s.add(b);
-		return s;
-	}
-
-	public static BitSet of(int a, int b, int c) {
-		BitSet s = new BitSet();
-		s.add(a);
-		s.add(b);
-		s.add(c);
-		return s;
-	}
-
-	public static BitSet of(int a, int b, int c, int d) {
-		BitSet s = new BitSet();
-		s.add(a);
-		s.add(b);
-		s.add(c);
-		s.add(d);
-		return s;
-	}
-
-	/** return this | a in a new set */
-	public BitSet or(BitSet a) {
-		if ( a==null ) {
-			return this;
-		}
-		BitSet s = (BitSet)this.clone();
-		s.orInPlace(a);
-		return s;
-	}
-
-	/** or this element into this set (grow as necessary to accommodate) */
-	public void add(int el) {
-		int n = wordNumber(el);
-		if (n >= bits.length) {
-			growToInclude(el);
-		}
-		bits[n] |= bitMask(el);
-	}
-
-	/**
-	 * Grows the set to a larger number of bits.
-	 * @param bit element that must fit in set
-	 */
-	public void growToInclude(int bit) {
-		int newSize = Math.max(bits.length << 1, numWordsToHold(bit));
-		long newbits[] = new long[newSize];
-		System.arraycopy(bits, 0, newbits, 0, bits.length);
-		bits = newbits;
-	}
-
-	public void orInPlace(BitSet a) {
-		if ( a==null ) {
-			return;
-		}
-		// If this is smaller than a, grow this first
-		if (a.bits.length > bits.length) {
-			setSize(a.bits.length);
-		}
-		int min = Math.min(bits.length, a.bits.length);
-		for (int i = min - 1; i >= 0; i--) {
-			bits[i] |= a.bits[i];
-		}
-	}
-
-	/**
-	 * Sets the size of a set.
-	 * @param nwords how many words the new set should be
-	 */
-	private void setSize(int nwords) {
-		long newbits[] = new long[nwords];
-		int n = Math.min(nwords, bits.length);
-		System.arraycopy(bits, 0, newbits, 0, n);
-		bits = newbits;
-	}
-
-    private final static long bitMask(int bitNumber) {
-        int bitPosition = bitNumber & MOD_MASK; // bitNumber mod BITS
-        return 1L << bitPosition;
-    }
-
-    public Object clone() {
-        BitSet s;
-        try {
-            s = (BitSet)super.clone();
-            s.bits = new long[bits.length];
-            System.arraycopy(bits, 0, s.bits, 0, bits.length);
-        }
-        catch (CloneNotSupportedException e) {
-            throw new InternalError();
-        }
-        return s;
-    }
-
-    public int size() {
-        int deg = 0;
-        for (int i = bits.length - 1; i >= 0; i--) {
-            long word = bits[i];
-            if (word != 0L) {
-                for (int bit = BITS - 1; bit >= 0; bit--) {
-                    if ((word & (1L << bit)) != 0) {
-                        deg++;
-                    }
-                }
-            }
-        }
-        return deg;
-    }
-
-    public boolean equals(Object other) {
-        if ( other == null || !(other instanceof BitSet) ) {
-            return false;
-        }
-
-        BitSet otherSet = (BitSet)other;
-
-        int n = Math.min(this.bits.length, otherSet.bits.length);
-
-        // for any bits in common, compare
-        for (int i=0; i<n; i++) {
-            if (this.bits[i] != otherSet.bits[i]) {
-                return false;
-            }
-        }
-
-        // make sure any extra bits are off
-
-        if (this.bits.length > n) {
-            for (int i = n+1; i<this.bits.length; i++) {
-                if (this.bits[i] != 0) {
-                    return false;
-                }
-            }
-        }
-        else if (otherSet.bits.length > n) {
-            for (int i = n+1; i<otherSet.bits.length; i++) {
-                if (otherSet.bits[i] != 0) {
-                    return false;
-                }
-            }
-        }
-
-        return true;
-    }
-
-    public boolean member(int el) {
-		if ( el<0 ) {
-			return false;
-		}
-        int n = wordNumber(el);
-        if (n >= bits.length) return false;
-        return (bits[n] & bitMask(el)) != 0;
-    }
-
-	// remove this element from this set
-	public void remove(int el) {
-		int n = wordNumber(el);
-		if (n < bits.length) {
-			bits[n] &= ~bitMask(el);
-		}
-	}
-
-    public boolean isNil() {
-        for (int i = bits.length - 1; i >= 0; i--) {
-            if (bits[i] != 0) return false;
-        }
-        return true;
-    }
-
-    private final int numWordsToHold(int el) {
-        return (el >> LOG_BITS) + 1;
-    }
-
-    public int numBits() {
-        return bits.length << LOG_BITS; // num words * bits per word
-    }
-
-    /** return how much space is being used by the bits array not
-     *  how many actually have member bits on.
-     */
-    public int lengthInLongWords() {
-        return bits.length;
-    }
-
-    /**Is this contained within a? */
-    /*
-	public boolean subset(BitSet a) {
-        if (a == null || !(a instanceof BitSet)) return false;
-        return this.and(a).equals(this);
-    }
-	*/
-
-    public int[] toArray() {
-        int[] elems = new int[size()];
-        int en = 0;
-        for (int i = 0; i < (bits.length << LOG_BITS); i++) {
-            if (member(i)) {
-                elems[en++] = i;
-            }
-        }
-        return elems;
-    }
-
-    public long[] toPackedArray() {
-        return bits;
-    }
-
-	private final static int wordNumber(int bit) {
-		return bit >> LOG_BITS; // bit / BITS
-	}
-
-	public String toString() {
-		return toString(null);
-	}
-
-	public String toString(String[] tokenNames) {
-		StringBuffer buf = new StringBuffer();
-		String separator = ",";
-		boolean havePrintedAnElement = false;
-		buf.append('{');
-
-		for (int i = 0; i < (bits.length << LOG_BITS); i++) {
-			if (member(i)) {
-				if (i > 0 && havePrintedAnElement ) {
-					buf.append(separator);
-				}
-				if ( tokenNames!=null ) {
-					buf.append(tokenNames[i]);
-				}
-				else {
-					buf.append(i);
-				}
-				havePrintedAnElement = true;
-			}
-		}
-		buf.append('}');
-		return buf.toString();
-	}
-
-
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/CharStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/CharStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/CharStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/CharStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,57 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-/** A source of characters for an ANTLR lexer */
-public interface CharStream extends IntStream {
-    public static final int EOF = -1;
-
-	/** For infinite streams, you don't need this; primarily I'm providing
-	 *  a useful interface for action code.  Just make sure actions don't
-	 *  use this on streams that don't support it.
-	 */
-	public String substring(int start, int stop);
-
-	/** Get the ith character of lookahead.  This is the same usually as
-	 *  LA(i).  This will be used for labels in the generated
-	 *  lexer code.  I'd prefer to return a char here type-wise, but it's
-	 *  probably better to be 32-bit clean and be consistent with LA.
-	 */
-	public int LT(int i);
-
-	/** ANTLR tracks the line information automatically */
-	int getLine();
-
-	/** Because this stream can rewind, we need to be able to reset the line */
-	void setLine(int line);
-
-	void setCharPositionInLine(int pos);
-
-	/** The index of the character relative to the beginning of the line 0..n-1 */
-	int getCharPositionInLine();
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/CharStreamState.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/CharStreamState.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/CharStreamState.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/CharStreamState.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-/** When walking ahead with cyclic DFA or for syntactic predicates,
- *  we need to record the state of the input stream (char index,
- *  line, etc...) so that we can rewind the state after scanning ahead.
- *
- *  This is the complete state of a stream.
- */
-public class CharStreamState {
-	/** Index into the char stream of next lookahead char */
-	int p;
-
-	/** What line number is the scanner at before processing buffer[p]? */
-	int line;
-	
-	/** What char position 0..n-1 in line is scanner before processing buffer[p]? */
-	int charPositionInLine;
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/ClassicToken.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/ClassicToken.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/ClassicToken.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/ClassicToken.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,141 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-/** A Token object like we'd use in ANTLR 2.x; has an actual string created
- *  and associated with this object.  These objects are needed for imaginary
- *  tree nodes that have payload objects.  We need to create a Token object
- *  that has a string; the tree node will point at this token.  CommonToken
- *  has indexes into a char stream and hence cannot be used to introduce
- *  new strings.
- */
-public class ClassicToken implements Token {
-	protected String text;
-	protected int type;
-	protected int line;
-	protected int charPositionInLine;
-	protected int channel=DEFAULT_CHANNEL;
-
-	/** What token number is this from 0..n-1 tokens */
-	protected int index;
-
-	public ClassicToken(int type) {
-		this.type = type;
-	}
-
-	public ClassicToken(Token oldToken) {
-		text = oldToken.getText();
-		type = oldToken.getType();
-		line = oldToken.getLine();
-		charPositionInLine = oldToken.getCharPositionInLine();
-		channel = oldToken.getChannel();
-	}
-
-	public ClassicToken(int type, String text) {
-		this.type = type;
-		this.text = text;
-	}
-
-	public ClassicToken(int type, String text, int channel) {
-		this.type = type;
-		this.text = text;
-		this.channel = channel;
-	}
-
-	public int getType() {
-		return type;
-	}
-
-	public void setLine(int line) {
-		this.line = line;
-	}
-
-	public String getText() {
-		return text;
-	}
-
-	public void setText(String text) {
-		this.text = text;
-	}
-
-	public int getLine() {
-		return line;
-	}
-
-	public int getCharPositionInLine() {
-		return charPositionInLine;
-	}
-
-	public void setCharPositionInLine(int charPositionInLine) {
-		this.charPositionInLine = charPositionInLine;
-	}
-
-	public int getChannel() {
-		return channel;
-	}
-
-	public void setChannel(int channel) {
-		this.channel = channel;
-	}
-
-	public void setType(int type) {
-		this.type = type;
-	}
-
-	public int getTokenIndex() {
-		return index;
-	}
-
-	public void setTokenIndex(int index) {
-		this.index = index;
-	}
-
-	public CharStream getInputStream() {
-		return null;
-	}
-
-	public void setInputStream(CharStream input) {
-	}
-	
-	public String toString() {
-		String channelStr = "";
-		if ( channel>0 ) {
-			channelStr=",channel="+channel;
-		}
-		String txt = getText();
-		if ( txt!=null ) {
-			txt = txt.replaceAll("\n","\\\\n");
-			txt = txt.replaceAll("\r","\\\\r");
-			txt = txt.replaceAll("\t","\\\\t");
-		}
-		else {
-			txt = "<no text>";
-		}
-		return "[@"+getTokenIndex()+",'"+txt+"',<"+type+">"+channelStr+","+line+":"+getCharPositionInLine()+"]";
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/CommonToken.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/CommonToken.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/CommonToken.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/CommonToken.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,185 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-import java.io.Serializable;
-
-public class CommonToken implements Token, Serializable {
-	protected int type;
-	protected int line;
-	protected int charPositionInLine = -1; // set to invalid position
-	protected int channel=DEFAULT_CHANNEL;
-	protected transient CharStream input;
-
-	/** We need to be able to change the text once in a while.  If
-	 *  this is non-null, then getText should return this.  Note that
-	 *  start/stop are not affected by changing this.
-	  */
-	protected String text;
-
-	/** What token number is this from 0..n-1 tokens; < 0 implies invalid index */
-	protected int index = -1;
-
-	/** The char position into the input buffer where this token starts */
-	protected int start;
-
-	/** The char position into the input buffer where this token stops */
-	protected int stop;
-
-	public CommonToken(int type) {
-		this.type = type;
-	}
-
-	public CommonToken(CharStream input, int type, int channel, int start, int stop) {
-		this.input = input;
-		this.type = type;
-		this.channel = channel;
-		this.start = start;
-		this.stop = stop;
-	}
-
-	public CommonToken(int type, String text) {
-		this.type = type;
-		this.channel = DEFAULT_CHANNEL;
-		this.text = text;
-	}
-
-	public CommonToken(Token oldToken) {
-		text = oldToken.getText();
-		type = oldToken.getType();
-		line = oldToken.getLine();
-		index = oldToken.getTokenIndex();
-		charPositionInLine = oldToken.getCharPositionInLine();
-		channel = oldToken.getChannel();
-		if ( oldToken instanceof CommonToken ) {
-			start = ((CommonToken)oldToken).start;
-			stop = ((CommonToken)oldToken).stop;
-		}
-	}
-
-	public int getType() {
-		return type;
-	}
-
-	public void setLine(int line) {
-		this.line = line;
-	}
-
-	public String getText() {
-		if ( text!=null ) {
-			return text;
-		}
-		if ( input==null ) {
-			return null;
-		}
-		text = input.substring(start,stop);
-		return text;
-	}
-
-	/** Override the text for this token.  getText() will return this text
-	 *  rather than pulling from the buffer.  Note that this does not mean
-	 *  that start/stop indexes are not valid.  It means that that input
-	 *  was converted to a new string in the token object.
-	 */
-	public void setText(String text) {
-		this.text = text;
-	}
-
-	public int getLine() {
-		return line;
-	}
-
-	public int getCharPositionInLine() {
-		return charPositionInLine;
-	}
-
-	public void setCharPositionInLine(int charPositionInLine) {
-		this.charPositionInLine = charPositionInLine;
-	}
-
-	public int getChannel() {
-		return channel;
-	}
-
-	public void setChannel(int channel) {
-		this.channel = channel;
-	}
-
-	public void setType(int type) {
-		this.type = type;
-	}
-
-	public int getStartIndex() {
-		return start;
-	}
-
-	public void setStartIndex(int start) {
-		this.start = start;
-	}
-
-	public int getStopIndex() {
-		return stop;
-	}
-
-	public void setStopIndex(int stop) {
-		this.stop = stop;
-	}
-
-	public int getTokenIndex() {
-		return index;
-	}
-
-	public void setTokenIndex(int index) {
-		this.index = index;
-	}
-
-	public CharStream getInputStream() {
-		return input;
-	}
-
-	public void setInputStream(CharStream input) {
-		this.input = input;
-	}
-
-	public String toString() {
-		String channelStr = "";
-		if ( channel>0 ) {
-			channelStr=",channel="+channel;
-		}
-		String txt = getText();
-		if ( txt!=null ) {
-			txt = txt.replaceAll("\n","\\\\n");
-			txt = txt.replaceAll("\r","\\\\r");
-			txt = txt.replaceAll("\t","\\\\t");
-		}
-		else {
-			txt = "<no text>";
-		}
-		return "[@"+getTokenIndex()+","+start+":"+stop+"='"+txt+"',<"+type+">"+channelStr+","+line+":"+getCharPositionInLine()+"]";
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/CommonTokenStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/CommonTokenStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/CommonTokenStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/CommonTokenStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,379 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-import java.util.*;
-
-/** The most common stream of tokens is one where every token is buffered up
- *  and tokens are prefiltered for a certain channel (the parser will only
- *  see these tokens and cannot change the filter channel number during the
- *  parse).
- *
- *  TODO: how to access the full token stream?  How to track all tokens matched per rule?
- */
-public class CommonTokenStream implements TokenStream {
-    protected TokenSource tokenSource;
-
-	/** Record every single token pulled from the source so we can reproduce
-	 *  chunks of it later.
-	 */
-	protected List tokens;
-
-	/** Map<tokentype, channel> to override some Tokens' channel numbers */
-	protected Map channelOverrideMap;
-
-	/** Set<tokentype>; discard any tokens with this type */
-	protected Set discardSet;
-
-	/** Skip tokens on any channel but this one; this is how we skip whitespace... */
-	protected int channel = Token.DEFAULT_CHANNEL;
-
-	/** By default, track all incoming tokens */
-	protected boolean discardOffChannelTokens = false;
-
-	/** Track the last mark() call result value for use in rewind(). */
-	protected int lastMarker;
-
-	/** The index into the tokens list of the current token (next token
-     *  to consume).  p==-1 indicates that the tokens list is empty
-     */
-    protected int p = -1;
-
-	public CommonTokenStream() {
-		tokens = new ArrayList(500);
-	}
-
-	public CommonTokenStream(TokenSource tokenSource) {
-	    this();
-		this.tokenSource = tokenSource;
-	}
-
-	public CommonTokenStream(TokenSource tokenSource, int channel) {
-		this(tokenSource);
-		this.channel = channel;
-	}
-
-	/** Reset this token stream by setting its token source. */
-	public void setTokenSource(TokenSource tokenSource) {
-		this.tokenSource = tokenSource;
-		tokens.clear();
-		p = -1;
-		channel = Token.DEFAULT_CHANNEL;
-	}
-
-	/** Load all tokens from the token source and put in tokens.
-	 *  This is done upon first LT request because you might want to
-	 *  set some token type / channel overrides before filling buffer.
-	 */
-	protected void fillBuffer() {
-		int index = 0;
-		Token t = tokenSource.nextToken();
-		while ( t!=null && t.getType()!=CharStream.EOF ) {
-			boolean discard = false;
-			// is there a channel override for token type?
-			if ( channelOverrideMap!=null ) {
-				Integer channelI = (Integer)
-					channelOverrideMap.get(new Integer(t.getType()));
-				if ( channelI!=null ) {
-					t.setChannel(channelI.intValue());
-				}
-			}
-			if ( discardSet!=null &&
-				 discardSet.contains(new Integer(t.getType())) )
-			{
-				discard = true;
-			}
-			else if ( discardOffChannelTokens && t.getChannel()!=this.channel ) {
-				discard = true;
-			}
-			if ( !discard )	{
-				t.setTokenIndex(index);
-				tokens.add(t);
-				index++;
-			}
-			t = tokenSource.nextToken();
-		}
-		// leave p pointing at first token on channel
-		p = 0;
-		p = skipOffTokenChannels(p);
-    }
-
-	/** Move the input pointer to the next incoming token.  The stream
-	 *  must become active with LT(1) available.  consume() simply
-	 *  moves the input pointer so that LT(1) points at the next
-	 *  input symbol. Consume at least one token.
-	 *
-	 *  Walk past any token not on the channel the parser is listening to.
-	 */
-	public void consume() {
-		if ( p<tokens.size() ) {
-            p++;
-			p = skipOffTokenChannels(p); // leave p on valid token
-        }
-    }
-
-	/** Given a starting index, return the index of the first on-channel
-	 *  token.
-	 */
-	protected int skipOffTokenChannels(int i) {
-		int n = tokens.size();
-		while ( i<n && ((Token)tokens.get(i)).getChannel()!=channel ) {
-			i++;
-		}
-		return i;
-	}
-
-	protected int skipOffTokenChannelsReverse(int i) {
-		while ( i>=0 && ((Token)tokens.get(i)).getChannel()!=channel ) {
-			i--;
-		}
-		return i;
-	}
-
-	/** A simple filter mechanism whereby you can tell this token stream
-	 *  to force all tokens of type ttype to be on channel.  For example,
-	 *  when interpreting, we cannot exec actions so we need to tell
-	 *  the stream to force all WS and NEWLINE to be a different, ignored
-	 *  channel.
-	 */
-	public void setTokenTypeChannel(int ttype, int channel) {
-		if ( channelOverrideMap==null ) {
-			channelOverrideMap = new HashMap();
-		}
-        channelOverrideMap.put(new Integer(ttype), new Integer(channel));
-	}
-
-	public void discardTokenType(int ttype) {
-		if ( discardSet==null ) {
-			discardSet = new HashSet();
-		}
-        discardSet.add(new Integer(ttype));
-	}
-
-	public void discardOffChannelTokens(boolean discardOffChannelTokens) {
-		this.discardOffChannelTokens = discardOffChannelTokens;
-	}
-
-	public List getTokens() {
-		if ( p == -1 ) {
-			fillBuffer();
-		}
-		return tokens;
-	}
-
-	public List getTokens(int start, int stop) {
-		return getTokens(start, stop, (BitSet)null);
-	}
-
-	/** Given a start and stop index, return a List of all tokens in
-	 *  the token type BitSet.  Return null if no tokens were found.  This
-	 *  method looks at both on and off channel tokens.
-	 */
-	public List getTokens(int start, int stop, BitSet types) {
-		if ( p == -1 ) {
-			fillBuffer();
-		}
-		if ( stop>=tokens.size() ) {
-			stop=tokens.size()-1;
-		}
-		if ( start<0 ) {
-			start=0;
-		}
-		if ( start>stop ) {
-			return null;
-		}
-
-		// list = tokens[start:stop]:{Token t, t.getType() in types}
-		List filteredTokens = new ArrayList();
-		for (int i=start; i<=stop; i++) {
-			Token t = (Token)tokens.get(i);
-			if ( types==null || types.member(t.getType()) ) {
-				filteredTokens.add(t);
-			}
-		}
-		if ( filteredTokens.size()==0 ) {
-			filteredTokens = null;
-		}
-		return filteredTokens;
-	}
-
-	public List getTokens(int start, int stop, List types) {
-		return getTokens(start,stop,new BitSet(types));
-	}
-
-	public List getTokens(int start, int stop, int ttype) {
-		return getTokens(start,stop,BitSet.of(ttype));
-	}
-
-	/** Get the ith token from the current position 1..n where k=1 is the
-	 *  first symbol of lookahead.
-	 */
-	public Token LT(int k) {
-		if ( p == -1 ) {
-			fillBuffer();
-		}
-		if ( k==0 ) {
-			return null;
-		}
-		if ( k<0 ) {
-			return LB(-k);
-		}
-		//System.out.print("LT(p="+p+","+k+")=");
-		if ( (p+k-1) >= tokens.size() ) {
-			return Token.EOF_TOKEN;
-		}
-		//System.out.println(tokens.get(p+k-1));
-		int i = p;
-		int n = 1;
-		// find k good tokens
-		while ( n<k ) {
-			// skip off-channel tokens
-			i = skipOffTokenChannels(i+1); // leave p on valid token
-			n++;
-		}
-		if ( i>=tokens.size() ) {
-			return Token.EOF_TOKEN;
-		}
-        return (Token)tokens.get(i);
-    }
-
-	/** Look backwards k tokens on-channel tokens */
-	protected Token LB(int k) {
-		//System.out.print("LB(p="+p+","+k+") ");
-		if ( p == -1 ) {
-			fillBuffer();
-		}
-		if ( k==0 ) {
-			return null;
-		}
-		if ( (p-k)<0 ) {
-			return null;
-		}
-
-		int i = p;
-		int n = 1;
-		// find k good tokens looking backwards
-		while ( n<=k ) {
-			// skip off-channel tokens
-			i = skipOffTokenChannelsReverse(i-1); // leave p on valid token
-			n++;
-		}
-		if ( i<0 ) {
-			return null;
-		}
-		return (Token)tokens.get(i);
-	}
-
-	/** Return absolute token i; ignore which channel the tokens are on;
-	 *  that is, count all tokens not just on-channel tokens.
-	 */
-	public Token get(int i) {
-		return (Token)tokens.get(i);
-	}
-
-    public int LA(int i) {
-        return LT(i).getType();
-    }
-
-    public int mark() {
-		if ( p == -1 ) {
-			fillBuffer();
-		}
-		lastMarker = index();
-		return lastMarker;
-	}
-
-	public void release(int marker) {
-		// no resources to release
-	}
-
-	public int size() {
-		return tokens.size();
-	}
-
-    public int index() {
-        return p;
-    }
-
-	public void rewind(int marker) {
-		seek(marker);
-	}
-
-	public void rewind() {
-		seek(lastMarker);
-	}
-
-	public void reset() {
-		p = 0;
-		lastMarker = 0;
-	}
-	
-	public void seek(int index) {
-		p = index;
-	}
-
-	public TokenSource getTokenSource() {
-		return tokenSource;
-	}
-
-	public String getSourceName() {
-		return getTokenSource().getSourceName();
-	}
-
-	public String toString() {
-		if ( p == -1 ) {
-			fillBuffer();
-		}
-		return toString(0, tokens.size()-1);
-	}
-
-	public String toString(int start, int stop) {
-		if ( start<0 || stop<0 ) {
-			return null;
-		}
-		if ( p == -1 ) {
-			fillBuffer();
-		}
-		if ( stop>=tokens.size() ) {
-			stop = tokens.size()-1;
-		}
- 		StringBuffer buf = new StringBuffer();
-		for (int i = start; i <= stop; i++) {
-			Token t = (Token)tokens.get(i);
-			buf.append(t.getText());
-		}
-		return buf.toString();
-	}
-
-	public String toString(Token start, Token stop) {
-		if ( start!=null && stop!=null ) {
-			return toString(start.getTokenIndex(), stop.getTokenIndex());
-		}
-		return null;
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/BlankDebugEventListener.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/BlankDebugEventListener.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/BlankDebugEventListener.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/BlankDebugEventListener.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.debug;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognitionException;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-
-/** A blank listener that does nothing; useful for real classes so
- *  they don't have to have lots of blank methods and are less
- *  sensitive to updates to debug interface.
- */
-public class BlankDebugEventListener implements DebugEventListener {
-	public void enterRule(String grammarFileName, String ruleName) {}
-	public void exitRule(String grammarFileName, String ruleName) {}
-	public void enterAlt(int alt) {}
-	public void enterSubRule(int decisionNumber) {}
-	public void exitSubRule(int decisionNumber) {}
-	public void enterDecision(int decisionNumber) {}
-	public void exitDecision(int decisionNumber) {}
-	public void location(int line, int pos) {}
-	public void consumeToken(Token token) {}
-	public void consumeHiddenToken(Token token) {}
-	public void LT(int i, Token t) {}
-	public void mark(int i) {}
-	public void rewind(int i) {}
-	public void rewind() {}
-	public void beginBacktrack(int level) {}
-	public void endBacktrack(int level, boolean successful) {}
-	public void recognitionException(RecognitionException e) {}
-	public void beginResync() {}
-	public void endResync() {}
-	public void semanticPredicate(boolean result, String predicate) {}
-	public void commence() {}
-	public void terminate() {}
-
-	// Tree parsing stuff
-
-	public void consumeNode(Object t) {}
-	public void LT(int i, Object t) {}
-
-	// AST Stuff
-
-	public void nilNode(Object t) {}
-	public void errorNode(Object t) {}
-	public void createNode(Object t) {}
-	public void createNode(Object node, Token token) {}
-	public void becomeRoot(Object newRoot, Object oldRoot) {}
-	public void addChild(Object root, Object child) {}
-	public void setTokenBoundaries(Object t, int tokenStartIndex, int tokenStopIndex) {}
-}
-
-
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugEventHub.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugEventHub.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugEventHub.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugEventHub.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,292 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.debug;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognitionException;
-
-import java.util.List;
-import java.util.ArrayList;
-
-/** Broadcast debug events to multiple listeners.  Lets you debug and still
- *  use the event mechanism to build parse trees etc...  Not thread-safe.
- *  Don't add events in one thread while parser fires events in another.
- * 
- *  @see also DebugEventRepeater
- */
-public class DebugEventHub implements DebugEventListener {
-	protected List listeners = new ArrayList();
-
-	public DebugEventHub(DebugEventListener listener) {
-		listeners.add(listener);
-	}
-
-	public DebugEventHub(DebugEventListener a, DebugEventListener b) {
-		listeners.add(a);
-		listeners.add(b);
-	}
-
-	/** Add another listener to broadcast events too.  Not thread-safe.
-	 *  Don't add events in one thread while parser fires events in another.
-	 */
-	public void addListener(DebugEventListener listener) {
-		listeners.add(listener);
-	}
-	
-	/* To avoid a mess like this:
-		public void enterRule(final String ruleName) {
-			broadcast(new Code(){
-				public void exec(DebugEventListener listener) {listener.enterRule(ruleName);}}
-				);
-		}
-		I am dup'ing the for-loop in each.  Where are Java closures!? blech!
-	 */
-
-	public void enterRule(String grammarFileName, String ruleName) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.enterRule(grammarFileName,ruleName);
-		}
-	}
-
-	public void exitRule(String grammarFileName, String ruleName) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.exitRule(grammarFileName, ruleName);
-		}
-	}
-
-	public void enterAlt(int alt) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.enterAlt(alt);
-		}
-	}
-
-	public void enterSubRule(int decisionNumber) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.enterSubRule(decisionNumber);
-		}
-	}
-
-	public void exitSubRule(int decisionNumber) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.exitSubRule(decisionNumber);
-		}
-	}
-
-	public void enterDecision(int decisionNumber) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.enterDecision(decisionNumber);
-		}
-	}
-
-	public void exitDecision(int decisionNumber) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.exitDecision(decisionNumber);
-		}
-	}
-
-	public void location(int line, int pos) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.location(line, pos);
-		}
-	}
-
-	public void consumeToken(Token token) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.consumeToken(token);
-		}
-	}
-
-	public void consumeHiddenToken(Token token) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.consumeHiddenToken(token);
-		}
-	}
-
-	public void LT(int index, Token t) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.LT(index, t);
-		}
-	}
-
-	public void mark(int index) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.mark(index);
-		}
-	}
-
-	public void rewind(int index) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.rewind(index);
-		}
-	}
-
-	public void rewind() {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.rewind();
-		}
-	}
-
-	public void beginBacktrack(int level) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.beginBacktrack(level);
-		}
-	}
-
-	public void endBacktrack(int level, boolean successful) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.endBacktrack(level, successful);
-		}
-	}
-
-	public void recognitionException(RecognitionException e) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.recognitionException(e);
-		}
-	}
-
-	public void beginResync() {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.beginResync();
-		}
-	}
-
-	public void endResync() {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.endResync();
-		}
-	}
-
-	public void semanticPredicate(boolean result, String predicate) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.semanticPredicate(result, predicate);
-		}
-	}
-
-	public void commence() {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.commence();
-		}
-	}
-
-	public void terminate() {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.terminate();
-		}
-	}
-
-
-	// Tree parsing stuff
-
-	public void consumeNode(Object t) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.consumeNode(t);
-		}
-	}
-
-	public void LT(int index, Object t) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.LT(index, t);
-		}
-	}
-
-
-	// AST Stuff
-
-	public void nilNode(Object t) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.nilNode(t);
-		}
-	}
-
-	public void errorNode(Object t) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.errorNode(t);
-		}
-	}
-
-	public void createNode(Object t) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.createNode(t);
-		}
-	}
-
-	public void createNode(Object node, Token token) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.createNode(node, token);
-		}
-	}
-
-	public void becomeRoot(Object newRoot, Object oldRoot) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.becomeRoot(newRoot, oldRoot);
-		}
-	}
-
-	public void addChild(Object root, Object child) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.addChild(root, child);
-		}
-	}
-
-	public void setTokenBoundaries(Object t, int tokenStartIndex, int tokenStopIndex) {
-		for (int i = 0; i < listeners.size(); i++) {
-			DebugEventListener listener = (DebugEventListener)listeners.get(i);
-			listener.setTokenBoundaries(t, tokenStartIndex, tokenStopIndex);
-		}
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugEventListener.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugEventListener.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugEventListener.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugEventListener.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,323 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.debug;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognitionException;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-
-/** All debugging events that a recognizer can trigger.
- *
- *  I did not create a separate AST debugging interface as it would create
- *  lots of extra classes and DebugParser has a dbg var defined, which makes
- *  it hard to change to ASTDebugEventListener.  I looked hard at this issue
- *  and it is easier to understand as one monolithic event interface for all
- *  possible events.  Hopefully, adding ST debugging stuff won't be bad.  Leave
- *  for future. 4/26/2006.
- */
-public interface DebugEventListener {
-	/** Moved to version 2 for v3.1: added grammar name to enter/exit Rule */
-	public static final String PROTOCOL_VERSION = "2";
-	
-	/** serialized version of true */
-	public static final int TRUE = 1;
-	public static final int FALSE = 0;
-
-	/** The parser has just entered a rule.  No decision has been made about
-	 *  which alt is predicted.  This is fired AFTER init actions have been
-	 *  executed.  Attributes are defined and available etc...
-	 *  The grammarFileName allows composite grammars to jump around among
-	 *  multiple grammar files.
-	 */
-	public void enterRule(String grammarFileName, String ruleName);
-
-	/** Because rules can have lots of alternatives, it is very useful to
-	 *  know which alt you are entering.  This is 1..n for n alts.
-	 */
-	public void enterAlt(int alt);
-
-	/** This is the last thing executed before leaving a rule.  It is
-	 *  executed even if an exception is thrown.  This is triggered after
-	 *  error reporting and recovery have occurred (unless the exception is
-	 *  not caught in this rule).  This implies an "exitAlt" event.
-	 *  The grammarFileName allows composite grammars to jump around among
-	 *  multiple grammar files.
-	 */
-	public void exitRule(String grammarFileName, String ruleName);
-
-	/** Track entry into any (...) subrule other EBNF construct */
-	public void enterSubRule(int decisionNumber);
-
-	public void exitSubRule(int decisionNumber);
-
-	/** Every decision, fixed k or arbitrary, has an enter/exit event
-	 *  so that a GUI can easily track what LT/consume events are
-	 *  associated with prediction.  You will see a single enter/exit
-	 *  subrule but multiple enter/exit decision events, one for each
-	 *  loop iteration.
-	 */
-	public void enterDecision(int decisionNumber);
-
-	public void exitDecision(int decisionNumber);
-
-	/** An input token was consumed; matched by any kind of element.
-	 *  Trigger after the token was matched by things like match(), matchAny().
-	 */
-	public void consumeToken(Token t);
-
-	/** An off-channel input token was consumed.
-	 *  Trigger after the token was matched by things like match(), matchAny().
-	 *  (unless of course the hidden token is first stuff in the input stream).
-	 */
-	public void consumeHiddenToken(Token t);
-
-	/** Somebody (anybody) looked ahead.  Note that this actually gets
-	 *  triggered by both LA and LT calls.  The debugger will want to know
-	 *  which Token object was examined.  Like consumeToken, this indicates
-	 *  what token was seen at that depth.  A remote debugger cannot look
-	 *  ahead into a file it doesn't have so LT events must pass the token
-	 *  even if the info is redundant.
-	 */
-	public void LT(int i, Token t);
-
-	/** The parser is going to look arbitrarily ahead; mark this location,
-	 *  the token stream's marker is sent in case you need it.
-	 */
-	public void mark(int marker);
-
-	/** After an arbitrairly long lookahead as with a cyclic DFA (or with
-	 *  any backtrack), this informs the debugger that stream should be
-	 *  rewound to the position associated with marker.
-	 */
-	public void rewind(int marker);
-
-	/** Rewind to the input position of the last marker.
-	 *  Used currently only after a cyclic DFA and just
-	 *  before starting a sem/syn predicate to get the
-	 *  input position back to the start of the decision.
-	 *  Do not "pop" the marker off the state.  mark(i)
-	 *  and rewind(i) should balance still.
-	 */
-	public void rewind();
-
-	public void beginBacktrack(int level);
-
-	public void endBacktrack(int level, boolean successful);
-
-	/** To watch a parser move through the grammar, the parser needs to
-	 *  inform the debugger what line/charPos it is passing in the grammar.
-	 *  For now, this does not know how to switch from one grammar to the
-	 *  other and back for island grammars etc...
-	 *
-	 *  This should also allow breakpoints because the debugger can stop
-	 *  the parser whenever it hits this line/pos.
-	 */
-	public void location(int line, int pos);
-
-	/** A recognition exception occurred such as NoViableAltException.  I made
-	 *  this a generic event so that I can alter the exception hierachy later
-	 *  without having to alter all the debug objects.
-	 *
-	 *  Upon error, the stack of enter rule/subrule must be properly unwound.
-	 *  If no viable alt occurs it is within an enter/exit decision, which
-	 *  also must be rewound.  Even the rewind for each mark must be unwount.
-	 *  In the Java target this is pretty easy using try/finally, if a bit
-	 *  ugly in the generated code.  The rewind is generated in DFA.predict()
-	 *  actually so no code needs to be generated for that.  For languages
-	 *  w/o this "finally" feature (C++?), the target implementor will have
-	 *  to build an event stack or something.
-	 *
-	 *  Across a socket for remote debugging, only the RecognitionException
-	 *  data fields are transmitted.  The token object or whatever that
-	 *  caused the problem was the last object referenced by LT.  The
-	 *  immediately preceding LT event should hold the unexpected Token or
-	 *  char.
-	 *
-	 *  Here is a sample event trace for grammar:
-	 *
-	 *  b : C ({;}A|B) // {;} is there to prevent A|B becoming a set
-     *    | D
-     *    ;
-     *
-	 *  The sequence for this rule (with no viable alt in the subrule) for
-	 *  input 'c c' (there are 3 tokens) is:
-	 *
-	 *		commence
-	 *		LT(1)
-	 *		enterRule b
-	 *		location 7 1
-	 *		enter decision 3
-	 *		LT(1)
-	 *		exit decision 3
-	 *		enterAlt1
-	 *		location 7 5
-	 *		LT(1)
-	 *		consumeToken [c/<4>,1:0]
-	 *		location 7 7
-	 *		enterSubRule 2
-	 *		enter decision 2
-	 *		LT(1)
-	 *		LT(1)
-	 *		recognitionException NoViableAltException 2 1 2
-	 *		exit decision 2
-	 *		exitSubRule 2
-	 *		beginResync
-	 *		LT(1)
-	 *		consumeToken [c/<4>,1:1]
-	 *		LT(1)
-	 *		endResync
-	 *		LT(-1)
-	 *		exitRule b
-	 *		terminate
-	 */
-	public void recognitionException(RecognitionException e);
-
-	/** Indicates the recognizer is about to consume tokens to resynchronize
-	 *  the parser.  Any consume events from here until the recovered event
-	 *  are not part of the parse--they are dead tokens.
-	 */
-	public void beginResync();
-
-	/** Indicates that the recognizer has finished consuming tokens in order
-	 *  to resychronize.  There may be multiple beginResync/endResync pairs
-	 *  before the recognizer comes out of errorRecovery mode (in which
-	 *  multiple errors are suppressed).  This will be useful
-	 *  in a gui where you want to probably grey out tokens that are consumed
-	 *  but not matched to anything in grammar.  Anything between
-	 *  a beginResync/endResync pair was tossed out by the parser.
-	 */
-	public void endResync();
-
-	/** A semantic predicate was evaluate with this result and action text */
-	public void semanticPredicate(boolean result, String predicate);
-
-	/** Announce that parsing has begun.  Not technically useful except for
-	 *  sending events over a socket.  A GUI for example will launch a thread
-	 *  to connect and communicate with a remote parser.  The thread will want
-	 *  to notify the GUI when a connection is made.  ANTLR parsers
-	 *  trigger this upon entry to the first rule (the ruleLevel is used to
-	 *  figure this out).
-	 */
-	public void commence();
-
-	/** Parsing is over; successfully or not.  Mostly useful for telling
-	 *  remote debugging listeners that it's time to quit.  When the rule
-	 *  invocation level goes to zero at the end of a rule, we are done
-	 *  parsing.
-	 */
-	public void terminate();
-
-
-	// T r e e  P a r s i n g
-
-	/** Input for a tree parser is an AST, but we know nothing for sure
-	 *  about a node except its type and text (obtained from the adaptor).
-	 *  This is the analog of the consumeToken method.  Again, the ID is
-	 *  the hashCode usually of the node so it only works if hashCode is
-	 *  not implemented.  If the type is UP or DOWN, then
-	 *  the ID is not really meaningful as it's fixed--there is
-	 *  just one UP node and one DOWN navigation node.
-	 * @param t
-	 */
-	public void consumeNode(Object t);
-
-	/** The tree parser lookedahead.  If the type is UP or DOWN,
-	 *  then the ID is not really meaningful as it's fixed--there is
-	 *  just one UP node and one DOWN navigation node.
-	 */
-	public void LT(int i, Object t);
-
-
-	// A S T  E v e n t s
-
-	/** A nil was created (even nil nodes have a unique ID...
-	 *  they are not "null" per se).  As of 4/28/2006, this
-	 *  seems to be uniquely triggered when starting a new subtree
-	 *  such as when entering a subrule in automatic mode and when
-	 *  building a tree in rewrite mode.
-     *
- 	 *  If you are receiving this event over a socket via
-	 *  RemoteDebugEventSocketListener then only t.ID is set.
-	 */
-	public void nilNode(Object t);
-
-	/** Upon syntax error, recognizers bracket the error with an error node
-	 *  if they are building ASTs.
-	 * @param t
-	 */
-	public void errorNode(Object t);
-
-	/** Announce a new node built from token elements such as type etc...
-	 * 
-	 *  If you are receiving this event over a socket via
-	 *  RemoteDebugEventSocketListener then only t.ID, type, text are
-	 *  set.
-	 */
-	public void createNode(Object t);
-
-	/** Announce a new node built from an existing token.
-	 *
-	 *  If you are receiving this event over a socket via
-	 *  RemoteDebugEventSocketListener then only node.ID and token.tokenIndex
-	 *  are set.
-	 */
-	public void createNode(Object node, Token token);
-
-	/** Make a node the new root of an existing root.  See
-	 *
-	 *  Note: the newRootID parameter is possibly different
-	 *  than the TreeAdaptor.becomeRoot() newRoot parameter.
-	 *  In our case, it will always be the result of calling
-	 *  TreeAdaptor.becomeRoot() and not root_n or whatever.
-	 *
-	 *  The listener should assume that this event occurs
-	 *  only when the current subrule (or rule) subtree is
-	 *  being reset to newRootID.
-	 * 
-	 *  If you are receiving this event over a socket via
-	 *  RemoteDebugEventSocketListener then only IDs are set.
-	 *
-	 *  @see org.eclipse.persistence.internal.libraries.antlr.runtime.tree.TreeAdaptor.becomeRoot()
-	 */
-	public void becomeRoot(Object newRoot, Object oldRoot);
-
-	/** Make childID a child of rootID.
-	 *
-	 *  If you are receiving this event over a socket via
-	 *  RemoteDebugEventSocketListener then only IDs are set.
-	 * 
-	 *  @see org.eclipse.persistence.internal.libraries.antlr.runtime.tree.TreeAdaptor.addChild()
-	 */
-	public void addChild(Object root, Object child);
-
-	/** Set the token start/stop token index for a subtree root or node.
-	 *
-	 *  If you are receiving this event over a socket via
-	 *  RemoteDebugEventSocketListener then only t.ID is set.
-	 */
-	public void setTokenBoundaries(Object t, int tokenStartIndex, int tokenStopIndex);
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugEventRepeater.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugEventRepeater.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugEventRepeater.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugEventRepeater.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,88 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.debug;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognitionException;
-
-/** A simple event repeater (proxy) that delegates all functionality to the
- *  listener sent into the ctor.  Useful if you want to listen in on a few
- *  debug events w/o interrupting the debugger.  Just subclass the repeater
- *  and override the methods you want to listen in on.  Remember to call
- *  the method in this class so the event will continue on to the original
- *  recipient.
- *
- *  @see DebugEventHub
- */
-public class DebugEventRepeater implements DebugEventListener {
-	protected DebugEventListener listener;
-
-	public DebugEventRepeater(DebugEventListener listener) {
-		this.listener = listener;
-	}
-	
-	public void enterRule(String grammarFileName, String ruleName) { listener.enterRule(grammarFileName, ruleName); }
-	public void exitRule(String grammarFileName, String ruleName) { listener.exitRule(grammarFileName, ruleName); }
-	public void enterAlt(int alt) { listener.enterAlt(alt); }
-	public void enterSubRule(int decisionNumber) { listener.enterSubRule(decisionNumber); }
-	public void exitSubRule(int decisionNumber) { listener.exitSubRule(decisionNumber); }
-	public void enterDecision(int decisionNumber) { listener.enterDecision(decisionNumber); }
-	public void exitDecision(int decisionNumber) { listener.exitDecision(decisionNumber); }
-	public void location(int line, int pos) { listener.location(line, pos); }
-	public void consumeToken(Token token) { listener.consumeToken(token); }
-	public void consumeHiddenToken(Token token) { listener.consumeHiddenToken(token); }
-	public void LT(int i, Token t) { listener.LT(i, t); }
-	public void mark(int i) { listener.mark(i); }
-	public void rewind(int i) { listener.rewind(i); }
-	public void rewind() { listener.rewind(); }
-	public void beginBacktrack(int level) { listener.beginBacktrack(level); }
-	public void endBacktrack(int level, boolean successful) { listener.endBacktrack(level, successful); }
-	public void recognitionException(RecognitionException e) { listener.recognitionException(e); }
-	public void beginResync() { listener.beginResync(); }
-	public void endResync() { listener.endResync(); }
-	public void semanticPredicate(boolean result, String predicate) { listener.semanticPredicate(result, predicate); }
-	public void commence() { listener.commence(); }
-	public void terminate() { listener.terminate(); }
-
-	// Tree parsing stuff
-
-	public void consumeNode(Object t) { listener.consumeNode(t); }
-	public void LT(int i, Object t) { listener.LT(i, t); }
-
-	// AST Stuff
-
-	public void nilNode(Object t) { listener.nilNode(t); }
-	public void errorNode(Object t) { listener.errorNode(t); }
-	public void createNode(Object t) { listener.createNode(t); }
-	public void createNode(Object node, Token token) { listener.createNode(node, token); }
-	public void becomeRoot(Object newRoot, Object oldRoot) { listener.becomeRoot(newRoot, oldRoot); }
-	public void addChild(Object root, Object child) { listener.addChild(root, child); }
-	public void setTokenBoundaries(Object t, int tokenStartIndex, int tokenStopIndex) {
-		listener.setTokenBoundaries(t, tokenStartIndex, tokenStopIndex);
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugEventSocketProxy.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugEventSocketProxy.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugEventSocketProxy.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugEventSocketProxy.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,354 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.debug;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognitionException;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.BaseRecognizer;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.tree.TreeAdaptor;
-
-import java.io.*;
-import java.net.ServerSocket;
-import java.net.Socket;
-
-/** A proxy debug event listener that forwards events over a socket to
- *  a debugger (or any other listener) using a simple text-based protocol;
- *  one event per line.  ANTLRWorks listens on server socket with a
- *  RemoteDebugEventSocketListener instance.  These two objects must therefore
- *  be kept in sync.  New events must be handled on both sides of socket.
- */
-public class DebugEventSocketProxy extends BlankDebugEventListener {
-	public static final int DEFAULT_DEBUGGER_PORT = 49100; // was 49153
-	protected int port = DEFAULT_DEBUGGER_PORT;
-	protected ServerSocket serverSocket;
-	protected Socket socket;
-	protected String grammarFileName;
-	protected PrintWriter out;
-	protected BufferedReader in;
-
-	/** Who am i debugging? */
-	protected BaseRecognizer recognizer;
-
-	/** Almost certainly the recognizer will have adaptor set, but
-	 *  we don't know how to cast it (Parser or TreeParser) to get
-	 *  the adaptor field.  Must be set with a constructor. :(
-	 */
-	protected TreeAdaptor adaptor;
-
-	public DebugEventSocketProxy(BaseRecognizer recognizer, TreeAdaptor adaptor) {
-		this(recognizer, DEFAULT_DEBUGGER_PORT, adaptor);
-	}
-
-	public DebugEventSocketProxy(BaseRecognizer recognizer, int port, TreeAdaptor adaptor) {
-		this.grammarFileName = recognizer.getGrammarFileName();
-		this.adaptor = adaptor;
-		this.port = port;
-	}
-
-	public void handshake() throws IOException {
-		if ( serverSocket==null ) {
-			serverSocket = new ServerSocket(port);
-			socket = serverSocket.accept();
-			socket.setTcpNoDelay(true);
-			OutputStream os = socket.getOutputStream();
-			OutputStreamWriter osw = new OutputStreamWriter(os, "UTF8");
-			out = new PrintWriter(new BufferedWriter(osw));
-			InputStream is = socket.getInputStream();
-			InputStreamReader isr = new InputStreamReader(is, "UTF8");
-			in = new BufferedReader(isr);
-			out.println("ANTLR "+ DebugEventListener.PROTOCOL_VERSION);
-			out.println("grammar \""+ grammarFileName);
-			out.flush();
-			ack();			
-		}
-	}
-
-	public void commence() {
-		// don't bother sending event; listener will trigger upon connection
-	}
-
-	public void terminate() {
-		transmit("terminate");
-		out.close();
-		try {
-			socket.close();
-		}
-		catch (IOException ioe) {
-			ioe.printStackTrace(System.err);
-		}
-	}
-
-	protected void ack() {
-		try {
-			in.readLine();
-		}
-		catch (IOException ioe) {
-			ioe.printStackTrace(System.err);
-		}
-	}
-
-	protected void transmit(String event) {
-		out.println(event);
-		out.flush();
-		ack();
-	}
-
-	public void enterRule(String grammarFileName, String ruleName) {
-		transmit("enterRule\t"+grammarFileName+"\t"+ruleName);
-	}
-
-	public void enterAlt(int alt) {
-		transmit("enterAlt\t"+alt);
-	}
-
-	public void exitRule(String grammarFileName, String ruleName) {
-		transmit("exitRule\t"+grammarFileName+"\t"+ruleName);
-	}
-
-	public void enterSubRule(int decisionNumber) {
-		transmit("enterSubRule\t"+decisionNumber);
-	}
-
-	public void exitSubRule(int decisionNumber) {
-		transmit("exitSubRule\t"+decisionNumber);
-	}
-
-	public void enterDecision(int decisionNumber) {
-		transmit("enterDecision\t"+decisionNumber);
-	}
-
-	public void exitDecision(int decisionNumber) {
-		transmit("exitDecision\t"+decisionNumber);
-	}
-
-	public void consumeToken(Token t) {
-		String buf = serializeToken(t);
-		transmit("consumeToken\t"+buf);
-	}
-
-	public void consumeHiddenToken(Token t) {
-		String buf = serializeToken(t);
-		transmit("consumeHiddenToken\t"+buf);
-	}
-
-	public void LT(int i, Token t) {
-        if(t != null)
-            transmit("LT\t"+i+"\t"+serializeToken(t));
-	}
-
-	public void mark(int i) {
-		transmit("mark\t"+i);
-	}
-
-	public void rewind(int i) {
-		transmit("rewind\t"+i);
-	}
-
-	public void rewind() {
-		transmit("rewind");
-	}
-
-	public void beginBacktrack(int level) {
-		transmit("beginBacktrack\t"+level);
-	}
-
-	public void endBacktrack(int level, boolean successful) {
-		transmit("endBacktrack\t"+level+"\t"+(successful?TRUE:FALSE));
-	}
-
-	public void location(int line, int pos) {
-		transmit("location\t"+line+"\t"+pos);
-	}
-
-	public void recognitionException(RecognitionException e) {
-		StringBuffer buf = new StringBuffer(50);
-		buf.append("exception\t");
-		buf.append(e.getClass().getName());
-		// dump only the data common to all exceptions for now
-		buf.append("\t");
-		buf.append(e.index);
-		buf.append("\t");
-		buf.append(e.line);
-		buf.append("\t");
-		buf.append(e.charPositionInLine);
-		transmit(buf.toString());
-	}
-
-	public void beginResync() {
-		transmit("beginResync");
-	}
-
-	public void endResync() {
-		transmit("endResync");
-	}
-
-	public void semanticPredicate(boolean result, String predicate) {
-		StringBuffer buf = new StringBuffer(50);
-		buf.append("semanticPredicate\t");
-		buf.append(result);
-		serializeText(buf, predicate);
-		transmit(buf.toString());
-	}
-
-	// A S T  P a r s i n g  E v e n t s
-
-	public void consumeNode(Object t) {
-		StringBuffer buf = new StringBuffer(50);
-		buf.append("consumeNode");
-		serializeNode(buf, t);
-		transmit(buf.toString());
-	}
-
-	public void LT(int i, Object t) {
-		int ID = adaptor.getUniqueID(t);
-		String text = adaptor.getText(t);
-		int type = adaptor.getType(t);
-		StringBuffer buf = new StringBuffer(50);
-		buf.append("LN\t"); // lookahead node; distinguish from LT in protocol
-		buf.append(i);
-		serializeNode(buf, t);
-		transmit(buf.toString());
-	}
-
-	protected void serializeNode(StringBuffer buf, Object t) {
-		int ID = adaptor.getUniqueID(t);
-		String text = adaptor.getText(t);
-		int type = adaptor.getType(t);
-		buf.append("\t");
-		buf.append(ID);
-		buf.append("\t");
-		buf.append(type);
-		Token token = adaptor.getToken(t);
-		int line = -1;
-		int pos = -1;
-		if ( token!=null ) {
-			line = token.getLine();
-			pos = token.getCharPositionInLine();
-		}
-		buf.append("\t");
-		buf.append(line);
-		buf.append("\t");
-		buf.append(pos);
-		int tokenIndex = adaptor.getTokenStartIndex(t);
-		buf.append("\t");
-		buf.append(tokenIndex);
-		serializeText(buf, text);
-	}
-
-	
-	// A S T  E v e n t s
-
-	public void nilNode(Object t) {
-		int ID = adaptor.getUniqueID(t);
-		transmit("nilNode\t"+ID);
-	}
-
-	public void errorNode(Object t) {
-		int ID = adaptor.getUniqueID(t);
-		String text = t.toString();
-		StringBuffer buf = new StringBuffer(50);
-		buf.append("errorNode\t");
-		buf.append(ID);
-		buf.append("\t");
-		buf.append(Token.INVALID_TOKEN_TYPE);
-		serializeText(buf, text);
-		transmit(buf.toString());
-	}
-
-	public void createNode(Object t) {
-		int ID = adaptor.getUniqueID(t);
-		String text = adaptor.getText(t);
-		int type = adaptor.getType(t);
-		StringBuffer buf = new StringBuffer(50);
-		buf.append("createNodeFromTokenElements\t");
-		buf.append(ID);
-		buf.append("\t");
-		buf.append(type);
-		serializeText(buf, text);
-		transmit(buf.toString());
-	}
-
-	public void createNode(Object node, Token token) {
-		int ID = adaptor.getUniqueID(node);
-		int tokenIndex = token.getTokenIndex();
-		transmit("createNode\t"+ID+"\t"+tokenIndex);
-	}
-
-	public void becomeRoot(Object newRoot, Object oldRoot) {
-		int newRootID = adaptor.getUniqueID(newRoot);
-		int oldRootID = adaptor.getUniqueID(oldRoot);
-		transmit("becomeRoot\t"+newRootID+"\t"+oldRootID);
-	}
-
-	public void addChild(Object root, Object child) {
-		int rootID = adaptor.getUniqueID(root);
-		int childID = adaptor.getUniqueID(child);
-		transmit("addChild\t"+rootID+"\t"+childID);
-	}
-
-	public void setTokenBoundaries(Object t, int tokenStartIndex, int tokenStopIndex) {
-		int ID = adaptor.getUniqueID(t);
-		transmit("setTokenBoundaries\t"+ID+"\t"+tokenStartIndex+"\t"+tokenStopIndex);
-	}
-
-
-    // support
-
-    public void setTreeAdaptor(TreeAdaptor adaptor) { this.adaptor = adaptor; }
-    public TreeAdaptor getTreeAdaptor() { return adaptor; }
-
-    protected String serializeToken(Token t) {
-        StringBuffer buf = new StringBuffer(50);
-        buf.append(t.getTokenIndex()); buf.append('\t');
-        buf.append(t.getType()); buf.append('\t');
-        buf.append(t.getChannel()); buf.append('\t');
-        buf.append(t.getLine()); buf.append('\t');
-		buf.append(t.getCharPositionInLine());
-		serializeText(buf, t.getText());
-		return buf.toString();
-	}
-
-	protected void serializeText(StringBuffer buf, String text) {
-		buf.append("\t\"");
-		if ( text==null ) {
-			text = "";
-		}
-		// escape \n and \r all text for token appears to exist on one line
-		// this escape is slow but easy to understand
-		text = escapeNewlines(text);
-		buf.append(text);
-	}
-
-	protected String escapeNewlines(String txt) {
-		txt = txt.replaceAll("%","%25");   // escape all escape char ;)
-		txt = txt.replaceAll("\n","%0A");  // escape \n
-		txt = txt.replaceAll("\r","%0D");  // escape \r
-		return txt;
-	}
-}
-
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugParser.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugParser.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugParser.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugParser.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,97 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.debug;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.*;
-
-import java.io.IOException;
-
-public class DebugParser extends Parser {
-	/** Who to notify when events in the parser occur. */
-	protected DebugEventListener dbg = null;
-
-	/** Used to differentiate between fixed lookahead and cyclic DFA decisions
-	 *  while profiling.
- 	 */
-	public boolean isCyclicDecision = false;
-
-	/** Create a normal parser except wrap the token stream in a debug
-	 *  proxy that fires consume events.
-	 */
-	public DebugParser(TokenStream input, DebugEventListener dbg, RecognizerSharedState state) {
-		super(input instanceof DebugTokenStream?input:new DebugTokenStream(input,dbg), state);
-		setDebugListener(dbg);
-	}
-
-	public DebugParser(TokenStream input, RecognizerSharedState state) {
-		super(input instanceof DebugTokenStream?input:new DebugTokenStream(input,null), state);
-	}
-
-	public DebugParser(TokenStream input, DebugEventListener dbg) {
-		this(input instanceof DebugTokenStream?input:new DebugTokenStream(input,dbg), dbg, null);
-	}
-
-	/** Provide a new debug event listener for this parser.  Notify the
-	 *  input stream too that it should send events to this listener.
-	 */
-	public void setDebugListener(DebugEventListener dbg) {
-		if ( input instanceof DebugTokenStream ) {
-			((DebugTokenStream)input).setDebugListener(dbg);
-		}
-		this.dbg = dbg;
-	}
-
-	public DebugEventListener getDebugListener() {
-		return dbg;
-	}
-
-	public void reportError(IOException e) {
-		System.err.println(e);
-		e.printStackTrace(System.err);
-	}
-
-	public void beginResync() {
-		dbg.beginResync();
-	}
-
-	public void endResync() {
-		dbg.endResync();
-	}
-
-	public void beginBacktrack(int level) {
-		dbg.beginBacktrack(level);
-	}
-
-	public void endBacktrack(int level, boolean successful) {
-		dbg.endBacktrack(level,successful);		
-	}
-
-	public void reportError(RecognitionException e) {
-		dbg.recognitionException(e);
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugTokenStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugTokenStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugTokenStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugTokenStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,150 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.debug;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.*;
-
-public class DebugTokenStream implements TokenStream {
-	protected DebugEventListener dbg;
-	public TokenStream input;
-	protected boolean initialStreamState = true;
-
-	/** Track the last mark() call result value for use in rewind(). */
-	protected int lastMarker;
-
-	public DebugTokenStream(TokenStream input, DebugEventListener dbg) {
-		this.input = input;
-		setDebugListener(dbg);
-		// force TokenStream to get at least first valid token
-		// so we know if there are any hidden tokens first in the stream
-		input.LT(1);
-	}
-
-	public void setDebugListener(DebugEventListener dbg) {
-		this.dbg = dbg;
-	}
-
-	public void consume() {
-		if ( initialStreamState ) {
-			consumeInitialHiddenTokens();
-		}
-		int a = input.index();
-		Token t = input.LT(1);
-		input.consume();
-		int b = input.index();
-		dbg.consumeToken(t);
-		if ( b>a+1 ) {
-			// then we consumed more than one token; must be off channel tokens
-			for (int i=a+1; i<b; i++) {
-				dbg.consumeHiddenToken(input.get(i));
-			}
-		}
-	}
-
-	/* consume all initial off-channel tokens */
-	protected void consumeInitialHiddenTokens() {
-		int firstOnChannelTokenIndex = input.index();
-		for (int i=0; i<firstOnChannelTokenIndex; i++) {
-			dbg.consumeHiddenToken(input.get(i));
-		}
-		initialStreamState = false;
-	}
-
-	public Token LT(int i) {
-		if ( initialStreamState ) {
-			consumeInitialHiddenTokens();
-		}
-		dbg.LT(i, input.LT(i));
-		return input.LT(i);
-	}
-
-	public int LA(int i) {
-		if ( initialStreamState ) {
-			consumeInitialHiddenTokens();
-		}
-		dbg.LT(i, input.LT(i));
-		return input.LA(i);
-	}
-
-	public Token get(int i) {
-		return input.get(i);
-	}
-
-	public int mark() {
-		lastMarker = input.mark();
-		dbg.mark(lastMarker);
-		return lastMarker;
-	}
-
-	public int index() {
-		return input.index();
-	}
-
-	public void rewind(int marker) {
-		dbg.rewind(marker);
-		input.rewind(marker);
-	}
-
-	public void rewind() {
-		dbg.rewind();
-		input.rewind(lastMarker);
-	}
-
-	public void release(int marker) {
-	}
-
-	public void seek(int index) {
-		// TODO: implement seek in dbg interface
-		// db.seek(index);
-		input.seek(index);
-	}
-
-	public int size() {
-		return input.size();
-	}
-
-	public TokenSource getTokenSource() {
-		return input.getTokenSource();
-	}
-
-	public String getSourceName() {
-		return getTokenSource().getSourceName();
-	}
-
-	public String toString() {
-		return input.toString();
-	}
-
-	public String toString(int start, int stop) {
-		return input.toString(start,stop);
-	}
-
-	public String toString(Token start, Token stop) {
-		return input.toString(start,stop);
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugTreeAdaptor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugTreeAdaptor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugTreeAdaptor.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugTreeAdaptor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,250 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.debug;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.TokenStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognitionException;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.tree.TreeAdaptor;
-
-/** A TreeAdaptor proxy that fires debugging events to a DebugEventListener
- *  delegate and uses the TreeAdaptor delegate to do the actual work.  All
- *  AST events are triggered by this adaptor; no code gen changes are needed
- *  in generated rules.  Debugging events are triggered *after* invoking
- *  tree adaptor routines.
- *
- *  Trees created with actions in rewrite actions like "-> ^(ADD {foo} {bar})"
- *  cannot be tracked as they might not use the adaptor to create foo, bar.
- *  The debug listener has to deal with tree node IDs for which it did
- *  not see a createNode event.  A single <unknown> node is sufficient even
- *  if it represents a whole tree.
- */
-public class DebugTreeAdaptor implements TreeAdaptor {
-	protected DebugEventListener dbg;
-	protected TreeAdaptor adaptor;
-
-	public DebugTreeAdaptor(DebugEventListener dbg, TreeAdaptor adaptor) {
-		this.dbg = dbg;
-		this.adaptor = adaptor;
-	}
-
-	public Object create(Token payload) {
-		if ( payload.getTokenIndex() < 0 ) {
-			// could be token conjured up during error recovery
-			return create(payload.getType(), payload.getText());
-		}
-		Object node = adaptor.create(payload);
-		dbg.createNode(node, payload);
-		return node;
-	}
-
-	public Object errorNode(TokenStream input, Token start, Token stop,
-							RecognitionException e)
-	{
-		Object node = adaptor.errorNode(input, start, stop, e);
-		if ( node!=null ) {
-			dbg.errorNode(node);
-		}
-		return node;
-	}
-
-	public Object dupTree(Object tree) {
-		Object t = adaptor.dupTree(tree);
-		// walk the tree and emit create and add child events
-		// to simulate what dupTree has done. dupTree does not call this debug
-		// adapter so I must simulate.
-		simulateTreeConstruction(t);
-		return t;
-	}
-
-	/** ^(A B C): emit create A, create B, add child, ...*/
-	protected void simulateTreeConstruction(Object t) {
-		dbg.createNode(t);
-		int n = adaptor.getChildCount(t);
-		for (int i=0; i<n; i++) {
-			Object child = adaptor.getChild(t, i);
-			simulateTreeConstruction(child);
-			dbg.addChild(t, child);
-		}
-	}
-
-	public Object dupNode(Object treeNode) {
-		Object d = adaptor.dupNode(treeNode);
-		dbg.createNode(d);
-		return d;
-	}
-
-	public Object nil() {
-		Object node = adaptor.nil();
-		dbg.nilNode(node);
-		return node;
-	}
-
-	public boolean isNil(Object tree) {
-		return adaptor.isNil(tree);
-	}
-
-	public void addChild(Object t, Object child) {
-		if ( t==null || child==null ) {
-			return;
-		}
-		adaptor.addChild(t,child);
-		dbg.addChild(t, child);
-	}
-
-	public Object becomeRoot(Object newRoot, Object oldRoot) {
-		Object n = adaptor.becomeRoot(newRoot, oldRoot);
-		dbg.becomeRoot(newRoot, oldRoot);
-		return n;
-	}
-
-	public Object rulePostProcessing(Object root) {
-		return adaptor.rulePostProcessing(root);
-	}
-
-	public void addChild(Object t, Token child) {
-		Object n = this.create(child);
-		this.addChild(t, n);
-	}
-
-	public Object becomeRoot(Token newRoot, Object oldRoot) {
-		Object n = this.create(newRoot);
-		adaptor.becomeRoot(n, oldRoot);
-		dbg.becomeRoot(newRoot, oldRoot);
-		return n;
-	}
-
-	public Object create(int tokenType, Token fromToken) {
-		Object node = adaptor.create(tokenType, fromToken);
-		dbg.createNode(node);
-		return node;
-	}
-
-	public Object create(int tokenType, Token fromToken, String text) {
-		Object node = adaptor.create(tokenType, fromToken, text);
-		dbg.createNode(node);
-		return node;
-	}
-
-	public Object create(int tokenType, String text) {
-		Object node = adaptor.create(tokenType, text);
-		dbg.createNode(node);
-		return node;
-	}
-
-	public int getType(Object t) {
-		return adaptor.getType(t);
-	}
-
-	public void setType(Object t, int type) {
-		adaptor.setType(t, type);
-	}
-
-	public String getText(Object t) {
-		return adaptor.getText(t);
-	}
-
-	public void setText(Object t, String text) {
-		adaptor.setText(t, text);
-	}
-
-	public Token getToken(Object t) {
-		return adaptor.getToken(t);
-	}
-
-	public void setTokenBoundaries(Object t, Token startToken, Token stopToken) {
-		adaptor.setTokenBoundaries(t, startToken, stopToken);
-		if ( t!=null && startToken!=null && stopToken!=null ) {
-			dbg.setTokenBoundaries(
-				t, startToken.getTokenIndex(),
-				stopToken.getTokenIndex());
-		}
-	}
-
-	public int getTokenStartIndex(Object t) {
-		return adaptor.getTokenStartIndex(t);
-	}
-
-	public int getTokenStopIndex(Object t) {
-		return adaptor.getTokenStopIndex(t);
-	}
-
-	public Object getChild(Object t, int i) {
-		return adaptor.getChild(t, i);
-	}
-
-	public void setChild(Object t, int i, Object child) {
-		adaptor.setChild(t, i, child);
-	}
-
-	public Object deleteChild(Object t, int i) {
-		return deleteChild(t, i);
-	}
-
-	public int getChildCount(Object t) {
-		return adaptor.getChildCount(t);
-	}
-
-	public int getUniqueID(Object node) {
-		return adaptor.getUniqueID(node);
-	}
-
-	public Object getParent(Object t) {
-		return adaptor.getParent(t);
-	}
-
-	public int getChildIndex(Object t) {
-		return adaptor.getChildIndex(t);
-	}
-
-	public void setParent(Object t, Object parent) {
-		adaptor.setParent(t, parent);
-	}
-
-	public void setChildIndex(Object t, int index) {
-		adaptor.setChildIndex(t, index);
-	}
-
-	public void replaceChildren(Object parent, int startChildIndex, int stopChildIndex, Object t) {
-		adaptor.replaceChildren(parent, startChildIndex, stopChildIndex, t);
-	}
-
-	// support
-
-	public DebugEventListener getDebugListener() {
-		return dbg;
-	}
-
-	public void setDebugListener(DebugEventListener dbg) {
-		this.dbg = dbg;
-	}
-
-	public TreeAdaptor getTreeAdaptor() {
-		return adaptor;
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugTreeNodeStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugTreeNodeStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugTreeNodeStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugTreeNodeStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,155 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.debug;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.tree.TreeAdaptor;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.tree.TreeNodeStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.TokenStream;
-
-/** Debug any tree node stream.  The constructor accepts the stream
- *  and a debug listener.  As node stream calls come in, debug events
- *  are triggered.
- */
-public class DebugTreeNodeStream implements TreeNodeStream {
-	protected DebugEventListener dbg;
-	protected TreeAdaptor adaptor;
-	protected TreeNodeStream input;
-	protected boolean initialStreamState = true;
-
-	/** Track the last mark() call result value for use in rewind(). */
-	protected int lastMarker;
-
-	public DebugTreeNodeStream(TreeNodeStream input,
-							   DebugEventListener dbg)
-	{
-		this.input = input;
-		this.adaptor = input.getTreeAdaptor();
-		this.input.setUniqueNavigationNodes(true);
-		setDebugListener(dbg);
-	}
-
-	public void setDebugListener(DebugEventListener dbg) {
-		this.dbg = dbg;
-	}
-
-	public TreeAdaptor getTreeAdaptor() {
-		return adaptor;
-	}
-
-	public void consume() {
-		Object node = input.LT(1);
-		input.consume();
-		dbg.consumeNode(node);
-	}
-
-	public Object get(int i) {
-		return input.get(i);
-	}
-
-	public Object LT(int i) {
-		Object node = input.LT(i);
-		int ID = adaptor.getUniqueID(node);
-		String text = adaptor.getText(node);
-		int type = adaptor.getType(node);
-		dbg.LT(i, node);
-		return node;
-	}
-
-	public int LA(int i) {
-		Object node = input.LT(i);
-		int ID = adaptor.getUniqueID(node);
-		String text = adaptor.getText(node);
-		int type = adaptor.getType(node);
-		dbg.LT(i, node);
-		return type;
-	}
-
-	public int mark() {
-		lastMarker = input.mark();
-		dbg.mark(lastMarker);
-		return lastMarker;
-	}
-
-	public int index() {
-		return input.index();
-	}
-
-	public void rewind(int marker) {
-		dbg.rewind(marker);
-		input.rewind(marker);
-	}
-
-	public void rewind() {
-		dbg.rewind();
-		input.rewind(lastMarker);
-	}
-
-	public void release(int marker) {
-	}
-
-	public void seek(int index) {
-		// TODO: implement seek in dbg interface
-		// db.seek(index);
-		input.seek(index);
-	}
-
-	public int size() {
-		return input.size();
-	}
-
-    public void reset() { ; }
-
-    public Object getTreeSource() {
-		return input;
-	}
-
-	public String getSourceName() {
-		return getTokenStream().getSourceName();
-	}
-
-	public TokenStream getTokenStream() {
-		return input.getTokenStream();
-	}
-
-	/** It is normally this object that instructs the node stream to
-	 *  create unique nav nodes, but to satisfy interface, we have to
-	 *  define it.  It might be better to ignore the parameter but
-	 *  there might be a use for it later, so I'll leave.
-	 */
-	public void setUniqueNavigationNodes(boolean uniqueNavigationNodes) {
-		input.setUniqueNavigationNodes(uniqueNavigationNodes);
-	}
-
-	public void replaceChildren(Object parent, int startChildIndex, int stopChildIndex, Object t) {
-		input.replaceChildren(parent, startChildIndex, stopChildIndex, t);
-	}
-
-	public String toString(Object start, Object stop) {
-		return input.toString(start,stop);
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugTreeParser.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugTreeParser.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugTreeParser.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/DebugTreeParser.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,109 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.debug;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.*;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.tree.TreeNodeStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.tree.TreeParser;
-
-import java.io.IOException;
-
-public class DebugTreeParser extends TreeParser {
-	/** Who to notify when events in the parser occur. */
-	protected DebugEventListener dbg = null;
-
-	/** Used to differentiate between fixed lookahead and cyclic DFA decisions
-	 *  while profiling.
- 	 */
-	public boolean isCyclicDecision = false;
-
-	/** Create a normal parser except wrap the token stream in a debug
-	 *  proxy that fires consume events.
-	 */
-	public DebugTreeParser(TreeNodeStream input, DebugEventListener dbg, RecognizerSharedState state) {
-		super(input instanceof DebugTreeNodeStream?input:new DebugTreeNodeStream(input,dbg), state);
-		setDebugListener(dbg);
-	}
-
-	public DebugTreeParser(TreeNodeStream input, RecognizerSharedState state) {
-		super(input instanceof DebugTreeNodeStream?input:new DebugTreeNodeStream(input,null), state);
-	}
-
-	public DebugTreeParser(TreeNodeStream input, DebugEventListener dbg) {
-		this(input instanceof DebugTreeNodeStream?input:new DebugTreeNodeStream(input,dbg), dbg, null);
-	}
-
-	/** Provide a new debug event listener for this parser.  Notify the
-	 *  input stream too that it should send events to this listener.
-	 */
-	public void setDebugListener(DebugEventListener dbg) {
-		if ( input instanceof DebugTreeNodeStream ) {
-			((DebugTreeNodeStream)input).setDebugListener(dbg);
-		}
-		this.dbg = dbg;
-	}
-
-	public DebugEventListener getDebugListener() {
-		return dbg;
-	}
-
-	public void reportError(IOException e) {
-		System.err.println(e);
-		e.printStackTrace(System.err);
-	}
-
-	public void reportError(RecognitionException e) {
-		dbg.recognitionException(e);
-	}
-
-	protected Object getMissingSymbol(IntStream input,
-									  RecognitionException e,
-									  int expectedTokenType,
-									  BitSet follow)
-	{
-		Object o = super.getMissingSymbol(input, e, expectedTokenType, follow);
-		dbg.consumeNode(o);
-		return o;
-	}
-
-	public void beginResync() {
-		dbg.beginResync();
-	}
-
-	public void endResync() {
-		dbg.endResync();
-	}
-
-	public void beginBacktrack(int level) {
-		dbg.beginBacktrack(level);
-	}
-
-	public void endBacktrack(int level, boolean successful) {
-		dbg.endBacktrack(level,successful);		
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/ParseTreeBuilder.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/ParseTreeBuilder.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/ParseTreeBuilder.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/ParseTreeBuilder.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,109 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.debug;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognitionException;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.tree.ParseTree;
-
-import java.util.Stack;
-import java.util.ArrayList;
-import java.util.List;
-
-/** This parser listener tracks rule entry/exit and token matches
- *  to build a simple parse tree using ParseTree nodes.
- */
-public class ParseTreeBuilder extends BlankDebugEventListener {
-	public static final String EPSILON_PAYLOAD = "<epsilon>";
-	
-	Stack callStack = new Stack();
-	List hiddenTokens = new ArrayList();
-	int backtracking = 0;
-
-	public ParseTreeBuilder(String grammarName) {
-		ParseTree root = create("<grammar "+grammarName+">");
-		callStack.push(root);
-	}
-
-	public ParseTree getTree() {
-		return (ParseTree)callStack.elementAt(0);
-	}
-
-	/**  What kind of node to create.  You might want to override
-	 *   so I factored out creation here.
-	 */
-	public ParseTree create(Object payload) {
-		return new ParseTree(payload);
-	}
-
-	public ParseTree epsilonNode() {
-		return create(EPSILON_PAYLOAD);
-	}
-
-	/** Backtracking or cyclic DFA, don't want to add nodes to tree */
-	public void enterDecision(int d) { backtracking++; }
-	public void exitDecision(int i) { backtracking--; }
-
-	public void enterRule(String filename, String ruleName) {
-		if ( backtracking>0 ) return;
-		ParseTree parentRuleNode = (ParseTree)callStack.peek();
-		ParseTree ruleNode = create(ruleName);
-		parentRuleNode.addChild(ruleNode);
-		callStack.push(ruleNode);
-	}
-
-	public void exitRule(String filename, String ruleName) {
-		if ( backtracking>0 ) return;
-		ParseTree ruleNode = (ParseTree)callStack.peek();
-		if ( ruleNode.getChildCount()==0 ) {
-			ruleNode.addChild(epsilonNode());
-		}
-		callStack.pop();		
-	}
-
-	public void consumeToken(Token token) {
-		if ( backtracking>0 ) return;
-		ParseTree ruleNode = (ParseTree)callStack.peek();
-		ParseTree elementNode = create(token);
-		elementNode.hiddenTokens = this.hiddenTokens;
-		this.hiddenTokens = new ArrayList();
-		ruleNode.addChild(elementNode);
-	}
-
-	public void consumeHiddenToken(Token token) {
-		if ( backtracking>0 ) return;
-		hiddenTokens.add(token);
-	}
-
-	public void recognitionException(RecognitionException e) {
-		if ( backtracking>0 ) return;
-		ParseTree ruleNode = (ParseTree)callStack.peek();
-		ParseTree errorNode = create(e);
-		ruleNode.addChild(errorNode);
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/Profiler.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/Profiler.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/Profiler.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/Profiler.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,506 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.debug;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.*;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.misc.Stats;
-
-import java.util.*;
-import java.io.IOException;
-
-/** Using the debug event interface, track what is happening in the parser
- *  and record statistics about the runtime.
- */
-public class Profiler extends BlankDebugEventListener {
-	/** Because I may change the stats, I need to track that for later
-	 *  computations to be consistent.
-	 */
-	public static final String Version = "2";
-	public static final String RUNTIME_STATS_FILENAME = "runtime.stats";
-	public static final int NUM_RUNTIME_STATS = 29;
-
-	public DebugParser parser = null;
-
-	// working variables
-
-	protected int ruleLevel = 0;
-	protected int decisionLevel = 0;
-	protected int maxLookaheadInCurrentDecision = 0;
-	protected CommonToken lastTokenConsumed=null;
-
-	protected List lookaheadStack = new ArrayList();
-
-	// stats variables
-
-	public int numRuleInvocations = 0;
-	public int numGuessingRuleInvocations = 0;
-	public int maxRuleInvocationDepth = 0;
-	public int numFixedDecisions = 0;
-	public int numCyclicDecisions = 0;
-	public int numBacktrackDecisions = 0;
-	public int[] decisionMaxFixedLookaheads = new int[200]; // TODO: make List
-	public int[] decisionMaxCyclicLookaheads = new int[200];
-	public List decisionMaxSynPredLookaheads = new ArrayList();
-	public int numHiddenTokens = 0;
-	public int numCharsMatched = 0;
-	public int numHiddenCharsMatched = 0;
-	public int numSemanticPredicates = 0;
-	public int numSyntacticPredicates = 0;
-	protected int numberReportedErrors = 0;
-	public int numMemoizationCacheMisses = 0;
-	public int numMemoizationCacheHits = 0;
-	public int numMemoizationCacheEntries = 0;
-
-	public Profiler() {
-	}
-
-	public Profiler(DebugParser parser) {
-		this.parser = parser;
-	}
-
-	public void enterRule(String grammarFileName, String ruleName) {
-		//System.out.println("enterRule "+ruleName);
-		ruleLevel++;
-		numRuleInvocations++;
-		if ( ruleLevel >maxRuleInvocationDepth ) {
-			maxRuleInvocationDepth = ruleLevel;
-		}
-
-	}
-
-	/** Track memoization; this is not part of standard debug interface
-	 *  but is triggered by profiling.  Code gen inserts an override
-	 *  for this method in the recognizer, which triggers this method.
-	 */
-	public void examineRuleMemoization(IntStream input,
-									   int ruleIndex,
-									   String ruleName)
-	{
-		//System.out.println("examine memo "+ruleName);
-		int stopIndex = parser.getRuleMemoization(ruleIndex, input.index());
-		if ( stopIndex==BaseRecognizer.MEMO_RULE_UNKNOWN ) {
-			//System.out.println("rule "+ruleIndex+" missed @ "+input.index());
-			numMemoizationCacheMisses++;
-			numGuessingRuleInvocations++; // we'll have to enter
-		}
-		else {
-			// regardless of rule success/failure, if in cache, we have a cache hit
-			//System.out.println("rule "+ruleIndex+" hit @ "+input.index());
-			numMemoizationCacheHits++;
-		}
-	}
-
-	public void memoize(IntStream input,
-						int ruleIndex,
-						int ruleStartIndex,
-						String ruleName)
-	{
-		// count how many entries go into table
-		//System.out.println("memoize "+ruleName);
-		numMemoizationCacheEntries++;
-	}
-
-	public void exitRule(String grammarFileName, String ruleName) {
-		ruleLevel--;
-	}
-
-	public void enterDecision(int decisionNumber) {
-		decisionLevel++;
-		int startingLookaheadIndex = parser.getTokenStream().index();
-		//System.out.println("enterDecision "+decisionNumber+" @ index "+startingLookaheadIndex);
-		lookaheadStack.add(new Integer(startingLookaheadIndex));
-	}
-
-	public void exitDecision(int decisionNumber) {
-		//System.out.println("exitDecision "+decisionNumber);
-		// track how many of acyclic, cyclic here as we don't know what kind
-		// yet in enterDecision event.
-		if ( parser.isCyclicDecision ) {
-			numCyclicDecisions++;
-		}
-		else {
-			numFixedDecisions++;
-		}
-		lookaheadStack.remove(lookaheadStack.size()-1); // pop lookahead depth counter
-		decisionLevel--;
-		if ( parser.isCyclicDecision ) {
-			if ( numCyclicDecisions>=decisionMaxCyclicLookaheads.length ) {
-				int[] bigger = new int[decisionMaxCyclicLookaheads.length*2];
-				System.arraycopy(decisionMaxCyclicLookaheads,0,bigger,0,decisionMaxCyclicLookaheads.length);
-				decisionMaxCyclicLookaheads = bigger;
-			}
-			decisionMaxCyclicLookaheads[numCyclicDecisions-1] = maxLookaheadInCurrentDecision;
-		}
-		else {
-			if ( numFixedDecisions>=decisionMaxFixedLookaheads.length ) {
-				int[] bigger = new int[decisionMaxFixedLookaheads.length*2];
-				System.arraycopy(decisionMaxFixedLookaheads,0,bigger,0,decisionMaxFixedLookaheads.length);
-				decisionMaxFixedLookaheads = bigger;
-			}
-			decisionMaxFixedLookaheads[numFixedDecisions-1] = maxLookaheadInCurrentDecision;
-		}
-		parser.isCyclicDecision = false; // can't nest so just reset to false
-		maxLookaheadInCurrentDecision = 0;
-	}
-
-	public void consumeToken(Token token) {
-		//System.out.println("consume token "+token);
-		lastTokenConsumed = (CommonToken)token;
-	}
-
-	/** The parser is in a decision if the decision depth > 0.  This
-	 *  works for backtracking also, which can have nested decisions.
-	 */
-	public boolean inDecision() {
-		return decisionLevel>0;
-	}
-
-	public void consumeHiddenToken(Token token) {
-		//System.out.println("consume hidden token "+token);
-		lastTokenConsumed = (CommonToken)token;
-	}
-
-	/** Track refs to lookahead if in a fixed/nonfixed decision.
-	 */
-	public void LT(int i, Token t) {
-		if ( inDecision() ) {
-			// get starting index off stack
-			int stackTop = lookaheadStack.size()-1;
-			Integer startingIndex = (Integer)lookaheadStack.get(stackTop);
-			// compute lookahead depth
-			int thisRefIndex = parser.getTokenStream().index();
-			int numHidden =
-				getNumberOfHiddenTokens(startingIndex.intValue(), thisRefIndex);
-			int depth = i + thisRefIndex - startingIndex.intValue() - numHidden;
-			/*
-			System.out.println("LT("+i+") @ index "+thisRefIndex+" is depth "+depth+
-				" max is "+maxLookaheadInCurrentDecision);
-			*/
-			if ( depth>maxLookaheadInCurrentDecision ) {
-				maxLookaheadInCurrentDecision = depth;
-			}
-		}
-	}
-
-	/** Track backtracking decisions.  You'll see a fixed or cyclic decision
-	 *  and then a backtrack.
-	 *
-	 * 		enter rule
-	 * 		...
-	 * 		enter decision
-	 * 		LA and possibly consumes (for cyclic DFAs)
-	 * 		begin backtrack level
-	 * 		mark m
-	 * 		rewind m
-	 * 		end backtrack level, success
-	 * 		exit decision
-	 * 		...
-	 * 		exit rule
-	 */
-	public void beginBacktrack(int level) {
-		//System.out.println("enter backtrack "+level);
-		numBacktrackDecisions++;
-	}
-
-	/** Successful or not, track how much lookahead synpreds use */
-	public void endBacktrack(int level, boolean successful) {
-		//System.out.println("exit backtrack "+level+": "+successful);
-		decisionMaxSynPredLookaheads.add(
-			new Integer(maxLookaheadInCurrentDecision)
-		);
-	}
-
-	/*
-	public void mark(int marker) {
-		int i = parser.getTokenStream().index();
-		System.out.println("mark @ index "+i);
-		synPredLookaheadStack.add(new Integer(i));
-	}
-
-	public void rewind(int marker) {
-		// pop starting index off stack
-		int stackTop = synPredLookaheadStack.size()-1;
-		Integer startingIndex = (Integer)synPredLookaheadStack.get(stackTop);
-		synPredLookaheadStack.remove(synPredLookaheadStack.size()-1);
-		// compute lookahead depth
-		int stopIndex = parser.getTokenStream().index();
-		System.out.println("rewind @ index "+stopIndex);
-		int depth = stopIndex - startingIndex.intValue();
-		System.out.println("depth of lookahead for synpred: "+depth);
-		decisionMaxSynPredLookaheads.add(
-			new Integer(depth)
-		);
-	}
-	*/
-
-	public void recognitionException(RecognitionException e) {
-		numberReportedErrors++;
-	}
-
-	public void semanticPredicate(boolean result, String predicate) {
-		if ( inDecision() ) {
-			numSemanticPredicates++;
-		}
-	}
-
-	public void terminate() {
-		String stats = toNotifyString();
-		try {
-			Stats.writeReport(RUNTIME_STATS_FILENAME,stats);
-		}
-		catch (IOException ioe) {
-			System.err.println(ioe);
-			ioe.printStackTrace(System.err);
-		}
-		System.out.println(toString(stats));
-	}
-
-	public void setParser(DebugParser parser) {
-		this.parser = parser;
-	}
-
-	// R E P O R T I N G
-
-	public String toNotifyString() {
-		TokenStream input = parser.getTokenStream();
-		for (int i=0; i<input.size()&&lastTokenConsumed!=null&&i<=lastTokenConsumed.getTokenIndex(); i++) {
-			Token t = input.get(i);
-			if ( t.getChannel()!=Token.DEFAULT_CHANNEL ) {
-				numHiddenTokens++;
-				numHiddenCharsMatched += t.getText().length();
-			}
-		}
-		numCharsMatched = lastTokenConsumed.getStopIndex() + 1;
-		decisionMaxFixedLookaheads = trim(decisionMaxFixedLookaheads, numFixedDecisions);
-		decisionMaxCyclicLookaheads = trim(decisionMaxCyclicLookaheads, numCyclicDecisions);
-		StringBuffer buf = new StringBuffer();
-		buf.append(Version);
-		buf.append('\t');
-		buf.append(parser.getClass().getName());
-		buf.append('\t');
-		buf.append(numRuleInvocations);
-		buf.append('\t');
-		buf.append(maxRuleInvocationDepth);
-		buf.append('\t');
-		buf.append(numFixedDecisions);
-		buf.append('\t');
-		buf.append(Stats.min(decisionMaxFixedLookaheads));
-		buf.append('\t');
-		buf.append(Stats.max(decisionMaxFixedLookaheads));
-		buf.append('\t');
-		buf.append(Stats.avg(decisionMaxFixedLookaheads));
-		buf.append('\t');
-		buf.append(Stats.stddev(decisionMaxFixedLookaheads));
-		buf.append('\t');
-		buf.append(numCyclicDecisions);
-		buf.append('\t');
-		buf.append(Stats.min(decisionMaxCyclicLookaheads));
-		buf.append('\t');
-		buf.append(Stats.max(decisionMaxCyclicLookaheads));
-		buf.append('\t');
-		buf.append(Stats.avg(decisionMaxCyclicLookaheads));
-		buf.append('\t');
-		buf.append(Stats.stddev(decisionMaxCyclicLookaheads));
-		buf.append('\t');
-		buf.append(numBacktrackDecisions);
-		buf.append('\t');
-		buf.append(Stats.min(toArray(decisionMaxSynPredLookaheads)));
-		buf.append('\t');
-		buf.append(Stats.max(toArray(decisionMaxSynPredLookaheads)));
-		buf.append('\t');
-		buf.append(Stats.avg(toArray(decisionMaxSynPredLookaheads)));
-		buf.append('\t');
-		buf.append(Stats.stddev(toArray(decisionMaxSynPredLookaheads)));
-		buf.append('\t');
-		buf.append(numSemanticPredicates);
-		buf.append('\t');
-		buf.append(parser.getTokenStream().size());
-		buf.append('\t');
-		buf.append(numHiddenTokens);
-		buf.append('\t');
-		buf.append(numCharsMatched);
-		buf.append('\t');
-		buf.append(numHiddenCharsMatched);
-		buf.append('\t');
-		buf.append(numberReportedErrors);
-		buf.append('\t');
-		buf.append(numMemoizationCacheHits);
-		buf.append('\t');
-		buf.append(numMemoizationCacheMisses);
-		buf.append('\t');
-		buf.append(numGuessingRuleInvocations);
-		buf.append('\t');
-		buf.append(numMemoizationCacheEntries);
-		return buf.toString();
-	}
-
-	public String toString() {
-		return toString(toNotifyString());
-	}
-
-	protected static String[] decodeReportData(String data) {
-		String[] fields = new String[NUM_RUNTIME_STATS];
-		StringTokenizer st = new StringTokenizer(data, "\t");
-		int i = 0;
-		while ( st.hasMoreTokens() ) {
-			fields[i] = st.nextToken();
-			i++;
-		}
-		if ( i!=NUM_RUNTIME_STATS ) {
-			return null;
-		}
-		return fields;
-	}
-
-	public static String toString(String notifyDataLine) {
-		String[] fields = decodeReportData(notifyDataLine);
-		if ( fields==null ) {
-			return null;
-		}
-		StringBuffer buf = new StringBuffer();
-		buf.append("ANTLR Runtime Report; Profile Version ");
-		buf.append(fields[0]);
-		buf.append('\n');
-		buf.append("parser name ");
-		buf.append(fields[1]);
-		buf.append('\n');
-		buf.append("Number of rule invocations ");
-		buf.append(fields[2]);
-		buf.append('\n');
-		buf.append("Number of rule invocations in \"guessing\" mode ");
-		buf.append(fields[27]);
-		buf.append('\n');
-		buf.append("max rule invocation nesting depth ");
-		buf.append(fields[3]);
-		buf.append('\n');
-		buf.append("number of fixed lookahead decisions ");
-		buf.append(fields[4]);
-		buf.append('\n');
-		buf.append("min lookahead used in a fixed lookahead decision ");
-		buf.append(fields[5]);
-		buf.append('\n');
-		buf.append("max lookahead used in a fixed lookahead decision ");
-		buf.append(fields[6]);
-		buf.append('\n');
-		buf.append("average lookahead depth used in fixed lookahead decisions ");
-		buf.append(fields[7]);
-		buf.append('\n');
-		buf.append("standard deviation of depth used in fixed lookahead decisions ");
-		buf.append(fields[8]);
-		buf.append('\n');
-		buf.append("number of arbitrary lookahead decisions ");
-		buf.append(fields[9]);
-		buf.append('\n');
-		buf.append("min lookahead used in an arbitrary lookahead decision ");
-		buf.append(fields[10]);
-		buf.append('\n');
-		buf.append("max lookahead used in an arbitrary lookahead decision ");
-		buf.append(fields[11]);
-		buf.append('\n');
-		buf.append("average lookahead depth used in arbitrary lookahead decisions ");
-		buf.append(fields[12]);
-		buf.append('\n');
-		buf.append("standard deviation of depth used in arbitrary lookahead decisions ");
-		buf.append(fields[13]);
-		buf.append('\n');
-		buf.append("number of evaluated syntactic predicates ");
-		buf.append(fields[14]);
-		buf.append('\n');
-		buf.append("min lookahead used in a syntactic predicate ");
-		buf.append(fields[15]);
-		buf.append('\n');
-		buf.append("max lookahead used in a syntactic predicate ");
-		buf.append(fields[16]);
-		buf.append('\n');
-		buf.append("average lookahead depth used in syntactic predicates ");
-		buf.append(fields[17]);
-		buf.append('\n');
-		buf.append("standard deviation of depth used in syntactic predicates ");
-		buf.append(fields[18]);
-		buf.append('\n');
-		buf.append("rule memoization cache size ");
-		buf.append(fields[28]);
-		buf.append('\n');
-		buf.append("number of rule memoization cache hits ");
-		buf.append(fields[25]);
-		buf.append('\n');
-		buf.append("number of rule memoization cache misses ");
-		buf.append(fields[26]);
-		buf.append('\n');
-		buf.append("number of evaluated semantic predicates ");
-		buf.append(fields[19]);
-		buf.append('\n');
-		buf.append("number of tokens ");
-		buf.append(fields[20]);
-		buf.append('\n');
-		buf.append("number of hidden tokens ");
-		buf.append(fields[21]);
-		buf.append('\n');
-		buf.append("number of char ");
-		buf.append(fields[22]);
-		buf.append('\n');
-		buf.append("number of hidden char ");
-		buf.append(fields[23]);
-		buf.append('\n');
-		buf.append("number of syntax errors ");
-		buf.append(fields[24]);
-		buf.append('\n');
-		return buf.toString();
-	}
-
-	protected int[] trim(int[] X, int n) {
-		if ( n<X.length ) {
-			int[] trimmed = new int[n];
-			System.arraycopy(X,0,trimmed,0,n);
-			X = trimmed;
-		}
-		return X;
-	}
-
-	protected int[] toArray(List a) {
-		int[] x = new int[a.size()];
-		for (int i = 0; i < a.size(); i++) {
-			Integer I = (Integer) a.get(i);
-			x[i] = I.intValue();
-		}
-		return x;
-	}
-
-	/** Get num hidden tokens between i..j inclusive */
-	public int getNumberOfHiddenTokens(int i, int j) {
-		int n = 0;
-		TokenStream input = parser.getTokenStream();
-		for (int ti = i; ti<input.size() && ti <= j; ti++) {
-			Token t = input.get(ti);
-			if ( t.getChannel()!=Token.DEFAULT_CHANNEL ) {
-				n++;
-			}
-		}
-		return n;
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/RemoteDebugEventSocketListener.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/RemoteDebugEventSocketListener.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/RemoteDebugEventSocketListener.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/RemoteDebugEventSocketListener.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,527 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.debug;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognitionException;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.CharStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.tree.BaseTree;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.tree.Tree;
-
-import java.io.*;
-import java.net.ConnectException;
-import java.net.Socket;
-import java.util.StringTokenizer;
-
-public class RemoteDebugEventSocketListener implements Runnable {
-	static final int MAX_EVENT_ELEMENTS = 8;
-	DebugEventListener listener;
-	String machine;
-	int port;
-	Socket channel = null;
-	PrintWriter out;
-	BufferedReader in;
-	String event;
-	/** Version of ANTLR (dictates events) */
-	public String version;
-	public String grammarFileName;
-	/** Track the last token index we saw during a consume.  If same, then
-	 *  set a flag that we have a problem.
-	 */
-	int previousTokenIndex = -1;
-	boolean tokenIndexesInvalid = false;
-
-	public static class ProxyToken implements Token {
-		int index;
-		int type;
-		int channel;
-		int line;
-		int charPos;
-		String text;
-		public ProxyToken(int index) { this.index = index; }		
-		public ProxyToken(int index, int type, int channel,
-						  int line, int charPos, String text)
-		{
-			this.index = index;
-			this.type = type;
-			this.channel = channel;
-			this.line = line;
-			this.charPos = charPos;
-			this.text = text;
-		}
-		public String getText() {
-			return text;
-		}
-		public void setText(String text) {
-			this.text = text;
-		}
-		public int getType() {
-			return type;
-		}
-		public void setType(int ttype) {
-			this.type = ttype;
-		}
-		public int getLine() {
-			return line;
-		}
-		public void setLine(int line) {
-			this.line = line;
-		}
-		public int getCharPositionInLine() {
-			return charPos;
-		}
-		public void setCharPositionInLine(int pos) {
-			this.charPos = pos;
-		}
-		public int getChannel() {
-			return channel;
-		}
-		public void setChannel(int channel) {
-			this.channel = channel;
-		}
-		public int getTokenIndex() {
-			return index;
-		}
-		public void setTokenIndex(int index) {
-			this.index = index;
-		}
-		public CharStream getInputStream() {
-			return null;
-		}
-		public void setInputStream(CharStream input) {
-		}
-		public String toString() {
-			String channelStr = "";
-			if ( channel!=Token.DEFAULT_CHANNEL ) {
-				channelStr=",channel="+channel;
-			}
-			return "["+getText()+"/<"+type+">"+channelStr+","+line+":"+getCharPositionInLine()+",@"+index+"]";
-		}
-	}
-
-	public static class ProxyTree extends BaseTree {
-		public int ID;
-		public int type;
-		public int line = 0;
-		public int charPos = -1;
-		public int tokenIndex = -1;
-		public String text;
-		
-		public ProxyTree(int ID, int type, int line, int charPos, int tokenIndex, String text) {
-			this.ID = ID;
-			this.type = type;
-			this.line = line;
-			this.charPos = charPos;
-			this.tokenIndex = tokenIndex;
-			this.text = text;
-		}
-
-		public ProxyTree(int ID) { this.ID = ID; }
-
-		public int getTokenStartIndex() { return tokenIndex; }
-		public void setTokenStartIndex(int index) {	}
-		public int getTokenStopIndex() { return 0; }
-		public void setTokenStopIndex(int index) { }
-		public Tree dupNode() {	return null; }
-		public int getType() { return type; }
-		public String getText() { return text; }
-		public String toString() {
-			return "fix this";
-		}
-	}
-
-	public RemoteDebugEventSocketListener(DebugEventListener listener,
-										  String machine,
-										  int port) throws IOException
-	{
-		this.listener = listener;
-		this.machine = machine;
-		this.port = port;
-
-        if( !openConnection() ) {
-            throw new ConnectException();
-        }
-	}
-
-	protected void eventHandler() {
-		try {
-			handshake();
-			event = in.readLine();
-			while ( event!=null ) {
-				dispatch(event);
-				ack();
-				event = in.readLine();
-			}
-		}
-		catch (Exception e) {
-			System.err.println(e);
-			e.printStackTrace(System.err);
-		}
-		finally {
-            closeConnection();
-		}
-	}
-
-    protected boolean openConnection() {
-        boolean success = false;
-        try {
-            channel = new Socket(machine, port);
-            channel.setTcpNoDelay(true);
-			OutputStream os = channel.getOutputStream();
-			OutputStreamWriter osw = new OutputStreamWriter(os, "UTF8");
-			out = new PrintWriter(new BufferedWriter(osw));
-			InputStream is = channel.getInputStream();
-			InputStreamReader isr = new InputStreamReader(is, "UTF8");
-			in = new BufferedReader(isr);
-            success = true;
-        } catch(Exception e) {
-            System.err.println(e);
-        }
-        return success;
-    }
-
-    protected void closeConnection() {
-        try {
-            in.close(); in = null;
-            out.close(); out = null;
-            channel.close(); channel=null;
-        }
-        catch (Exception e) {
-            System.err.println(e);
-            e.printStackTrace(System.err);
-        }
-        finally {
-            if ( in!=null ) {
-                try {in.close();} catch (IOException ioe) {
-                    System.err.println(ioe);
-                }
-            }
-            if ( out!=null ) {
-                out.close();
-            }
-            if ( channel!=null ) {
-                try {channel.close();} catch (IOException ioe) {
-                    System.err.println(ioe);
-                }
-            }
-        }
-
-    }
-
-	protected void handshake() throws IOException {
-		String antlrLine = in.readLine();
-		String[] antlrElements = getEventElements(antlrLine);
-		version = antlrElements[1];
-		String grammarLine = in.readLine();
-		String[] grammarElements = getEventElements(grammarLine);
-		grammarFileName = grammarElements[1];
-		ack();
-		listener.commence(); // inform listener after handshake
-	}
-
-	protected void ack() {
-        out.println("ack");
-		out.flush();
-	}
-
-	protected void dispatch(String line) {
-        //System.out.println("event: "+line);
-        String[] elements = getEventElements(line);
-		if ( elements==null || elements[0]==null ) {
-			System.err.println("unknown debug event: "+line);
-			return;
-		}
-		if ( elements[0].equals("enterRule") ) {
-			listener.enterRule(elements[1], elements[2]);
-		}
-		else if ( elements[0].equals("exitRule") ) {
-			listener.exitRule(elements[1], elements[2]);
-		}
-		else if ( elements[0].equals("enterAlt") ) {
-			listener.enterAlt(Integer.parseInt(elements[1]));
-		}
-		else if ( elements[0].equals("enterSubRule") ) {
-			listener.enterSubRule(Integer.parseInt(elements[1]));
-		}
-		else if ( elements[0].equals("exitSubRule") ) {
-			listener.exitSubRule(Integer.parseInt(elements[1]));
-		}
-		else if ( elements[0].equals("enterDecision") ) {
-			listener.enterDecision(Integer.parseInt(elements[1]));
-		}
-		else if ( elements[0].equals("exitDecision") ) {
-			listener.exitDecision(Integer.parseInt(elements[1]));
-		}
-		else if ( elements[0].equals("location") ) {
-			listener.location(Integer.parseInt(elements[1]),
-							  Integer.parseInt(elements[2]));
-		}
-		else if ( elements[0].equals("consumeToken") ) {
-			ProxyToken t = deserializeToken(elements, 1);
-			if ( t.getTokenIndex() == previousTokenIndex ) {
-				tokenIndexesInvalid = true;
-			}
-			previousTokenIndex = t.getTokenIndex();
-			listener.consumeToken(t);
-		}
-		else if ( elements[0].equals("consumeHiddenToken") ) {
-			ProxyToken t = deserializeToken(elements, 1);
-			if ( t.getTokenIndex() == previousTokenIndex ) {
-				tokenIndexesInvalid = true;
-			}
-			previousTokenIndex = t.getTokenIndex();
-			listener.consumeHiddenToken(t);
-		}
-		else if ( elements[0].equals("LT") ) {
-			Token t = deserializeToken(elements, 2);
-			listener.LT(Integer.parseInt(elements[1]), t);
-		}
-		else if ( elements[0].equals("mark") ) {
-			listener.mark(Integer.parseInt(elements[1]));
-		}
-		else if ( elements[0].equals("rewind") ) {
-			if ( elements[1]!=null ) {
-				listener.rewind(Integer.parseInt(elements[1]));
-			}
-			else {
-				listener.rewind();
-			}
-		}
-		else if ( elements[0].equals("beginBacktrack") ) {
-			listener.beginBacktrack(Integer.parseInt(elements[1]));
-		}
-		else if ( elements[0].equals("endBacktrack") ) {
-			int level = Integer.parseInt(elements[1]);
-			int successI = Integer.parseInt(elements[2]);
-			listener.endBacktrack(level, successI==DebugEventListener.TRUE);
-		}
-		else if ( elements[0].equals("exception") ) {
-			String excName = elements[1];
-			String indexS = elements[2];
-			String lineS = elements[3];
-			String posS = elements[4];
-			Class excClass = null;
-			try {
-				excClass = Class.forName(excName);
-				RecognitionException e =
-					(RecognitionException)excClass.newInstance();
-				e.index = Integer.parseInt(indexS);
-				e.line = Integer.parseInt(lineS);
-				e.charPositionInLine = Integer.parseInt(posS);
-				listener.recognitionException(e);
-			}
-			catch (ClassNotFoundException cnfe) {
-				System.err.println("can't find class "+cnfe);
-				cnfe.printStackTrace(System.err);
-			}
-			catch (InstantiationException ie) {
-				System.err.println("can't instantiate class "+ie);
-				ie.printStackTrace(System.err);
-			}
-			catch (IllegalAccessException iae) {
-				System.err.println("can't access class "+iae);
-				iae.printStackTrace(System.err);
-			}
-		}
-		else if ( elements[0].equals("beginResync") ) {
-			listener.beginResync();
-		}
-		else if ( elements[0].equals("endResync") ) {
-			listener.endResync();
-		}
-		else if ( elements[0].equals("terminate") ) {
-			listener.terminate();
-		}
-		else if ( elements[0].equals("semanticPredicate") ) {
-			Boolean result = Boolean.valueOf(elements[1]);
-			String predicateText = elements[2];
-			predicateText = unEscapeNewlines(predicateText);
-			listener.semanticPredicate(result.booleanValue(),
-									   predicateText);
-		}
-		else if ( elements[0].equals("consumeNode") ) {
-			ProxyTree node = deserializeNode(elements, 1);
-			listener.consumeNode(node);
-		}
-		else if ( elements[0].equals("LN") ) {
-			int i = Integer.parseInt(elements[1]);
-			ProxyTree node = deserializeNode(elements, 2);
-			listener.LT(i, node);
-		}
-		else if ( elements[0].equals("createNodeFromTokenElements") ) {
-			int ID = Integer.parseInt(elements[1]);
-			int type = Integer.parseInt(elements[2]);
-			String text = elements[3];
-			text = unEscapeNewlines(text);
-			ProxyTree node = new ProxyTree(ID, type, -1, -1, -1, text);
-			listener.createNode(node);
-		}
-		else if ( elements[0].equals("createNode") ) {
-			int ID = Integer.parseInt(elements[1]);
-			int tokenIndex = Integer.parseInt(elements[2]);
-			// create dummy node/token filled with ID, tokenIndex
-			ProxyTree node = new ProxyTree(ID);
-			ProxyToken token = new ProxyToken(tokenIndex);
-			listener.createNode(node, token);
-		}
-		else if ( elements[0].equals("nilNode") ) {
-			int ID = Integer.parseInt(elements[1]);
-			ProxyTree node = new ProxyTree(ID);
-			listener.nilNode(node);
-		}
-		else if ( elements[0].equals("errorNode") ) {
-			// TODO: do we need a special tree here?
-			int ID = Integer.parseInt(elements[1]);
-			int type = Integer.parseInt(elements[2]);
-			String text = elements[3];
-			text = unEscapeNewlines(text);
-			ProxyTree node = new ProxyTree(ID, type, -1, -1, -1, text);
-			listener.errorNode(node);
-		}
-		else if ( elements[0].equals("becomeRoot") ) {
-			int newRootID = Integer.parseInt(elements[1]);
-			int oldRootID = Integer.parseInt(elements[2]);
-			ProxyTree newRoot = new ProxyTree(newRootID);
-			ProxyTree oldRoot = new ProxyTree(oldRootID);
-			listener.becomeRoot(newRoot, oldRoot);
-		}
-		else if ( elements[0].equals("addChild") ) {
-			int rootID = Integer.parseInt(elements[1]);
-			int childID = Integer.parseInt(elements[2]);
-			ProxyTree root = new ProxyTree(rootID);
-			ProxyTree child = new ProxyTree(childID);
-			listener.addChild(root, child);
-		}
-		else if ( elements[0].equals("setTokenBoundaries") ) {
-			int ID = Integer.parseInt(elements[1]);
-			ProxyTree node = new ProxyTree(ID);
-			listener.setTokenBoundaries(
-				node,
-				Integer.parseInt(elements[2]),
-				Integer.parseInt(elements[3]));
-		}
-		else {
-			System.err.println("unknown debug event: "+line);
-		}
-	}
-
-	protected ProxyTree deserializeNode(String[] elements, int offset) {
-		int ID = Integer.parseInt(elements[offset+0]);
-		int type = Integer.parseInt(elements[offset+1]);
-		int tokenLine = Integer.parseInt(elements[offset+2]);
-		int charPositionInLine = Integer.parseInt(elements[offset+3]);
-		int tokenIndex = Integer.parseInt(elements[offset+4]);
-		String text = elements[offset+5];
-		text = unEscapeNewlines(text);
-		return new ProxyTree(ID, type, tokenLine, charPositionInLine, tokenIndex, text);
-	}
-
-	protected ProxyToken deserializeToken(String[] elements,
-										  int offset)
-	{
-		String indexS = elements[offset+0];
-		String typeS = elements[offset+1];
-		String channelS = elements[offset+2];
-		String lineS = elements[offset+3];
-		String posS = elements[offset+4];
-		String text = elements[offset+5];
-		text = unEscapeNewlines(text);
-		int index = Integer.parseInt(indexS);
-		ProxyToken t =
-			new ProxyToken(index,
-						   Integer.parseInt(typeS),
-						   Integer.parseInt(channelS),
-						   Integer.parseInt(lineS),
-						   Integer.parseInt(posS),
-						   text);
-		return t;
-	}
-
-	/** Create a thread to listen to the remote running recognizer */
-	public void start() {
-		Thread t = new Thread(this);
-		t.start();
-	}
-
-	public void run() {
-		eventHandler();
-	}
-
-	// M i s c
-
-	public String[] getEventElements(String event) {
-		if ( event==null ) {
-			return null;
-		}
-		String[] elements = new String[MAX_EVENT_ELEMENTS];
-		String str = null; // a string element if present (must be last)
-		try {
-			int firstQuoteIndex = event.indexOf('"');
-			if ( firstQuoteIndex>=0 ) {
-				// treat specially; has a string argument like "a comment\n
-				// Note that the string is terminated by \n not end quote.
-				// Easier to parse that way.
-				String eventWithoutString = event.substring(0,firstQuoteIndex);
-				str = event.substring(firstQuoteIndex+1,event.length());
-				event = eventWithoutString;
-			}
-			StringTokenizer st = new StringTokenizer(event, "\t", false);
-			int i = 0;
-			while ( st.hasMoreTokens() ) {
-				if ( i>=MAX_EVENT_ELEMENTS ) {
-					// ErrorManager.internalError("event has more than "+MAX_EVENT_ELEMENTS+" args: "+event);
-					return elements;
-				}
-				elements[i] = st.nextToken();
-				i++;
-			}
-			if ( str!=null ) {
-				elements[i] = str;
-			}
-		}
-		catch (Exception e) {
-			e.printStackTrace(System.err);
-		}
-		return elements;
-	}
-
-	protected String unEscapeNewlines(String txt) {
-		// this unescape is slow but easy to understand
-		txt = txt.replaceAll("%0A","\n");  // unescape \n
-		txt = txt.replaceAll("%0D","\r");  // unescape \r
-		txt = txt.replaceAll("%25","%");   // undo escaped escape chars
-		return txt;
-	}
-
-	public boolean tokenIndexesAreInvalid() {
-		return false;
-		//return tokenIndexesInvalid;
-	}
-
-}
-
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/TraceDebugEventListener.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/TraceDebugEventListener.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/TraceDebugEventListener.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/TraceDebugEventListener.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,96 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.debug;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.tree.TreeAdaptor;
-
-/** Print out (most of) the events... Useful for debugging, testing... */
-public class TraceDebugEventListener extends BlankDebugEventListener {
-	TreeAdaptor adaptor;
-
-	public TraceDebugEventListener(TreeAdaptor adaptor) {
-		this.adaptor = adaptor;
-	}
-
-	public void enterRule(String ruleName) { System.out.println("enterRule "+ruleName); }
-	public void exitRule(String ruleName) { System.out.println("exitRule "+ruleName); }
-	public void enterSubRule(int decisionNumber) { System.out.println("enterSubRule"); }
-	public void exitSubRule(int decisionNumber) { System.out.println("exitSubRule"); }
-	public void location(int line, int pos) {System.out.println("location "+line+":"+pos);}
-
-	// Tree parsing stuff
-
-	public void consumeNode(Object t) {
-		int ID = adaptor.getUniqueID(t);
-		String text = adaptor.getText(t);
-		int type = adaptor.getType(t);
-		System.out.println("consumeNode "+ID+" "+text+" "+type);
-	}
-
-	public void LT(int i, Object t) {
-		int ID = adaptor.getUniqueID(t);
-		String text = adaptor.getText(t);
-		int type = adaptor.getType(t);
-		System.out.println("LT "+i+" "+ID+" "+text+" "+type);
-	}
-
-
-	// AST stuff
-	public void nilNode(Object t) {System.out.println("nilNode "+adaptor.getUniqueID(t));}
-
-	public void createNode(Object t) {
-		int ID = adaptor.getUniqueID(t);
-		String text = adaptor.getText(t);
-		int type = adaptor.getType(t);
-		System.out.println("create "+ID+": "+text+", "+type);
-	}
-
-	public void createNode(Object node, Token token) {
-		int ID = adaptor.getUniqueID(node);
-		String text = adaptor.getText(node);
-		int tokenIndex = token.getTokenIndex();
-		System.out.println("create "+ID+": "+tokenIndex);
-	}
-
-	public void becomeRoot(Object newRoot, Object oldRoot) {
-		System.out.println("becomeRoot "+adaptor.getUniqueID(newRoot)+", "+
-						   adaptor.getUniqueID(oldRoot));
-	}
-
-	public void addChild(Object root, Object child) {
-		System.out.println("addChild "+adaptor.getUniqueID(root)+", "+
-						   adaptor.getUniqueID(child));
-	}
-
-	public void setTokenBoundaries(Object t, int tokenStartIndex, int tokenStopIndex) {
-		System.out.println("setTokenBoundaries "+adaptor.getUniqueID(t)+", "+
-						   tokenStartIndex+", "+tokenStopIndex);
-	}
-}
-
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/Tracer.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/Tracer.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/Tracer.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/debug/Tracer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,65 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.debug;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.IntStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.TokenStream;
-
-/** The default tracer mimics the traceParser behavior of ANTLR 2.x.
- *  This listens for debugging events from the parser and implies
- *  that you cannot debug and trace at the same time.
- */
-public class Tracer extends BlankDebugEventListener {
-	public IntStream input;
-	protected int level = 0;
-
-	public Tracer(IntStream input) {
-		this.input = input;
-	}
-
-	public void enterRule(String ruleName) {
-		for (int i=1; i<=level; i++) {System.out.print(" ");}
-		System.out.println("> "+ruleName+" lookahead(1)="+getInputSymbol(1));
-		level++;
-	}
-
-	public void exitRule(String ruleName) {
-		level--;
-		for (int i=1; i<=level; i++) {System.out.print(" ");}
-		System.out.println("< "+ruleName+" lookahead(1)="+getInputSymbol(1));
-	}
-
-	public Object getInputSymbol(int k) {
-		if ( input instanceof TokenStream ) {
-			return ((TokenStream)input).LT(k);
-		}
-		return new Character((char)input.LA(k));
-	}
-}
-
-
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/DFA.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/DFA.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/DFA.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/DFA.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,229 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-/** A DFA implemented as a set of transition tables.
- *
- *  Any state that has a semantic predicate edge is special; those states
- *  are generated with if-then-else structures in a specialStateTransition()
- *  which is generated by cyclicDFA template.
- *
- *  There are at most 32767 states (16-bit signed short).
- *  Could get away with byte sometimes but would have to generate different
- *  types and the simulation code too.  For a point of reference, the Java
- *  lexer's Tokens rule DFA has 326 states roughly.
- */
-public class DFA {
-	protected short[] eot;
-	protected short[] eof;
-	protected char[] min;
-    protected char[] max;
-    protected short[] accept;
-    protected short[] special;
-    protected short[][] transition;
-
-	protected int decisionNumber;
-
-	/** Which recognizer encloses this DFA?  Needed to check backtracking */
-	protected BaseRecognizer recognizer;
-
-	public static final boolean debug = false;
-
-	/** From the input stream, predict what alternative will succeed
-	 *  using this DFA (representing the covering regular approximation
-	 *  to the underlying CFL).  Return an alternative number 1..n.  Throw
-	 *  an exception upon error.
-	 */
-	public int predict(IntStream input)
-		throws RecognitionException
-	{
-		if ( debug ) {
-			System.err.println("Enter DFA.predict for decision "+decisionNumber);
-		}
-		int mark = input.mark(); // remember where decision started in input
-		int s = 0; // we always start at s0
-		try {
-			while ( true ) {
-				if ( debug ) System.err.println("DFA "+decisionNumber+" state "+s+" LA(1)="+(char)input.LA(1)+"("+input.LA(1)+
-												"), index="+input.index());
-				int specialState = special[s];
-				if ( specialState>=0 ) {
-					if ( debug ) {
-						System.err.println("DFA "+decisionNumber+
-							" state "+s+" is special state "+specialState);
-					}
-					s = specialStateTransition(specialState,input);
-					if ( debug ) {
-						System.err.println("DFA "+decisionNumber+
-							" returns from special state "+specialState+" to "+s);
-					}
-					if ( s==-1 ) {
-						noViableAlt(s,input);
-						return 0;
-					}
-					input.consume();
-					continue;
-				}
-				if ( accept[s] >= 1 ) {
-					if ( debug ) System.err.println("accept; predict "+accept[s]+" from state "+s);
-					return accept[s];
-				}
-				// look for a normal char transition
-				char c = (char)input.LA(1); // -1 == \uFFFF, all tokens fit in 65000 space
-				if (c>=min[s] && c<=max[s]) {
-					int snext = transition[s][c-min[s]]; // move to next state
-					if ( snext < 0 ) {
-						// was in range but not a normal transition
-						// must check EOT, which is like the else clause.
-						// eot[s]>=0 indicates that an EOT edge goes to another
-						// state.
-						if ( eot[s]>=0 ) {  // EOT Transition to accept state?
-							if ( debug ) System.err.println("EOT transition");
-							s = eot[s];
-							input.consume();
-							// TODO: I had this as return accept[eot[s]]
-							// which assumed here that the EOT edge always
-							// went to an accept...faster to do this, but
-							// what about predicated edges coming from EOT
-							// target?
-							continue;
-						}
-						noViableAlt(s,input);
-						return 0;
-					}
-					s = snext;
-					input.consume();
-					continue;
-				}
-				if ( eot[s]>=0 ) {  // EOT Transition?
-					if ( debug ) System.err.println("EOT transition");
-					s = eot[s];
-					input.consume();
-					continue;
-				}
-				if ( c==(char)Token.EOF && eof[s]>=0 ) {  // EOF Transition to accept state?
-					if ( debug ) System.err.println("accept via EOF; predict "+accept[eof[s]]+" from "+eof[s]);
-					return accept[eof[s]];
-				}
-				// not in range and not EOF/EOT, must be invalid symbol
-				if ( debug ) {
-					System.err.println("min["+s+"]="+min[s]);
-					System.err.println("max["+s+"]="+max[s]);
-					System.err.println("eot["+s+"]="+eot[s]);
-					System.err.println("eof["+s+"]="+eof[s]);
-					for (int p=0; p<transition[s].length; p++) {
-						System.err.print(transition[s][p]+" ");
-					}
-					System.err.println();
-				}
-				noViableAlt(s,input);
-				return 0;
-			}
-		}
-		finally {
-			input.rewind(mark);
-		}
-	}
-
-	protected void noViableAlt(int s, IntStream input) throws NoViableAltException {
-		if (recognizer.state.backtracking>0) {
-			recognizer.state.failed=true;
-			return;
-		}
-		NoViableAltException nvae =
-			new NoViableAltException(getDescription(),
-									 decisionNumber,
-									 s,
-									 input);
-		error(nvae);
-		throw nvae;
-	}
-
-	/** A hook for debugging interface */
-	protected void error(NoViableAltException nvae) { ; }
-
-	public int specialStateTransition(int s, IntStream input)
-		throws NoViableAltException
-	{
-		return -1;
-	}
-
-	public String getDescription() {
-		return "n/a";
-	}
-
-	/** Given a String that has a run-length-encoding of some unsigned shorts
-	 *  like "\1\2\3\9", convert to short[] {2,9,9,9}.  We do this to avoid
-	 *  static short[] which generates so much init code that the class won't
-	 *  compile. :(
-	 */
-	public static short[] unpackEncodedString(String encodedString) {
-		// walk first to find how big it is.
-		int size = 0;
-		for (int i=0; i<encodedString.length(); i+=2) {
-			size += encodedString.charAt(i);
-		}
-		short[] data = new short[size];
-		int di = 0;
-		for (int i=0; i<encodedString.length(); i+=2) {
-			char n = encodedString.charAt(i);
-			char v = encodedString.charAt(i+1);
-			// add v n times to data
-			for (int j=1; j<=n; j++) {
-				data[di++] = (short)v;
-			}
-		}
-		return data;
-	}
-
-	/** Hideous duplication of code, but I need different typed arrays out :( */
-	public static char[] unpackEncodedStringToUnsignedChars(String encodedString) {
-		// walk first to find how big it is.
-		int size = 0;
-		for (int i=0; i<encodedString.length(); i+=2) {
-			size += encodedString.charAt(i);
-		}
-		char[] data = new char[size];
-		int di = 0;
-		for (int i=0; i<encodedString.length(); i+=2) {
-			char n = encodedString.charAt(i);
-			char v = encodedString.charAt(i+1);
-			// add v n times to data
-			for (int j=1; j<=n; j++) {
-				data[di++] = v;
-			}
-		}
-		return data;
-	}
-
-	/*
-	public int specialTransition(int state, int symbol) {
-		return 0;
-	}
-	*/
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/EarlyExitException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/EarlyExitException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/EarlyExitException.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/EarlyExitException.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-/**  The recognizer did not match anything for a (..)+ loop. */
-public class EarlyExitException extends RecognitionException {
-	public int decisionNumber;
-
-	/** Used for remote debugger deserialization */
-	public EarlyExitException() {;}
-	
-	public EarlyExitException(int decisionNumber, IntStream input) {
-		super(input);
-		this.decisionNumber = decisionNumber;
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/FailedPredicateException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/FailedPredicateException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/FailedPredicateException.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/FailedPredicateException.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,54 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-/** A semantic predicate failed during validation.  Validation of predicates
- *  occurs when normally parsing the alternative just like matching a token.
- *  Disambiguating predicate evaluation occurs when we hoist a predicate into
- *  a prediction decision.
- */
-public class FailedPredicateException extends RecognitionException {
-	public String ruleName;
-	public String predicateText;
-
-	/** Used for remote debugger deserialization */
-	public FailedPredicateException() {;}
-
-	public FailedPredicateException(IntStream input,
-									String ruleName,
-									String predicateText)
-	{
-		super(input);
-		this.ruleName = ruleName;
-		this.predicateText = predicateText;
-	}
-
-	public String toString() {
-		return "FailedPredicateException("+ruleName+",{"+predicateText+"}?)";
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/IntStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/IntStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/IntStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/IntStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,122 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-/** A simple stream of integers used when all I care about is the char
- *  or token type sequence (such as interpretation).
- */
-public interface IntStream {
-	void consume();
-
-	/** Get int at current input pointer + i ahead where i=1 is next int.
-	 *  Negative indexes are allowed.  LA(-1) is previous token (token
-	 *  just matched).  LA(-i) where i is before first token should
-	 *  yield -1, invalid char / EOF.
-	 */
-	int LA(int i);
-
-	/** Tell the stream to start buffering if it hasn't already.  Return
-     *  current input position, index(), or some other marker so that
-	 *  when passed to rewind() you get back to the same spot.
-	 *  rewind(mark()) should not affect the input cursor.  The Lexer
-	 *  track line/col info as well as input index so its markers are
-	 *  not pure input indexes.  Same for tree node streams.
-     */
-	int mark();
-
-	/** Return the current input symbol index 0..n where n indicates the
-     *  last symbol has been read.  The index is the symbol about to be
-	 *  read not the most recently read symbol.
-     */
-	int index();
-
-	/** Reset the stream so that next call to index would return marker.
-	 *  The marker will usually be index() but it doesn't have to be.  It's
-	 *  just a marker to indicate what state the stream was in.  This is
-	 *  essentially calling release() and seek().  If there are markers
-	 *  created after this marker argument, this routine must unroll them
-	 *  like a stack.  Assume the state the stream was in when this marker
-	 *  was created.
-	 */
-	void rewind(int marker);
-
-	/** Rewind to the input position of the last marker.
-	 *  Used currently only after a cyclic DFA and just
-	 *  before starting a sem/syn predicate to get the
-	 *  input position back to the start of the decision.
-	 *  Do not "pop" the marker off the state.  mark(i)
-	 *  and rewind(i) should balance still. It is
-	 *  like invoking rewind(last marker) but it should not "pop"
-	 *  the marker off.  It's like seek(last marker's input position).
-	 */
-	void rewind();
-
-	/** You may want to commit to a backtrack but don't want to force the
-	 *  stream to keep bookkeeping objects around for a marker that is
-	 *  no longer necessary.  This will have the same behavior as
-	 *  rewind() except it releases resources without the backward seek.
-	 *  This must throw away resources for all markers back to the marker
-	 *  argument.  So if you're nested 5 levels of mark(), and then release(2)
-	 *  you have to release resources for depths 2..5.
-	 */
-	void release(int marker);
-
-	/** Set the input cursor to the position indicated by index.  This is
-	 *  normally used to seek ahead in the input stream.  No buffering is
-	 *  required to do this unless you know your stream will use seek to
-	 *  move backwards such as when backtracking.
-	 *
-	 *  This is different from rewind in its multi-directional
-	 *  requirement and in that its argument is strictly an input cursor (index).
-	 *
-	 *  For char streams, seeking forward must update the stream state such
-	 *  as line number.  For seeking backwards, you will be presumably
-	 *  backtracking using the mark/rewind mechanism that restores state and
-	 *  so this method does not need to update state when seeking backwards.
-	 *
-	 *  Currently, this method is only used for efficient backtracking using
-	 *  memoization, but in the future it may be used for incremental parsing.
-	 *
-	 *  The index is 0..n-1.  A seek to position i means that LA(1) will
-	 *  return the ith symbol.  So, seeking to 0 means LA(1) will return the
-	 *  first element in the stream. 
-	 */
-	void seek(int index);
-
-	/** Only makes sense for streams that buffer everything up probably, but
-	 *  might be useful to display the entire stream or for testing.  This
-	 *  value includes a single EOF.
-	 */
-	int size();
-
-	/** Where are you getting symbols from?  Normally, implementations will
-	 *  pass the buck all the way to the lexer who can ask its input stream
-	 *  for the file name or whatever.
-	 */
-	public String getSourceName();
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/Lexer.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/Lexer.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/Lexer.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/Lexer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,335 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-/** A lexer is recognizer that draws input symbols from a character stream.
- *  lexer grammars result in a subclass of this object. A Lexer object
- *  uses simplified match() and error recovery mechanisms in the interest
- *  of speed.
- */
-public abstract class Lexer extends BaseRecognizer implements TokenSource {
-	/** Where is the lexer drawing characters from? */
-	protected CharStream input;
-
-	public Lexer() {
-	}
-
-	public Lexer(CharStream input) {
-		this.input = input;
-	}
-
-	public Lexer(CharStream input, RecognizerSharedState state) {
-		super(state);
-		this.input = input;
-	}
-
-	public void reset() {
-		super.reset(); // reset all recognizer state variables
-		// wack Lexer state variables
-		if ( input!=null ) {
-			input.seek(0); // rewind the input
-		}
-		if ( state==null ) {
-			return; // no shared state work to do
-		}
-		state.token = null;
-		state.type = Token.INVALID_TOKEN_TYPE;
-		state.channel = Token.DEFAULT_CHANNEL;
-		state.tokenStartCharIndex = -1;
-		state.tokenStartCharPositionInLine = -1;
-		state.tokenStartLine = -1;
-		state.text = null;
-	}
-
-	/** Return a token from this source; i.e., match a token on the char
-	 *  stream.
-	 */
-	public Token nextToken() {
-		while (true) {
-			state.token = null;
-			state.channel = Token.DEFAULT_CHANNEL;
-			state.tokenStartCharIndex = input.index();
-			state.tokenStartCharPositionInLine = input.getCharPositionInLine();
-			state.tokenStartLine = input.getLine();
-			state.text = null;
-			if ( input.LA(1)==CharStream.EOF ) {
-				return Token.EOF_TOKEN;
-			}
-			try {
-				mTokens();
-				if ( state.token==null ) {
-					emit();
-				}
-				else if ( state.token==Token.SKIP_TOKEN ) {
-					continue;
-				}
-				return state.token;
-			}
-			catch (NoViableAltException nva) {
-				reportError(nva);
-				recover(nva); // throw out current char and try again
-			}
-			catch (RecognitionException re) {
-				reportError(re);
-				// match() routine has already called recover()
-			}
-		}
-	}
-
-	/** Instruct the lexer to skip creating a token for current lexer rule
-	 *  and look for another token.  nextToken() knows to keep looking when
-	 *  a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
-	 *  if token==null at end of any token rule, it creates one for you
-	 *  and emits it.
-	 */
-	public void skip() {
-		state.token = Token.SKIP_TOKEN;
-	}
-
-	/** This is the lexer entry point that sets instance var 'token' */
-	public abstract void mTokens() throws RecognitionException;
-
-	/** Set the char stream and reset the lexer */
-	public void setCharStream(CharStream input) {
-		this.input = null;
-		reset();
-		this.input = input;
-	}
-
-	public CharStream getCharStream() {
-		return this.input;
-	}
-
-	public String getSourceName() {
-		return input.getSourceName();
-	}
-
-	/** Currently does not support multiple emits per nextToken invocation
-	 *  for efficiency reasons.  Subclass and override this method and
-	 *  nextToken (to push tokens into a list and pull from that list rather
-	 *  than a single variable as this implementation does).
-	 */
-	public void emit(Token token) {
-		state.token = token;
-	}
-
-	/** The standard method called to automatically emit a token at the
-	 *  outermost lexical rule.  The token object should point into the
-	 *  char buffer start..stop.  If there is a text override in 'text',
-	 *  use that to set the token's text.  Override this method to emit
-	 *  custom Token objects.
-	 *
-	 *  If you are building trees, then you should also override
-	 *  Parser or TreeParser.getMissingSymbol().
-	 */
-	public Token emit() {
-		Token t = new CommonToken(input, state.type, state.channel, state.tokenStartCharIndex, getCharIndex()-1);
-		t.setLine(state.tokenStartLine);
-		t.setText(state.text);
-		t.setCharPositionInLine(state.tokenStartCharPositionInLine);
-		emit(t);
-		return t;
-	}
-
-	public void match(String s) throws MismatchedTokenException {
-		int i = 0;
-		while ( i<s.length() ) {
-			if ( input.LA(1)!=s.charAt(i) ) {
-				if ( state.backtracking>0 ) {
-					state.failed = true;
-					return;
-				}
-				MismatchedTokenException mte =
-					new MismatchedTokenException(s.charAt(i), input);
-				recover(mte);
-				throw mte;
-			}
-			i++;
-			input.consume();
-			state.failed = false;
-		}
-	}
-
-	public void matchAny() {
-		input.consume();
-	}
-
-	public void match(int c) throws MismatchedTokenException {
-		if ( input.LA(1)!=c ) {
-			if ( state.backtracking>0 ) {
-				state.failed = true;
-				return;
-			}
-			MismatchedTokenException mte =
-				new MismatchedTokenException(c, input);
-			recover(mte);  // don't really recover; just consume in lexer
-			throw mte;
-		}
-		input.consume();
-		state.failed = false;
-	}
-
-	public void matchRange(int a, int b)
-		throws MismatchedRangeException
-	{
-		if ( input.LA(1)<a || input.LA(1)>b ) {
-			if ( state.backtracking>0 ) {
-				state.failed = true;
-				return;
-			}
-			MismatchedRangeException mre =
-				new MismatchedRangeException(a,b,input);
-			recover(mre);
-			throw mre;
-		}
-		input.consume();
-		state.failed = false;
-	}
-
-	public int getLine() {
-		return input.getLine();
-	}
-
-	public int getCharPositionInLine() {
-		return input.getCharPositionInLine();
-	}
-
-	/** What is the index of the current character of lookahead? */
-	public int getCharIndex() {
-		return input.index();
-	}
-
-	/** Return the text matched so far for the current token or any
-	 *  text override.
-	 */
-	public String getText() {
-		if ( state.text!=null ) {
-			return state.text;
-		}
-		return input.substring(state.tokenStartCharIndex,getCharIndex()-1);
-	}
-
-	/** Set the complete text of this token; it wipes any previous
-	 *  changes to the text.
-	 */
-	public void setText(String text) {
-		state.text = text;
-	}
-
-	public void reportError(RecognitionException e) {
-		/** TODO: not thought about recovery in lexer yet.
-		 *
-		// if we've already reported an error and have not matched a token
-		// yet successfully, don't report any errors.
-		if ( errorRecovery ) {
-			//System.err.print("[SPURIOUS] ");
-			return;
-		}
-		errorRecovery = true;
-		 */
-
-		displayRecognitionError(this.getTokenNames(), e);
-	}
-
-	public String getErrorMessage(RecognitionException e, String[] tokenNames) {
-		String msg = null;
-		if ( e instanceof MismatchedTokenException ) {
-			MismatchedTokenException mte = (MismatchedTokenException)e;
-			msg = "mismatched character "+getCharErrorDisplay(e.c)+" expecting "+getCharErrorDisplay(mte.expecting);
-		}
-		else if ( e instanceof NoViableAltException ) {
-			NoViableAltException nvae = (NoViableAltException)e;
-			// for development, can add "decision=<<"+nvae.grammarDecisionDescription+">>"
-			// and "(decision="+nvae.decisionNumber+") and
-			// "state "+nvae.stateNumber
-			msg = "no viable alternative at character "+getCharErrorDisplay(e.c);
-		}
-		else if ( e instanceof EarlyExitException ) {
-			EarlyExitException eee = (EarlyExitException)e;
-			// for development, can add "(decision="+eee.decisionNumber+")"
-			msg = "required (...)+ loop did not match anything at character "+getCharErrorDisplay(e.c);
-		}
-		else if ( e instanceof MismatchedNotSetException ) {
-			MismatchedNotSetException mse = (MismatchedNotSetException)e;
-			msg = "mismatched character "+getCharErrorDisplay(e.c)+" expecting set "+mse.expecting;
-		}
-		else if ( e instanceof MismatchedSetException ) {
-			MismatchedSetException mse = (MismatchedSetException)e;
-			msg = "mismatched character "+getCharErrorDisplay(e.c)+" expecting set "+mse.expecting;
-		}
-		else if ( e instanceof MismatchedRangeException ) {
-			MismatchedRangeException mre = (MismatchedRangeException)e;
-			msg = "mismatched character "+getCharErrorDisplay(e.c)+" expecting set "+
-				  getCharErrorDisplay(mre.a)+".."+getCharErrorDisplay(mre.b);
-		}
-		else {
-			msg = super.getErrorMessage(e, tokenNames);
-		}
-		return msg;
-	}
-
-	public String getCharErrorDisplay(int c) {
-		String s = String.valueOf((char)c);
-		switch ( c ) {
-			case Token.EOF :
-				s = "<EOF>";
-				break;
-			case '\n' :
-				s = "\\n";
-				break;
-			case '\t' :
-				s = "\\t";
-				break;
-			case '\r' :
-				s = "\\r";
-				break;
-		}
-		return "'"+s+"'";
-	}
-
-	/** Lexers can normally match any char in it's vocabulary after matching
-	 *  a token, so do the easy thing and just kill a character and hope
-	 *  it all works out.  You can instead use the rule invocation stack
-	 *  to do sophisticated error recovery if you are in a fragment rule.
-	 */
-	public void recover(RecognitionException re) {
-		//System.out.println("consuming char "+(char)input.LA(1)+" during recovery");
-		//re.printStackTrace();
-		input.consume();
-	}
-
-	public void traceIn(String ruleName, int ruleIndex)  {
-		String inputSymbol = ((char)input.LT(1))+" line="+getLine()+":"+getCharPositionInLine();
-		super.traceIn(ruleName, ruleIndex, inputSymbol);
-	}
-
-	public void traceOut(String ruleName, int ruleIndex)  {
-		String inputSymbol = ((char)input.LT(1))+" line="+getLine()+":"+getCharPositionInLine();
-		super.traceOut(ruleName, ruleIndex, inputSymbol);
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/misc/FastQueue.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/misc/FastQueue.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/misc/FastQueue.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/misc/FastQueue.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,93 +0,0 @@
-/*
-[The "BSD licence"]
-Copyright (c) 2005-2008 Terence Parr
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-3. The name of the author may not be used to endorse or promote products
-derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.misc;
-
-import java.util.List;
-import java.util.ArrayList;
-import java.util.NoSuchElementException;
-
-/** A queue that can dequeue and get(i) in O(1) and grow arbitrarily large.
- *  A linked list is fast at dequeue but slow at get(i).  An array is
- *  the reverse.  This is O(1) for both operations.
- *
- *  List grows until you dequeue last element at end of buffer. Then
- *  it resets to start filling at 0 again.  If adds/removes are balanced, the
- *  buffer will not grow too large.
- *
- *  No iterator stuff as that's not how we'll use it.
- */
-public class FastQueue<T> {
-    /** dynamically-sized buffer of elements */
-    protected List<T> data = new ArrayList<T>();
-    /** index of next element to fill */
-    protected int p = 0;
-
-    public void reset() { p = 0; data.clear(); }
-
-    /** Get and remove first element in queue */
-    public T remove() {
-        T o = get(0);
-        p++;
-        // have we hit end of buffer?
-        if ( p == data.size() ) {
-            // if so, it's an opportunity to start filling at index 0 again
-            clear(); // size goes to 0, but retains memory
-        }
-        return o;
-    }
-
-    public void add(T o) { data.add(o); }
-
-    public int size() { return data.size() - p; }
-
-    public T head() { return get(0); }
-
-    /** Return element i elements ahead of current element.  i==0 gets
-     *  current element.  This is not an absolute index into the data list
-     *  since p defines the start of the real list.
-     */
-    public T get(int i) {
-        if ( p+i >= data.size() ) {
-            throw new NoSuchElementException("queue index "+(p+i)+" > size "+data.size());
-        }
-        return data.get(p+i);
-    }
-
-    public void clear() { p = 0; data.clear(); }
-
-    /** Return string of current buffer contents; non-destructive */
-    public String toString() {
-        StringBuffer buf = new StringBuffer();
-        int n = size();
-        for (int i=0; i<n; i++) {
-            buf.append(get(i));
-            if ( (i+1)<n ) buf.append(" ");
-        }
-        return buf.toString();
-    }
-}
\ Manca newline alla fine del file
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/misc/IntArray.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/misc/IntArray.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/misc/IntArray.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/misc/IntArray.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,87 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.misc;
-
-/** A dynamic array that uses int not Integer objects. In principle this
- *  is more efficient in time, but certainly in space.
- *
- *  This is simple enough that you can access the data array directly,
- *  but make sure that you append elements only with add() so that you
- *  get dynamic sizing.  Make sure to call ensureCapacity() when you are
- *  manually adding new elements.
- *
- *  Doesn't impl List because it doesn't return objects and I mean this
- *  really as just an array not a List per se.  Manipulate the elements
- *  at will.  This has stack methods too.
- *
- *  When runtime can be 1.5, I'll make this generic.
- */
-public class IntArray {
-	public static final int INITIAL_SIZE = 10;
-	public int[] data;
-	protected int p = -1;
-
-	public void add(int v) {
-		ensureCapacity(p+1);
-		data[++p] = v;
-	}
-
-	public void push(int v) {
-		add(v);
-	}
-
-	public int pop() {
-		int v = data[p];
-		p--;
-		return v;
-	}
-
-	/** This only tracks elements added via push/add. */
-	public int size() {
-		return p;
-	}
-
-    public void clear() {
-        p = -1;
-    }
-
-    public void ensureCapacity(int index) {
-		if ( data==null ) {
-			data = new int[INITIAL_SIZE];
-		}
-		else if ( (index+1)>=data.length ) {
-			int newSize = data.length*2;
-			if ( index>newSize ) {
-				newSize = index+1;
-			}
-			int[] newData = new int[newSize];
-			System.arraycopy(data, 0, newData, 0, data.length);
-			data = newData;
-		}
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/misc/LookaheadStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/misc/LookaheadStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/misc/LookaheadStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/misc/LookaheadStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,163 +0,0 @@
-/*
-[The "BSD licence"]
-Copyright (c) 2005-2008 Terence Parr
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-3. The name of the author may not be used to endorse or promote products
-derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.misc;
-
-import java.util.List;
-import java.util.ArrayList;
-
-/** A lookahead queue that knows how to mark/release locations
- *  in the buffer for backtracking purposes. Any markers force the FastQueue
- *  superclass to keep all tokens until no more markers; then can reset
- *  to avoid growing a huge buffer.
- */
-public abstract class LookaheadStream<T> extends FastQueue<T> {
-    public static final int UNINITIALIZED_EOF_ELEMENT_INDEX = Integer.MAX_VALUE;
-
-    /** Set to buffer index of eof when nextElement returns eof */
-    protected int eofElementIndex = UNINITIALIZED_EOF_ELEMENT_INDEX;
-
-    /** Returned by nextElement upon end of stream; we add to buffer also */
-    public T eof = null;
-
-    /** Track the last mark() call result value for use in rewind(). */
-    protected int lastMarker;
-
-    /** tracks how deep mark() calls are nested */
-    protected int markDepth = 0;    
-
-    public LookaheadStream(T eof) {
-        this.eof = eof;
-    }
-
-    public void reset() {
-        eofElementIndex = UNINITIALIZED_EOF_ELEMENT_INDEX;
-        super.reset();
-    }
-    
-    /** Implement nextElement to supply a stream of elements to this
-     *  lookahead buffer.  Return eof upon end of the stream we're pulling from.
-     */
-    public abstract T nextElement();
-
-    /** Get and remove first element in queue; override FastQueue.remove() */
-    public T remove() {
-        T o = get(0);
-        p++;
-        // have we hit end of buffer and not backtracking?
-        if ( p == data.size() && markDepth==0 ) {
-            // if so, it's an opportunity to start filling at index 0 again
-            clear(); // size goes to 0, but retains memory
-        }
-        return o;
-    }
-
-    /** Make sure we have at least one element to remove, even if EOF */
-    public void consume() { sync(1); remove(); }
-
-    /** Make sure we have 'need' elements from current position p. Last valid
-     *  p index is data.size()-1.  p+need-1 is the data index 'need' elements
-     *  ahead.  If we need 1 element, (p+1-1)==p must be < data.size().
-     */
-    public void sync(int need) {
-        int n = (p+need-1) - data.size() + 1; // how many more elements we need?
-        if ( n > 0 ) fill(n);                 // out of elements?
-    }
-
-    /** add n elements to buffer */
-    public void fill(int n) {
-        for (int i=1; i<=n; i++) {
-            T o = nextElement();
-            if ( o==eof ) {
-                data.add(eof);
-                eofElementIndex = data.size()-1;
-            }
-            else data.add(o);
-        }
-    }
-
-    //public boolean hasNext() { return eofElementIndex!=UNINITIALIZED_EOF_ELEMENT_INDEX; }
-    
-    /** Size of entire stream is unknown; we only know buffer size from FastQueue */
-    public int size() { throw new UnsupportedOperationException("streams are of unknown size"); }
-
-    public Object LT(int k) {
-		if ( k==0 ) {
-			return null;
-		}
-		if ( k<0 ) {
-			return LB(-k);
-		}
-		//System.out.print("LT(p="+p+","+k+")=");
-		if ( (p+k-1) >= eofElementIndex ) { // move to super.LT
-			return eof;
-		}
-        sync(k);
-        return get(k-1);
-	}
-
-	/** Look backwards k nodes */
-	protected Object LB(int k) {
-		if ( k==0 ) {
-			return null;
-		}
-		if ( (p-k)<0 ) {
-			return null;
-		}
-		return get(-k);
-	}
-
-    public Object getCurrentSymbol() { return LT(1); }
-
-    public int index() { return p; }
-
-	public int mark() {
-        markDepth++;
-        lastMarker = index();
-        return lastMarker;
-	}
-
-	public void release(int marker) {
-		// no resources to release
-	}
-
-	public void rewind(int marker) {
-        markDepth--;
-        seek(marker); // assume marker is top
-        // release(marker); // waste of call; it does nothing in this class
-    }
-
-	public void rewind() {
-        seek(lastMarker); // rewind but do not release marker
-    }
-
-    /** Seek to a 0-indexed position within data buffer.  Can't handle
-     *  case where you seek beyond end of existing buffer.  Normally used
-     *  to seek backwards in the buffer. Does not force loading of nodes.
-     */
-    public void seek(int index) { p = index; }
-}
\ Manca newline alla fine del file
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/misc/Stats.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/misc/Stats.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/misc/Stats.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/misc/Stats.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,144 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.misc;
-
-import java.io.*;
-
-/** Stats routines needed by profiler etc...
-
- // note that these routines return 0.0 if no values exist in the X[]
- // which is not "correct", but it is useful so I don't generate NaN
- // in my output
-
- */
-public class Stats {
-	public static final String ANTLRWORKS_DIR = "antlrworks";
-
-	/** Compute the sample (unbiased estimator) standard deviation following:
-	 *
-	 *  Computing Deviations: Standard Accuracy
-	 *  Tony F. Chan and John Gregg Lewis
-	 *  Stanford University
-	 *  Communications of ACM September 1979 of Volume 22 the ACM Number 9
-	 *
-	 *  The "two-pass" method from the paper; supposed to have better
-	 *  numerical properties than the textbook summation/sqrt.  To me
-	 *  this looks like the textbook method, but I ain't no numerical
-	 *  methods guy.
-	 */
-	public static double stddev(int[] X) {
-		int m = X.length;
-		if ( m<=1 ) {
-			return 0;
-		}
-		double xbar = avg(X);
-		double s2 = 0.0;
-		for (int i=0; i<m; i++){
-			s2 += (X[i] - xbar)*(X[i] - xbar);
-		}
-		s2 = s2/(m-1);
-		return Math.sqrt(s2);
-	}
-
-	/** Compute the sample mean */
-	public static double avg(int[] X) {
-		double xbar = 0.0;
-		int m = X.length;
-		if ( m==0 ) {
-			return 0;
-		}
-		for (int i=0; i<m; i++){
-			xbar += X[i];
-		}
-		if ( xbar>=0.0 ) {
-			return xbar / m;
-		}
-		return 0.0;
-	}
-
-	public static int min(int[] X) {
-		int min = Integer.MAX_VALUE;
-		int m = X.length;
-		if ( m==0 ) {
-			return 0;
-		}
-		for (int i=0; i<m; i++){
-			if ( X[i] < min ) {
-				min = X[i];
-			}
-		}
-		return min;
-	}
-
-	public static int max(int[] X) {
-		int max = Integer.MIN_VALUE;
-		int m = X.length;
-		if ( m==0 ) {
-			return 0;
-		}
-		for (int i=0; i<m; i++){
-			if ( X[i] > max ) {
-				max = X[i];
-			}
-		}
-		return max;
-	}
-
-	public static int sum(int[] X) {
-		int s = 0;
-		int m = X.length;
-		if ( m==0 ) {
-			return 0;
-		}
-		for (int i=0; i<m; i++){
-			s += X[i];
-		}
-		return s;
-	}
-
-	public static void writeReport(String filename, String data) throws IOException {
-		String absoluteFilename = getAbsoluteFileName(filename);
-		File f = new File(absoluteFilename);
-		File parent = f.getParentFile();
-		parent.mkdirs(); // ensure parent dir exists
-		// write file
-		FileOutputStream fos = new FileOutputStream(f, true); // append
-		BufferedOutputStream bos = new BufferedOutputStream(fos);
-		PrintStream ps = new PrintStream(bos);
-		ps.println(data);
-		ps.close();
-		bos.close();
-		fos.close();
-	}
-
-	public static String getAbsoluteFileName(String filename) {
-		return System.getProperty("user.home")+File.separator+
-					ANTLRWORKS_DIR +File.separator+
-					filename;
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedNotSetException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedNotSetException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedNotSetException.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedNotSetException.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-public class MismatchedNotSetException extends MismatchedSetException {
-	/** Used for remote debugger deserialization */
-	public MismatchedNotSetException() {;}
-
-	public MismatchedNotSetException(BitSet expecting, IntStream input) {
-		super(expecting, input);
-	}
-
-	public String toString() {
-		return "MismatchedNotSetException("+getUnexpectedType()+"!="+expecting+")";
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedRangeException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedRangeException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedRangeException.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedRangeException.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-public class MismatchedRangeException extends RecognitionException {
-	public int a,b;
-
-	/** Used for remote debugger deserialization */
-	public MismatchedRangeException() {;}
-
-	public MismatchedRangeException(int a, int b, IntStream input) {
-		super(input);
-		this.a = a;
-		this.b = b;
-	}
-
-	public String toString() {
-		return "MismatchedNotSetException("+getUnexpectedType()+" not in ["+a+","+b+"])";
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedSetException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedSetException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedSetException.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedSetException.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,44 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-public class MismatchedSetException extends RecognitionException {
-	public BitSet expecting;
-
-	/** Used for remote debugger deserialization */
-	public MismatchedSetException() {;}
-
-	public MismatchedSetException(BitSet expecting, IntStream input) {
-		super(input);
-		this.expecting = expecting;
-	}
-
-	public String toString() {
-		return "MismatchedSetException("+getUnexpectedType()+"!="+expecting+")";
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedTokenException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedTokenException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedTokenException.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedTokenException.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-/** A mismatched char or Token or tree node */
-public class MismatchedTokenException extends RecognitionException {
-	public int expecting = Token.INVALID_TOKEN_TYPE;
-
-	/** Used for remote debugger deserialization */
-	public MismatchedTokenException() {;}
-
-	public MismatchedTokenException(int expecting, IntStream input) {
-		super(input);
-		this.expecting = expecting;
-	}
-
-	public String toString() {
-		return "MismatchedTokenException("+getUnexpectedType()+"!="+expecting+")";
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedTreeNodeException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedTreeNodeException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedTreeNodeException.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/MismatchedTreeNodeException.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,49 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.tree.TreeNodeStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.tree.Tree;
-
-/**
- */
-public class MismatchedTreeNodeException extends RecognitionException {
-	public int expecting;
-
-	public MismatchedTreeNodeException() {
-	}
-
-	public MismatchedTreeNodeException(int expecting, TreeNodeStream input) {
-		super(input);
-		this.expecting = expecting;
-	}
-
-	public String toString() {
-		return "MismatchedTreeNodeException("+getUnexpectedType()+"!="+expecting+")";
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/MissingTokenException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/MissingTokenException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/MissingTokenException.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/MissingTokenException.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,56 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-/** We were expecting a token but it's not found.  The current token
- *  is actually what we wanted next.  Used for tree node errors too.
- */
-public class MissingTokenException extends MismatchedTokenException {
-	public Object inserted;
-	/** Used for remote debugger deserialization */
-	public MissingTokenException() {;}
-
-	public MissingTokenException(int expecting, IntStream input, Object inserted) {
-		super(expecting, input);
-		this.inserted = inserted;
-	}
-
-	public int getMissingType() {
-		return expecting;
-	}
-
-	public String toString() {
-		if ( inserted!=null && token!=null ) {
-			return "MissingTokenException(inserted "+inserted+" at "+token.getText()+")";
-		}
-		if ( token!=null ) {
-			return "MissingTokenException(at "+token.getText()+")";
-		}
-		return "MissingTokenException";
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/NoViableAltException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/NoViableAltException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/NoViableAltException.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/NoViableAltException.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,57 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-public class NoViableAltException extends RecognitionException {
-	public String grammarDecisionDescription;
-	public int decisionNumber;
-	public int stateNumber;
-
-	/** Used for remote debugger deserialization */
-	public NoViableAltException() {;}
-	
-	public NoViableAltException(String grammarDecisionDescription,
-								int decisionNumber,
-								int stateNumber,
-								IntStream input)
-	{
-		super(input);
-		this.grammarDecisionDescription = grammarDecisionDescription;
-		this.decisionNumber = decisionNumber;
-		this.stateNumber = stateNumber;
-	}
-
-	public String toString() {
-		if ( input instanceof CharStream ) {
-			return "NoViableAltException('"+(char)getUnexpectedType()+"'@["+grammarDecisionDescription+"])";
-		}
-		else {
-			return "NoViableAltException("+getUnexpectedType()+"@["+grammarDecisionDescription+"])";
-		}
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/Parser.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/Parser.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/Parser.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/Parser.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,98 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-/** A parser for TokenStreams.  "parser grammars" result in a subclass
- *  of this.
- */
-public class Parser extends BaseRecognizer {
-	public TokenStream input;
-
-	public Parser(TokenStream input) {
-		super(); // highlight that we go to super to set state object
-		setTokenStream(input);
-    }
-
-	public Parser(TokenStream input, RecognizerSharedState state) {
-		super(state); // share the state object with another parser
-		setTokenStream(input);
-    }
-
-	public void reset() {
-		super.reset(); // reset all recognizer state variables
-		if ( input!=null ) {
-			input.seek(0); // rewind the input
-		}
-	}
-
-	protected Object getCurrentInputSymbol(IntStream input) {
-		return ((TokenStream)input).LT(1);
-	}
-
-	protected Object getMissingSymbol(IntStream input,
-									  RecognitionException e,
-									  int expectedTokenType,
-									  BitSet follow)
-	{
-		String tokenText = null;
-		if ( expectedTokenType==Token.EOF ) tokenText = "<missing EOF>";
-		else tokenText = "<missing "+getTokenNames()[expectedTokenType]+">";
-		CommonToken t = new CommonToken(expectedTokenType, tokenText);
-		Token current = ((TokenStream)input).LT(1);
-		if ( current.getType() == Token.EOF ) {
-			current = ((TokenStream)input).LT(-1);
-		}
-		t.line = current.getLine();
-		t.charPositionInLine = current.getCharPositionInLine();
-		t.channel = DEFAULT_TOKEN_CHANNEL;
-		return t;
-	}
-
-	/** Set the token stream and reset the parser */
-	public void setTokenStream(TokenStream input) {
-		this.input = null;
-		reset();
-		this.input = input;
-	}
-
-    public TokenStream getTokenStream() {
-		return input;
-	}
-
-	public String getSourceName() {
-		return input.getSourceName();
-	}
-
-	public void traceIn(String ruleName, int ruleIndex)  {
-		super.traceIn(ruleName, ruleIndex, input.LT(1));
-	}
-
-	public void traceOut(String ruleName, int ruleIndex)  {
-		super.traceOut(ruleName, ruleIndex, input.LT(1));
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/ParserRuleReturnScope.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/ParserRuleReturnScope.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/ParserRuleReturnScope.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/ParserRuleReturnScope.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,52 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-/** Rules that return more than a single value must return an object
- *  containing all the values.  Besides the properties defined in
- *  RuleLabelScope.predefinedRulePropertiesScope there may be user-defined
- *  return values.  This class simply defines the minimum properties that
- *  are always defined and methods to access the others that might be
- *  available depending on output option such as template and tree.
- *
- *  Note text is not an actual property of the return value, it is computed
- *  from start and stop using the input stream's toString() method.  I
- *  could add a ctor to this so that we can pass in and store the input
- *  stream, but I'm not sure we want to do that.  It would seem to be undefined
- *  to get the .text property anyway if the rule matches tokens from multiple
- *  input streams.
- *
- *  I do not use getters for fields of objects that are used simply to
- *  group values such as this aggregate.  The getters/setters are there to
- *  satisfy the superclass interface.
- */
-public class ParserRuleReturnScope extends RuleReturnScope {
-	public Token start, stop;
-	public Object getStart() { return start; }
-	public Object getStop() { return stop; }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/RecognitionException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/RecognitionException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/RecognitionException.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/RecognitionException.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,180 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.tree.*;
-
-/** The root of the ANTLR exception hierarchy.
- *
- *  To avoid English-only error messages and to generally make things
- *  as flexible as possible, these exceptions are not created with strings,
- *  but rather the information necessary to generate an error.  Then
- *  the various reporting methods in Parser and Lexer can be overridden
- *  to generate a localized error message.  For example, MismatchedToken
- *  exceptions are built with the expected token type.
- *  So, don't expect getMessage() to return anything.
- *
- *  Note that as of Java 1.4, you can access the stack trace, which means
- *  that you can compute the complete trace of rules from the start symbol.
- *  This gives you considerable context information with which to generate
- *  useful error messages.
- *
- *  ANTLR generates code that throws exceptions upon recognition error and
- *  also generates code to catch these exceptions in each rule.  If you
- *  want to quit upon first error, you can turn off the automatic error
- *  handling mechanism using rulecatch action, but you still need to
- *  override methods mismatch and recoverFromMismatchSet.
- *
- *  In general, the recognition exceptions can track where in a grammar a
- *  problem occurred and/or what was the expected input.  While the parser
- *  knows its state (such as current input symbol and line info) that
- *  state can change before the exception is reported so current token index
- *  is computed and stored at exception time.  From this info, you can
- *  perhaps print an entire line of input not just a single token, for example.
- *  Better to just say the recognizer had a problem and then let the parser
- *  figure out a fancy report.
- */
-public class RecognitionException extends Exception {
-	/** What input stream did the error occur in? */
-	public transient IntStream input;
-
-	/** What is index of token/char were we looking at when the error occurred? */
-	public int index;
-
-	/** The current Token when an error occurred.  Since not all streams
-	 *  can retrieve the ith Token, we have to track the Token object.
-	 *  For parsers.  Even when it's a tree parser, token might be set.
-	 */
-	public Token token;
-
-	/** If this is a tree parser exception, node is set to the node with
-	 *  the problem.
-	 */
-	public Object node;
-
-	/** The current char when an error occurred. For lexers. */
-	public int c;
-
-	/** Track the line at which the error occurred in case this is
-	 *  generated from a lexer.  We need to track this since the
-	 *  unexpected char doesn't carry the line info.
-	 */
-	public int line;
-
-	public int charPositionInLine;
-
-	/** If you are parsing a tree node stream, you will encounter som
-	 *  imaginary nodes w/o line/col info.  We now search backwards looking
-	 *  for most recent token with line/col info, but notify getErrorHeader()
-	 *  that info is approximate.
-	 */
-	public boolean approximateLineInfo;
-
-	/** Used for remote debugger deserialization */
-	public RecognitionException() {
-	}
-
-	public RecognitionException(IntStream input) {
-		this.input = input;
-		this.index = input.index();
-		if ( input instanceof TokenStream ) {
-			this.token = ((TokenStream)input).LT(1);
-			this.line = token.getLine();
-			this.charPositionInLine = token.getCharPositionInLine();
-		}
-		if ( input instanceof TreeNodeStream ) {
-			extractInformationFromTreeNodeStream(input);
-		}
-		else if ( input instanceof CharStream ) {
-			this.c = input.LA(1);
-			this.line = ((CharStream)input).getLine();
-			this.charPositionInLine = ((CharStream)input).getCharPositionInLine();
-		}
-		else {
-			this.c = input.LA(1);
-		}
-	}
-
-	protected void extractInformationFromTreeNodeStream(IntStream input) {
-		TreeNodeStream nodes = (TreeNodeStream)input;
-		this.node = nodes.LT(1);
-		TreeAdaptor adaptor = nodes.getTreeAdaptor();
-		Token payload = adaptor.getToken(node);
-		if ( payload!=null ) {
-			this.token = payload;
-			if ( payload.getLine()<= 0 ) {
-				// imaginary node; no line/pos info; scan backwards
-				int i = -1;
-				Object priorNode = nodes.LT(i);
-				while ( priorNode!=null ) {
-					Token priorPayload = adaptor.getToken(priorNode);
-					if ( priorPayload!=null && priorPayload.getLine()>0 ) {
-						// we found the most recent real line / pos info
-						this.line = priorPayload.getLine();
-						this.charPositionInLine = priorPayload.getCharPositionInLine();
-						this.approximateLineInfo = true;
-						break;
-					}
-					--i;
-					priorNode = nodes.LT(i);
-				}
-			}
-			else { // node created from real token
-				this.line = payload.getLine();
-				this.charPositionInLine = payload.getCharPositionInLine();
-			}
-		}
-		else if ( this.node instanceof Tree) {
-			this.line = ((Tree)this.node).getLine();
-			this.charPositionInLine = ((Tree)this.node).getCharPositionInLine();
-			if ( this.node instanceof CommonTree) {
-				this.token = ((CommonTree)this.node).token;
-			}
-		}
-		else {
-			int type = adaptor.getType(this.node);
-			String text = adaptor.getText(this.node);
-			this.token = new CommonToken(type, text);
-		}
-	}
-
-	/** Return the token type or char of the unexpected input element */
-	public int getUnexpectedType() {
-		if ( input instanceof TokenStream ) {
-			return token.getType();
-		}
-		else if ( input instanceof TreeNodeStream ) {
-			TreeNodeStream nodes = (TreeNodeStream)input;
-			TreeAdaptor adaptor = nodes.getTreeAdaptor();
-			return adaptor.getType(node);
-		}
-		else {
-			return c;
-		}
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/RecognizerSharedState.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/RecognizerSharedState.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/RecognizerSharedState.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/RecognizerSharedState.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,144 +0,0 @@
-/*
-[The "BSD licence"]
-Copyright (c) 2005-2008 Terence Parr
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-3. The name of the author may not be used to endorse or promote products
-derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-import java.util.Map;
-
-/** The set of fields needed by an abstract recognizer to recognize input
- *  and recover from errors etc...  As a separate state object, it can be
- *  shared among multiple grammars; e.g., when one grammar imports another.
- *
- *  These fields are publically visible but the actual state pointer per
- *  parser is protected.
- */
-public class RecognizerSharedState {
-	/** Track the set of token types that can follow any rule invocation.
-	 *  Stack grows upwards.  When it hits the max, it grows 2x in size
-	 *  and keeps going.
-	 */
-	public BitSet[] following = new BitSet[BaseRecognizer.INITIAL_FOLLOW_STACK_SIZE];
-	public int _fsp = -1;
-
-	/** This is true when we see an error and before having successfully
-	 *  matched a token.  Prevents generation of more than one error message
-	 *  per error.
-	 */
-	public boolean errorRecovery = false;
-
-	/** The index into the input stream where the last error occurred.
-	 * 	This is used to prevent infinite loops where an error is found
-	 *  but no token is consumed during recovery...another error is found,
-	 *  ad naseum.  This is a failsafe mechanism to guarantee that at least
-	 *  one token/tree node is consumed for two errors.
-	 */
-	public int lastErrorIndex = -1;
-
-	/** In lieu of a return value, this indicates that a rule or token
-	 *  has failed to match.  Reset to false upon valid token match.
-	 */
-	public boolean failed = false;
-
-	/** Did the recognizer encounter a syntax error?  Track how many. */
-	public int syntaxErrors = 0;
-
-	/** If 0, no backtracking is going on.  Safe to exec actions etc...
-	 *  If >0 then it's the level of backtracking.
-	 */
-	public int backtracking = 0;
-
-	/** An array[size num rules] of Map<Integer,Integer> that tracks
-	 *  the stop token index for each rule.  ruleMemo[ruleIndex] is
-	 *  the memoization table for ruleIndex.  For key ruleStartIndex, you
-	 *  get back the stop token for associated rule or MEMO_RULE_FAILED.
-	 *
-	 *  This is only used if rule memoization is on (which it is by default).
-	 */
-	public Map[] ruleMemo;
-
-
-	// LEXER FIELDS (must be in same state object to avoid casting
-	//               constantly in generated code and Lexer object) :(
-
-
-	/** The goal of all lexer rules/methods is to create a token object.
-	 *  This is an instance variable as multiple rules may collaborate to
-	 *  create a single token.  nextToken will return this object after
-	 *  matching lexer rule(s).  If you subclass to allow multiple token
-	 *  emissions, then set this to the last token to be matched or
-	 *  something nonnull so that the auto token emit mechanism will not
-	 *  emit another token.
-	 */
-    public Token token;
-
-	/** What character index in the stream did the current token start at?
-	 *  Needed, for example, to get the text for current token.  Set at
-	 *  the start of nextToken.
- 	 */
-	public int tokenStartCharIndex = -1;
-
-	/** The line on which the first character of the token resides */
-	public int tokenStartLine;
-
-	/** The character position of first character within the line */
-	public int tokenStartCharPositionInLine;
-
-	/** The channel number for the current token */
-	public int channel;
-
-	/** The token type for the current token */
-	public int type;
-
-	/** You can set the text for the current token to override what is in
-	 *  the input char buffer.  Use setText() or can set this instance var.
- 	 */
-	public String text;
-
-    public RecognizerSharedState() {;}
-    
-    public RecognizerSharedState(RecognizerSharedState state) {
-        if ( this.following.length < state.following.length ) {
-            this.following = new BitSet[state.following.length];
-        }
-        System.arraycopy(state.following, 0, this.following, 0, state.following.length);
-        this._fsp = state._fsp;
-        this.errorRecovery = state.errorRecovery;
-        this.lastErrorIndex = state.lastErrorIndex;
-        this.failed = state.failed;
-        this.syntaxErrors = state.syntaxErrors;
-        this.backtracking = state.backtracking;
-        if ( state.ruleMemo!=null ) {
-            this.ruleMemo = new Map[state.ruleMemo.length];
-            System.arraycopy(state.ruleMemo, 0, this.ruleMemo, 0, state.ruleMemo.length);
-        }
-        this.token = state.token;
-        this.tokenStartCharIndex = state.tokenStartCharIndex;
-        this.tokenStartCharPositionInLine = state.tokenStartCharPositionInLine;
-        this.channel = state.channel;
-        this.type = state.type;
-        this.text = state.text;
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/RuleReturnScope.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/RuleReturnScope.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/RuleReturnScope.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/RuleReturnScope.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-/** Rules can return start/stop info as well as possible trees and templates */
-public class RuleReturnScope {
-	/** Return the start token or tree */
-	public Object getStart() { return null; }
-	/** Return the stop token or tree */
-	public Object getStop() { return null; }
-	/** Has a value potentially if output=AST; */
-	public Object getTree() { return null; }
-	/** Has a value potentially if output=template; Don't use StringTemplate
-	 *  type as it then causes a dependency with ST lib.
-	 */
-	public Object getTemplate() { return null; }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/SerializedGrammar.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/SerializedGrammar.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/SerializedGrammar.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/SerializedGrammar.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,170 +0,0 @@
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-import java.io.IOException;
-import java.io.FileInputStream;
-import java.io.BufferedInputStream;
-import java.io.DataInputStream;
-import java.util.List;
-import java.util.ArrayList;
-
-public class SerializedGrammar {
-    public static final String COOKIE = "$ANTLR";
-    public static final int FORMAT_VERSION = 1;
-    //public static org.antlr.tool.Grammar gr; // TESTING ONLY; remove later
-
-    public String name;
-    public char type; // in {l, p, t, c}
-    public List rules;
-
-    class Rule {
-        String name;
-        Block block;
-        public Rule(String name, Block block) {
-            this.name = name;
-            this.block = block;
-        }
-        public String toString() {
-            return name+":"+block;
-        }
-    }
-
-    class Block {
-        List[] alts;
-        public Block(List[] alts) {
-            this.alts = alts;
-        }
-        public String toString() {
-            StringBuffer buf = new StringBuffer();
-            buf.append("(");
-            for (int i = 0; i < alts.length; i++) {
-                List alt = alts[i];
-                if ( i>0 ) buf.append("|");
-                buf.append(alt.toString());
-            }
-            buf.append(")");
-            return buf.toString();
-        }
-    }
-
-    class TokenRef {
-        int ttype;
-        public TokenRef(int ttype) { this.ttype = ttype; }
-        public String toString() { return String.valueOf(ttype); }
-    }
-
-    class RuleRef {
-        int ruleIndex;
-        public RuleRef(int ruleIndex) { this.ruleIndex = ruleIndex; }
-        public String toString() { return String.valueOf(ruleIndex); }
-    }
-
-    public SerializedGrammar(String filename) throws IOException {
-        System.out.println("loading "+filename);
-        FileInputStream fis = new FileInputStream(filename);
-        BufferedInputStream bos = new BufferedInputStream(fis);
-        DataInputStream in = new DataInputStream(bos);
-        readFile(in);
-        in.close();
-    }
-
-    protected void readFile(DataInputStream in) throws IOException {
-        String cookie = readString(in); // get $ANTLR
-        if ( !cookie.equals(COOKIE) ) throw new IOException("not a serialized grammar file");
-        int version = in.readByte();
-        char grammarType = (char)in.readByte();
-        this.type = grammarType;
-        String grammarName = readString(in);
-        this.name = grammarName;
-        System.out.println(grammarType+" grammar "+grammarName);
-        int numRules = in.readShort();
-        System.out.println("num rules = "+numRules);
-        rules = readRules(in, numRules);
-    }
-
-    protected List readRules(DataInputStream in, int numRules) throws IOException {
-        List rules = new ArrayList();
-        for (int i=0; i<numRules; i++) {
-            Rule r = readRule(in);
-            rules.add(r);
-        }
-        return rules;
-    }
-
-    protected Rule readRule(DataInputStream in) throws IOException {
-        byte R = in.readByte();
-        if ( R!='R' ) throw new IOException("missing R on start of rule");
-        String name = readString(in);
-        System.out.println("rule: "+name);
-        byte B = in.readByte();
-        Block b = readBlock(in);
-        byte period = in.readByte();
-        if ( period!='.' ) throw new IOException("missing . on end of rule");
-        return new Rule(name, b);
-    }
-
-    protected Block readBlock(DataInputStream in) throws IOException {
-        int nalts = in.readShort();
-        List[] alts = new List[nalts];
-        //System.out.println("enter block n="+nalts);
-        for (int i=0; i<nalts; i++) {
-            List alt = readAlt(in);
-            alts[i] = alt;
-        }
-        //System.out.println("exit block");
-        return new Block(alts);
-    }
-
-    protected List readAlt(DataInputStream in) throws IOException {
-        List alt = new ArrayList();
-        byte A = in.readByte();
-        if ( A!='A' ) throw new IOException("missing A on start of alt");
-        byte cmd = in.readByte();
-        while ( cmd!=';' ) {
-            switch (cmd) {
-                case 't' :
-                    int ttype = in.readShort();
-                    alt.add(new TokenRef(ttype));
-                    //System.out.println("read token "+gr.getTokenDisplayName(ttype));
-                    break;
-                case 'r' :
-                    int ruleIndex = in.readShort();
-                    alt.add(new RuleRef(ruleIndex));
-                    //System.out.println("read rule "+gr.getRuleName(ruleIndex));
-                    break;
-                case '.' : // wildcard
-                    break;
-                case '-' : // range
-                    int from = in.readChar();
-                    int to = in.readChar();
-                    break;
-                case '~' : // not
-                    int notThisTokenType = in.readShort();
-                    break;
-                case 'B' : // nested block
-                    Block b = readBlock(in);
-                    alt.add(b);
-                    break;
-            }
-            cmd = in.readByte();
-        }
-        //System.out.println("exit alt");
-        return alt;
-    }
-
-    protected String readString(DataInputStream in) throws IOException {
-        byte c = in.readByte();
-        StringBuffer buf = new StringBuffer();
-        while ( c!=';' ) {
-            buf.append((char)c);
-            c = in.readByte();
-        }
-        return buf.toString();
-    }
-
-    public String toString() {
-        StringBuffer buf = new StringBuffer();
-        buf.append(type+" grammar "+name);
-        buf.append(rules);
-        return buf.toString();
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/Token.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/Token.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/Token.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/Token.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,91 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-public interface Token {
-	public static final int EOR_TOKEN_TYPE = 1;
-
-	/** imaginary tree navigation type; traverse "get child" link */
-	public static final int DOWN = 2;
-	/** imaginary tree navigation type; finish with a child list */
-	public static final int UP = 3;
-
-	public static final int MIN_TOKEN_TYPE = UP+1;
-
-    public static final int EOF = CharStream.EOF;
-	public static final Token EOF_TOKEN = new CommonToken(EOF);
-	
-	public static final int INVALID_TOKEN_TYPE = 0;
-	public static final Token INVALID_TOKEN = new CommonToken(INVALID_TOKEN_TYPE);
-
-	/** In an action, a lexer rule can set token to this SKIP_TOKEN and ANTLR
-	 *  will avoid creating a token for this symbol and try to fetch another.
-	 */
-	public static final Token SKIP_TOKEN = new CommonToken(INVALID_TOKEN_TYPE);
-
-	/** All tokens go to the parser (unless skip() is called in that rule)
-	 *  on a particular "channel".  The parser tunes to a particular channel
-	 *  so that whitespace etc... can go to the parser on a "hidden" channel.
-	 */
-	public static final int DEFAULT_CHANNEL = 0;
-	
-	/** Anything on different channel than DEFAULT_CHANNEL is not parsed
-	 *  by parser.
-	 */
-	public static final int HIDDEN_CHANNEL = 99;
-
-	/** Get the text of the token */
-	public String getText();
-	public void setText(String text);
-
-	public int getType();
-	public void setType(int ttype);
-	/**  The line number on which this token was matched; line=1..n */
-	public int getLine();
-    public void setLine(int line);
-
-	/** The index of the first character relative to the beginning of the line 0..n-1 */
-	public int getCharPositionInLine();
-	public void setCharPositionInLine(int pos);
-
-	public int getChannel();
-	public void setChannel(int channel);
-
-	/** An index from 0..n-1 of the token object in the input stream.
-	 *  This must be valid in order to use the ANTLRWorks debugger.
-	 */
-	public int getTokenIndex();
-	public void setTokenIndex(int index);
-
-	/** From what character stream was this token created?  You don't have to
-	 *  implement but it's nice to know where a Token comes from if you have
-	 *  include files etc... on the input.
-	 */
-	public CharStream getInputStream();
-	public void setInputStream(CharStream input);
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/TokenRewriteStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/TokenRewriteStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/TokenRewriteStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/TokenRewriteStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,566 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-import java.util.*;
-
-/** Useful for dumping out the input stream after doing some
- *  augmentation or other manipulations.
- *
- *  You can insert stuff, replace, and delete chunks.  Note that the
- *  operations are done lazily--only if you convert the buffer to a
- *  String.  This is very efficient because you are not moving data around
- *  all the time.  As the buffer of tokens is converted to strings, the
- *  toString() method(s) check to see if there is an operation at the
- *  current index.  If so, the operation is done and then normal String
- *  rendering continues on the buffer.  This is like having multiple Turing
- *  machine instruction streams (programs) operating on a single input tape. :)
- *
- *  Since the operations are done lazily at toString-time, operations do not
- *  screw up the token index values.  That is, an insert operation at token
- *  index i does not change the index values for tokens i+1..n-1.
- *
- *  Because operations never actually alter the buffer, you may always get
- *  the original token stream back without undoing anything.  Since
- *  the instructions are queued up, you can easily simulate transactions and
- *  roll back any changes if there is an error just by removing instructions.
- *  For example,
- *
- *   CharStream input = new ANTLRFileStream("input");
- *   TLexer lex = new TLexer(input);
- *   TokenRewriteStream tokens = new TokenRewriteStream(lex);
- *   T parser = new T(tokens);
- *   parser.startRule();
- *
- * 	 Then in the rules, you can execute
- *      Token t,u;
- *      ...
- *      input.insertAfter(t, "text to put after t");}
- * 		input.insertAfter(u, "text after u");}
- * 		System.out.println(tokens.toString());
- *
- *  Actually, you have to cast the 'input' to a TokenRewriteStream. :(
- *
- *  You can also have multiple "instruction streams" and get multiple
- *  rewrites from a single pass over the input.  Just name the instruction
- *  streams and use that name again when printing the buffer.  This could be
- *  useful for generating a C file and also its header file--all from the
- *  same buffer:
- *
- *      tokens.insertAfter("pass1", t, "text to put after t");}
- * 		tokens.insertAfter("pass2", u, "text after u");}
- * 		System.out.println(tokens.toString("pass1"));
- * 		System.out.println(tokens.toString("pass2"));
- *
- *  If you don't use named rewrite streams, a "default" stream is used as
- *  the first example shows.
- */
-public class TokenRewriteStream extends CommonTokenStream {
-	public static final String DEFAULT_PROGRAM_NAME = "default";
-    public static final int PROGRAM_INIT_SIZE = 100;
-	public static final int MIN_TOKEN_INDEX = 0;
-
-	// Define the rewrite operation hierarchy
-
-	class RewriteOperation {
-        /** What index into rewrites List are we? */
-        protected int instructionIndex;
-        /** Token buffer index. */
-        protected int index;
-		protected Object text;
-		protected RewriteOperation(int index, Object text) {
-			this.index = index;
-			this.text = text;
-		}
-		/** Execute the rewrite operation by possibly adding to the buffer.
-		 *  Return the index of the next token to operate on.
-		 */
-		public int execute(StringBuffer buf) {
-			return index;
-		}
-		public String toString() {
-			String opName = getClass().getName();
-			int $index = opName.indexOf('$');
-			opName = opName.substring($index+1, opName.length());
-			return "<"+opName+"@"+index+":\""+text+"\">";			
-		}
-	}
-
-	class InsertBeforeOp extends RewriteOperation {
-		public InsertBeforeOp(int index, Object text) {
-			super(index,text);
-		}
-		public int execute(StringBuffer buf) {
-			buf.append(text);
-			buf.append(((Token)tokens.get(index)).getText());			
-			return index+1;
-		}
-	}
-
-	/** I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
-	 *  instructions.
-	 */
-	class ReplaceOp extends RewriteOperation {
-		protected int lastIndex;
-		public ReplaceOp(int from, int to, Object text) {
-			super(from,text);
-			lastIndex = to;
-		}
-		public int execute(StringBuffer buf) {
-			if ( text!=null ) {
-				buf.append(text);
-			}
-			return lastIndex+1;
-		}
-		public String toString() {
-			return "<ReplaceOp@"+index+".."+lastIndex+":\""+text+"\">";
-		}
-	}
-
-	class DeleteOp extends ReplaceOp {
-		public DeleteOp(int from, int to) {
-			super(from, to, null);
-		}
-		public String toString() {
-			return "<DeleteOp@"+index+".."+lastIndex+">";
-		}
-	}
-
-	/** You may have multiple, named streams of rewrite operations.
-	 *  I'm calling these things "programs."
-	 *  Maps String (name) -> rewrite (List)
-	 */
-	protected Map programs = null;
-
-	/** Map String (program name) -> Integer index */
-	protected Map lastRewriteTokenIndexes = null;
-
-	public TokenRewriteStream() {
-		init();
-	}
-
-	protected void init() {
-		programs = new HashMap();
-		programs.put(DEFAULT_PROGRAM_NAME, new ArrayList(PROGRAM_INIT_SIZE));
-		lastRewriteTokenIndexes = new HashMap();
-	}
-
-	public TokenRewriteStream(TokenSource tokenSource) {
-	    super(tokenSource);
-		init();
-	}
-
-	public TokenRewriteStream(TokenSource tokenSource, int channel) {
-		super(tokenSource, channel);
-		init();
-	}
-
-	public void rollback(int instructionIndex) {
-		rollback(DEFAULT_PROGRAM_NAME, instructionIndex);
-	}
-
-	/** Rollback the instruction stream for a program so that
-	 *  the indicated instruction (via instructionIndex) is no
-	 *  longer in the stream.  UNTESTED!
-	 */
-	public void rollback(String programName, int instructionIndex) {
-		List is = (List)programs.get(programName);
-		if ( is!=null ) {
-			programs.put(programName, is.subList(MIN_TOKEN_INDEX,instructionIndex));
-		}
-	}
-
-	public void deleteProgram() {
-		deleteProgram(DEFAULT_PROGRAM_NAME);
-	}
-
-	/** Reset the program so that no instructions exist */
-	public void deleteProgram(String programName) {
-		rollback(programName, MIN_TOKEN_INDEX);
-	}
-
-	public void insertAfter(Token t, Object text) {
-		insertAfter(DEFAULT_PROGRAM_NAME, t, text);
-	}
-
-	public void insertAfter(int index, Object text) {
-		insertAfter(DEFAULT_PROGRAM_NAME, index, text);
-	}
-
-	public void insertAfter(String programName, Token t, Object text) {
-		insertAfter(programName,t.getTokenIndex(), text);
-	}
-
-	public void insertAfter(String programName, int index, Object text) {
-		// to insert after, just insert before next index (even if past end)
-		insertBefore(programName,index+1, text);
-		//addToSortedRewriteList(programName, new InsertAfterOp(index,text));
-	}
-
-	public void insertBefore(Token t, Object text) {
-		insertBefore(DEFAULT_PROGRAM_NAME, t, text);
-	}
-
-	public void insertBefore(int index, Object text) {
-		insertBefore(DEFAULT_PROGRAM_NAME, index, text);
-	}
-
-	public void insertBefore(String programName, Token t, Object text) {
-		insertBefore(programName, t.getTokenIndex(), text);
-	}
-
-	public void insertBefore(String programName, int index, Object text) {
-		//addToSortedRewriteList(programName, new InsertBeforeOp(index,text));
-		RewriteOperation op = new InsertBeforeOp(index,text);
-		List rewrites = getProgram(programName);
-        op.instructionIndex = rewrites.size();
-        rewrites.add(op);		
-	}
-
-	public void replace(int index, Object text) {
-		replace(DEFAULT_PROGRAM_NAME, index, index, text);
-	}
-
-	public void replace(int from, int to, Object text) {
-		replace(DEFAULT_PROGRAM_NAME, from, to, text);
-	}
-
-	public void replace(Token indexT, Object text) {
-		replace(DEFAULT_PROGRAM_NAME, indexT, indexT, text);
-	}
-
-	public void replace(Token from, Token to, Object text) {
-		replace(DEFAULT_PROGRAM_NAME, from, to, text);
-	}
-
-	public void replace(String programName, int from, int to, Object text) {
-		if ( from > to || from<0 || to<0 || to >= tokens.size() ) {
-			throw new IllegalArgumentException("replace: range invalid: "+from+".."+to+"(size="+tokens.size()+")");
-		}
-		RewriteOperation op = new ReplaceOp(from, to, text);
-		List rewrites = getProgram(programName);
-        op.instructionIndex = rewrites.size();
-        rewrites.add(op);
-	}
-
-	public void replace(String programName, Token from, Token to, Object text) {
-		replace(programName,
-				from.getTokenIndex(),
-				to.getTokenIndex(),
-				text);
-	}
-
-	public void delete(int index) {
-		delete(DEFAULT_PROGRAM_NAME, index, index);
-	}
-
-	public void delete(int from, int to) {
-		delete(DEFAULT_PROGRAM_NAME, from, to);
-	}
-
-	public void delete(Token indexT) {
-		delete(DEFAULT_PROGRAM_NAME, indexT, indexT);
-	}
-
-	public void delete(Token from, Token to) {
-		delete(DEFAULT_PROGRAM_NAME, from, to);
-	}
-
-	public void delete(String programName, int from, int to) {
-		replace(programName,from,to,null);
-	}
-
-	public void delete(String programName, Token from, Token to) {
-		replace(programName,from,to,null);
-	}
-
-	public int getLastRewriteTokenIndex() {
-		return getLastRewriteTokenIndex(DEFAULT_PROGRAM_NAME);
-	}
-
-	protected int getLastRewriteTokenIndex(String programName) {
-		Integer I = (Integer)lastRewriteTokenIndexes.get(programName);
-		if ( I==null ) {
-			return -1;
-		}
-		return I.intValue();
-	}
-
-	protected void setLastRewriteTokenIndex(String programName, int i) {
-		lastRewriteTokenIndexes.put(programName, new Integer(i));
-	}
-
-	protected List getProgram(String name) {
-		List is = (List)programs.get(name);
-		if ( is==null ) {
-			is = initializeProgram(name);
-		}
-		return is;
-	}
-
-	private List initializeProgram(String name) {
-		List is = new ArrayList(PROGRAM_INIT_SIZE);
-		programs.put(name, is);
-		return is;
-	}
-
-	public String toOriginalString() {
-		return toOriginalString(MIN_TOKEN_INDEX, size()-1);
-	}
-
-	public String toOriginalString(int start, int end) {
-		StringBuffer buf = new StringBuffer();
-		for (int i=start; i>=MIN_TOKEN_INDEX && i<=end && i<tokens.size(); i++) {
-			buf.append(get(i).getText());
-		}
-		return buf.toString();
-	}
-
-	public String toString() {
-		return toString(MIN_TOKEN_INDEX, size()-1);
-	}
-
-	public String toString(String programName) {
-		return toString(programName, MIN_TOKEN_INDEX, size()-1);
-	}
-
-	public String toString(int start, int end) {
-		return toString(DEFAULT_PROGRAM_NAME, start, end);
-	}
-
-	public String toString(String programName, int start, int end) {
-		List rewrites = (List)programs.get(programName);
-
-        // ensure start/end are in range
-        if ( end>tokens.size()-1 ) end = tokens.size()-1;
-        if ( start<0 ) start = 0;
-
-        if ( rewrites==null || rewrites.size()==0 ) {
-			return toOriginalString(start,end); // no instructions to execute
-		}
-		StringBuffer buf = new StringBuffer();
-
-		// First, optimize instruction stream
-		Map indexToOp = reduceToSingleOperationPerIndex(rewrites);
-
-        // Walk buffer, executing instructions and emitting tokens
-        int i = start;
-        while ( i <= end && i < tokens.size() ) {
-			RewriteOperation op = (RewriteOperation)indexToOp.get(new Integer(i));
-			indexToOp.remove(new Integer(i)); // remove so any left have index size-1
-			Token t = (Token) tokens.get(i);
-			if ( op==null ) {
-				// no operation at that index, just dump token
-				buf.append(t.getText());
-				i++; // move to next token
-			}
-			else {
-				i = op.execute(buf); // execute operation and skip
-			}
-		}
-
-        // include stuff after end if it's last index in buffer
-        // So, if they did an insertAfter(lastValidIndex, "foo"), include
-        // foo if end==lastValidIndex.
-        if ( end==tokens.size()-1 ) {
-            // Scan any remaining operations after last token
-            // should be included (they will be inserts).
-            Iterator it = indexToOp.values().iterator();
-            while (it.hasNext()) {
-                RewriteOperation op = (RewriteOperation)it.next();
-                if ( op.index >= tokens.size()-1 ) buf.append(op.text);
-            }
-        }
-        return buf.toString();
-	}
-
-	/** We need to combine operations and report invalid operations (like
-	 *  overlapping replaces that are not completed nested).  Inserts to
-	 *  same index need to be combined etc...   Here are the cases:
-	 *
-	 *  I.i.u I.j.v								leave alone, nonoverlapping
-	 *  I.i.u I.i.v								combine: Iivu
-	 *
-	 *  R.i-j.u R.x-y.v	| i-j in x-y			delete first R
-	 *  R.i-j.u R.i-j.v							delete first R
-	 *  R.i-j.u R.x-y.v	| x-y in i-j			ERROR
-	 *  R.i-j.u R.x-y.v	| boundaries overlap	ERROR
-	 *
-	 *  I.i.u R.x-y.v | i in x-y				delete I
-	 *  I.i.u R.x-y.v | i not in x-y			leave alone, nonoverlapping
-	 *  R.x-y.v I.i.u | i in x-y				ERROR
-	 *  R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
-	 *  R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
-	 *
-	 *  I.i.u = insert u before op @ index i
-	 *  R.x-y.u = replace x-y indexed tokens with u
-	 *
-	 *  First we need to examine replaces.  For any replace op:
-	 *
-	 * 		1. wipe out any insertions before op within that range.
-	 *		2. Drop any replace op before that is contained completely within
-	 *         that range.
-	 *		3. Throw exception upon boundary overlap with any previous replace.
-	 *
-	 *  Then we can deal with inserts:
-	 *
-	 * 		1. for any inserts to same index, combine even if not adjacent.
-	 * 		2. for any prior replace with same left boundary, combine this
-	 *         insert with replace and delete this replace.
-	 * 		3. throw exception if index in same range as previous replace
-	 *
-	 *  Don't actually delete; make op null in list. Easier to walk list.
-	 *  Later we can throw as we add to index -> op map.
-	 *
-	 *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
-	 *  inserted stuff would be before the replace range.  But, if you
-	 *  add tokens in front of a method body '{' and then delete the method
-	 *  body, I think the stuff before the '{' you added should disappear too.
-	 *
-	 *  Return a map from token index to operation.
-	 */
-	protected Map reduceToSingleOperationPerIndex(List rewrites) {
-		//System.out.println("rewrites="+rewrites);
-
-		// WALK REPLACES
-		for (int i = 0; i < rewrites.size(); i++) {
-			RewriteOperation op = (RewriteOperation)rewrites.get(i);
-			if ( op==null ) continue;
-			if ( !(op instanceof ReplaceOp) ) continue;
-			ReplaceOp rop = (ReplaceOp)rewrites.get(i);
-			// Wipe prior inserts within range
-			List inserts = getKindOfOps(rewrites, InsertBeforeOp.class, i);
-			for (int j = 0; j < inserts.size(); j++) {
-				InsertBeforeOp iop = (InsertBeforeOp) inserts.get(j);
-				if ( iop.index >= rop.index && iop.index <= rop.lastIndex ) {
-                    // delete insert as it's a no-op.
-                    rewrites.set(iop.instructionIndex, null);
-				}
-			}
-			// Drop any prior replaces contained within
-			List prevReplaces = getKindOfOps(rewrites, ReplaceOp.class, i);
-			for (int j = 0; j < prevReplaces.size(); j++) {
-				ReplaceOp prevRop = (ReplaceOp) prevReplaces.get(j);
-				if ( prevRop.index>=rop.index && prevRop.lastIndex <= rop.lastIndex ) {
-                    // delete replace as it's a no-op.
-                    rewrites.set(prevRop.instructionIndex, null);
-					continue;
-				}
-				// throw exception unless disjoint or identical
-				boolean disjoint =
-					prevRop.lastIndex<rop.index || prevRop.index > rop.lastIndex;
-				boolean same =
-					prevRop.index==rop.index && prevRop.lastIndex==rop.lastIndex;
-				if ( !disjoint && !same ) {
-					throw new IllegalArgumentException("replace op boundaries of "+rop+
-													   " overlap with previous "+prevRop);
-				}
-			}
-		}
-
-		// WALK INSERTS
-		for (int i = 0; i < rewrites.size(); i++) {
-			RewriteOperation op = (RewriteOperation)rewrites.get(i);
-			if ( op==null ) continue;
-			if ( !(op instanceof InsertBeforeOp) ) continue;
-			InsertBeforeOp iop = (InsertBeforeOp)rewrites.get(i);
-			// combine current insert with prior if any at same index
-			List prevInserts = getKindOfOps(rewrites, InsertBeforeOp.class, i);
-			for (int j = 0; j < prevInserts.size(); j++) {
-				InsertBeforeOp prevIop = (InsertBeforeOp) prevInserts.get(j);
-				if ( prevIop.index == iop.index ) { // combine objects
-					// convert to strings...we're in process of toString'ing
-					// whole token buffer so no lazy eval issue with any templates
-					iop.text = catOpText(iop.text,prevIop.text);
-                    // delete redundant prior insert
-                    rewrites.set(prevIop.instructionIndex, null);
-				}
-			}
-			// look for replaces where iop.index is in range; error
-			List prevReplaces = getKindOfOps(rewrites, ReplaceOp.class, i);
-			for (int j = 0; j < prevReplaces.size(); j++) {
-				ReplaceOp rop = (ReplaceOp) prevReplaces.get(j);
-				if ( iop.index == rop.index ) {
-					rop.text = catOpText(iop.text,rop.text);
-					rewrites.set(i, null);  // delete current insert
-					continue;
-				}
-				if ( iop.index >= rop.index && iop.index <= rop.lastIndex ) {
-					throw new IllegalArgumentException("insert op "+iop+
-													   " within boundaries of previous "+rop);
-				}
-			}
-		}
-		// System.out.println("rewrites after="+rewrites);
-		Map m = new HashMap();
-		for (int i = 0; i < rewrites.size(); i++) {
-			RewriteOperation op = (RewriteOperation)rewrites.get(i);
-			if ( op==null ) continue; // ignore deleted ops
-			if ( m.get(new Integer(op.index))!=null ) {
-				throw new Error("should only be one op per index");
-			}
-			m.put(new Integer(op.index), op);
-		}
-		//System.out.println("index to op: "+m);
-		return m;
-	}
-
-	protected String catOpText(Object a, Object b) {
-		String x = "";
-		String y = "";
-		if ( a!=null ) x = a.toString();
-		if ( b!=null ) y = b.toString();
-		return x+y;
-	}
-	protected List getKindOfOps(List rewrites, Class kind) {
-		return getKindOfOps(rewrites, kind, rewrites.size());
-	}
-
-    /** Get all operations before an index of a particular kind */
-    protected List getKindOfOps(List rewrites, Class kind, int before) {
-		List ops = new ArrayList();
-		for (int i=0; i<before && i<rewrites.size(); i++) {
-			RewriteOperation op = (RewriteOperation)rewrites.get(i);
-			if ( op==null ) continue; // ignore deleted
-			if ( op.getClass() == kind ) ops.add(op);
-		}		
-		return ops;
-	}
-
-	public String toDebugString() {
-		return toDebugString(MIN_TOKEN_INDEX, size()-1);
-	}
-
-	public String toDebugString(int start, int end) {
-		StringBuffer buf = new StringBuffer();
-		for (int i=start; i>=MIN_TOKEN_INDEX && i<=end && i<tokens.size(); i++) {
-			buf.append(get(i));
-		}
-		return buf.toString();
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/TokenSource.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/TokenSource.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/TokenSource.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/TokenSource.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,54 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-/** A source of tokens must provide a sequence of tokens via nextToken()
- *  and also must reveal it's source of characters; CommonToken's text is
- *  computed from a CharStream; it only store indices into the char stream.
- *
- *  Errors from the lexer are never passed to the parser.  Either you want
- *  to keep going or you do not upon token recognition error.  If you do not
- *  want to continue lexing then you do not want to continue parsing.  Just
- *  throw an exception not under RecognitionException and Java will naturally
- *  toss you all the way out of the recognizers.  If you want to continue
- *  lexing then you should not throw an exception to the parser--it has already
- *  requested a token.  Keep lexing until you get a valid one.  Just report
- *  errors and keep going, looking for a valid token.
- */
-public interface TokenSource {
-	/** Return a Token object from your input stream (usually a CharStream).
-	 *  Do not fail/return upon lexing error; keep chewing on the characters
-	 *  until you get a good one; errors are not passed through to the parser.
-	 */
-	public Token nextToken();
-
-	/** Where are you getting tokens from? normally the implication will simply
-	 *  ask lexers input stream.
-	 */
-	public String getSourceName();
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/TokenStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/TokenStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/TokenStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/TokenStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,68 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-/** A stream of tokens accessing tokens from a TokenSource */
-public interface TokenStream extends IntStream {
-    /** Get Token at current input pointer + i ahead where i=1 is next Token.
-	 *  i<0 indicates tokens in the past.  So -1 is previous token and -2 is
-	 *  two tokens ago. LT(0) is undefined.  For i>=n, return Token.EOFToken.
-	 *  Return null for LT(0) and any index that results in an absolute address
-	 *  that is negative.
-	 */
-    public Token LT(int k);
-
-	/** Get a token at an absolute index i; 0..n-1.  This is really only
-	 *  needed for profiling and debugging and token stream rewriting.
-	 *  If you don't want to buffer up tokens, then this method makes no
-	 *  sense for you.  Naturally you can't use the rewrite stream feature.
-	 *  I believe DebugTokenStream can easily be altered to not use
-	 *  this method, removing the dependency.
-	 */
-	public Token get(int i);
-
-	/** Where is this stream pulling tokens from?  This is not the name, but
-	 *  the object that provides Token objects.
-	 */
-	public TokenSource getTokenSource();
-
-	/** Return the text of all tokens from start to stop, inclusive.
-	 *  If the stream does not buffer all the tokens then it can just
-	 *  return "" or null;  Users should not access $ruleLabel.text in
-	 *  an action of course in that case.
-	 */
-	public String toString(int start, int stop);
-
-	/** Because the user is not required to use a token with an index stored
-	 *  in it, we must provide a means for two token objects themselves to
-	 *  indicate the start/end location.  Most often this will just delegate
-	 *  to the other toString(int,int).  This is also parallel with
-	 *  the TreeNodeStream.toString(Object,Object).
-	 */
-	public String toString(Token start, Token stop);
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/BaseTreeAdaptor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/BaseTreeAdaptor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/BaseTreeAdaptor.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/BaseTreeAdaptor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,278 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.TokenStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognitionException;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/** A TreeAdaptor that works with any Tree implementation. */
-public abstract class BaseTreeAdaptor implements TreeAdaptor {
-	/** System.identityHashCode() is not always unique; we have to
-	 *  track ourselves.  That's ok, it's only for debugging, though it's
-	 *  expensive: we have to create a hashtable with all tree nodes in it.
-	 */
-	protected Map treeToUniqueIDMap;
-	protected int uniqueNodeID = 1;
-
-	public Object nil() {
-		return create(null);
-	}
-
-	/** create tree node that holds the start and stop tokens associated
-	 *  with an error.
-	 *
-	 *  If you specify your own kind of tree nodes, you will likely have to
-	 *  override this method. CommonTree returns Token.INVALID_TOKEN_TYPE
-	 *  if no token payload but you might have to set token type for diff
-	 *  node type.
-     *
-     *  You don't have to subclass CommonErrorNode; you will likely need to
-     *  subclass your own tree node class to avoid class cast exception.
-	 */
-	public Object errorNode(TokenStream input, Token start, Token stop,
-							RecognitionException e)
-	{
-		CommonErrorNode t = new CommonErrorNode(input, start, stop, e);
-		//System.out.println("returning error node '"+t+"' @index="+input.index());
-		return t;
-	}
-
-	public boolean isNil(Object tree) {
-		return ((Tree)tree).isNil();
-	}
-
-	public Object dupTree(Object tree) {
-		return dupTree(tree, null);
-	}
-
-	/** This is generic in the sense that it will work with any kind of
-	 *  tree (not just Tree interface).  It invokes the adaptor routines
-	 *  not the tree node routines to do the construction.  
-	 */
-	public Object dupTree(Object t, Object parent) {
-		if ( t==null ) {
-			return null;
-		}
-		Object newTree = dupNode(t);
-		// ensure new subtree root has parent/child index set
-		setChildIndex(newTree, getChildIndex(t)); // same index in new tree
-		setParent(newTree, parent);
-		int n = getChildCount(t);
-		for (int i = 0; i < n; i++) {
-			Object child = getChild(t, i);
-			Object newSubTree = dupTree(child, t);
-			addChild(newTree, newSubTree);
-		}
-		return newTree;
-	}
-
-	/** Add a child to the tree t.  If child is a flat tree (a list), make all
-	 *  in list children of t.  Warning: if t has no children, but child does
-	 *  and child isNil then you can decide it is ok to move children to t via
-	 *  t.children = child.children; i.e., without copying the array.  Just
-	 *  make sure that this is consistent with have the user will build
-	 *  ASTs.
-	 */
-	public void addChild(Object t, Object child) {
-		if ( t!=null && child!=null ) {
-			((Tree)t).addChild((Tree)child);
-		}
-	}
-
-	/** If oldRoot is a nil root, just copy or move the children to newRoot.
-	 *  If not a nil root, make oldRoot a child of newRoot.
-	 *
-	 *    old=^(nil a b c), new=r yields ^(r a b c)
-	 *    old=^(a b c), new=r yields ^(r ^(a b c))
-	 *
-	 *  If newRoot is a nil-rooted single child tree, use the single
-	 *  child as the new root node.
-	 *
-	 *    old=^(nil a b c), new=^(nil r) yields ^(r a b c)
-	 *    old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
-	 *
-	 *  If oldRoot was null, it's ok, just return newRoot (even if isNil).
-	 *
-	 *    old=null, new=r yields r
-	 *    old=null, new=^(nil r) yields ^(nil r)
-	 *
-	 *  Return newRoot.  Throw an exception if newRoot is not a
-	 *  simple node or nil root with a single child node--it must be a root
-	 *  node.  If newRoot is ^(nil x) return x as newRoot.
-	 *
-	 *  Be advised that it's ok for newRoot to point at oldRoot's
-	 *  children; i.e., you don't have to copy the list.  We are
-	 *  constructing these nodes so we should have this control for
-	 *  efficiency.
-	 */
-	public Object becomeRoot(Object newRoot, Object oldRoot) {
-        //System.out.println("becomeroot new "+newRoot.toString()+" old "+oldRoot);
-        Tree newRootTree = (Tree)newRoot;
-		Tree oldRootTree = (Tree)oldRoot;
-		if ( oldRoot==null ) {
-			return newRoot;
-		}
-		// handle ^(nil real-node)
-		if ( newRootTree.isNil() ) {
-            int nc = newRootTree.getChildCount();
-            if ( nc==1 ) newRootTree = (Tree)newRootTree.getChild(0);
-            else if ( nc >1 ) {
-				// TODO: make tree run time exceptions hierarchy
-				throw new RuntimeException("more than one node as root (TODO: make exception hierarchy)");
-			}
-        }
-		// add oldRoot to newRoot; addChild takes care of case where oldRoot
-		// is a flat list (i.e., nil-rooted tree).  All children of oldRoot
-		// are added to newRoot.
-		newRootTree.addChild(oldRootTree);
-		return newRootTree;
-	}
-
-	/** Transform ^(nil x) to x and nil to null */
-	public Object rulePostProcessing(Object root) {
-		//System.out.println("rulePostProcessing: "+((Tree)root).toStringTree());
-		Tree r = (Tree)root;
-		if ( r!=null && r.isNil() ) {
-			if ( r.getChildCount()==0 ) {
-				r = null;
-			}
-			else if ( r.getChildCount()==1 ) {
-				r = (Tree)r.getChild(0);
-				// whoever invokes rule will set parent and child index
-				r.setParent(null);
-				r.setChildIndex(-1);
-			}
-		}
-		return r;
-	}
-
-	public Object becomeRoot(Token newRoot, Object oldRoot) {
-		return becomeRoot(create(newRoot), oldRoot);
-	}
-
-	public Object create(int tokenType, Token fromToken) {
-		fromToken = createToken(fromToken);
-		//((ClassicToken)fromToken).setType(tokenType);
-		fromToken.setType(tokenType);
-		Tree t = (Tree)create(fromToken);
-		return t;
-	}
-
-	public Object create(int tokenType, Token fromToken, String text) {
-		fromToken = createToken(fromToken);
-		fromToken.setType(tokenType);
-		fromToken.setText(text);
-		Tree t = (Tree)create(fromToken);
-		return t;
-	}
-
-	public Object create(int tokenType, String text) {
-		Token fromToken = createToken(tokenType, text);
-		Tree t = (Tree)create(fromToken);
-		return t;
-	}
-
-	public int getType(Object t) {
-		return ((Tree)t).getType();
-	}
-
-	public void setType(Object t, int type) {
-		throw new NoSuchMethodError("don't know enough about Tree node");
-	}
-
-	public String getText(Object t) {
-		return ((Tree)t).getText();
-	}
-
-	public void setText(Object t, String text) {
-		throw new NoSuchMethodError("don't know enough about Tree node");
-	}
-
-	public Object getChild(Object t, int i) {
-		return ((Tree)t).getChild(i);
-	}
-
-	public void setChild(Object t, int i, Object child) {
-		((Tree)t).setChild(i, (Tree)child);
-	}
-
-	public Object deleteChild(Object t, int i) {
-		return ((Tree)t).deleteChild(i);
-	}
-
-	public int getChildCount(Object t) {
-		return ((Tree)t).getChildCount();
-	}
-
-	public int getUniqueID(Object node) {
-		if ( treeToUniqueIDMap==null ) {
-			 treeToUniqueIDMap = new HashMap();
-		}
-		Integer prevID = (Integer)treeToUniqueIDMap.get(node);
-		if ( prevID!=null ) {
-			return prevID.intValue();
-		}
-		int ID = uniqueNodeID;
-		treeToUniqueIDMap.put(node, new Integer(ID));
-		uniqueNodeID++;
-		return ID;
-		// GC makes these nonunique:
-		// return System.identityHashCode(node);
-	}
-
-	/** Tell me how to create a token for use with imaginary token nodes.
-	 *  For example, there is probably no input symbol associated with imaginary
-	 *  token DECL, but you need to create it as a payload or whatever for
-	 *  the DECL node as in ^(DECL type ID).
-	 *
-	 *  If you care what the token payload objects' type is, you should
-	 *  override this method and any other createToken variant.
-	 */
-	public abstract Token createToken(int tokenType, String text);
-
-	/** Tell me how to create a token for use with imaginary token nodes.
-	 *  For example, there is probably no input symbol associated with imaginary
-	 *  token DECL, but you need to create it as a payload or whatever for
-	 *  the DECL node as in ^(DECL type ID).
-	 *
-	 *  This is a variant of createToken where the new token is derived from
-	 *  an actual real input token.  Typically this is for converting '{'
-	 *  tokens to BLOCK etc...  You'll see
-	 *
-	 *    r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
-	 *
-	 *  If you care what the token payload objects' type is, you should
-	 *  override this method and any other createToken variant.
-	 */
-	public abstract Token createToken(Token fromToken);
-}
-
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/BaseTree.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/BaseTree.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/BaseTree.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/BaseTree.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,349 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/** A generic tree implementation with no payload.  You must subclass to
- *  actually have any user data.  ANTLR v3 uses a list of children approach
- *  instead of the child-sibling approach in v2.  A flat tree (a list) is
- *  an empty node whose children represent the list.  An empty, but
- *  non-null node is called "nil".
- */
-public abstract class BaseTree implements Tree {
-	protected List children;
-
-	public BaseTree() {
-	}
-
-	/** Create a new node from an existing node does nothing for BaseTree
-	 *  as there are no fields other than the children list, which cannot
-	 *  be copied as the children are not considered part of this node. 
-	 */
-	public BaseTree(Tree node) {
-	}
-
-	public Tree getChild(int i) {
-		if ( children==null || i>=children.size() ) {
-			return null;
-		}
-		return (Tree)children.get(i);
-	}
-
-	/** Get the children internal List; note that if you directly mess with
-	 *  the list, do so at your own risk.
-	 */
-	public List getChildren() {
-		return children;
-	}
-
-	public Tree getFirstChildWithType(int type) {
-		for (int i = 0; children!=null && i < children.size(); i++) {
-			Tree t = (Tree) children.get(i);
-			if ( t.getType()==type ) {
-				return t;
-			}
-		}	
-		return null;
-	}
-
-	public int getChildCount() {
-		if ( children==null ) {
-			return 0;
-		}
-		return children.size();
-	}
-
-	/** Add t as child of this node.
-	 *
-	 *  Warning: if t has no children, but child does
-	 *  and child isNil then this routine moves children to t via
-	 *  t.children = child.children; i.e., without copying the array.
-	 */
-	public void addChild(Tree t) {
-		//System.out.println("add child "+t.toStringTree()+" "+this.toStringTree());
-		//System.out.println("existing children: "+children);
-		if ( t==null ) {
-			return; // do nothing upon addChild(null)
-		}
-		BaseTree childTree = (BaseTree)t;
-		if ( childTree.isNil() ) { // t is an empty node possibly with children
-			if ( this.children!=null && this.children == childTree.children ) {
-				throw new RuntimeException("attempt to add child list to itself");
-			}
-			// just add all of childTree's children to this
-			if ( childTree.children!=null ) {
-				if ( this.children!=null ) { // must copy, this has children already
-					int n = childTree.children.size();
-					for (int i = 0; i < n; i++) {
-						Tree c = (Tree)childTree.children.get(i);
-						this.children.add(c);
-						// handle double-link stuff for each child of nil root
-						c.setParent(this);
-						c.setChildIndex(children.size()-1);
-					}
-				}
-				else {
-					// no children for this but t has children; just set pointer
-					// call general freshener routine
-					this.children = childTree.children;
-					this.freshenParentAndChildIndexes();
-				}
-			}
-		}
-		else { // child is not nil (don't care about children)
-			if ( children==null ) {
-				children = createChildrenList(); // create children list on demand
-			}
-			children.add(t);
-			childTree.setParent(this);
-			childTree.setChildIndex(children.size()-1);
-		}
-		// System.out.println("now children are: "+children);
-	}
-
-	/** Add all elements of kids list as children of this node */
-	public void addChildren(List kids) {
-		for (int i = 0; i < kids.size(); i++) {
-			Tree t = (Tree) kids.get(i);
-			addChild(t);
-		}
-	}
-
-	public void setChild(int i, Tree t) {
-		if ( t==null ) {
-			return;
-		}
-		if ( t.isNil() ) {
-			throw new IllegalArgumentException("Can't set single child to a list");
-		}
-		if ( children==null ) {
-			children = createChildrenList();
-		}
-		children.set(i, t);
-		t.setParent(this);
-		t.setChildIndex(i);
-	}
-	
-	public Object deleteChild(int i) {
-		if ( children==null ) {
-			return null;
-		}
-		Tree killed = (Tree)children.remove(i);
-		// walk rest and decrement their child indexes
-		this.freshenParentAndChildIndexes(i);
-		return killed;
-	}
-
-	/** Delete children from start to stop and replace with t even if t is
-	 *  a list (nil-root tree).  num of children can increase or decrease.
-	 *  For huge child lists, inserting children can force walking rest of
-	 *  children to set their childindex; could be slow.
-	 */
-	public void replaceChildren(int startChildIndex, int stopChildIndex, Object t) {
-		/*
-		System.out.println("replaceChildren "+startChildIndex+", "+stopChildIndex+
-						   " with "+((BaseTree)t).toStringTree());
-		System.out.println("in="+toStringTree());
-		*/
-		if ( children==null ) {
-			throw new IllegalArgumentException("indexes invalid; no children in list");
-		}
-		int replacingHowMany = stopChildIndex - startChildIndex + 1;
-		int replacingWithHowMany;
-		BaseTree newTree = (BaseTree)t;
-		List newChildren = null;
-		// normalize to a list of children to add: newChildren
-		if ( newTree.isNil() ) {
-			newChildren = newTree.children;
-		}
-		else {
-			newChildren = new ArrayList(1);
-			newChildren.add(newTree);
-		}
-		replacingWithHowMany = newChildren.size();
-		int numNewChildren = newChildren.size();
-		int delta = replacingHowMany - replacingWithHowMany;
-		// if same number of nodes, do direct replace
-		if ( delta == 0 ) {
-			int j = 0; // index into new children
-			for (int i=startChildIndex; i<=stopChildIndex; i++) {
-				BaseTree child = (BaseTree)newChildren.get(j);
-				children.set(i, child);
-				child.setParent(this);
-				child.setChildIndex(i);
-                j++;
-            }
-		}
-		else if ( delta > 0 ) { // fewer new nodes than there were
-			// set children and then delete extra
-			for (int j=0; j<numNewChildren; j++) {
-				children.set(startChildIndex+j, newChildren.get(j));
-			}
-			int indexToDelete = startChildIndex+numNewChildren;
-			for (int c=indexToDelete; c<=stopChildIndex; c++) {
-				// delete same index, shifting everybody down each time
-				children.remove(indexToDelete);
-			}
-			freshenParentAndChildIndexes(startChildIndex);
-		}
-		else { // more new nodes than were there before
-			// fill in as many children as we can (replacingHowMany) w/o moving data
-			for (int j=0; j<replacingHowMany; j++) {
-				children.set(startChildIndex+j, newChildren.get(j));
-			}
-			int numToInsert = replacingWithHowMany-replacingHowMany;
-			for (int j=replacingHowMany; j<replacingWithHowMany; j++) {
-				children.add(startChildIndex+j, newChildren.get(j));
-			}
-			freshenParentAndChildIndexes(startChildIndex);
-		}
-		//System.out.println("out="+toStringTree());
-	}
-
-	/** Override in a subclass to change the impl of children list */
-	protected List createChildrenList() {
-		return new ArrayList();
-	}
-
-	public boolean isNil() {
-		return false;
-	}
-
-	/** Set the parent and child index values for all child of t */
-	public void freshenParentAndChildIndexes() {
-		freshenParentAndChildIndexes(0);
-	}
-
-	public void freshenParentAndChildIndexes(int offset) {
-		int n = getChildCount();
-		for (int c = offset; c < n; c++) {
-			Tree child = (Tree)getChild(c);
-			child.setChildIndex(c);
-			child.setParent(this);
-		}
-	}
-
-	public void sanityCheckParentAndChildIndexes() {
-		sanityCheckParentAndChildIndexes(null, -1);
-	}
-
-	public void sanityCheckParentAndChildIndexes(Tree parent, int i) {
-		if ( parent!=this.getParent() ) {
-			throw new IllegalStateException("parents don't match; expected "+parent+" found "+this.getParent());
-		}
-		if ( i!=this.getChildIndex() ) {
-			throw new IllegalStateException("child indexes don't match; expected "+i+" found "+this.getChildIndex());
-		}
-		int n = this.getChildCount();
-		for (int c = 0; c < n; c++) {
-			CommonTree child = (CommonTree)this.getChild(c);
-			child.sanityCheckParentAndChildIndexes(this, c);
-		}
-	}
-
-	/** BaseTree doesn't track child indexes. */
-	public int getChildIndex() {
-		return 0;
-	}
-	public void setChildIndex(int index) {
-	}
-
-	/** BaseTree doesn't track parent pointers. */
-	public Tree getParent() {
-		return null;
-	}
-
-    public void setParent(Tree t) {
-	}
-
-    /** Walk upwards looking for ancestor with this token type. */
-    public boolean hasAncestor(int ttype) { return getAncestor(ttype)!=null; }
-
-    /** Walk upwards and get first ancestor with this token type. */
-    public Tree getAncestor(int ttype) {
-        Tree t = this;
-        t = t.getParent();
-        while ( t!=null ) {
-            if ( t.getType()==ttype ) return t;
-            t = t.getParent();
-        }
-        return null;
-    }
-
-    /** Return a list of all ancestors of this node.  The first node of
-     *  list is the root and the last is the parent of this node.
-     */
-    public List getAncestors() {
-        if ( getParent()==null ) return null;
-        List ancestors = new ArrayList();
-        Tree t = this;
-        t = t.getParent();
-        while ( t!=null ) {
-            ancestors.add(0, t); // insert at start
-            t = t.getParent();
-        }
-        return ancestors;
-    }
-
-    /** Print out a whole tree not just a node */
-    public String toStringTree() {
-		if ( children==null || children.size()==0 ) {
-			return this.toString();
-		}
-		StringBuffer buf = new StringBuffer();
-		if ( !isNil() ) {
-			buf.append("(");
-			buf.append(this.toString());
-			buf.append(' ');
-		}
-		for (int i = 0; children!=null && i < children.size(); i++) {
-			Tree t = (Tree)children.get(i);
-			if ( i>0 ) {
-				buf.append(' ');
-			}
-			buf.append(t.toStringTree());
-		}
-		if ( !isNil() ) {
-			buf.append(")");
-		}
-		return buf.toString();
-	}
-
-    public int getLine() {
-		return 0;
-	}
-
-	public int getCharPositionInLine() {
-		return 0;
-	}
-
-	/** Override to say how a node (not a tree) should look as text */
-	public abstract String toString();
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/BufferedTreeNodeStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/BufferedTreeNodeStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/BufferedTreeNodeStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/BufferedTreeNodeStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,478 +0,0 @@
-/*
-[The "BSD licence"]
-Copyright (c) 2005-2008 Terence Parr
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-3. The name of the author may not be used to endorse or promote products
-derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.TokenStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.misc.IntArray;
-import java.util.*;
-
-/** A buffered stream of tree nodes.  Nodes can be from a tree of ANY kind.
- *
- *  This node stream sucks all nodes out of the tree specified in
- *  the constructor during construction and makes pointers into
- *  the tree using an array of Object pointers. The stream necessarily
- *  includes pointers to DOWN and UP and EOF nodes.
- *
- *  This stream knows how to mark/release for backtracking.
- *
- *  This stream is most suitable for tree interpreters that need to
- *  jump around a lot or for tree parsers requiring speed (at cost of memory).
- *  There is some duplicated functionality here with UnBufferedTreeNodeStream
- *  but just in bookkeeping, not tree walking etc...
- *
- *  TARGET DEVELOPERS:
- *
- *  This is the old CommonTreeNodeStream that buffered up entire node stream.
- *  No need to implement really as new CommonTreeNodeStream is much better
- *  and covers what we need.
- *
- *  @see CommonTreeNodeStream
- */
-public class BufferedTreeNodeStream implements TreeNodeStream {
-	public static final int DEFAULT_INITIAL_BUFFER_SIZE = 100;
-	public static final int INITIAL_CALL_STACK_SIZE = 10;
-
-    protected class StreamIterator implements Iterator {
-		int i = 0;
-		public boolean hasNext() {
-			return i<nodes.size();
-		}
-
-		public Object next() {
-			int current = i;
-			i++;
-			if ( current < nodes.size() ) {
-				return nodes.get(current);
-			}
-			return eof;
-		}
-
-		public void remove() {
-			throw new RuntimeException("cannot remove nodes from stream");
-		}
-	}
-
-	// all these navigation nodes are shared and hence they
-	// cannot contain any line/column info
-
-	protected Object down;
-	protected Object up;
-	protected Object eof;
-
-	/** The complete mapping from stream index to tree node.
-	 *  This buffer includes pointers to DOWN, UP, and EOF nodes.
-	 *  It is built upon ctor invocation.  The elements are type
-	 *  Object as we don't what the trees look like.
-	 *
-	 *  Load upon first need of the buffer so we can set token types
-	 *  of interest for reverseIndexing.  Slows us down a wee bit to
-	 *  do all of the if p==-1 testing everywhere though.
-	 */
-	protected List nodes;
-
-	/** Pull nodes from which tree? */
-	protected Object root;
-
-	/** IF this tree (root) was created from a token stream, track it. */
-	protected TokenStream tokens;
-
-	/** What tree adaptor was used to build these trees */
-	TreeAdaptor adaptor;
-
-	/** Reuse same DOWN, UP navigation nodes unless this is true */
-	protected boolean uniqueNavigationNodes = false;
-
-	/** The index into the nodes list of the current node (next node
-	 *  to consume).  If -1, nodes array not filled yet.
-	 */
-	protected int p = -1;
-
-	/** Track the last mark() call result value for use in rewind(). */
-	protected int lastMarker;
-
-	/** Stack of indexes used for push/pop calls */
-	protected IntArray calls;
-
-	public BufferedTreeNodeStream(Object tree) {
-		this(new CommonTreeAdaptor(), tree);
-	}
-
-	public BufferedTreeNodeStream(TreeAdaptor adaptor, Object tree) {
-		this(adaptor, tree, DEFAULT_INITIAL_BUFFER_SIZE);
-	}
-
-	public BufferedTreeNodeStream(TreeAdaptor adaptor, Object tree, int initialBufferSize) {
-		this.root = tree;
-		this.adaptor = adaptor;
-		nodes = new ArrayList(initialBufferSize);
-		down = adaptor.create(Token.DOWN, "DOWN");
-		up = adaptor.create(Token.UP, "UP");
-		eof = adaptor.create(Token.EOF, "EOF");
-	}
-
-	/** Walk tree with depth-first-search and fill nodes buffer.
-	 *  Don't do DOWN, UP nodes if its a list (t is isNil).
-	 */
-	protected void fillBuffer() {
-		fillBuffer(root);
-		//System.out.println("revIndex="+tokenTypeToStreamIndexesMap);
-		p = 0; // buffer of nodes intialized now
-	}
-
-	public void fillBuffer(Object t) {
-		boolean nil = adaptor.isNil(t);
-		if ( !nil ) {
-			nodes.add(t); // add this node
-		}
-		// add DOWN node if t has children
-		int n = adaptor.getChildCount(t);
-		if ( !nil && n>0 ) {
-			addNavigationNode(Token.DOWN);
-		}
-		// and now add all its children
-		for (int c=0; c<n; c++) {
-			Object child = adaptor.getChild(t,c);
-			fillBuffer(child);
-		}
-		// add UP node if t has children
-		if ( !nil && n>0 ) {
-			addNavigationNode(Token.UP);
-		}
-	}
-
-	/** What is the stream index for node? 0..n-1
-	 *  Return -1 if node not found.
-	 */
-	protected int getNodeIndex(Object node) {
-		if ( p==-1 ) {
-			fillBuffer();
-		}
-		for (int i = 0; i < nodes.size(); i++) {
-			Object t = (Object) nodes.get(i);
-			if ( t==node ) {
-				return i;
-			}
-		}
-		return -1;
-	}
-
-	/** As we flatten the tree, we use UP, DOWN nodes to represent
-	 *  the tree structure.  When debugging we need unique nodes
-	 *  so instantiate new ones when uniqueNavigationNodes is true.
-	 */
-	protected void addNavigationNode(final int ttype) {
-		Object navNode = null;
-		if ( ttype==Token.DOWN ) {
-			if ( hasUniqueNavigationNodes() ) {
-				navNode = adaptor.create(Token.DOWN, "DOWN");
-			}
-			else {
-				navNode = down;
-			}
-		}
-		else {
-			if ( hasUniqueNavigationNodes() ) {
-				navNode = adaptor.create(Token.UP, "UP");
-			}
-			else {
-				navNode = up;
-			}
-		}
-		nodes.add(navNode);
-	}
-
-	public Object get(int i) {
-		if ( p==-1 ) {
-			fillBuffer();
-		}
-		return nodes.get(i);
-	}
-
-	public Object LT(int k) {
-		if ( p==-1 ) {
-			fillBuffer();
-		}
-		if ( k==0 ) {
-			return null;
-		}
-		if ( k<0 ) {
-			return LB(-k);
-		}
-		//System.out.print("LT(p="+p+","+k+")=");
-		if ( (p+k-1) >= nodes.size() ) {
-			return eof;
-		}
-		return nodes.get(p+k-1);
-	}
-
-	public Object getCurrentSymbol() { return LT(1); }
-
-/*
-	public Object getLastTreeNode() {
-		int i = index();
-		if ( i>=size() ) {
-			i--; // if at EOF, have to start one back
-		}
-		System.out.println("start last node: "+i+" size=="+nodes.size());
-		while ( i>=0 &&
-			(adaptor.getType(get(i))==Token.EOF ||
-			 adaptor.getType(get(i))==Token.UP ||
-			 adaptor.getType(get(i))==Token.DOWN) )
-		{
-			i--;
-		}
-		System.out.println("stop at node: "+i+" "+nodes.get(i));
-		return nodes.get(i);
-	}
-*/
-	
-	/** Look backwards k nodes */
-	protected Object LB(int k) {
-		if ( k==0 ) {
-			return null;
-		}
-		if ( (p-k)<0 ) {
-			return null;
-		}
-		return nodes.get(p-k);
-	}
-
-	public Object getTreeSource() {
-		return root;
-	}
-
-	public String getSourceName() {
-		return getTokenStream().getSourceName();
-	}
-
-	public TokenStream getTokenStream() {
-		return tokens;
-	}
-
-	public void setTokenStream(TokenStream tokens) {
-		this.tokens = tokens;
-	}
-
-	public TreeAdaptor getTreeAdaptor() {
-		return adaptor;
-	}
-
-	public void setTreeAdaptor(TreeAdaptor adaptor) {
-		this.adaptor = adaptor;
-	}
-
-	public boolean hasUniqueNavigationNodes() {
-		return uniqueNavigationNodes;
-	}
-
-	public void setUniqueNavigationNodes(boolean uniqueNavigationNodes) {
-		this.uniqueNavigationNodes = uniqueNavigationNodes;
-	}
-
-	public void consume() {
-		if ( p==-1 ) {
-			fillBuffer();
-		}
-		p++;
-	}
-
-	public int LA(int i) {
-		return adaptor.getType(LT(i));
-	}
-
-	public int mark() {
-		if ( p==-1 ) {
-			fillBuffer();
-		}
-		lastMarker = index();
-		return lastMarker;
-	}
-
-	public void release(int marker) {
-		// no resources to release
-	}
-
-	public int index() {
-		return p;
-	}
-
-	public void rewind(int marker) {
-		seek(marker);
-	}
-
-	public void rewind() {
-		seek(lastMarker);
-	}
-
-	public void seek(int index) {
-		if ( p==-1 ) {
-			fillBuffer();
-		}
-		p = index;
-	}
-
-	/** Make stream jump to a new location, saving old location.
-	 *  Switch back with pop().
-	 */
-	public void push(int index) {
-		if ( calls==null ) {
-			calls = new IntArray();
-		}
-		calls.push(p); // save current index
-		seek(index);
-	}
-
-	/** Seek back to previous index saved during last push() call.
-	 *  Return top of stack (return index).
-	 */
-	public int pop() {
-		int ret = calls.pop();
-		seek(ret);
-		return ret;
-	}
-
-	public void reset() {
-		p = 0;
-		lastMarker = 0;
-        if (calls != null) {
-            calls.clear();
-        }
-    }
-
-	public int size() {
-		if ( p==-1 ) {
-			fillBuffer();
-		}
-		return nodes.size();
-	}
-
-	public Iterator iterator() {
-		if ( p==-1 ) {
-			fillBuffer();
-		}
-		return new StreamIterator();
-	}
-
-	// TREE REWRITE INTERFACE
-
-	public void replaceChildren(Object parent, int startChildIndex, int stopChildIndex, Object t) {
-		if ( parent!=null ) {
-			adaptor.replaceChildren(parent, startChildIndex, stopChildIndex, t);
-		}
-	}
-
-	/** Used for testing, just return the token type stream */
-	public String toTokenTypeString() {
-		if ( p==-1 ) {
-			fillBuffer();
-		}
-		StringBuffer buf = new StringBuffer();
-		for (int i = 0; i < nodes.size(); i++) {
-			Object t = (Object) nodes.get(i);
-			buf.append(" ");
-			buf.append(adaptor.getType(t));
-		}
-		return buf.toString();
-	}
-
-	/** Debugging */
-	public String toTokenString(int start, int stop) {
-		if ( p==-1 ) {
-			fillBuffer();
-		}
-		StringBuffer buf = new StringBuffer();
-		for (int i = start; i < nodes.size() && i <= stop; i++) {
-			Object t = (Object) nodes.get(i);
-			buf.append(" ");
-			buf.append(adaptor.getToken(t));
-		}
-		return buf.toString();
-	}
-
-	public String toString(Object start, Object stop) {
-		System.out.println("toString");
-		if ( start==null || stop==null ) {
-			return null;
-		}
-		if ( p==-1 ) {
-			fillBuffer();
-		}
-		//System.out.println("stop: "+stop);
-		if ( start instanceof CommonTree )
-			System.out.print("toString: "+((CommonTree)start).getToken()+", ");
-		else
-			System.out.println(start);
-		if ( stop instanceof CommonTree )
-			System.out.println(((CommonTree)stop).getToken());
-		else
-			System.out.println(stop);
-		// if we have the token stream, use that to dump text in order
-		if ( tokens!=null ) {
-			int beginTokenIndex = adaptor.getTokenStartIndex(start);
-			int endTokenIndex = adaptor.getTokenStopIndex(stop);
-			// if it's a tree, use start/stop index from start node
-			// else use token range from start/stop nodes
-			if ( adaptor.getType(stop)==Token.UP ) {
-				endTokenIndex = adaptor.getTokenStopIndex(start);
-			}
-			else if ( adaptor.getType(stop)==Token.EOF ) {
-				endTokenIndex = size()-2; // don't use EOF
-			}
-			return tokens.toString(beginTokenIndex, endTokenIndex);
-		}
-		// walk nodes looking for start
-		Object t = null;
-		int i = 0;
-		for (; i < nodes.size(); i++) {
-			t = nodes.get(i);
-			if ( t==start ) {
-				break;
-			}
-		}
-		// now walk until we see stop, filling string buffer with text
-		 StringBuffer buf = new StringBuffer();
-		t = nodes.get(i);
-		while ( t!=stop ) {
-			String text = adaptor.getText(t);
-			if ( text==null ) {
-				text = " "+String.valueOf(adaptor.getType(t));
-			}
-			buf.append(text);
-			i++;
-			t = nodes.get(i);
-		}
-		// include stop node too
-		String text = adaptor.getText(stop);
-		if ( text==null ) {
-			text = " "+String.valueOf(adaptor.getType(stop));
-		}
-		buf.append(text);
-		return buf.toString();
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/CommonErrorNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/CommonErrorNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/CommonErrorNode.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/CommonErrorNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,108 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.*;
-
-/** A node representing erroneous token range in token stream */
-public class CommonErrorNode extends CommonTree {
-	public IntStream input;
-	public Token start;
-	public Token stop;
-	public RecognitionException trappedException;
-
-	public CommonErrorNode(TokenStream input, Token start, Token stop,
-						   RecognitionException e)
-	{
-		//System.out.println("start: "+start+", stop: "+stop);
-		if ( stop==null ||
-			 (stop.getTokenIndex() < start.getTokenIndex() &&
-			  stop.getType()!=Token.EOF) )
-		{
-			// sometimes resync does not consume a token (when LT(1) is
-			// in follow set.  So, stop will be 1 to left to start. adjust.
-			// Also handle case where start is the first token and no token
-			// is consumed during recovery; LT(-1) will return null.
-			stop = start;
-		}
-		this.input = input;
-		this.start = start;
-		this.stop = stop;
-		this.trappedException = e;
-	}
-
-	public boolean isNil() {
-		return false;
-	}
-
-	public int getType() {
-		return Token.INVALID_TOKEN_TYPE;
-	}
-
-	public String getText() {
-		String badText = null;
-		if ( start instanceof Token ) {
-			int i = ((Token)start).getTokenIndex();
-			int j = ((Token)stop).getTokenIndex();
-			if ( ((Token)stop).getType() == Token.EOF ) {
-				j = ((TokenStream)input).size();
-			}
-			badText = ((TokenStream)input).toString(i, j);
-		}
-		else if ( start instanceof Tree ) {
-			badText = ((TreeNodeStream)input).toString(start, stop);
-		}
-		else {
-			// people should subclass if they alter the tree type so this
-			// next one is for sure correct.
-			badText = "<unknown>";
-		}
-		return badText;
-	}
-
-	public String toString() {
-		if ( trappedException instanceof MissingTokenException ) {
-			return "<missing type: "+
-				   ((MissingTokenException)trappedException).getMissingType()+
-				   ">";
-		}
-		else if ( trappedException instanceof UnwantedTokenException ) {
-			return "<extraneous: "+
-				   ((UnwantedTokenException)trappedException).getUnexpectedToken()+
-				   ", resync="+getText()+">";
-		}
-		else if ( trappedException instanceof MismatchedTokenException ) {
-			return "<mismatched token: "+trappedException.token+", resync="+getText()+">";
-		}
-		else if ( trappedException instanceof NoViableAltException ) {
-			return "<unexpected: "+trappedException.token+
-				   ", resync="+getText()+">";
-		}
-		return "<error: "+getText()+">";
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/CommonTreeAdaptor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/CommonTreeAdaptor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/CommonTreeAdaptor.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/CommonTreeAdaptor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,168 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.CommonToken;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-
-/** A TreeAdaptor that works with any Tree implementation.  It provides
- *  really just factory methods; all the work is done by BaseTreeAdaptor.
- *  If you would like to have different tokens created than ClassicToken
- *  objects, you need to override this and then set the parser tree adaptor to
- *  use your subclass.
- *
- *  To get your parser to build nodes of a different type, override
- *  create(Token), errorNode(), and to be safe, YourTreeClass.dupNode().
- *  dupNode is called to duplicate nodes during rewrite operations.
- */
-public class CommonTreeAdaptor extends BaseTreeAdaptor {
-	/** Duplicate a node.  This is part of the factory;
-	 *	override if you want another kind of node to be built.
-	 *
-	 *  I could use reflection to prevent having to override this
-	 *  but reflection is slow.
-	 */
-	public Object dupNode(Object t) {
-		if ( t==null ) return null;
-		return ((Tree)t).dupNode();
-	}
-
-	public Object create(Token payload) {
-		return new CommonTree(payload);
-	}
-
-	/** Tell me how to create a token for use with imaginary token nodes.
-	 *  For example, there is probably no input symbol associated with imaginary
-	 *  token DECL, but you need to create it as a payload or whatever for
-	 *  the DECL node as in ^(DECL type ID).
-	 *
-	 *  If you care what the token payload objects' type is, you should
-	 *  override this method and any other createToken variant.
-	 */
-	public Token createToken(int tokenType, String text) {
-		return new CommonToken(tokenType, text);
-	}
-
-	/** Tell me how to create a token for use with imaginary token nodes.
-	 *  For example, there is probably no input symbol associated with imaginary
-	 *  token DECL, but you need to create it as a payload or whatever for
-	 *  the DECL node as in ^(DECL type ID).
-	 *
-	 *  This is a variant of createToken where the new token is derived from
-	 *  an actual real input token.  Typically this is for converting '{'
-	 *  tokens to BLOCK etc...  You'll see
-	 *
-	 *    r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
-	 *
-	 *  If you care what the token payload objects' type is, you should
-	 *  override this method and any other createToken variant.
-	 */
-	public Token createToken(Token fromToken) {
-		return new CommonToken(fromToken);
-	}
-
-	/** Track start/stop token for subtree root created for a rule.
-	 *  Only works with Tree nodes.  For rules that match nothing,
-	 *  seems like this will yield start=i and stop=i-1 in a nil node.
-	 *  Might be useful info so I'll not force to be i..i.
-	 */
-	public void setTokenBoundaries(Object t, Token startToken, Token stopToken) {
-		if ( t==null ) return;
-		int start = 0;
-		int stop = 0;
-		if ( startToken!=null ) start = startToken.getTokenIndex();
-		if ( stopToken!=null ) stop = stopToken.getTokenIndex();
-		((Tree)t).setTokenStartIndex(start);
-		((Tree)t).setTokenStopIndex(stop);
-	}
-
-	public int getTokenStartIndex(Object t) {
-		if ( t==null ) return -1;
-		return ((Tree)t).getTokenStartIndex();
-	}
-
-	public int getTokenStopIndex(Object t) {
-		if ( t==null ) return -1;
-		return ((Tree)t).getTokenStopIndex();
-	}
-
-	public String getText(Object t) {
-		if ( t==null ) return null;
-		return ((Tree)t).getText();
-	}
-
-    public int getType(Object t) {
-		if ( t==null ) return Token.INVALID_TOKEN_TYPE;
-		return ((Tree)t).getType();
-	}
-
-	/** What is the Token associated with this node?  If
-	 *  you are not using CommonTree, then you must
-	 *  override this in your own adaptor.
-	 */
-	public Token getToken(Object t) {
-		if ( t instanceof CommonTree ) {
-			return ((CommonTree)t).getToken();
-		}
-		return null; // no idea what to do
-	}
-
-	public Object getChild(Object t, int i) {
-		if ( t==null ) return null;
-        return ((Tree)t).getChild(i);
-    }
-
-    public int getChildCount(Object t) {
-		if ( t==null ) return 0;
-        return ((Tree)t).getChildCount();
-    }
-
-	public Object getParent(Object t) {
-		if ( t==null ) return null;
-        return ((Tree)t).getParent();
-	}
-
-	public void setParent(Object t, Object parent) {
-        if ( t!=null ) ((Tree)t).setParent((Tree)parent);
-	}
-
-	public int getChildIndex(Object t) {
-        if ( t==null ) return 0;
-		return ((Tree)t).getChildIndex();
-	}
-
-	public void setChildIndex(Object t, int index) {
-        if ( t!=null ) ((Tree)t).setChildIndex(index);
-	}
-
-	public void replaceChildren(Object parent, int startChildIndex, int stopChildIndex, Object t) {
-		if ( parent!=null ) {
-			((Tree)parent).replaceChildren(startChildIndex, stopChildIndex, t);
-		}
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/CommonTree.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/CommonTree.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/CommonTree.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/CommonTree.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,185 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-
-/** A tree node that is wrapper for a Token object.  After 3.0 release
- *  while building tree rewrite stuff, it became clear that computing
- *  parent and child index is very difficult and cumbersome.  Better to
- *  spend the space in every tree node.  If you don't want these extra
- *  fields, it's easy to cut them out in your own BaseTree subclass.
- */
-public class CommonTree extends BaseTree {
-	/** A single token is the payload */
-	public Token token;
-
-	/** What token indexes bracket all tokens associated with this node
-	 *  and below?
-	 */
-	protected int startIndex=-1, stopIndex=-1;
-
-	/** Who is the parent node of this node; if null, implies node is root */
-	public CommonTree parent;
-
-	/** What index is this node in the child list? Range: 0..n-1 */
-	public int childIndex = -1;
-
-	public CommonTree() { }
-	
-	public CommonTree(CommonTree node) {
-		super(node);
-		this.token = node.token;
-		this.startIndex = node.startIndex;
-		this.stopIndex = node.stopIndex;
-	}
-
-	public CommonTree(Token t) {
-		this.token = t;
-	}
-
-	public Token getToken() {
-		return token;
-	}
-
-	public Tree dupNode() {
-		return new CommonTree(this);
-	}
-
-	public boolean isNil() {
-		return token==null;
-	}
-
-	public int getType() {
-		if ( token==null ) {
-			return Token.INVALID_TOKEN_TYPE;
-		}
-		return token.getType();
-	}
-
-	public String getText() {
-		if ( token==null ) {
-			return null;
-		}
-		return token.getText();
-	}
-
-	public int getLine() {
-		if ( token==null || token.getLine()==0 ) {
-			if ( getChildCount()>0 ) {
-				return getChild(0).getLine();
-			}
-			return 0;
-		}
-		return token.getLine();
-	}
-
-	public int getCharPositionInLine() {
-		if ( token==null || token.getCharPositionInLine()==-1 ) {
-			if ( getChildCount()>0 ) {
-				return getChild(0).getCharPositionInLine();
-			}
-			return 0;
-		}
-		return token.getCharPositionInLine();
-	}
-
-	public int getTokenStartIndex() {
-		if ( startIndex==-1 && token!=null ) {
-			return token.getTokenIndex();
-		}
-		return startIndex;
-	}
-
-	public void setTokenStartIndex(int index) {
-		startIndex = index;
-	}
-
-	public int getTokenStopIndex() {
-		if ( stopIndex==-1 && token!=null ) {
-			return token.getTokenIndex();
-		}
-		return stopIndex;
-	}
-
-	public void setTokenStopIndex(int index) {
-		stopIndex = index;
-	}
-
-    /** For every node in this subtree, make sure it's start/stop token's
-     *  are set.  Walk depth first, visit bottom up.  Only updates nodes
-     *  with at least one token index < 0.
-     */
-    public void setUnknownTokenBoundaries() {
-        if ( children==null ) {
-            if ( startIndex<0 || stopIndex<0 ) {
-                startIndex = stopIndex = token.getTokenIndex();
-            }
-            return;
-        }
-        for (int i=0; i<children.size(); i++) {
-            ((CommonTree)children.get(i)).setUnknownTokenBoundaries();
-        }
-        if ( startIndex>=0 && stopIndex>=0 ) return; // already set
-        if ( children.size() > 0 ) {
-            CommonTree firstChild = (CommonTree)children.get(0);
-            CommonTree lastChild = (CommonTree)children.get(children.size()-1);
-            startIndex = firstChild.getTokenStartIndex();
-            stopIndex = lastChild.getTokenStopIndex();
-        }
-    }
-
-	public int getChildIndex() {
-		return childIndex;
-	}
-
-	public Tree getParent() {
-		return parent;
-	}
-
-	public void setParent(Tree t) {
-		this.parent = (CommonTree)t;
-	}
-
-	public void setChildIndex(int index) {
-		this.childIndex = index;
-	}
-
-	public String toString() {
-		if ( isNil() ) {
-			return "nil";
-		}
-		if ( getType()==Token.INVALID_TOKEN_TYPE ) {
-			return "<errornode>";
-		}
-		if ( token==null ) {
-			return null;
-		}
-		return token.getText();
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/CommonTreeNodeStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/CommonTreeNodeStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/CommonTreeNodeStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/CommonTreeNodeStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,167 +0,0 @@
-/*
-[The "BSD licence"]
-Copyright (c) 2005-2008 Terence Parr
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-3. The name of the author may not be used to endorse or promote products
-derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.TokenStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.misc.LookaheadStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.misc.IntArray;
-
-import java.util.*;
-
-public class CommonTreeNodeStream extends LookaheadStream<Object> implements TreeNodeStream {
-	public static final int DEFAULT_INITIAL_BUFFER_SIZE = 100;
-	public static final int INITIAL_CALL_STACK_SIZE = 10;
-
-	/** Pull nodes from which tree? */
-	protected Object root;
-
-	/** If this tree (root) was created from a token stream, track it. */
-	protected TokenStream tokens;
-
-	/** What tree adaptor was used to build these trees */
-	TreeAdaptor adaptor;
-
-    /** The tree iterator we using */
-    protected TreeIterator it;
-
-    /** Stack of indexes used for push/pop calls */
-    protected IntArray calls;    
-
-    /** Tree (nil A B C) trees like flat A B C streams */
-    protected boolean hasNilRoot = false;
-
-    /** Tracks tree depth.  Level=0 means we're at root node level. */
-    protected int level = 0;
-
-	public CommonTreeNodeStream(Object tree) {
-		this(new CommonTreeAdaptor(), tree);
-	}
-
-	public CommonTreeNodeStream(TreeAdaptor adaptor, Object tree) {
-        super(adaptor.create(Token.EOF, "EOF")); // set EOF
-		this.root = tree;
-		this.adaptor = adaptor;
-        it = new TreeIterator(root);
-        it.eof = this.eof; // make sure tree iterator returns the EOF we want
-	}
-
-    public void reset() {
-        super.reset();
-        it.reset();
-        hasNilRoot = false;
-        level = 0;
-        if ( calls != null ) calls.clear();
-    }
-    
-    /** Pull elements from tree iterator.  Track tree level 0..max_level.
-     *  If nil rooted tree, don't give initial nil and DOWN nor final UP.
-     */
-    public Object nextElement() {
-        Object t = it.next();
-        //System.out.println("pulled "+adaptor.getType(t));
-        if ( t == it.up ) {
-            level--;
-            if ( level==0 && hasNilRoot ) return it.next(); // don't give last UP; get EOF
-        }
-        else if ( t == it.down ) level++;
-        if ( level==0 && adaptor.isNil(t) ) { // if nil root, scarf nil, DOWN
-            hasNilRoot = true;
-            t = it.next(); // t is now DOWN, so get first real node next
-            level++;
-            t = it.next();
-        }
-        return t;
-    }
-
-    public void setUniqueNavigationNodes(boolean uniqueNavigationNodes) { }
-
-	public Object getTreeSource() {	return root; }
-
-	public String getSourceName() { return getTokenStream().getSourceName(); }
-
-	public TokenStream getTokenStream() { return tokens; }
-
-	public void setTokenStream(TokenStream tokens) { this.tokens = tokens; }
-
-	public TreeAdaptor getTreeAdaptor() { return adaptor; }
-
-	public void setTreeAdaptor(TreeAdaptor adaptor) { this.adaptor = adaptor; }
-
-	public int LA(int i) { return adaptor.getType(LT(i)); }
-
-    /** Make stream jump to a new location, saving old location.
-     *  Switch back with pop().
-     */
-    public void push(int index) {
-        if ( calls==null ) {
-            calls = new IntArray();
-        }
-        calls.push(p); // save current index
-        seek(index);
-    }
-
-    /** Seek back to previous index saved during last push() call.
-     *  Return top of stack (return index).
-     */
-    public int pop() {
-        int ret = calls.pop();
-        seek(ret);
-        return ret;
-    }    
-
-	// TREE REWRITE INTERFACE
-
-	public void replaceChildren(Object parent, int startChildIndex, int stopChildIndex, Object t) {
-		if ( parent!=null ) {
-			adaptor.replaceChildren(parent, startChildIndex, stopChildIndex, t);
-		}
-	}
-
-	public String toString(Object start, Object stop) {
-        // we'll have to walk from start to stop in tree; we're not keeping
-        // a complete node stream buffer
-        return "n/a";
-	}
-
-    /** For debugging; destructive: moves tree iterator to end. */
-    public String toTokenTypeString() {
-        reset();
-		StringBuffer buf = new StringBuffer();
-        Object o = LT(1);
-        int type = adaptor.getType(o);
-        while ( type!=Token.EOF ) {
-            buf.append(" ");
-            buf.append(type);
-            consume();
-            o = LT(1);
-            type = adaptor.getType(o);
-		}
-		return buf.toString();
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/DOTTreeGenerator.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/DOTTreeGenerator.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/DOTTreeGenerator.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/DOTTreeGenerator.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,224 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.antlr.stringtemplate.StringTemplate;
-
-import java.util.HashMap;
-
-/** A utility class to generate DOT diagrams (graphviz) from
- *  arbitrary trees.  You can pass in your own templates and
- *  can pass in any kind of tree or use Tree interface method.
- *  I wanted this separator so that you don't have to include
- *  ST just to use the org.eclipse.persistence.internal.libraries.antlr.runtime.tree.* package.
- *  This is a set of non-static methods so you can subclass
- *  to override.  For example, here is an invocation:
- *
- *      CharStream input = new ANTLRInputStream(System.in);
- *      TLexer lex = new TLexer(input);
- *      CommonTokenStream tokens = new CommonTokenStream(lex);
- *      TParser parser = new TParser(tokens);
- *      TParser.e_return r = parser.e();
- *      Tree t = (Tree)r.tree;
- *      System.out.println(t.toStringTree());
- *      DOTTreeGenerator gen = new DOTTreeGenerator();
- *      StringTemplate st = gen.toDOT(t);
- *      System.out.println(st);
- */
-public class DOTTreeGenerator {
-
-	public static StringTemplate _treeST =
-		new StringTemplate(
-			"digraph {\n\n" +
-			"\tordering=out;\n" +
-			"\tranksep=.4;\n" +
-			"\tbgcolor=\"lightgrey\"; node [shape=box, fixedsize=false, fontsize=12, fontname=\"Helvetica-bold\", fontcolor=\"blue\"\n" +
-			"\t\twidth=.25, height=.25, color=\"black\", fillcolor=\"white\", style=\"filled, solid, bold\"];\n" +
-			"\tedge [arrowsize=.5, color=\"black\", style=\"bold\"]\n\n" +
-			"  $nodes$\n" +
-			"  $edges$\n" +
-			"}\n");
-
-	public static StringTemplate _nodeST =
-			new StringTemplate("$name$ [label=\"$text$\"];\n");
-
-	public static StringTemplate _edgeST =
-			new StringTemplate("$parent$ -> $child$ // \"$parentText$\" -> \"$childText$\"\n");
-
-	/** Track node to number mapping so we can get proper node name back */
-	HashMap nodeToNumberMap = new HashMap();
-
-	/** Track node number so we can get unique node names */
-	int nodeNumber = 0;
-
-	public StringTemplate toDOT(Object tree,
-								TreeAdaptor adaptor,
-								StringTemplate _treeST,
-								StringTemplate _edgeST)
-	{
-		StringTemplate treeST = _treeST.getInstanceOf();
-		nodeNumber = 0;
-		toDOTDefineNodes(tree, adaptor, treeST);
-		nodeNumber = 0;
-		toDOTDefineEdges(tree, adaptor, treeST);
-		/*
-		if ( adaptor.getChildCount(tree)==0 ) {
-            // single node, don't do edge.
-            treeST.setAttribute("nodes", adaptor.getText(tree));
-        }
-        */
-		return treeST;
-	}
-
-	public StringTemplate toDOT(Object tree,
-								TreeAdaptor adaptor)
-	{
-		return toDOT(tree, adaptor, _treeST, _edgeST);
-	}
-
-	/** Generate DOT (graphviz) for a whole tree not just a node.
-	 *  For example, 3+4*5 should generate:
-	 *
-	 * digraph {
-	 *   node [shape=plaintext, fixedsize=true, fontsize=11, fontname="Courier",
-	 *         width=.4, height=.2];
-	 *   edge [arrowsize=.7]
-	 *   "+"->3
-	 *   "+"->"*"
-	 *   "*"->4
-	 *   "*"->5
-	 * }
-	 *
-	 * Return the ST not a string in case people want to alter.
-	 *
-	 * Takes a Tree interface object.
-	 */
-	public StringTemplate toDOT(Tree tree) {
-		return toDOT(tree, new CommonTreeAdaptor());
-	}
-
-	protected void toDOTDefineNodes(Object tree,
-									TreeAdaptor adaptor,
-									StringTemplate treeST)
-	{
-		if ( tree==null ) {
-			return;
-		}
-		int n = adaptor.getChildCount(tree);
-		if ( n==0 ) {
-			// must have already dumped as child from previous
-			// invocation; do nothing
-			return;
-		}
-
-		// define parent node
-		StringTemplate parentNodeST = getNodeST(adaptor, tree);
-		treeST.setAttribute("nodes", parentNodeST);
-
-		// for each child, do a "<unique-name> [label=text]" node def
-		for (int i = 0; i < n; i++) {
-			Object child = adaptor.getChild(tree, i);
-			StringTemplate nodeST = getNodeST(adaptor, child);
-			treeST.setAttribute("nodes", nodeST);
-			toDOTDefineNodes(child, adaptor, treeST);
-		}
-	}
-
-	protected void toDOTDefineEdges(Object tree,
-									TreeAdaptor adaptor,
-									StringTemplate treeST)
-	{
-		if ( tree==null ) {
-			return;
-		}
-		int n = adaptor.getChildCount(tree);
-		if ( n==0 ) {
-			// must have already dumped as child from previous
-			// invocation; do nothing
-			return;
-		}
-
-		String parentName = "n"+getNodeNumber(tree);
-
-		// for each child, do a parent -> child edge using unique node names
-		String parentText = adaptor.getText(tree);
-		for (int i = 0; i < n; i++) {
-			Object child = adaptor.getChild(tree, i);
-			String childText = adaptor.getText(child);
-			String childName = "n"+getNodeNumber(child);
-			StringTemplate edgeST = _edgeST.getInstanceOf();
-			edgeST.setAttribute("parent", parentName);
-			edgeST.setAttribute("child", childName);
-			edgeST.setAttribute("parentText", fixString(parentText));
-			edgeST.setAttribute("childText", fixString(childText));
-			treeST.setAttribute("edges", edgeST);
-			toDOTDefineEdges(child, adaptor, treeST);
-		}
-	}
-
-	protected StringTemplate getNodeST(TreeAdaptor adaptor, Object t) {
-		String text = adaptor.getText(t);
-		StringTemplate nodeST = _nodeST.getInstanceOf();
-		String uniqueName = "n"+getNodeNumber(t);
-		nodeST.setAttribute("name", uniqueName);
-
-		nodeST.setAttribute("text", fixString(text));
-		return nodeST;
-	}
-
-	protected int getNodeNumber(Object t) {
-		Integer nI = (Integer)nodeToNumberMap.get(t);
-		if ( nI!=null ) {
-			return nI.intValue();
-		}
-		else {
-			nodeToNumberMap.put(t, new Integer(nodeNumber));
-			nodeNumber++;
-			return nodeNumber-1;
-		}
-	}
-
-    protected String fixString(String in)
-    {
-        String text = in;
-
-        if (text!=null) {
-
-            text = text.replaceAll("\"", "\\\\\"");
-            text = text.replaceAll("\\t", "    ");
-            text = text.replaceAll("\\n", "\\\\n");
-            text = text.replaceAll("\\r", "\\\\r");
-            if  (text.length() > 20)    {
-                text = text.substring(0, 8) + "..." + text.substring(text.length()-8);
-            }
-
-        }
-
-        return text;
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/ParseTree.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/ParseTree.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/ParseTree.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/ParseTree.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,119 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-
-import java.util.List;
-
-/** A record of the rules used to match a token sequence.  The tokens
- *  end up as the leaves of this tree and rule nodes are the interior nodes.
- *  This really adds no functionality, it is just an alias for CommonTree
- *  that is more meaningful (specific) and holds a String to display for a node.
- */
-public class ParseTree extends BaseTree {
-	public Object payload;
-	public List hiddenTokens;
-
-	public ParseTree(Object label) {
-		this.payload = label;
-	}
-
-	public Tree dupNode() {
-		return null;
-	}
-
-	public int getType() {
-		return 0;
-	}
-
-	public String getText() {
-		return toString();
-	}
-
-	public int getTokenStartIndex() {
-		return 0;
-	}
-
-	public void setTokenStartIndex(int index) {
-	}
-
-	public int getTokenStopIndex() {
-		return 0;
-	}
-
-	public void setTokenStopIndex(int index) {
-	}
-
-	public String toString() {
-		if ( payload instanceof Token ) {
-			Token t = (Token)payload;
-			if ( t.getType() == Token.EOF ) {
-				return "<EOF>";
-			}
-			return t.getText();
-		}
-		return payload.toString();
-	}
-
-	/** Emit a token and all hidden nodes before.  EOF node holds all
-	 *  hidden tokens after last real token.
-	 */
-	public String toStringWithHiddenTokens() {
-		StringBuffer buf = new StringBuffer();
-		if ( hiddenTokens!=null ) {
-			for (int i = 0; i < hiddenTokens.size(); i++) {
-				Token hidden = (Token) hiddenTokens.get(i);
-				buf.append(hidden.getText());
-			}
-		}
-		String nodeText = this.toString();
-		if ( !nodeText.equals("<EOF>") ) buf.append(nodeText);
-		return buf.toString();
-	}
-
-	/** Print out the leaves of this tree, which means printing original
-	 *  input back out.
-	 */
-	public String toInputString() {
-		StringBuffer buf = new StringBuffer();
-		_toStringLeaves(buf);
-		return buf.toString();
-	}
-
-	public void _toStringLeaves(StringBuffer buf) {
-		if ( payload instanceof Token ) { // leaf node token?
-			buf.append(this.toStringWithHiddenTokens());
-			return;
-		}
-		for (int i = 0; children!=null && i < children.size(); i++) {
-			ParseTree t = (ParseTree)children.get(i);
-			t._toStringLeaves(buf);
-		}
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteCardinalityException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteCardinalityException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteCardinalityException.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteCardinalityException.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,47 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-/** Base class for all exceptions thrown during AST rewrite construction.
- *  This signifies a case where the cardinality of two or more elements
- *  in a subrule are different: (ID INT)+ where |ID|!=|INT|
- */
-public class RewriteCardinalityException extends RuntimeException {
-	public String elementDescription;
-
-	public RewriteCardinalityException(String elementDescription) {
-		this.elementDescription = elementDescription;
-	}
-
-	public String getMessage() {
-		if ( elementDescription!=null ) {
-			return elementDescription;
-		}
-		return null;
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteEarlyExitException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteEarlyExitException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteEarlyExitException.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteEarlyExitException.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,39 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-/** No elements within a (...)+ in a rewrite rule */
-public class RewriteEarlyExitException extends RewriteCardinalityException {
-	public RewriteEarlyExitException() {
-		super(null);
-	}
-	public RewriteEarlyExitException(String elementDescription) {
-		super(elementDescription);
-	}
-
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteEmptyStreamException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteEmptyStreamException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteEmptyStreamException.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteEmptyStreamException.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,35 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-/** Ref to ID or expr but no tokens in ID stream or subtrees in expr stream */
-public class RewriteEmptyStreamException extends RewriteCardinalityException {
-	public RewriteEmptyStreamException(String elementDescription) {
-		super(elementDescription);
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteRuleElementStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteRuleElementStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteRuleElementStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteRuleElementStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,211 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.CommonToken;
-
-import java.util.List;
-import java.util.ArrayList;
-
-/** A generic list of elements tracked in an alternative to be used in
- *  a -> rewrite rule.  We need to subclass to fill in the next() method,
- *  which returns either an AST node wrapped around a token payload or
- *  an existing subtree.
- *
- *  Once you start next()ing, do not try to add more elements.  It will
- *  break the cursor tracking I believe.
- *
- *  @see org.eclipse.persistence.internal.libraries.antlr.runtime.tree.RewriteRuleSubtreeStream
- *  @see org.eclipse.persistence.internal.libraries.antlr.runtime.tree.RewriteRuleTokenStream
- *
- *  TODO: add mechanism to detect/puke on modification after reading from stream
- */
-public abstract class RewriteRuleElementStream {
-	/** Cursor 0..n-1.  If singleElement!=null, cursor is 0 until you next(),
-	 *  which bumps it to 1 meaning no more elements.
-	 */
-	protected int cursor = 0;
-
-	/** Track single elements w/o creating a list.  Upon 2nd add, alloc list */
-	protected Object singleElement;
-
-	/** The list of tokens or subtrees we are tracking */
-	protected List elements;
-
-	/** Once a node / subtree has been used in a stream, it must be dup'd
-	 *  from then on.  Streams are reset after subrules so that the streams
-	 *  can be reused in future subrules.  So, reset must set a dirty bit.
-	 *  If dirty, then next() always returns a dup.
-	 *
-	 *  I wanted to use "naughty bit" here, but couldn't think of a way
-	 *  to use "naughty".
-	 */
-	protected boolean dirty = false;
-
-	/** The element or stream description; usually has name of the token or
-	 *  rule reference that this list tracks.  Can include rulename too, but
-	 *  the exception would track that info.
-	 */
-	protected String elementDescription;
-	protected TreeAdaptor adaptor;
-
-	public RewriteRuleElementStream(TreeAdaptor adaptor, String elementDescription) {
-		this.elementDescription = elementDescription;
-		this.adaptor = adaptor;
-	}
-
-	/** Create a stream with one element */
-	public RewriteRuleElementStream(TreeAdaptor adaptor,
-									String elementDescription,
-									Object oneElement)
-	{
-		this(adaptor, elementDescription);
-		add(oneElement);
-	}
-
-	/** Create a stream, but feed off an existing list */
-	public RewriteRuleElementStream(TreeAdaptor adaptor,
-									String elementDescription,
-									List elements)
-	{
-		this(adaptor, elementDescription);
-		this.singleElement = null;
-		this.elements = elements;
-	}
-
-	/** Reset the condition of this stream so that it appears we have
-	 *  not consumed any of its elements.  Elements themselves are untouched.
-	 *  Once we reset the stream, any future use will need duplicates.  Set
-	 *  the dirty bit.
-	 */
-	public void reset() {
-		cursor = 0;
-		dirty = true;
-	}
-
-	public void add(Object el) {
-		//System.out.println("add '"+elementDescription+"' is "+el);
-		if ( el==null ) {
-			return;
-		}
-		if ( elements!=null ) { // if in list, just add
-			elements.add(el);
-			return;
-		}
-		if ( singleElement == null ) { // no elements yet, track w/o list
-			singleElement = el;
-			return;
-		}
-		// adding 2nd element, move to list
-		elements = new ArrayList(5);
-		elements.add(singleElement);
-		singleElement = null;
-		elements.add(el);
-	}
-
-	/** Return the next element in the stream.  If out of elements, throw
-	 *  an exception unless size()==1.  If size is 1, then return elements[0].
-	 *  Return a duplicate node/subtree if stream is out of elements and
-	 *  size==1.  If we've already used the element, dup (dirty bit set).
-	 */
-	public Object nextTree() {
-		int n = size();
-		if ( dirty || (cursor>=n && n==1) ) {
-			// if out of elements and size is 1, dup
-			Object el = _next();
-			return dup(el);
-		}
-		// test size above then fetch
-		Object el = _next();
-		return el;
-	}
-
-	/** do the work of getting the next element, making sure that it's
-	 *  a tree node or subtree.  Deal with the optimization of single-
-	 *  element list versus list of size > 1.  Throw an exception
-	 *  if the stream is empty or we're out of elements and size>1.
-	 *  protected so you can override in a subclass if necessary.
-	 */
-	protected Object _next() {
-		int n = size();
-		if ( n ==0 ) {
-			throw new RewriteEmptyStreamException(elementDescription);
-		}
-		if ( cursor>= n) { // out of elements?
-			if ( n ==1 ) {  // if size is 1, it's ok; return and we'll dup
-				return toTree(singleElement);
-			}
-			// out of elements and size was not 1, so we can't dup
-			throw new RewriteCardinalityException(elementDescription);
-		}
-		// we have elements
-		if ( singleElement!=null ) {
-			cursor++; // move cursor even for single element list
-			return toTree(singleElement);
-		}
-		// must have more than one in list, pull from elements
-		Object o = toTree(elements.get(cursor));
-		cursor++;
-		return o;
-	}
-
-	/** When constructing trees, sometimes we need to dup a token or AST
-	 * 	subtree.  Dup'ing a token means just creating another AST node
-	 *  around it.  For trees, you must call the adaptor.dupTree() unless
-	 *  the element is for a tree root; then it must be a node dup.
-	 */
-	protected abstract Object dup(Object el);
-
-	/** Ensure stream emits trees; tokens must be converted to AST nodes.
-	 *  AST nodes can be passed through unmolested.
-	 */
-	protected Object toTree(Object el) {
-		return el;
-	}
-
-	public boolean hasNext() {
-		 return (singleElement != null && cursor < 1) ||
-			   (elements!=null && cursor < elements.size());
-	}
-
-	public int size() {
-		int n = 0;
-		if ( singleElement != null ) {
-			n = 1;
-		}
-		if ( elements!=null ) {
-			return elements.size();
-		}
-		return n;
-	}
-
-	public String getDescription() {
-		return elementDescription;
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteRuleNodeStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteRuleNodeStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteRuleNodeStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteRuleNodeStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,70 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import java.util.List;
-
-/** Queues up nodes matched on left side of -> in a tree parser. This is
- *  the analog of RewriteRuleTokenStream for normal parsers. 
- */
-public class RewriteRuleNodeStream extends RewriteRuleElementStream {
-
-	public RewriteRuleNodeStream(TreeAdaptor adaptor, String elementDescription) {
-		super(adaptor, elementDescription);
-	}
-
-	/** Create a stream with one element */
-	public RewriteRuleNodeStream(TreeAdaptor adaptor,
-								 String elementDescription,
-								 Object oneElement)
-	{
-		super(adaptor, elementDescription, oneElement);
-	}
-
-	/** Create a stream, but feed off an existing list */
-	public RewriteRuleNodeStream(TreeAdaptor adaptor,
-								 String elementDescription,
-								 List elements)
-	{
-		super(adaptor, elementDescription, elements);
-	}
-
-	public Object nextNode() {
-		return _next();
-	}
-
-	protected Object toTree(Object el) {
-		return adaptor.dupNode(el);
-	}
-
-	protected Object dup(Object el) {
-		// we dup every node, so don't have to worry about calling dup; short-
-		// circuited next() so it doesn't call.
-		throw new UnsupportedOperationException("dup can't be called for a node stream.");
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteRuleSubtreeStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteRuleSubtreeStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteRuleSubtreeStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteRuleSubtreeStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,83 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import java.util.List;
-
-public class RewriteRuleSubtreeStream extends RewriteRuleElementStream {
-
-	public RewriteRuleSubtreeStream(TreeAdaptor adaptor, String elementDescription) {
-		super(adaptor, elementDescription);
-	}
-
-	/** Create a stream with one element */
-	public RewriteRuleSubtreeStream(TreeAdaptor adaptor,
-									String elementDescription,
-									Object oneElement)
-	{
-		super(adaptor, elementDescription, oneElement);
-	}
-
-	/** Create a stream, but feed off an existing list */
-	public RewriteRuleSubtreeStream(TreeAdaptor adaptor,
-									String elementDescription,
-									List elements)
-	{
-		super(adaptor, elementDescription, elements);
-	}
-
-	/** Treat next element as a single node even if it's a subtree.
-	 *  This is used instead of next() when the result has to be a
-	 *  tree root node.  Also prevents us from duplicating recently-added
-	 *  children; e.g., ^(type ID)+ adds ID to type and then 2nd iteration
-	 *  must dup the type node, but ID has been added.
-	 *
-	 *  Referencing a rule result twice is ok; dup entire tree as
-	 *  we can't be adding trees as root; e.g., expr expr.
-	 *
-	 *  Hideous code duplication here with super.next().  Can't think of
-	 *  a proper way to refactor.  This needs to always call dup node
-	 *  and super.next() doesn't know which to call: dup node or dup tree.
-	 */
-	public Object nextNode() {
-		int n = size();
-		if ( dirty || (cursor>=n && n==1) ) {
-			// if out of elements and size is 1, dup (at most a single node
-			// since this is for making root nodes).
-			Object el = _next();
-			return adaptor.dupNode(el);
-		}
-		// test size above then fetch
-		Object el = _next();
-		return el;
-	}
-
-	protected Object dup(Object el) {
-		return adaptor.dupTree(el);
-	}
-}
\ Manca newline alla fine del file
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteRuleTokenStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteRuleTokenStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteRuleTokenStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/RewriteRuleTokenStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-
-import java.util.List;
-
-public class RewriteRuleTokenStream extends RewriteRuleElementStream {
-
-	public RewriteRuleTokenStream(TreeAdaptor adaptor, String elementDescription) {
-		super(adaptor, elementDescription);
-	}
-
-	/** Create a stream with one element */
-	public RewriteRuleTokenStream(TreeAdaptor adaptor,
-								  String elementDescription,
-								  Object oneElement)
-	{
-		super(adaptor, elementDescription, oneElement);
-	}
-
-	/** Create a stream, but feed off an existing list */
-	public RewriteRuleTokenStream(TreeAdaptor adaptor,
-								  String elementDescription,
-								  List elements)
-	{
-		super(adaptor, elementDescription, elements);
-	}
-
-	/** Get next token from stream and make a node for it */
-	public Object nextNode() {
-		Token t = (Token)_next();
-		return adaptor.create(t);
-	}
-
-	public Token nextToken() {
-		return (Token)_next();
-	}
-
-	/** Don't convert to a tree unless they explicitly call nextTree.
-	 *  This way we can do hetero tree nodes in rewrite.
-	 */
-	protected Object toTree(Object el) {
-		return el;
-	}
-
-	protected Object dup(Object el) {
-		throw new UnsupportedOperationException("dup can't be called for a token stream.");
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeAdaptor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeAdaptor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeAdaptor.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeAdaptor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,263 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.TokenStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognitionException;
-
-/** How to create and navigate trees.  Rather than have a separate factory
- *  and adaptor, I've merged them.  Makes sense to encapsulate.
- *
- *  This takes the place of the tree construction code generated in the
- *  generated code in 2.x and the ASTFactory.
- *
- *  I do not need to know the type of a tree at all so they are all
- *  generic Objects.  This may increase the amount of typecasting needed. :(
- */
-public interface TreeAdaptor {
-	// C o n s t r u c t i o n
-
-	/** Create a tree node from Token object; for CommonTree type trees,
-	 *  then the token just becomes the payload.  This is the most
-	 *  common create call.
-	 *
-	 *  Override if you want another kind of node to be built.
-	 */
-	public Object create(Token payload);
-
-	/** Duplicate a single tree node.
-	 *  Override if you want another kind of node to be built.
-	 */
-	public Object dupNode(Object treeNode);
-
-	/** Duplicate tree recursively, using dupNode() for each node */
-	public Object dupTree(Object tree);
-
-	/** Return a nil node (an empty but non-null node) that can hold
-	 *  a list of element as the children.  If you want a flat tree (a list)
-	 *  use "t=adaptor.nil(); t.addChild(x); t.addChild(y);"
-	 */
-	public Object nil();
-
-	/** Return a tree node representing an error.  This node records the
-	 *  tokens consumed during error recovery.  The start token indicates the
-	 *  input symbol at which the error was detected.  The stop token indicates
-	 *  the last symbol consumed during recovery.
-	 *
-	 *  You must specify the input stream so that the erroneous text can
-	 *  be packaged up in the error node.  The exception could be useful
-	 *  to some applications; default implementation stores ptr to it in
-	 *  the CommonErrorNode.
-	 *
-	 *  This only makes sense during token parsing, not tree parsing.
-	 *  Tree parsing should happen only when parsing and tree construction
-	 *  succeed.
-	 */
-	public Object errorNode(TokenStream input, Token start, Token stop, RecognitionException e);
-
-	/** Is tree considered a nil node used to make lists of child nodes? */
-	public boolean isNil(Object tree);
-
-	/** Add a child to the tree t.  If child is a flat tree (a list), make all
-	 *  in list children of t.  Warning: if t has no children, but child does
-	 *  and child isNil then you can decide it is ok to move children to t via
-	 *  t.children = child.children; i.e., without copying the array.  Just
-	 *  make sure that this is consistent with have the user will build
-	 *  ASTs.  Do nothing if t or child is null.
-	 */
-	public void addChild(Object t, Object child);
-
-	/** If oldRoot is a nil root, just copy or move the children to newRoot.
-	 *  If not a nil root, make oldRoot a child of newRoot.
-	 *
-	 *    old=^(nil a b c), new=r yields ^(r a b c)
-	 *    old=^(a b c), new=r yields ^(r ^(a b c))
-	 *
-	 *  If newRoot is a nil-rooted single child tree, use the single
-	 *  child as the new root node.
-	 *
-	 *    old=^(nil a b c), new=^(nil r) yields ^(r a b c)
-	 *    old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
-	 *
-	 *  If oldRoot was null, it's ok, just return newRoot (even if isNil).
-	 *
-	 *    old=null, new=r yields r
-	 *    old=null, new=^(nil r) yields ^(nil r)
-	 *
-	 *  Return newRoot.  Throw an exception if newRoot is not a
-	 *  simple node or nil root with a single child node--it must be a root
-	 *  node.  If newRoot is ^(nil x) return x as newRoot.
-	 *
-	 *  Be advised that it's ok for newRoot to point at oldRoot's
-	 *  children; i.e., you don't have to copy the list.  We are
-	 *  constructing these nodes so we should have this control for
-	 *  efficiency.
-	 */
-	public Object becomeRoot(Object newRoot, Object oldRoot);
-
-	/** Given the root of the subtree created for this rule, post process
-	 *  it to do any simplifications or whatever you want.  A required
-	 *  behavior is to convert ^(nil singleSubtree) to singleSubtree
-	 *  as the setting of start/stop indexes relies on a single non-nil root
-	 *  for non-flat trees.
-	 *
-	 *  Flat trees such as for lists like "idlist : ID+ ;" are left alone
-	 *  unless there is only one ID.  For a list, the start/stop indexes
-	 *  are set in the nil node.
-	 *
-	 *  This method is executed after all rule tree construction and right
-	 *  before setTokenBoundaries().
-	 */
-	public Object rulePostProcessing(Object root);
-
-	/** For identifying trees.
-	 *
-	 *  How to identify nodes so we can say "add node to a prior node"?
-	 *  Even becomeRoot is an issue.  Use System.identityHashCode(node)
-	 *  usually.
-	 */
-	public int getUniqueID(Object node);
-
-
-	// R e w r i t e  R u l e s
-
-	/** Create a node for newRoot make it the root of oldRoot.
-	 *  If oldRoot is a nil root, just copy or move the children to newRoot.
-	 *  If not a nil root, make oldRoot a child of newRoot.
-	 *
-	 *  Return node created for newRoot.
-	 *
-	 *  Be advised: when debugging ASTs, the DebugTreeAdaptor manually
-	 *  calls create(Token child) and then plain becomeRoot(node, node)
-	 *  because it needs to trap calls to create, but it can't since it delegates
-	 *  to not inherits from the TreeAdaptor.
-	 */
-	public Object becomeRoot(Token newRoot, Object oldRoot);
-
-	/** Create a new node derived from a token, with a new token type.
-	 *  This is invoked from an imaginary node ref on right side of a
-	 *  rewrite rule as IMAG[$tokenLabel].
-	 *
-	 *  This should invoke createToken(Token).
-	 */
-	public Object create(int tokenType, Token fromToken);
-
-	/** Same as create(tokenType,fromToken) except set the text too.
-	 *  This is invoked from an imaginary node ref on right side of a
-	 *  rewrite rule as IMAG[$tokenLabel, "IMAG"].
-	 *
-	 *  This should invoke createToken(Token).
-	 */
-	public Object create(int tokenType, Token fromToken, String text);
-
-	/** Create a new node derived from a token, with a new token type.
-	 *  This is invoked from an imaginary node ref on right side of a
-	 *  rewrite rule as IMAG["IMAG"].
-	 *
-	 *  This should invoke createToken(int,String).
-	 */
-	public Object create(int tokenType, String text);
-
-
-	// C o n t e n t
-
-	/** For tree parsing, I need to know the token type of a node */
-	public int getType(Object t);
-
-	/** Node constructors can set the type of a node */
-	public void setType(Object t, int type);
-
-	public String getText(Object t);
-
-	/** Node constructors can set the text of a node */
-	public void setText(Object t, String text);
-
-	/** Return the token object from which this node was created.
-	 *  Currently used only for printing an error message.
-	 *  The error display routine in BaseRecognizer needs to
-	 *  display where the input the error occurred. If your
-	 *  tree of limitation does not store information that can
-	 *  lead you to the token, you can create a token filled with
-	 *  the appropriate information and pass that back.  See
-	 *  BaseRecognizer.getErrorMessage().
-	 */
-	public Token getToken(Object t);
-
-	/** Where are the bounds in the input token stream for this node and
-	 *  all children?  Each rule that creates AST nodes will call this
-	 *  method right before returning.  Flat trees (i.e., lists) will
-	 *  still usually have a nil root node just to hold the children list.
-	 *  That node would contain the start/stop indexes then.
-	 */
-	public void setTokenBoundaries(Object t, Token startToken, Token stopToken);
-
-	/** Get the token start index for this subtree; return -1 if no such index */
-	public int getTokenStartIndex(Object t);
-
-	/** Get the token stop index for this subtree; return -1 if no such index */
-	public int getTokenStopIndex(Object t);
-
-
-	// N a v i g a t i o n  /  T r e e  P a r s i n g
-
-	/** Get a child 0..n-1 node */
-	public Object getChild(Object t, int i);
-
-	/** Set ith child (0..n-1) to t; t must be non-null and non-nil node */
-	public void setChild(Object t, int i, Object child);
-
-	/** Remove ith child and shift children down from right. */
-	public Object deleteChild(Object t, int i);
-
-	/** How many children?  If 0, then this is a leaf node */
-	public int getChildCount(Object t);
-
-	/** Who is the parent node of this node; if null, implies node is root.
-	 *  If your node type doesn't handle this, it's ok but the tree rewrites
-	 *  in tree parsers need this functionality.
-	 */
-	public Object getParent(Object t);
-	public void setParent(Object t, Object parent);
-
-	/** What index is this node in the child list? Range: 0..n-1
-	 *  If your node type doesn't handle this, it's ok but the tree rewrites
-	 *  in tree parsers need this functionality.
-	 */
-	public int getChildIndex(Object t);
-	public void setChildIndex(Object t, int index);
-
-	/** Replace from start to stop child index of parent with t, which might
-	 *  be a list.  Number of children may be different
-	 *  after this call.
-	 *
-	 *  If parent is null, don't do anything; must be at root of overall tree.
-	 *  Can't replace whatever points to the parent externally.  Do nothing.
-	 */
-	public void replaceChildren(Object parent, int startChildIndex, int stopChildIndex, Object t);
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeFilter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeFilter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeFilter.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeFilter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,135 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognizerSharedState;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognitionException;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.TokenStream;
-
-/**
- Cut-n-paste from material I'm not using in the book anymore (edit later
- to make sense):
-
- Now, how are we going to test these tree patterns against every
-subtree in our original tree?  In what order should we visit nodes?
-For this application, it turns out we need a simple ``apply once''
-rule application strategy and a ``down then up'' tree traversal
-strategy.  Let's look at rule application first.
-
-As we visit each node, we need to see if any of our patterns match. If
-a pattern matches, we execute the associated tree rewrite and move on
-to the next node. In other words, we only look for a single rule
-application opportunity (we'll see below that we sometimes need to
-repeatedly apply rules). The following method applies a rule in a @cl
-TreeParser (derived from a tree grammar) to a tree:
-
-here is where weReferenced code/walking/patterns/TreePatternMatcher.java
-
-It uses reflection to lookup the appropriate rule within the generated
-tree parser class (@cl Simplify in this case). Most of the time, the
-rule will not match the tree.  To avoid issuing syntax errors and
-attempting error recovery, it bumps up the backtracking level.  Upon
-failure, the invoked rule immediately returns. If you don't plan on
-using this technique in your own ANTLR-based application, don't sweat
-the details. This method boils down to ``call a rule to match a tree,
-executing any embedded actions and rewrite rules.''
-
-At this point, we know how to define tree grammar rules and how to
-apply them to a particular subtree. The final piece of the tree
-pattern matcher is the actual tree traversal. We have to get the
-correct node visitation order.  In particular, we need to perform the
-scalar-vector multiply transformation on the way down (preorder) and
-we need to reduce multiply-by-zero subtrees on the way up (postorder).
-
-To implement a top-down visitor, we do a depth first walk of the tree,
-executing an action in the preorder position. To get a bottom-up
-visitor, we execute an action in the postorder position.  ANTLR
-provides a standard @cl TreeVisitor class with a depth first search @v
-visit method. That method executes either a @m pre or @m post method
-or both. In our case, we need to call @m applyOnce in both. On the way
-down, we'll look for @r vmult patterns. On the way up,
-we'll look for @r mult0 patterns.
- */
-public class TreeFilter extends TreeParser {
-    public interface fptr {
-        public void rule() throws RecognitionException;
-    }
-
-    protected TokenStream originalTokenStream;
-    protected TreeAdaptor originalAdaptor;
-
-    public TreeFilter(TreeNodeStream input) {
-        this(input, new RecognizerSharedState());
-    }
-    public TreeFilter(TreeNodeStream input, RecognizerSharedState state) {
-        super(input, state);
-        originalAdaptor = input.getTreeAdaptor();
-        originalTokenStream = input.getTokenStream();
-    }
-
-    public void applyOnce(Object t, fptr whichRule) {
-        if ( t==null ) return;
-        try {
-            // share TreeParser object but not parsing-related state
-            state = new RecognizerSharedState();
-            input = new CommonTreeNodeStream(originalAdaptor, t);
-            ((CommonTreeNodeStream)input).setTokenStream(originalTokenStream);
-            setBacktrackingLevel(1);
-            whichRule.rule();
-            setBacktrackingLevel(0);
-        }
-        catch (RecognitionException e) { ; }
-    }
-
-    public void downup(Object t) {
-        TreeVisitor v = new TreeVisitor(new CommonTreeAdaptor());
-        TreeVisitorAction actions = new TreeVisitorAction() {
-            public Object pre(Object t)  { applyOnce(t, topdown_fptr); return t; }
-            public Object post(Object t) { applyOnce(t, bottomup_fptr); return t; }
-        };
-        v.visit(t, actions);
-    }
-        
-    fptr topdown_fptr = new fptr() {
-        public void rule() throws RecognitionException {
-            topdown();
-        }
-    };
-
-    fptr bottomup_fptr = new fptr() {
-        public void rule() throws RecognitionException {
-            bottomup();
-        }
-    };
-
-    // methods the downup strategy uses to do the up and down rules.
-    // to override, just define tree grammar rule topdown and turn on
-    // filter=true.
-    public void topdown() throws RecognitionException {;}
-    public void bottomup() throws RecognitionException {;}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeIterator.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeIterator.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeIterator.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeIterator.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,131 +0,0 @@
-/*
-[The "BSD licence"]
-Copyright (c) 2005-2008 Terence Parr
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-3. The name of the author may not be used to endorse or promote products
-derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.misc.FastQueue;
-
-import java.util.Iterator;
-
-/** Return a node stream from a doubly-linked tree whose nodes
- *  know what child index they are.  No remove() is supported.
- *
- *  Emit navigation nodes (DOWN, UP, and EOF) to let show tree structure.
- */
-public class TreeIterator implements Iterator {
-    protected TreeAdaptor adaptor;
-    protected Object root;
-    protected Object tree;
-    protected boolean firstTime = true;
-
-    // navigation nodes to return during walk and at end
-    public Object up;
-    public Object down;
-    public Object eof;
-
-    /** If we emit UP/DOWN nodes, we need to spit out multiple nodes per
-     *  next() call.
-     */
-    protected FastQueue nodes;
-
-    public TreeIterator(Object tree) {
-        this(new CommonTreeAdaptor(),tree);
-    }
-
-    public TreeIterator(TreeAdaptor adaptor, Object tree) {
-        this.adaptor = adaptor;
-        this.tree = tree;
-        this.root = tree;
-        nodes = new FastQueue();
-        down = adaptor.create(Token.DOWN, "DOWN");
-        up = adaptor.create(Token.UP, "UP");
-        eof = adaptor.create(Token.EOF, "EOF");
-    }
-
-    public void reset() {
-        firstTime = true;
-        tree = root;
-        nodes.clear();
-    }
-
-    public boolean hasNext() {
-        if ( firstTime ) return root!=null;
-        if ( nodes!=null && nodes.size()>0 ) return true;
-        if ( tree==null ) return false;
-        if ( adaptor.getChildCount(tree)>0 ) return true;
-        return adaptor.getParent(tree)!=null; // back at root?
-    }
-
-    public Object next() {
-        if ( firstTime ) { // initial condition
-            firstTime = false;
-            if ( adaptor.getChildCount(tree)==0 ) { // single node tree (special)
-                nodes.add(eof);
-                return tree;
-            }
-            return tree;
-        }
-        // if any queued up, use those first
-        if ( nodes!=null && nodes.size()>0 ) return nodes.remove();
-
-        // no nodes left?
-        if ( tree==null ) return eof;
-
-        // next node will be child 0 if any children
-        if ( adaptor.getChildCount(tree)>0 ) {
-            tree = adaptor.getChild(tree, 0);
-            nodes.add(tree); // real node is next after DOWN
-            return down;
-        }
-        // if no children, look for next sibling of tree or ancestor
-        Object parent = adaptor.getParent(tree);
-        // while we're out of siblings, keep popping back up towards root
-        while ( parent!=null &&
-                adaptor.getChildIndex(tree)+1 >= adaptor.getChildCount(parent) )
-        {
-            nodes.add(up); // we're moving back up
-            tree = parent;
-            parent = adaptor.getParent(tree);
-        }
-        // no nodes left?
-        if ( parent==null ) {
-            tree = null; // back at root? nothing left then
-            nodes.add(eof); // add to queue, might have UP nodes in there
-            return nodes.remove();
-        }
-
-        // must have found a node with an unvisited sibling
-        // move to it and return it
-        int nextSiblingIndex = adaptor.getChildIndex(tree) + 1;
-        tree = adaptor.getChild(parent, nextSiblingIndex);
-        nodes.add(tree); // add to queue, might have UP nodes in there
-        return nodes.remove();
-    }
-
-    public void remove() { throw new UnsupportedOperationException(); }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/Tree.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/Tree.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/Tree.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/Tree.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,127 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-
-import java.util.List;
-
-/** What does a tree look like?  ANTLR has a number of support classes
- *  such as CommonTreeNodeStream that work on these kinds of trees.  You
- *  don't have to make your trees implement this interface, but if you do,
- *  you'll be able to use more support code.
- *
- *  NOTE: When constructing trees, ANTLR can build any kind of tree; it can
- *  even use Token objects as trees if you add a child list to your tokens.
- *
- *  This is a tree node without any payload; just navigation and factory stuff.
- */
-public interface Tree {
-	public static final Tree INVALID_NODE = new CommonTree(Token.INVALID_TOKEN);
-
-	Tree getChild(int i);
-
-	int getChildCount();
-
-	// Tree tracks parent and child index now > 3.0
-
-	public Tree getParent();
-
-	public void setParent(Tree t);
-
-    /** Is there is a node above with token type ttype? */
-    public boolean hasAncestor(int ttype);
-
-    /** Walk upwards and get first ancestor with this token type. */
-    public Tree getAncestor(int ttype);
-
-    /** Return a list of all ancestors of this node.  The first node of
-     *  list is the root and the last is the parent of this node.
-     */
-    public List getAncestors();
-
-    /** This node is what child index? 0..n-1 */
-	public int getChildIndex();
-
-	public void setChildIndex(int index);
-
-	/** Set the parent and child index values for all children */
-	public void freshenParentAndChildIndexes();
-
-	/** Add t as a child to this node.  If t is null, do nothing.  If t
-	 *  is nil, add all children of t to this' children.
-	 */
-	void addChild(Tree t);
-
-	/** Set ith child (0..n-1) to t; t must be non-null and non-nil node */
-	public void setChild(int i, Tree t);
-
-	public Object deleteChild(int i);
-
-	/** Delete children from start to stop and replace with t even if t is
-	 *  a list (nil-root tree).  num of children can increase or decrease.
-	 *  For huge child lists, inserting children can force walking rest of
-	 *  children to set their childindex; could be slow.
-	 */
-	public void replaceChildren(int startChildIndex, int stopChildIndex, Object t);	
-
-	/** Indicates the node is a nil node but may still have children, meaning
-	 *  the tree is a flat list.
-	 */
-	boolean isNil();
-
-	/**  What is the smallest token index (indexing from 0) for this node
-	 *   and its children?
-	 */
-	int getTokenStartIndex();
-
-	void setTokenStartIndex(int index);
-
-	/**  What is the largest token index (indexing from 0) for this node
-	 *   and its children?
-	 */
-	int getTokenStopIndex();
-
-	void setTokenStopIndex(int index);
-
-	Tree dupNode();
-
-	/** Return a token type; needed for tree parsing */
-	int getType();
-
-	String getText();
-
-	/** In case we don't have a token payload, what is the line for errors? */
-	int getLine();
-
-	int getCharPositionInLine();
-
-	String toStringTree();
-
-	String toString();
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeNodeStream.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeNodeStream.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeNodeStream.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeNodeStream.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,106 +0,0 @@
-/*
-[The "BSD licence"]
-Copyright (c) 2005-2008 Terence Parr
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-3. The name of the author may not be used to endorse or promote products
-derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.IntStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.TokenStream;
-
-/** A stream of tree nodes, accessing nodes from a tree of some kind */
-public interface TreeNodeStream extends IntStream {
-	/** Get a tree node at an absolute index i; 0..n-1.
-	 *  If you don't want to buffer up nodes, then this method makes no
-	 *  sense for you.
-	 */
-	public Object get(int i);
-
-	/** Get tree node at current input pointer + i ahead where i=1 is next node.
-	 *  i<0 indicates nodes in the past.  So LT(-1) is previous node, but
-	 *  implementations are not required to provide results for k < -1.
-	 *  LT(0) is undefined.  For i>=n, return null.
-	 *  Return null for LT(0) and any index that results in an absolute address
-	 *  that is negative.
-	 *
-	 *  This is analogus to the LT() method of the TokenStream, but this
-	 *  returns a tree node instead of a token.  Makes code gen identical
-	 *  for both parser and tree grammars. :)
-	 */
-	public Object LT(int k);
-
-	/** Where is this stream pulling nodes from?  This is not the name, but
-	 *  the object that provides node objects.
-	 */
-	public Object getTreeSource();
-
-	/** If the tree associated with this stream was created from a TokenStream,
-	 *  you can specify it here.  Used to do rule $text attribute in tree
-	 *  parser.  Optional unless you use tree parser rule text attribute
-	 *  or output=template and rewrite=true options.
-	 */
-	public TokenStream getTokenStream();
-
-	/** What adaptor can tell me how to interpret/navigate nodes and
-	 *  trees.  E.g., get text of a node.
-	 */
-	public TreeAdaptor getTreeAdaptor();
-
-	/** As we flatten the tree, we use UP, DOWN nodes to represent
-	 *  the tree structure.  When debugging we need unique nodes
-	 *  so we have to instantiate new ones.  When doing normal tree
-	 *  parsing, it's slow and a waste of memory to create unique
-	 *  navigation nodes.  Default should be false;
-	 */
-	public void setUniqueNavigationNodes(boolean uniqueNavigationNodes);
-
-    /** Reset the tree node stream in such a way that it acts like
-     *  a freshly constructed stream.
-     */
-    public void reset();
-
-	/** Return the text of all nodes from start to stop, inclusive.
-	 *  If the stream does not buffer all the nodes then it can still
-	 *  walk recursively from start until stop.  You can always return
-	 *  null or "" too, but users should not access $ruleLabel.text in
-	 *  an action of course in that case.
-	 */
-	public String toString(Object start, Object stop);
-
-
-	// REWRITING TREES (used by tree parser)
-
-	/** Replace from start to stop child index of parent with t, which might
-	 *  be a list.  Number of children may be different
-	 *  after this call.  The stream is notified because it is walking the
-	 *  tree and might need to know you are monkeying with the underlying
-	 *  tree.  Also, it might be able to modify the node stream to avoid
-	 *  restreaming for future phases.
-	 *
-	 *  If parent is null, don't do anything; must be at root of overall tree.
-	 *  Can't replace whatever points to the parent externally.  Do nothing.
-	 */
-	public void replaceChildren(Object parent, int startChildIndex, int stopChildIndex, Object t);
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeParser.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeParser.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeParser.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeParser.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,168 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.*;
-
-import java.util.regex.Pattern;
-import java.util.regex.Matcher;
-
-/** A parser for a stream of tree nodes.  "tree grammars" result in a subclass
- *  of this.  All the error reporting and recovery is shared with Parser via
- *  the BaseRecognizer superclass.
-*/
-public class TreeParser extends BaseRecognizer {
-	public static final int DOWN = Token.DOWN;
-	public static final int UP = Token.UP;
-
-    // precompiled regex used by inContext
-    static String dotdot = ".*[^.]\\.\\.[^.].*";
-    static String doubleEtc = ".*\\.\\.\\.\\s+\\.\\.\\..*";
-    static Pattern dotdotPattern = Pattern.compile(dotdot);
-    static Pattern doubleEtcPattern = Pattern.compile(doubleEtc);
-
-	protected TreeNodeStream input;
-
-	public TreeParser(TreeNodeStream input) {
-		super(); // highlight that we go to super to set state object
-		setTreeNodeStream(input);
-	}
-
-	public TreeParser(TreeNodeStream input, RecognizerSharedState state) {
-		super(state); // share the state object with another parser
-		setTreeNodeStream(input);
-    }
-
-	public void reset() {
-		super.reset(); // reset all recognizer state variables
-		if ( input!=null ) {
-			input.seek(0); // rewind the input
-		}
-	}
-
-	/** Set the input stream */
-	public void setTreeNodeStream(TreeNodeStream input) {
-		this.input = input;
-	}
-
-	public TreeNodeStream getTreeNodeStream() {
-		return input;
-	}
-
-	public String getSourceName() {
-		return input.getSourceName();
-	}
-
-	protected Object getCurrentInputSymbol(IntStream input) {
-		return ((TreeNodeStream)input).LT(1);
-	}
-
-	protected Object getMissingSymbol(IntStream input,
-									  RecognitionException e,
-									  int expectedTokenType,
-									  BitSet follow)
-	{
-		String tokenText =
-			"<missing "+getTokenNames()[expectedTokenType]+">";
-		return new CommonTree(new CommonToken(expectedTokenType, tokenText));
-	}
-
-    /** Match '.' in tree parser has special meaning.  Skip node or
-	 *  entire tree if node has children.  If children, scan until
-	 *  corresponding UP node.
-	 */
-	public void matchAny(IntStream ignore) { // ignore stream, copy of input
-		state.errorRecovery = false;
-		state.failed = false;
-		Object look = input.LT(1);
-		if ( input.getTreeAdaptor().getChildCount(look)==0 ) {
-			input.consume(); // not subtree, consume 1 node and return
-			return;
-		}
-		// current node is a subtree, skip to corresponding UP.
-		// must count nesting level to get right UP
-		int level=0;
-		int tokenType = input.getTreeAdaptor().getType(look);
-		while ( tokenType!=Token.EOF && !(tokenType==UP && level==0) ) {
-			input.consume();
-			look = input.LT(1);
-			tokenType = input.getTreeAdaptor().getType(look);
-			if ( tokenType == DOWN ) {
-				level++;
-			}
-			else if ( tokenType == UP ) {
-				level--;
-			}
-		}
-		input.consume(); // consume UP
-	}
-
-    /** We have DOWN/UP nodes in the stream that have no line info; override.
-	 *  plus we want to alter the exception type.  Don't try to recover
-	 *  from tree parser errors inline...
-     */
-    protected Object recoverFromMismatchedToken(IntStream input,
-                                                int ttype,
-                                                BitSet follow)
-        throws RecognitionException
-    {
-        throw new MismatchedTreeNodeException(ttype, (TreeNodeStream)input);
-    }
-
-    /** Prefix error message with the grammar name because message is
-	 *  always intended for the programmer because the parser built
-	 *  the input tree not the user.
-	 */
-	public String getErrorHeader(RecognitionException e) {
-		return getGrammarFileName()+": node from "+
-			   (e.approximateLineInfo?"after ":"")+"line "+e.line+":"+e.charPositionInLine;
-	}
-
-	/** Tree parsers parse nodes they usually have a token object as
-	 *  payload. Set the exception token and do the default behavior.
-	 */
-	public String getErrorMessage(RecognitionException e, String[] tokenNames) {
-		if ( this instanceof TreeParser ) {
-			TreeAdaptor adaptor = ((TreeNodeStream)e.input).getTreeAdaptor();
-			e.token = adaptor.getToken(e.node);
-			if ( e.token==null ) { // could be an UP/DOWN node
-				e.token = new CommonToken(adaptor.getType(e.node),
-										  adaptor.getText(e.node));
-			}
-		}
-		return super.getErrorMessage(e, tokenNames);
-	}
-
-	public void traceIn(String ruleName, int ruleIndex)  {
-		super.traceIn(ruleName, ruleIndex, input.LT(1));
-	}
-
-	public void traceOut(String ruleName, int ruleIndex)  {
-		super.traceOut(ruleName, ruleIndex, input.LT(1));
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreePatternLexer.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreePatternLexer.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreePatternLexer.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreePatternLexer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,135 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-public class TreePatternLexer {
-	public static final int EOF = -1;
-	public static final int BEGIN = 1;
-	public static final int END = 2;
-	public static final int ID = 3;
-	public static final int ARG = 4;
-	public static final int PERCENT = 5;
-	public static final int COLON = 6;
-	public static final int DOT = 7;
-
-	/** The tree pattern to lex like "(A B C)" */
-	protected String pattern;
-
-	/** Index into input string */
-	protected int p = -1;
-
-	/** Current char */
-	protected int c;
-
-	/** How long is the pattern in char? */
-	protected int n;
-
-	/** Set when token type is ID or ARG (name mimics Java's StreamTokenizer) */
-	public StringBuffer sval = new StringBuffer();
-
-	public boolean error = false;
-
-	public TreePatternLexer(String pattern) {
-		this.pattern = pattern;
-		this.n = pattern.length();
-		consume();
-	}
-
-	public int nextToken() {
-		sval.setLength(0); // reset, but reuse buffer
-		while ( c != EOF ) {
-			if ( c==' ' || c=='\n' || c=='\r' || c=='\t' ) {
-				consume();
-				continue;
-			}
-			if ( (c>='a' && c<='z') || (c>='A' && c<='Z') || c=='_' ) {
-				sval.append((char)c);
-				consume();
-				while ( (c>='a' && c<='z') || (c>='A' && c<='Z') ||
-						(c>='0' && c<='9') || c=='_' )
-				{
-					sval.append((char)c);
-					consume();
-				}
-				return ID;
-			}
-			if ( c=='(' ) {
-				consume();
-				return BEGIN;
-			}
-			if ( c==')' ) {
-				consume();
-				return END;
-			}
-			if ( c=='%' ) {
-				consume();
-				return PERCENT;
-			}
-			if ( c==':' ) {
-				consume();
-				return COLON;
-			}
-			if ( c=='.' ) {
-				consume();
-				return DOT;
-			}
-			if ( c=='[' ) { // grab [x] as a string, returning x
-				consume();
-				while ( c!=']' ) {
-					if ( c=='\\' ) {
-						consume();
-						if ( c!=']' ) {
-							sval.append('\\');
-						}
-						sval.append((char)c);
-					}
-					else {
-						sval.append((char)c);
-					}
-					consume();
-				}
-				consume();
-				return ARG;
-			}
-			consume();
-			error = true;
-			return EOF;
-		}
-		return EOF;
-	}
-
-	protected void consume() {
-		p++;
-		if ( p>=n ) {
-			c = EOF;
-		}
-		else {
-			c = pattern.charAt(p);
-		}
-	}
-}
\ Manca newline alla fine del file
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreePatternParser.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreePatternParser.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreePatternParser.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreePatternParser.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,156 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.CommonToken;
-
-public class TreePatternParser {
-	protected TreePatternLexer tokenizer;
-	protected int ttype;
-	protected TreeWizard wizard;
-	protected TreeAdaptor adaptor;
-
-	public TreePatternParser(TreePatternLexer tokenizer, TreeWizard wizard, TreeAdaptor adaptor) {
-		this.tokenizer = tokenizer;
-		this.wizard = wizard;
-		this.adaptor = adaptor;
-		ttype = tokenizer.nextToken(); // kickstart
-	}
-
-	public Object pattern() {
-		if ( ttype==TreePatternLexer.BEGIN ) {
-			return parseTree();
-		}
-		else if ( ttype==TreePatternLexer.ID ) {
-			Object node = parseNode();
-			if ( ttype==TreePatternLexer.EOF ) {
-				return node;
-			}
-			return null; // extra junk on end
-		}
-		return null;
-	}
-
-	public Object parseTree() {
-		if ( ttype != TreePatternLexer.BEGIN ) {
-			System.out.println("no BEGIN");
-			return null;
-		}
-		ttype = tokenizer.nextToken();
-		Object root = parseNode();
-		if ( root==null ) {
-			return null;
-		}
-		while ( ttype==TreePatternLexer.BEGIN ||
-				ttype==TreePatternLexer.ID ||
-				ttype==TreePatternLexer.PERCENT ||
-				ttype==TreePatternLexer.DOT )
-		{
-			if ( ttype==TreePatternLexer.BEGIN ) {
-				Object subtree = parseTree();
-				adaptor.addChild(root, subtree);
-			}
-			else {
-				Object child = parseNode();
-				if ( child==null ) {
-					return null;
-				}
-				adaptor.addChild(root, child);
-			}
-		}
-		if ( ttype != TreePatternLexer.END ) {
-			System.out.println("no END");
-			return null;
-		}
-		ttype = tokenizer.nextToken();
-		return root;
-	}
-
-	public Object parseNode() {
-		// "%label:" prefix
-		String label = null;
-		if ( ttype == TreePatternLexer.PERCENT ) {
-			ttype = tokenizer.nextToken();
-			if ( ttype != TreePatternLexer.ID ) {
-				return null;
-			}
-			label = tokenizer.sval.toString();
-			ttype = tokenizer.nextToken();
-			if ( ttype != TreePatternLexer.COLON ) {
-				return null;
-			}
-			ttype = tokenizer.nextToken(); // move to ID following colon
-		}
-
-		// Wildcard?
-		if ( ttype == TreePatternLexer.DOT ) {
-			ttype = tokenizer.nextToken();
-			Token wildcardPayload = new CommonToken(0, ".");
-			TreeWizard.TreePattern node =
-				new TreeWizard.WildcardTreePattern(wildcardPayload);
-			if ( label!=null ) {
-				node.label = label;
-			}
-			return node;
-		}
-
-		// "ID" or "ID[arg]"
-		if ( ttype != TreePatternLexer.ID ) {
-			return null;
-		}
-		String tokenName = tokenizer.sval.toString();
-		ttype = tokenizer.nextToken();
-		if ( tokenName.equals("nil") ) {
-			return adaptor.nil();
-		}
-		String text = tokenName;
-		// check for arg
-		String arg = null;
-		if ( ttype == TreePatternLexer.ARG ) {
-			arg = tokenizer.sval.toString();
-			text = arg;
-			ttype = tokenizer.nextToken();
-		}
-		
-		// create node
-		int treeNodeType = wizard.getTokenType(tokenName);
-		if ( treeNodeType==Token.INVALID_TOKEN_TYPE ) {
-			return null;
-		}
-		Object node;
-		node = adaptor.create(treeNodeType, text);
-		if ( label!=null && node.getClass()==TreeWizard.TreePattern.class ) {
-			((TreeWizard.TreePattern)node).label = label;
-		}
-		if ( arg!=null && node.getClass()==TreeWizard.TreePattern.class ) {
-			((TreeWizard.TreePattern)node).hasTextArg = true;
-		}
-		return node;
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeRewriter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeRewriter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeRewriter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeRewriter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,120 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognizerSharedState;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognitionException;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.TokenStream;
-
-public class TreeRewriter extends TreeParser {
-    public interface fptr {
-        public Object rule() throws RecognitionException;
-    }
-
-    protected boolean showTransformations = false;
-
-    protected TokenStream originalTokenStream;
-    protected TreeAdaptor originalAdaptor;
-    
-    public TreeRewriter(TreeNodeStream input) {
-        this(input, new RecognizerSharedState());
-    }
-    public TreeRewriter(TreeNodeStream input, RecognizerSharedState state) {
-        super(input, state);
-        originalAdaptor = input.getTreeAdaptor();
-        originalTokenStream = input.getTokenStream();        
-    }
-
-    public Object applyOnce(Object t, fptr whichRule) {
-        if ( t==null ) return null;
-        try {
-            // share TreeParser object but not parsing-related state
-            state = new RecognizerSharedState();
-            input = new CommonTreeNodeStream(originalAdaptor, t);
-            ((CommonTreeNodeStream)input).setTokenStream(originalTokenStream);
-            setBacktrackingLevel(1);
-            TreeRuleReturnScope r = (TreeRuleReturnScope)whichRule.rule();
-            setBacktrackingLevel(0);
-            if ( failed() ) return t;
-            if ( showTransformations &&
-                 r!=null && !t.equals(r.getTree()) && r.getTree()!=null )
-            {
-                reportTransformation(t, r.getTree());
-            }
-            if ( r!=null && r.getTree()!=null ) return r.getTree();
-            else return t;
-        }
-        catch (RecognitionException e) { ; }
-        return t;
-    }
-
-    public Object applyRepeatedly(Object t, fptr whichRule) {
-        boolean treeChanged = true;
-        while ( treeChanged ) {
-            Object u = applyOnce(t, whichRule);
-            treeChanged = !t.equals(u);
-            t = u;
-        }
-        return t;
-    }
-
-    public Object downup(Object t) { return downup(t, false); }
-
-    public Object downup(Object t, boolean showTransformations) {
-        this.showTransformations = showTransformations;
-        TreeVisitor v = new TreeVisitor(new CommonTreeAdaptor());
-        TreeVisitorAction actions = new TreeVisitorAction() {
-            public Object pre(Object t)  { return applyOnce(t, topdown_fptr); }
-            public Object post(Object t) { return applyRepeatedly(t, bottomup_ftpr); }
-        };
-        t = v.visit(t, actions);
-        return t;
-    }
-
-    /** Override this if you need transformation tracing to go somewhere
-     *  other than stdout or if you're not using Tree-derived trees.
-     */
-    public void reportTransformation(Object oldTree, Object newTree) {
-        System.out.println(((Tree)oldTree).toStringTree()+" -> "+
-                           ((Tree)newTree).toStringTree());
-    }
-
-    fptr topdown_fptr = new fptr() {
-        public Object rule() throws RecognitionException { return topdown(); }
-    };
-    
-    fptr bottomup_ftpr = new fptr() {
-        public Object rule() throws RecognitionException { return bottomup(); }
-    };
-
-    // methods the downup strategy uses to do the up and down rules.
-    // to override, just define tree grammar rule topdown and turn on
-    // filter=true.
-    public Object topdown() throws RecognitionException { return null; }
-    public Object bottomup() throws RecognitionException { return null; }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeRuleReturnScope.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeRuleReturnScope.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeRuleReturnScope.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeRuleReturnScope.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RuleReturnScope;
-
-/** This is identical to the ParserRuleReturnScope except that
- *  the start property is a tree nodes not Token object
- *  when you are parsing trees.  To be generic the tree node types
- *  have to be Object.
- */
-public class TreeRuleReturnScope extends RuleReturnScope {
-	/** First node or root node of tree matched for this rule. */
-	public Object start;
-	public Object getStart() { return start; }	
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeVisitorAction.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeVisitorAction.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeVisitorAction.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeVisitorAction.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,19 +0,0 @@
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-/** How to execute code for node t when a visitor visits node t.  Execute
- *  pre() before visiting children and execute post() after visiting children.
- */
-public interface TreeVisitorAction {
-    /** Execute an action before visiting children of t.  Return t or
-     *  a rewritten t.  It is up to the visitor to decide what to do
-     *  with the return value.  Children of returned value will be
-     *  visited if using TreeVisitor.visit().
-     */
-    public Object pre(Object t);
-
-    /** Execute an action after visiting children of t.  Return t or
-     *  a rewritten t.  It is up to the visitor to decide what to do
-     *  with the return value.
-     */
-    public Object post(Object t);
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-/** Do a depth first walk of a tree, applying pre() and post() actions
- *  as we discover and finish nodes.
- */
-public class TreeVisitor {
-    protected TreeAdaptor adaptor;
-    
-    public TreeVisitor(TreeAdaptor adaptor) {
-        this.adaptor = adaptor;
-    }
-    public TreeVisitor() { this(new CommonTreeAdaptor()); }
-    
-    /** Visit every node in tree t and trigger an action for each node
-     *  before/after having visited all of its children.
-     *  Execute both actions even if t has no children.
-     *  If a child visit yields a new child, it can update its
-     *  parent's child list or just return the new child.  The
-     *  child update code works even if the child visit alters its parent
-     *  and returns the new tree.
-     *
-     *  Return result of applying post action to this node.
-     */
-    public Object visit(Object t, TreeVisitorAction action) {
-        // System.out.println("visit "+((Tree)t).toStringTree());
-        boolean isNil = adaptor.isNil(t);
-        if ( action!=null && !isNil ) {
-            t = action.pre(t); // if rewritten, walk children of new t
-        }
-        int n = adaptor.getChildCount(t);
-        for (int i=0; i<n; i++) {
-            Object child = adaptor.getChild(t, i);
-            Object visitResult = visit(child, action);
-            Object childAfterVisit = adaptor.getChild(t, i);
-            if ( visitResult !=  childAfterVisit ) { // result & child differ?
-                adaptor.setChild(t, i, visitResult);
-            }
-        }
-        if ( action!=null && !isNil ) t = action.post(t);
-        return t;
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeWizard.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeWizard.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeWizard.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/tree/TreeWizard.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,528 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime.tree;
-
-import org.eclipse.persistence.internal.libraries.antlr.runtime.Token;
-
-import java.util.*;
-
-/** Build and navigate trees with this object.  Must know about the names
- *  of tokens so you have to pass in a map or array of token names (from which
- *  this class can build the map).  I.e., Token DECL means nothing unless the
- *  class can translate it to a token type.
- *
- *  In order to create nodes and navigate, this class needs a TreeAdaptor.
- *
- *  This class can build a token type -> node index for repeated use or for
- *  iterating over the various nodes with a particular type.
- *
- *  This class works in conjunction with the TreeAdaptor rather than moving
- *  all this functionality into the adaptor.  An adaptor helps build and
- *  navigate trees using methods.  This class helps you do it with string
- *  patterns like "(A B C)".  You can create a tree from that pattern or
- *  match subtrees against it.
- */
-public class TreeWizard {
-	protected TreeAdaptor adaptor;
-	protected Map tokenNameToTypeMap;
-
-	public interface ContextVisitor {
-		// TODO: should this be called visit or something else?
-		public void visit(Object t, Object parent, int childIndex, Map labels);
-	}
-
-	public static abstract class Visitor implements ContextVisitor {
-		public void visit(Object t, Object parent, int childIndex, Map labels) {
-			visit(t);
-		}
-		public abstract void visit(Object t);
-	}
-
-	/** When using %label:TOKENNAME in a tree for parse(), we must
-	 *  track the label.
-	 */
-	public static class TreePattern extends CommonTree {
-		public String label;
-		public boolean hasTextArg;
-		public TreePattern(Token payload) {
-			super(payload);
-		}
-		public String toString() {
-			if ( label!=null ) {
-				return "%"+label+":"+super.toString();
-			}
-			else {
-				return super.toString();				
-			}
-		}
-	}
-
-	public static class WildcardTreePattern extends TreePattern {
-		public WildcardTreePattern(Token payload) {
-			super(payload);
-		}
-	}
-
-	/** This adaptor creates TreePattern objects for use during scan() */
-	public static class TreePatternTreeAdaptor extends CommonTreeAdaptor {
-		public Object create(Token payload) {
-			return new TreePattern(payload);
-		}
-	}
-
-	// TODO: build indexes for the wizard
-
-	/** During fillBuffer(), we can make a reverse index from a set
-	 *  of token types of interest to the list of indexes into the
-	 *  node stream.  This lets us convert a node pointer to a
-	 *  stream index semi-efficiently for a list of interesting
-	 *  nodes such as function definition nodes (you'll want to seek
-	 *  to their bodies for an interpreter).  Also useful for doing
-	 *  dynamic searches; i.e., go find me all PLUS nodes.
-	protected Map tokenTypeToStreamIndexesMap;
-
-	/** If tokenTypesToReverseIndex set to INDEX_ALL then indexing
-	 *  occurs for all token types.
-	public static final Set INDEX_ALL = new HashSet();
-
-	/** A set of token types user would like to index for faster lookup.
-	 *  If this is INDEX_ALL, then all token types are tracked.  If null,
-	 *  then none are indexed.
-	protected Set tokenTypesToReverseIndex = null;
-	*/
-
-	public TreeWizard(TreeAdaptor adaptor) {
-		this.adaptor = adaptor;
-	}
-
-	public TreeWizard(TreeAdaptor adaptor, Map tokenNameToTypeMap) {
-		this.adaptor = adaptor;
-		this.tokenNameToTypeMap = tokenNameToTypeMap;
-	}
-
-	public TreeWizard(TreeAdaptor adaptor, String[] tokenNames) {
-		this.adaptor = adaptor;
-		this.tokenNameToTypeMap = computeTokenTypes(tokenNames);
-	}
-
-	public TreeWizard(String[] tokenNames) {
-		this(null, tokenNames);
-	}
-
-	/** Compute a Map<String, Integer> that is an inverted index of
-	 *  tokenNames (which maps int token types to names).
-	 */
-	public Map computeTokenTypes(String[] tokenNames) {
-		Map m = new HashMap();
-		if ( tokenNames==null ) {
-			return m;
-		}
-		for (int ttype = Token.MIN_TOKEN_TYPE; ttype < tokenNames.length; ttype++) {
-			String name = tokenNames[ttype];
-			m.put(name, new Integer(ttype));
-		}
-		return m;
-	}
-
-	/** Using the map of token names to token types, return the type. */
-	public int getTokenType(String tokenName) {
-	 	if ( tokenNameToTypeMap==null ) {
-			 return Token.INVALID_TOKEN_TYPE;
-		 }
-		Integer ttypeI = (Integer)tokenNameToTypeMap.get(tokenName);
-		if ( ttypeI!=null ) {
-			return ttypeI.intValue();
-		}
-		return Token.INVALID_TOKEN_TYPE;
-	}
-
-	/** Walk the entire tree and make a node name to nodes mapping.
-	 *  For now, use recursion but later nonrecursive version may be
-	 *  more efficient.  Returns Map<Integer, List> where the List is
-	 *  of your AST node type.  The Integer is the token type of the node.
-	 *
-	 *  TODO: save this index so that find and visit are faster
-	 */
-	public Map index(Object t) {
-		Map m = new HashMap();
-		_index(t, m);
-		return m;
-	}
-
-	/** Do the work for index */
-	protected void _index(Object t, Map m) {
-		if ( t==null ) {
-			return;
-		}
-		int ttype = adaptor.getType(t);
-		List elements = (List)m.get(new Integer(ttype));
-		if ( elements==null ) {
-			elements = new ArrayList();
-			m.put(new Integer(ttype), elements);
-		}
-		elements.add(t);
-		int n = adaptor.getChildCount(t);
-		for (int i=0; i<n; i++) {
-			Object child = adaptor.getChild(t, i);
-			_index(child, m);
-		}
-	}
-
-	/** Return a List of tree nodes with token type ttype */
-	public List find(Object t, int ttype) {
-		final List nodes = new ArrayList();
-		visit(t, ttype, new TreeWizard.Visitor() {
-			public void visit(Object t) {
-				nodes.add(t);
-			}
-		});
-		return nodes;
-	}
-
-	/** Return a List of subtrees matching pattern. */
-	public List find(Object t, String pattern) {
-		final List subtrees = new ArrayList();
-		// Create a TreePattern from the pattern
-		TreePatternLexer tokenizer = new TreePatternLexer(pattern);
-		TreePatternParser parser =
-			new TreePatternParser(tokenizer, this, new TreePatternTreeAdaptor());
-		final TreePattern tpattern = (TreePattern)parser.pattern();
-		// don't allow invalid patterns
-		if ( tpattern==null ||
-			 tpattern.isNil() ||
-			 tpattern.getClass()==WildcardTreePattern.class )
-		{
-			return null;
-		}
-		int rootTokenType = tpattern.getType();
-		visit(t, rootTokenType, new TreeWizard.ContextVisitor() {
-			public void visit(Object t, Object parent, int childIndex, Map labels) {
-				if ( _parse(t, tpattern, null) ) {
-					subtrees.add(t);
-				}
-			}
-		});
-		return subtrees;
-	}
-
-	public Object findFirst(Object t, int ttype) {
-		return null;
-	}
-
-	public Object findFirst(Object t, String pattern) {
-		return null;
-	}
-
-	/** Visit every ttype node in t, invoking the visitor.  This is a quicker
-	 *  version of the general visit(t, pattern) method.  The labels arg
-	 *  of the visitor action method is never set (it's null) since using
-	 *  a token type rather than a pattern doesn't let us set a label.
-	 */
-	public void visit(Object t, int ttype, ContextVisitor visitor) {
-		_visit(t, null, 0, ttype, visitor);
-	}
-
-	/** Do the recursive work for visit */
-	protected void _visit(Object t, Object parent, int childIndex, int ttype, ContextVisitor visitor) {
-		if ( t==null ) {
-			return;
-		}
-		if ( adaptor.getType(t)==ttype ) {
-			visitor.visit(t, parent, childIndex, null);
-		}
-		int n = adaptor.getChildCount(t);
-		for (int i=0; i<n; i++) {
-			Object child = adaptor.getChild(t, i);
-			_visit(child, t, i, ttype, visitor);
-		}
-	}
-
-	/** For all subtrees that match the pattern, execute the visit action.
-	 *  The implementation uses the root node of the pattern in combination
-	 *  with visit(t, ttype, visitor) so nil-rooted patterns are not allowed.
-	 *  Patterns with wildcard roots are also not allowed.
-	 */
-	public void visit(Object t, final String pattern, final ContextVisitor visitor) {
-		// Create a TreePattern from the pattern
-		TreePatternLexer tokenizer = new TreePatternLexer(pattern);
-		TreePatternParser parser =
-			new TreePatternParser(tokenizer, this, new TreePatternTreeAdaptor());
-		final TreePattern tpattern = (TreePattern)parser.pattern();
-		// don't allow invalid patterns
-		if ( tpattern==null ||
-			 tpattern.isNil() ||
-			 tpattern.getClass()==WildcardTreePattern.class )
-		{
-			return;
-		}
-		final Map labels = new HashMap(); // reused for each _parse
-		int rootTokenType = tpattern.getType();
-		visit(t, rootTokenType, new TreeWizard.ContextVisitor() {
-			public void visit(Object t, Object parent, int childIndex, Map unusedlabels) {
-				// the unusedlabels arg is null as visit on token type doesn't set.
-				labels.clear();
-				if ( _parse(t, tpattern, labels) ) {
-					visitor.visit(t, parent, childIndex, labels);
-				}
-			}
-		});
-	}
-
-	/** Given a pattern like (ASSIGN %lhs:ID %rhs:.) with optional labels
-	 *  on the various nodes and '.' (dot) as the node/subtree wildcard,
-	 *  return true if the pattern matches and fill the labels Map with
-	 *  the labels pointing at the appropriate nodes.  Return false if
-	 *  the pattern is malformed or the tree does not match.
-	 *
-	 *  If a node specifies a text arg in pattern, then that must match
-	 *  for that node in t.
-	 *
-	 *  TODO: what's a better way to indicate bad pattern? Exceptions are a hassle 
-	 */
-	public boolean parse(Object t, String pattern, Map labels) {
-		TreePatternLexer tokenizer = new TreePatternLexer(pattern);
-		TreePatternParser parser =
-			new TreePatternParser(tokenizer, this, new TreePatternTreeAdaptor());
-		TreePattern tpattern = (TreePattern)parser.pattern();
-		/*
-		System.out.println("t="+((Tree)t).toStringTree());
-		System.out.println("scant="+tpattern.toStringTree());
-		*/
-		boolean matched = _parse(t, tpattern, labels);
-		return matched;
-	}
-
-	public boolean parse(Object t, String pattern) {
-		return parse(t, pattern, null);
-	}
-
-	/** Do the work for parse. Check to see if the t2 pattern fits the
-	 *  structure and token types in t1.  Check text if the pattern has
-	 *  text arguments on nodes.  Fill labels map with pointers to nodes
-	 *  in tree matched against nodes in pattern with labels.
-	 */
-	protected boolean _parse(Object t1, TreePattern tpattern, Map labels) {
-		// make sure both are non-null
-		if ( t1==null || tpattern==null ) {
-			return false;
-		}
-		// check roots (wildcard matches anything)
-		if ( tpattern.getClass() != WildcardTreePattern.class ) {
-			if ( adaptor.getType(t1) != tpattern.getType() ) return false;
-            // if pattern has text, check node text
-			if ( tpattern.hasTextArg && !adaptor.getText(t1).equals(tpattern.getText()) ) {
-				return false;
-			}
-		}
-		if ( tpattern.label!=null && labels!=null ) {
-			// map label in pattern to node in t1
-			labels.put(tpattern.label, t1);
-		}
-		// check children
-		int n1 = adaptor.getChildCount(t1);
-		int n2 = tpattern.getChildCount();
-		if ( n1 != n2 ) {
-			return false;
-		}
-		for (int i=0; i<n1; i++) {
-			Object child1 = adaptor.getChild(t1, i);
-			TreePattern child2 = (TreePattern)tpattern.getChild(i);
-			if ( !_parse(child1, child2, labels) ) {
-				return false;
-			}
-		}
-		return true;
-	}
-
-	/** Create a tree or node from the indicated tree pattern that closely
-	 *  follows ANTLR tree grammar tree element syntax:
-	 *
-	 * 		(root child1 ... child2).
-	 *
-	 *  You can also just pass in a node: ID
-	 * 
-	 *  Any node can have a text argument: ID[foo]
-	 *  (notice there are no quotes around foo--it's clear it's a string).
-	 *
-	 *  nil is a special name meaning "give me a nil node".  Useful for
-	 *  making lists: (nil A B C) is a list of A B C.
- 	 */
-	public Object create(String pattern) {
-		TreePatternLexer tokenizer = new TreePatternLexer(pattern);
-		TreePatternParser parser = new TreePatternParser(tokenizer, this, adaptor);
-		Object t = parser.pattern();
-		return t;
-	}
-
-	/** Compare t1 and t2; return true if token types/text, structure match exactly.
-	 *  The trees are examined in their entirety so that (A B) does not match
-	 *  (A B C) nor (A (B C)). 
-	 // TODO: allow them to pass in a comparator
-	 *  TODO: have a version that is nonstatic so it can use instance adaptor
-	 *
-	 *  I cannot rely on the tree node's equals() implementation as I make
-	 *  no constraints at all on the node types nor interface etc... 
-	 */
-	public static boolean equals(Object t1, Object t2, TreeAdaptor adaptor) {
-		return _equals(t1, t2, adaptor);
-	}
-
-	/** Compare type, structure, and text of two trees, assuming adaptor in
-	 *  this instance of a TreeWizard.
-	 */
-	public boolean equals(Object t1, Object t2) {
-		return _equals(t1, t2, adaptor);
-	}
-
-	protected static boolean _equals(Object t1, Object t2, TreeAdaptor adaptor) {
-		// make sure both are non-null
-		if ( t1==null || t2==null ) {
-			return false;
-		}
-		// check roots
-		if ( adaptor.getType(t1) != adaptor.getType(t2) ) {
-			return false;
-		}
-		if ( !adaptor.getText(t1).equals(adaptor.getText(t2)) ) {
-			return false;
-		}
-		// check children
-		int n1 = adaptor.getChildCount(t1);
-		int n2 = adaptor.getChildCount(t2);
-		if ( n1 != n2 ) {
-			return false;
-		}
-		for (int i=0; i<n1; i++) {
-			Object child1 = adaptor.getChild(t1, i);
-			Object child2 = adaptor.getChild(t2, i);
-			if ( !_equals(child1, child2, adaptor) ) {
-				return false;
-			}
-		}
-		return true;
-	}
-
-	// TODO: next stuff taken from CommonTreeNodeStream
-	
-		/** Given a node, add this to the reverse index tokenTypeToStreamIndexesMap.
-	 *  You can override this method to alter how indexing occurs.  The
-	 *  default is to create a
-	 *
-	 *    Map<Integer token type,ArrayList<Integer stream index>>
-	 *
-	 *  This data structure allows you to find all nodes with type INT in order.
-	 *
-	 *  If you really need to find a node of type, say, FUNC quickly then perhaps
-	 *
-	 *    Map<Integertoken type,Map<Object tree node,Integer stream index>>
-	 *
-	 *  would be better for you.  The interior maps map a tree node to
-	 *  the index so you don't have to search linearly for a specific node.
-	 *
-	 *  If you change this method, you will likely need to change
-	 *  getNodeIndex(), which extracts information.
-	protected void fillReverseIndex(Object node, int streamIndex) {
-		//System.out.println("revIndex "+node+"@"+streamIndex);
-		if ( tokenTypesToReverseIndex==null ) {
-			return; // no indexing if this is empty (nothing of interest)
-		}
-		if ( tokenTypeToStreamIndexesMap==null ) {
-			tokenTypeToStreamIndexesMap = new HashMap(); // first indexing op
-		}
-		int tokenType = adaptor.getType(node);
-		Integer tokenTypeI = new Integer(tokenType);
-		if ( !(tokenTypesToReverseIndex==INDEX_ALL ||
-			   tokenTypesToReverseIndex.contains(tokenTypeI)) )
-		{
-			return; // tokenType not of interest
-		}
-		Integer streamIndexI = new Integer(streamIndex);
-		ArrayList indexes = (ArrayList)tokenTypeToStreamIndexesMap.get(tokenTypeI);
-		if ( indexes==null ) {
-			indexes = new ArrayList(); // no list yet for this token type
-			indexes.add(streamIndexI); // not there yet, add
-			tokenTypeToStreamIndexesMap.put(tokenTypeI, indexes);
-		}
-		else {
-			if ( !indexes.contains(streamIndexI) ) {
-				indexes.add(streamIndexI); // not there yet, add
-			}
-		}
-	}
-
-	/** Track the indicated token type in the reverse index.  Call this
-	 *  repeatedly for each type or use variant with Set argument to
-	 *  set all at once.
-	 * @param tokenType
-	public void reverseIndex(int tokenType) {
-		if ( tokenTypesToReverseIndex==null ) {
-			tokenTypesToReverseIndex = new HashSet();
-		}
-		else if ( tokenTypesToReverseIndex==INDEX_ALL ) {
-			return;
-		}
-		tokenTypesToReverseIndex.add(new Integer(tokenType));
-	}
-
-	/** Track the indicated token types in the reverse index. Set
-	 *  to INDEX_ALL to track all token types.
-	public void reverseIndex(Set tokenTypes) {
-		tokenTypesToReverseIndex = tokenTypes;
-	}
-
-	/** Given a node pointer, return its index into the node stream.
-	 *  This is not its Token stream index.  If there is no reverse map
-	 *  from node to stream index or the map does not contain entries
-	 *  for node's token type, a linear search of entire stream is used.
-	 *
-	 *  Return -1 if exact node pointer not in stream.
-	public int getNodeIndex(Object node) {
-		//System.out.println("get "+node);
-		if ( tokenTypeToStreamIndexesMap==null ) {
-			return getNodeIndexLinearly(node);
-		}
-		int tokenType = adaptor.getType(node);
-		Integer tokenTypeI = new Integer(tokenType);
-		ArrayList indexes = (ArrayList)tokenTypeToStreamIndexesMap.get(tokenTypeI);
-		if ( indexes==null ) {
-			//System.out.println("found linearly; stream index = "+getNodeIndexLinearly(node));
-			return getNodeIndexLinearly(node);
-		}
-		for (int i = 0; i < indexes.size(); i++) {
-			Integer streamIndexI = (Integer)indexes.get(i);
-			Object n = get(streamIndexI.intValue());
-			if ( n==node ) {
-				//System.out.println("found in index; stream index = "+streamIndexI);
-				return streamIndexI.intValue(); // found it!
-			}
-		}
-		return -1;
-	}
-
-	*/
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/UnwantedTokenException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/UnwantedTokenException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/antlr/runtime/UnwantedTokenException.java	2012-11-03 21:24:12.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/antlr/runtime/UnwantedTokenException.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,53 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.eclipse.persistence.internal.libraries.antlr.runtime;
-
-/** An extra token while parsing a TokenStream */
-public class UnwantedTokenException extends MismatchedTokenException {
-	/** Used for remote debugger deserialization */
-	public UnwantedTokenException() {;}
-
-	public UnwantedTokenException(int expecting, IntStream input) {
-		super(expecting, input);
-	}
-
-	public Token getUnexpectedToken() {
-		return token;
-	}
-
-	public String toString() {
-		String exp = ", expected "+expecting;
-		if ( expecting==Token.INVALID_TOKEN_TYPE ) {
-			exp = "";
-		}
-		if ( token==null ) {
-			return "UnwantedTokenException(found="+null+exp+")";
-		}
-		return "UnwantedTokenException(found="+token.getText()+exp+")";
-	}
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/AnnotationVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/AnnotationVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/AnnotationVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/AnnotationVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,97 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * A visitor to visit a Java annotation. The methods of this interface must be
- * called in the following order: (<tt>visit<tt> | <tt>visitEnum<tt> | 
- * <tt>visitAnnotation<tt> | <tt>visitArray<tt>)* <tt>visitEnd<tt>.
- *
- * @author Eric Bruneton
- * @author Eugene Kuleshov
- */
-public interface AnnotationVisitor {
-
-    /**
-     * Visits a primitive value of the annotation.
-     * 
-     * @param name the value name.
-     * @param value the actual value, whose type must be {@link Byte},
-     *        {@link Boolean}, {@link Character}, {@link Short},
-     *        {@link Integer}, {@link Long}, {@link Float}, {@link Double},
-     *        {@link String} or {@link Type}. This value can also be an array
-     *        of byte, boolean, short, char, int, long, float or double values
-     *        (this is equivalent to using {@link #visitArray visitArray} and
-     *        visiting each array element in turn, but is more convenient).
-     */
-    void visit(String name, Object value);
-
-    /**
-     * Visits an enumeration value of the annotation.
-     * 
-     * @param name the value name.
-     * @param desc the class descriptor of the enumeration class.
-     * @param value the actual enumeration value.
-     */
-    void visitEnum(String name, String desc, String value);
-
-    /**
-     * Visits a nested annotation value of the annotation.
-     * 
-     * @param name the value name.
-     * @param desc the class descriptor of the nested annotation class.
-     * @return a visitor to visit the actual nested annotation value, or
-     *         <tt>null</tt> if this visitor is not interested in visiting
-     *         this nested annotation. <i>The nested annotation value must be
-     *         fully visited before calling other methods on this annotation
-     *         visitor</i>.
-     */
-    AnnotationVisitor visitAnnotation(String name, String desc);
-
-    /**
-     * Visits an array value of the annotation. Note that arrays of primitive
-     * types (such as byte, boolean, short, char, int, long, float or double)
-     * can be passed as value to {@link #visit visit}. This is what
-     * {@link ClassReader} does.
-     * 
-     * @param name the value name.
-     * @return a visitor to visit the actual array value elements, or
-     *         <tt>null</tt> if this visitor is not interested in visiting
-     *         these values. The 'name' parameters passed to the methods of this
-     *         visitor are ignored. <i>All the array values must be visited
-     *         before calling other methods on this annotation visitor</i>.
-     */
-    AnnotationVisitor visitArray(String name);
-
-    /**
-     * Visits the end of the annotation.
-     */
-    void visitEnd();
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/AnnotationWriter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/AnnotationWriter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/AnnotationWriter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/AnnotationWriter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,316 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * An {@link AnnotationVisitor} that generates annotations in bytecode form.
- * 
- * @author Eric Bruneton
- * @author Eugene Kuleshov
- */
-final class AnnotationWriter implements AnnotationVisitor {
-
-    /**
-     * The class writer to which this annotation must be added.
-     */
-    private final ClassWriter cw;
-
-    /**
-     * The number of values in this annotation.
-     */
-    private int size;
-
-    /**
-     * <tt>true<tt> if values are named, <tt>false</tt> otherwise. Annotation 
-     * writers used for annotation default and annotation arrays use unnamed
-     * values.
-     */
-    private final boolean named;
-
-    /**
-     * The annotation values in bytecode form. This byte vector only contains
-     * the values themselves, i.e. the number of values must be stored as a
-     * unsigned short just before these bytes.
-     */
-    private final ByteVector bv;
-
-    /**
-     * The byte vector to be used to store the number of values of this
-     * annotation. See {@link #bv}.
-     */
-    private final ByteVector parent;
-
-    /**
-     * Where the number of values of this annotation must be stored in
-     * {@link #parent}.
-     */
-    private final int offset;
-
-    /**
-     * Next annotation writer. This field is used to store annotation lists.
-     */
-    AnnotationWriter next;
-
-    /**
-     * Previous annotation writer. This field is used to store annotation lists.
-     */
-    AnnotationWriter prev;
-
-    // ------------------------------------------------------------------------
-    // Constructor
-    // ------------------------------------------------------------------------
-
-    /**
-     * Constructs a new {@link AnnotationWriter}.
-     * 
-     * @param cw the class writer to which this annotation must be added.
-     * @param named <tt>true<tt> if values are named, <tt>false</tt> otherwise.
-     * @param bv where the annotation values must be stored.
-     * @param parent where the number of annotation values must be stored.
-     * @param offset where in <tt>parent</tt> the number of annotation values must 
-     *      be stored.
-     */
-    AnnotationWriter(
-        final ClassWriter cw,
-        final boolean named,
-        final ByteVector bv,
-        final ByteVector parent,
-        final int offset)
-    {
-        this.cw = cw;
-        this.named = named;
-        this.bv = bv;
-        this.parent = parent;
-        this.offset = offset;
-    }
-
-    // ------------------------------------------------------------------------
-    // Implementation of the AnnotationVisitor interface
-    // ------------------------------------------------------------------------
-
-    public void visit(final String name, final Object value) {
-        ++size;
-        if (named) {
-            bv.putShort(cw.newUTF8(name));
-        }
-        if (value instanceof String) {
-            bv.put12('s', cw.newUTF8((String) value));
-        } else if (value instanceof Byte) {
-            bv.put12('B', cw.newInteger(((Byte) value).byteValue()).index);
-        } else if (value instanceof Boolean) {
-            int v = ((Boolean) value).booleanValue() ? 1 : 0;
-            bv.put12('Z', cw.newInteger(v).index);
-        } else if (value instanceof Character) {
-            bv.put12('C', cw.newInteger(((Character) value).charValue()).index);
-        } else if (value instanceof Short) {
-            bv.put12('S', cw.newInteger(((Short) value).shortValue()).index);
-        } else if (value instanceof Type) {
-            bv.put12('c', cw.newUTF8(((Type) value).getDescriptor()));
-        } else if (value instanceof byte[]) {
-            byte[] v = (byte[]) value;
-            bv.put12('[', v.length);
-            for (int i = 0; i < v.length; i++) {
-                bv.put12('B', cw.newInteger(v[i]).index);
-            }
-        } else if (value instanceof boolean[]) {
-            boolean[] v = (boolean[]) value;
-            bv.put12('[', v.length);
-            for (int i = 0; i < v.length; i++) {
-                bv.put12('Z', cw.newInteger(v[i] ? 1 : 0).index);
-            }
-        } else if (value instanceof short[]) {
-            short[] v = (short[]) value;
-            bv.put12('[', v.length);
-            for (int i = 0; i < v.length; i++) {
-                bv.put12('S', cw.newInteger(v[i]).index);
-            }
-        } else if (value instanceof char[]) {
-            char[] v = (char[]) value;
-            bv.put12('[', v.length);
-            for (int i = 0; i < v.length; i++) {
-                bv.put12('C', cw.newInteger(v[i]).index);
-            }
-        } else if (value instanceof int[]) {
-            int[] v = (int[]) value;
-            bv.put12('[', v.length);
-            for (int i = 0; i < v.length; i++) {
-                bv.put12('I', cw.newInteger(v[i]).index);
-            }
-        } else if (value instanceof long[]) {
-            long[] v = (long[]) value;
-            bv.put12('[', v.length);
-            for (int i = 0; i < v.length; i++) {
-                bv.put12('J', cw.newLong(v[i]).index);
-            }
-        } else if (value instanceof float[]) {
-            float[] v = (float[]) value;
-            bv.put12('[', v.length);
-            for (int i = 0; i < v.length; i++) {
-                bv.put12('F', cw.newFloat(v[i]).index);
-            }
-        } else if (value instanceof double[]) {
-            double[] v = (double[]) value;
-            bv.put12('[', v.length);
-            for (int i = 0; i < v.length; i++) {
-                bv.put12('D', cw.newDouble(v[i]).index);
-            }
-        } else {
-            Item i = cw.newConstItem(value);
-            bv.put12(".s.IFJDCS".charAt(i.type), i.index);
-        }
-    }
-
-    public void visitEnum(
-        final String name,
-        final String desc,
-        final String value)
-    {
-        ++size;
-        if (named) {
-            bv.putShort(cw.newUTF8(name));
-        }
-        bv.put12('e', cw.newUTF8(desc)).putShort(cw.newUTF8(value));
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String name,
-        final String desc)
-    {
-        ++size;
-        if (named) {
-            bv.putShort(cw.newUTF8(name));
-        }
-        // write tag and type, and reserve space for values count
-        bv.put12('@', cw.newUTF8(desc)).putShort(0);
-        return new AnnotationWriter(cw, true, bv, bv, bv.length - 2);
-    }
-
-    public AnnotationVisitor visitArray(final String name) {
-        ++size;
-        if (named) {
-            bv.putShort(cw.newUTF8(name));
-        }
-        // write tag, and reserve space for array size
-        bv.put12('[', 0);
-        return new AnnotationWriter(cw, false, bv, bv, bv.length - 2);
-    }
-
-    public void visitEnd() {
-        if (parent != null) {
-            byte[] data = parent.data;
-            data[offset] = (byte) (size >>> 8);
-            data[offset + 1] = (byte) size;
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Utility methods
-    // ------------------------------------------------------------------------
-
-    /**
-     * Returns the size of this annotation writer list.
-     * 
-     * @return the size of this annotation writer list.
-     */
-    int getSize() {
-        int size = 0;
-        AnnotationWriter aw = this;
-        while (aw != null) {
-            size += aw.bv.length;
-            aw = aw.next;
-        }
-        return size;
-    }
-
-    /**
-     * Puts the annotations of this annotation writer list into the given byte
-     * vector.
-     * 
-     * @param out where the annotations must be put.
-     */
-    void put(final ByteVector out) {
-        int n = 0;
-        int size = 2;
-        AnnotationWriter aw = this;
-        AnnotationWriter last = null;
-        while (aw != null) {
-            ++n;
-            size += aw.bv.length;
-            aw.visitEnd(); // in case user forgot to call visitEnd
-            aw.prev = last;
-            last = aw;
-            aw = aw.next;
-        }
-        out.putInt(size);
-        out.putShort(n);
-        aw = last;
-        while (aw != null) {
-            out.putByteArray(aw.bv.data, 0, aw.bv.length);
-            aw = aw.prev;
-        }
-    }
-
-    /**
-     * Puts the given annotation lists into the given byte vector.
-     * 
-     * @param panns an array of annotation writer lists.
-     * @param off index of the first annotation to be written.
-     * @param out where the annotations must be put.
-     */
-    static void put(
-        final AnnotationWriter[] panns,
-        final int off,
-        final ByteVector out)
-    {
-        int size = 1 + 2 * (panns.length - off);
-        for (int i = off; i < panns.length; ++i) {
-            size += panns[i] == null ? 0 : panns[i].getSize();
-        }
-        out.putInt(size).putByte(panns.length - off);
-        for (int i = off; i < panns.length; ++i) {
-            AnnotationWriter aw = panns[i];
-            AnnotationWriter last = null;
-            int n = 0;
-            while (aw != null) {
-                ++n;
-                aw.visitEnd(); // in case user forgot to call visitEnd
-                aw.prev = last;
-                last = aw;
-                aw = aw.next;
-            }
-            out.putShort(n);
-            aw = last;
-            while (aw != null) {
-                out.putByteArray(aw.bv.data, 0, aw.bv.length);
-                aw = aw.prev;
-            }
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/Attribute.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/Attribute.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/Attribute.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/Attribute.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,254 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * A non standard class, field, method or code attribute.
- * 
- * @author Eric Bruneton
- * @author Eugene Kuleshov
- */
-public class Attribute {
-
-    /**
-     * The type of this attribute.
-     */
-    public final String type;
-
-    /**
-     * The raw value of this attribute, used only for unknown attributes.
-     */
-    byte[] value;
-
-    /**
-     * The next attribute in this attribute list. May be <tt>null</tt>.
-     */
-    Attribute next;
-
-    /**
-     * Constructs a new empty attribute.
-     * 
-     * @param type the type of the attribute.
-     */
-    protected Attribute(final String type) {
-        this.type = type;
-    }
-
-    /**
-     * Returns <tt>true</tt> if this type of attribute is unknown. The default
-     * implementation of this method always returns <tt>true</tt>.
-     * 
-     * @return <tt>true</tt> if this type of attribute is unknown.
-     */
-    public boolean isUnknown() {
-        return true;
-    }
-
-    /**
-     * Returns <tt>true</tt> if this type of attribute is a code attribute.
-     * 
-     * @return <tt>true</tt> if this type of attribute is a code attribute.
-     */
-    public boolean isCodeAttribute() {
-        return false;
-    }
-
-    /**
-     * Returns the labels corresponding to this attribute.
-     * 
-     * @return the labels corresponding to this attribute, or <tt>null</tt> if
-     *         this attribute is not a code attribute that contains labels.
-     */
-    protected Label[] getLabels() {
-        return null;
-    }
-
-    /**
-     * Reads a {@link #type type} attribute. This method must return a <i>new</i>
-     * {@link Attribute} object, of type {@link #type type}, corresponding to
-     * the <tt>len</tt> bytes starting at the given offset, in the given class
-     * reader.
-     * 
-     * @param cr the class that contains the attribute to be read.
-     * @param off index of the first byte of the attribute's content in {@link
-     *        ClassReader#b cr.b}. The 6 attribute header bytes, containing the
-     *        type and the length of the attribute, are not taken into account
-     *        here.
-     * @param len the length of the attribute's content.
-     * @param buf buffer to be used to call
-     *        {@link ClassReader#readUTF8 readUTF8},
-     *        {@link ClassReader#readClass(int,char[]) readClass} or
-     *        {@link ClassReader#readConst readConst}.
-     * @param codeOff index of the first byte of code's attribute content in
-     *        {@link ClassReader#b cr.b}, or -1 if the attribute to be read is
-     *        not a code attribute. The 6 attribute header bytes, containing the
-     *        type and the length of the attribute, are not taken into account
-     *        here.
-     * @param labels the labels of the method's code, or <tt>null</tt> if the
-     *        attribute to be read is not a code attribute.
-     * @return a <i>new</i> {@link Attribute} object corresponding to the given
-     *         bytes.
-     */
-    protected Attribute read(
-        final ClassReader cr,
-        final int off,
-        final int len,
-        final char[] buf,
-        final int codeOff,
-        final Label[] labels)
-    {
-        Attribute attr = new Attribute(type);
-        attr.value = new byte[len];
-        System.arraycopy(cr.b, off, attr.value, 0, len);
-        return attr;
-    }
-
-    /**
-     * Returns the byte array form of this attribute.
-     * 
-     * @param cw the class to which this attribute must be added. This parameter
-     *        can be used to add to the constant pool of this class the items
-     *        that corresponds to this attribute.
-     * @param code the bytecode of the method corresponding to this code
-     *        attribute, or <tt>null</tt> if this attribute is not a code
-     *        attributes.
-     * @param len the length of the bytecode of the method corresponding to this
-     *        code attribute, or <tt>null</tt> if this attribute is not a code
-     *        attribute.
-     * @param maxStack the maximum stack size of the method corresponding to
-     *        this code attribute, or -1 if this attribute is not a code
-     *        attribute.
-     * @param maxLocals the maximum number of local variables of the method
-     *        corresponding to this code attribute, or -1 if this attribute is
-     *        not a code attribute.
-     * @return the byte array form of this attribute.
-     */
-    protected ByteVector write(
-        final ClassWriter cw,
-        final byte[] code,
-        final int len,
-        final int maxStack,
-        final int maxLocals)
-    {
-        ByteVector v = new ByteVector();
-        v.data = value;
-        v.length = value.length;
-        return v;
-    }
-
-    /**
-     * Returns the length of the attribute list that begins with this attribute.
-     * 
-     * @return the length of the attribute list that begins with this attribute.
-     */
-    final int getCount() {
-        int count = 0;
-        Attribute attr = this;
-        while (attr != null) {
-            count += 1;
-            attr = attr.next;
-        }
-        return count;
-    }
-
-    /**
-     * Returns the size of all the attributes in this attribute list.
-     * 
-     * @param cw the class writer to be used to convert the attributes into byte
-     *        arrays, with the {@link #write write} method.
-     * @param code the bytecode of the method corresponding to these code
-     *        attributes, or <tt>null</tt> if these attributes are not code
-     *        attributes.
-     * @param len the length of the bytecode of the method corresponding to
-     *        these code attributes, or <tt>null</tt> if these attributes are
-     *        not code attributes.
-     * @param maxStack the maximum stack size of the method corresponding to
-     *        these code attributes, or -1 if these attributes are not code
-     *        attributes.
-     * @param maxLocals the maximum number of local variables of the method
-     *        corresponding to these code attributes, or -1 if these attributes
-     *        are not code attributes.
-     * @return the size of all the attributes in this attribute list. This size
-     *         includes the size of the attribute headers.
-     */
-    final int getSize(
-        final ClassWriter cw,
-        final byte[] code,
-        final int len,
-        final int maxStack,
-        final int maxLocals)
-    {
-        Attribute attr = this;
-        int size = 0;
-        while (attr != null) {
-            cw.newUTF8(attr.type);
-            size += attr.write(cw, code, len, maxStack, maxLocals).length + 6;
-            attr = attr.next;
-        }
-        return size;
-    }
-
-    /**
-     * Writes all the attributes of this attribute list in the given byte
-     * vector.
-     * 
-     * @param cw the class writer to be used to convert the attributes into byte
-     *        arrays, with the {@link #write write} method.
-     * @param code the bytecode of the method corresponding to these code
-     *        attributes, or <tt>null</tt> if these attributes are not code
-     *        attributes.
-     * @param len the length of the bytecode of the method corresponding to
-     *        these code attributes, or <tt>null</tt> if these attributes are
-     *        not code attributes.
-     * @param maxStack the maximum stack size of the method corresponding to
-     *        these code attributes, or -1 if these attributes are not code
-     *        attributes.
-     * @param maxLocals the maximum number of local variables of the method
-     *        corresponding to these code attributes, or -1 if these attributes
-     *        are not code attributes.
-     * @param out where the attributes must be written.
-     */
-    final void put(
-        final ClassWriter cw,
-        final byte[] code,
-        final int len,
-        final int maxStack,
-        final int maxLocals,
-        final ByteVector out)
-    {
-        Attribute attr = this;
-        while (attr != null) {
-            ByteVector b = attr.write(cw, code, len, maxStack, maxLocals);
-            out.putShort(cw.newUTF8(attr.type)).putInt(b.length);
-            out.putByteArray(b.data, 0, b.length);
-            attr = attr.next;
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/ByteVector.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/ByteVector.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/ByteVector.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/ByteVector.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,293 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * A dynamically extensible vector of bytes. This class is roughly equivalent to
- * a DataOutputStream on top of a ByteArrayOutputStream, but is more efficient.
- * 
- * @author Eric Bruneton
- */
-public class ByteVector {
-
-    /**
-     * The content of this vector.
-     */
-    byte[] data;
-
-    /**
-     * Actual number of bytes in this vector.
-     */
-    int length;
-
-    /**
-     * Constructs a new {@link ByteVector ByteVector} with a default initial
-     * size.
-     */
-    public ByteVector() {
-        data = new byte[64];
-    }
-
-    /**
-     * Constructs a new {@link ByteVector ByteVector} with the given initial
-     * size.
-     * 
-     * @param initialSize the initial size of the byte vector to be constructed.
-     */
-    public ByteVector(final int initialSize) {
-        data = new byte[initialSize];
-    }
-
-    /**
-     * Puts a byte into this byte vector. The byte vector is automatically
-     * enlarged if necessary.
-     * 
-     * @param b a byte.
-     * @return this byte vector.
-     */
-    public ByteVector putByte(final int b) {
-        int length = this.length;
-        if (length + 1 > data.length) {
-            enlarge(1);
-        }
-        data[length++] = (byte) b;
-        this.length = length;
-        return this;
-    }
-
-    /**
-     * Puts two bytes into this byte vector. The byte vector is automatically
-     * enlarged if necessary.
-     * 
-     * @param b1 a byte.
-     * @param b2 another byte.
-     * @return this byte vector.
-     */
-    ByteVector put11(final int b1, final int b2) {
-        int length = this.length;
-        if (length + 2 > data.length) {
-            enlarge(2);
-        }
-        byte[] data = this.data;
-        data[length++] = (byte) b1;
-        data[length++] = (byte) b2;
-        this.length = length;
-        return this;
-    }
-
-    /**
-     * Puts a short into this byte vector. The byte vector is automatically
-     * enlarged if necessary.
-     * 
-     * @param s a short.
-     * @return this byte vector.
-     */
-    public ByteVector putShort(final int s) {
-        int length = this.length;
-        if (length + 2 > data.length) {
-            enlarge(2);
-        }
-        byte[] data = this.data;
-        data[length++] = (byte) (s >>> 8);
-        data[length++] = (byte) s;
-        this.length = length;
-        return this;
-    }
-
-    /**
-     * Puts a byte and a short into this byte vector. The byte vector is
-     * automatically enlarged if necessary.
-     * 
-     * @param b a byte.
-     * @param s a short.
-     * @return this byte vector.
-     */
-    ByteVector put12(final int b, final int s) {
-        int length = this.length;
-        if (length + 3 > data.length) {
-            enlarge(3);
-        }
-        byte[] data = this.data;
-        data[length++] = (byte) b;
-        data[length++] = (byte) (s >>> 8);
-        data[length++] = (byte) s;
-        this.length = length;
-        return this;
-    }
-
-    /**
-     * Puts an int into this byte vector. The byte vector is automatically
-     * enlarged if necessary.
-     * 
-     * @param i an int.
-     * @return this byte vector.
-     */
-    public ByteVector putInt(final int i) {
-        int length = this.length;
-        if (length + 4 > data.length) {
-            enlarge(4);
-        }
-        byte[] data = this.data;
-        data[length++] = (byte) (i >>> 24);
-        data[length++] = (byte) (i >>> 16);
-        data[length++] = (byte) (i >>> 8);
-        data[length++] = (byte) i;
-        this.length = length;
-        return this;
-    }
-
-    /**
-     * Puts a long into this byte vector. The byte vector is automatically
-     * enlarged if necessary.
-     * 
-     * @param l a long.
-     * @return this byte vector.
-     */
-    public ByteVector putLong(final long l) {
-        int length = this.length;
-        if (length + 8 > data.length) {
-            enlarge(8);
-        }
-        byte[] data = this.data;
-        int i = (int) (l >>> 32);
-        data[length++] = (byte) (i >>> 24);
-        data[length++] = (byte) (i >>> 16);
-        data[length++] = (byte) (i >>> 8);
-        data[length++] = (byte) i;
-        i = (int) l;
-        data[length++] = (byte) (i >>> 24);
-        data[length++] = (byte) (i >>> 16);
-        data[length++] = (byte) (i >>> 8);
-        data[length++] = (byte) i;
-        this.length = length;
-        return this;
-    }
-
-    /**
-     * Puts an UTF8 string into this byte vector. The byte vector is
-     * automatically enlarged if necessary.
-     * 
-     * @param s a String.
-     * @return this byte vector.
-     */
-    public ByteVector putUTF8(final String s) {
-        int charLength = s.length();
-        int len = length;
-        if (len + 2 + charLength > data.length) {
-            enlarge(2 + charLength);
-        }
-        byte[] data = this.data;
-        // optimistic algorithm: instead of computing the byte length and then
-        // serializing the string (which requires two loops), we assume the byte
-        // length is equal to char length (which is the most frequent case), and
-        // we start serializing the string right away. During the serialization,
-        // if we find that this assumption is wrong, we continue with the
-        // general method.
-        data[len++] = (byte) (charLength >>> 8);
-        data[len++] = (byte) charLength;
-        for (int i = 0; i < charLength; ++i) {
-            char c = s.charAt(i);
-            if (c >= '\001' && c <= '\177') {
-                data[len++] = (byte) c;
-            } else {
-                int byteLength = i;
-                for (int j = i; j < charLength; ++j) {
-                    c = s.charAt(j);
-                    if (c >= '\001' && c <= '\177') {
-                        byteLength++;
-                    } else if (c > '\u07FF') {
-                        byteLength += 3;
-                    } else {
-                        byteLength += 2;
-                    }
-                }
-                data[length] = (byte) (byteLength >>> 8);
-                data[length + 1] = (byte) byteLength;
-                if (length + 2 + byteLength > data.length) {
-                    length = len;
-                    enlarge(2 + byteLength);
-                    data = this.data;
-                }
-                for (int j = i; j < charLength; ++j) {
-                    c = s.charAt(j);
-                    if (c >= '\001' && c <= '\177') {
-                        data[len++] = (byte) c;
-                    } else if (c > '\u07FF') {
-                        data[len++] = (byte) (0xE0 | c >> 12 & 0xF);
-                        data[len++] = (byte) (0x80 | c >> 6 & 0x3F);
-                        data[len++] = (byte) (0x80 | c & 0x3F);
-                    } else {
-                        data[len++] = (byte) (0xC0 | c >> 6 & 0x1F);
-                        data[len++] = (byte) (0x80 | c & 0x3F);
-                    }
-                }
-                break;
-            }
-        }
-        length = len;
-        return this;
-    }
-
-    /**
-     * Puts an array of bytes into this byte vector. The byte vector is
-     * automatically enlarged if necessary.
-     * 
-     * @param b an array of bytes. May be <tt>null</tt> to put <tt>len</tt>
-     *        null bytes into this byte vector.
-     * @param off index of the fist byte of b that must be copied.
-     * @param len number of bytes of b that must be copied.
-     * @return this byte vector.
-     */
-    public ByteVector putByteArray(final byte[] b, final int off, final int len)
-    {
-        if (length + len > data.length) {
-            enlarge(len);
-        }
-        if (b != null) {
-            System.arraycopy(b, off, data, length, len);
-        }
-        length += len;
-        return this;
-    }
-
-    /**
-     * Enlarge this byte vector so that it can receive n more bytes.
-     * 
-     * @param size number of additional bytes that this byte vector should be
-     *        able to receive.
-     */
-    private void enlarge(final int size) {
-        int length1 = 2 * data.length;
-        int length2 = length + size;
-        byte[] newData = new byte[length1 > length2 ? length1 : length2];
-        System.arraycopy(data, 0, newData, 0, length);
-        data = newData;
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/ClassAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/ClassAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/ClassAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/ClassAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,121 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * An empty {@link ClassVisitor} that delegates to another {@link ClassVisitor}.
- * This class can be used as a super class to quickly implement usefull class
- * adapter classes, just by overriding the necessary methods.
- * 
- * @author Eric Bruneton
- */
-public class ClassAdapter implements ClassVisitor {
-
-    /**
-     * The {@link ClassVisitor} to which this adapter delegates calls.
-     */
-    protected ClassVisitor cv;
-
-    /**
-     * Constructs a new {@link ClassAdapter} object.
-     * 
-     * @param cv the class visitor to which this adapter must delegate calls.
-     */
-    public ClassAdapter(final ClassVisitor cv) {
-        this.cv = cv;
-    }
-
-    public void visit(
-        final int version,
-        final int access,
-        final String name,
-        final String signature,
-        final String superName,
-        final String[] interfaces)
-    {
-        cv.visit(version, access, name, signature, superName, interfaces);
-    }
-
-    public void visitSource(final String source, final String debug) {
-        cv.visitSource(source, debug);
-    }
-
-    public void visitOuterClass(
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        cv.visitOuterClass(owner, name, desc);
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        return cv.visitAnnotation(desc, visible);
-    }
-
-    public void visitAttribute(final Attribute attr) {
-        cv.visitAttribute(attr);
-    }
-
-    public void visitInnerClass(
-        final String name,
-        final String outerName,
-        final String innerName,
-        final int access)
-    {
-        cv.visitInnerClass(name, outerName, innerName, access);
-    }
-
-    public FieldVisitor visitField(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final Object value)
-    {
-        return cv.visitField(access, name, desc, signature, value);
-    }
-
-    public MethodVisitor visitMethod(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final String[] exceptions)
-    {
-        return cv.visitMethod(access, name, desc, signature, exceptions);
-    }
-
-    public void visitEnd() {
-        cv.visitEnd();
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/ClassReader.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/ClassReader.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/ClassReader.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/ClassReader.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,2048 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-import java.io.InputStream;
-import java.io.IOException;
-
-/**
- * A Java class parser to make a {@link ClassVisitor} visit an existing class.
- * This class parses a byte array conforming to the Java class file format and
- * calls the appropriate visit methods of a given class visitor for each field,
- * method and bytecode instruction encountered.
- * 
- * @author Eric Bruneton
- * @author Eugene Kuleshov
- */
-public class ClassReader {
-
-    /**
-     * True to enable signatures support.
-     */
-    static final boolean SIGNATURES = true;
-    
-    /**
-     * True to enable annotations support.
-     */
-    static final boolean ANNOTATIONS = true;
-    
-    /**
-     * True to enable stack map frames support.
-     */
-    static final boolean FRAMES = true;
-    
-    /**
-     * True to enable bytecode writing support.
-     */
-    static final boolean WRITER = true;
-    
-    /**
-     * True to enable JSR_W and GOTO_W support.
-     */
-    static final boolean RESIZE = true;
-    
-    /**
-     * Flag to skip method code. If this class is set <code>CODE</code>
-     * attribute won't be visited. This can be used, for example, to retrieve
-     * annotations for methods and method parameters.
-     */
-    public static final int SKIP_CODE = 1;
-
-    /**
-     * Flag to skip the debug information in the class. If this flag is set the
-     * debug information of the class is not visited, i.e. the
-     * {@link MethodVisitor#visitLocalVariable visitLocalVariable} and
-     * {@link MethodVisitor#visitLineNumber visitLineNumber} methods will not be
-     * called.
-     */
-    public static final int SKIP_DEBUG = 2;
-
-    /**
-     * Flag to skip the stack map frames in the class. If this flag is set the
-     * stack map frames of the class is not visited, i.e. the
-     * {@link MethodVisitor#visitFrame visitFrame} method will not be called.
-     * This flag is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is
-     * used: it avoids visiting frames that will be ignored and recomputed from
-     * scratch in the class writer.
-     */
-    public static final int SKIP_FRAMES = 4;
-
-    /**
-     * Flag to expand the stack map frames. By default stack map frames are
-     * visited in their original format (i.e. "expanded" for classes whose
-     * version is less than V1_6, and "compressed" for the other classes). If
-     * this flag is set, stack map frames are always visited in expanded format
-     * (this option adds a decompression/recompression step in ClassReader and
-     * ClassWriter which degrades performances quite a lot).
-     */
-    public static final int EXPAND_FRAMES = 8;
-
-    /**
-     * The class to be parsed. <i>The content of this array must not be
-     * modified. This field is intended for {@link Attribute} sub classes, and
-     * is normally not needed by class generators or adapters.</i>
-     */
-    public final byte[] b;
-
-    /**
-     * The start index of each constant pool item in {@link #b b}, plus one.
-     * The one byte offset skips the constant pool item tag that indicates its
-     * type.
-     */
-    private final int[] items;
-
-    /**
-     * The String objects corresponding to the CONSTANT_Utf8 items. This cache
-     * avoids multiple parsing of a given CONSTANT_Utf8 constant pool item,
-     * which GREATLY improves performances (by a factor 2 to 3). This caching
-     * strategy could be extended to all constant pool items, but its benefit
-     * would not be so great for these items (because they are much less
-     * expensive to parse than CONSTANT_Utf8 items).
-     */
-    private final String[] strings;
-
-    /**
-     * Maximum length of the strings contained in the constant pool of the
-     * class.
-     */
-    private final int maxStringLength;
-
-    /**
-     * Start index of the class header information (access, name...) in
-     * {@link #b b}.
-     */
-    public final int header;
-
-    // ------------------------------------------------------------------------
-    // Constructors
-    // ------------------------------------------------------------------------
-
-    /**
-     * Constructs a new {@link ClassReader} object.
-     * 
-     * @param b the bytecode of the class to be read.
-     */
-    public ClassReader(final byte[] b) {
-        this(b, 0, b.length);
-    }
-
-    /**
-     * Constructs a new {@link ClassReader} object.
-     * 
-     * @param b the bytecode of the class to be read.
-     * @param off the start offset of the class data.
-     * @param len the length of the class data.
-     */
-    public ClassReader(final byte[] b, final int off, final int len) {
-        this.b = b;
-        // parses the constant pool
-        items = new int[readUnsignedShort(off + 8)];
-        int n = items.length;
-        strings = new String[n];
-        int max = 0;
-        int index = off + 10;
-        for (int i = 1; i < n; ++i) {
-            items[i] = index + 1;
-            int size;
-            switch (b[index]) {
-                case ClassWriter.FIELD:
-                case ClassWriter.METH:
-                case ClassWriter.IMETH:
-                case ClassWriter.INT:
-                case ClassWriter.FLOAT:
-                case ClassWriter.NAME_TYPE:
-                    size = 5;
-                    break;
-                case ClassWriter.LONG:
-                case ClassWriter.DOUBLE:
-                    size = 9;
-                    ++i;
-                    break;
-                case ClassWriter.UTF8:
-                    size = 3 + readUnsignedShort(index + 1);
-                    if (size > max) {
-                        max = size;
-                    }
-                    break;
-                // case ClassWriter.CLASS:
-                // case ClassWriter.STR:
-                default:
-                    size = 3;
-                    break;
-            }
-            index += size;
-        }
-        maxStringLength = max;
-        // the class header information starts just after the constant pool
-        header = index;
-    }
-
-    /**
-     * Returns the class's access flags (see {@link Opcodes}). This value may
-     * not reflect Deprecated and Synthetic flags when bytecode is before 1.5
-     * and those flags are represented by attributes.
-     * 
-     * @return the class access flags
-     * 
-     * @see ClassVisitor#visit(int, int, String, String, String, String[])
-     */
-    public int getAccess() {
-        return readUnsignedShort(header);
-    }
-
-    /**
-     * Returns the internal name of the class (see
-     * {@link Type#getInternalName() getInternalName}).
-     * 
-     * @return the internal class name
-     * 
-     * @see ClassVisitor#visit(int, int, String, String, String, String[])
-     */
-    public String getClassName() {
-        return readClass(header + 2, new char[maxStringLength]);
-    }
-
-    /**
-     * Returns the internal of name of the super class (see
-     * {@link Type#getInternalName() getInternalName}). For interfaces, the
-     * super class is {@link Object}.
-     * 
-     * @return the internal name of super class, or <tt>null</tt> for
-     *         {@link Object} class.
-     * 
-     * @see ClassVisitor#visit(int, int, String, String, String, String[])
-     */
-    public String getSuperName() {
-        int n = items[readUnsignedShort(header + 4)];
-        return n == 0 ? null : readUTF8(n, new char[maxStringLength]);
-    }
-
-    /**
-     * Returns the internal names of the class's interfaces (see
-     * {@link Type#getInternalName() getInternalName}).
-     * 
-     * @return the array of internal names for all implemented interfaces or
-     *         <tt>null</tt>.
-     * 
-     * @see ClassVisitor#visit(int, int, String, String, String, String[])
-     */
-    public String[] getInterfaces() {
-        int index = header + 6;
-        int n = readUnsignedShort(index);
-        String[] interfaces = new String[n];
-        if (n > 0) {
-            char[] buf = new char[maxStringLength];
-            for (int i = 0; i < n; ++i) {
-                index += 2;
-                interfaces[i] = readClass(index, buf);
-            }
-        }
-        return interfaces;
-    }
-
-    /**
-     * Copies the constant pool data into the given {@link ClassWriter}. Should
-     * be called before the {@link #accept(ClassVisitor,int)} method.
-     * 
-     * @param classWriter the {@link ClassWriter} to copy constant pool into.
-     */
-    void copyPool(final ClassWriter classWriter) {
-        char[] buf = new char[maxStringLength];
-        int ll = items.length;
-        Item[] items2 = new Item[ll];
-        for (int i = 1; i < ll; i++) {
-            int index = items[i];
-            int tag = b[index - 1];
-            Item item = new Item(i);
-            int nameType;
-            switch (tag) {
-                case ClassWriter.FIELD:
-                case ClassWriter.METH:
-                case ClassWriter.IMETH:
-                    nameType = items[readUnsignedShort(index + 2)];
-                    item.set(tag,
-                            readClass(index, buf),
-                            readUTF8(nameType, buf),
-                            readUTF8(nameType + 2, buf));
-                    break;
-
-                case ClassWriter.INT:
-                    item.set(readInt(index));
-                    break;
-
-                case ClassWriter.FLOAT:
-                    item.set(Float.intBitsToFloat(readInt(index)));
-                    break;
-
-                case ClassWriter.NAME_TYPE:
-                    item.set(tag,
-                            readUTF8(index, buf),
-                            readUTF8(index + 2, buf),
-                            null);
-                    break;
-
-                case ClassWriter.LONG:
-                    item.set(readLong(index));
-                    ++i;
-                    break;
-
-                case ClassWriter.DOUBLE:
-                    item.set(Double.longBitsToDouble(readLong(index)));
-                    ++i;
-                    break;
-
-                case ClassWriter.UTF8: {
-                    String s = strings[i];
-                    if (s == null) {
-                        index = items[i];
-                        s = strings[i] = readUTF(index + 2,
-                                readUnsignedShort(index),
-                                buf);
-                    }
-                    item.set(tag, s, null, null);
-                }
-                    break;
-
-                // case ClassWriter.STR:
-                // case ClassWriter.CLASS:
-                default:
-                    item.set(tag, readUTF8(index, buf), null, null);
-                    break;
-            }
-
-            int index2 = item.hashCode % items2.length;
-            item.next = items2[index2];
-            items2[index2] = item;
-        }
-
-        int off = items[1] - 1;
-        classWriter.pool.putByteArray(b, off, header - off);
-        classWriter.items = items2;
-        classWriter.threshold = (int) (0.75d * ll);
-        classWriter.index = ll;
-    }
-
-    /**
-     * Constructs a new {@link ClassReader} object.
-     * 
-     * @param is an input stream from which to read the class.
-     * @throws IOException if a problem occurs during reading.
-     */
-    public ClassReader(final InputStream is) throws IOException {
-        this(readClass(is));
-    }
-
-    /**
-     * Constructs a new {@link ClassReader} object.
-     * 
-     * @param name the fully qualified name of the class to be read.
-     * @throws IOException if an exception occurs during reading.
-     */
-    public ClassReader(final String name) throws IOException {
-        this(ClassLoader.getSystemResourceAsStream(name.replace('.', '/')
-                + ".class"));
-    }
-
-    /**
-     * Reads the bytecode of a class.
-     * 
-     * @param is an input stream from which to read the class.
-     * @return the bytecode read from the given input stream.
-     * @throws IOException if a problem occurs during reading.
-     */
-    private static byte[] readClass(final InputStream is) throws IOException {
-        if (is == null) {
-            throw new IOException("Class not found");
-        }
-        byte[] b = new byte[is.available()];
-        int len = 0;
-        while (true) {
-            int n = is.read(b, len, b.length - len);
-            if (n == -1) {
-                if (len < b.length) {
-                    byte[] c = new byte[len];
-                    System.arraycopy(b, 0, c, 0, len);
-                    b = c;
-                }
-                return b;
-            }
-            len += n;
-            if (len == b.length) {
-                int last = is.read();
-                if (last < 0) {
-                    return b;
-                }
-                byte[] c = new byte[b.length + 1000];
-                System.arraycopy(b, 0, c, 0, len);
-                c[len++] = (byte) last;
-                b = c;
-            }
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Public methods
-    // ------------------------------------------------------------------------
-
-    /**
-     * Makes the given visitor visit the Java class of this {@link ClassReader}.
-     * This class is the one specified in the constructor (see
-     * {@link #ClassReader(byte[]) ClassReader}).
-     * 
-     * @param classVisitor the visitor that must visit this class.
-     * @param flags option flags that can be used to modify the default behavior
-     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},
-     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.
-     */
-    public void accept(final ClassVisitor classVisitor, final int flags) {
-        accept(classVisitor, new Attribute[0], flags);
-    }
-
-    /**
-     * Makes the given visitor visit the Java class of this {@link ClassReader}.
-     * This class is the one specified in the constructor (see
-     * {@link #ClassReader(byte[]) ClassReader}).
-     * 
-     * @param classVisitor the visitor that must visit this class.
-     * @param attrs prototypes of the attributes that must be parsed during the
-     *        visit of the class. Any attribute whose type is not equal to the
-     *        type of one the prototypes will not be parsed: its byte array
-     *        value will be passed unchanged to the ClassWriter. <i>This may
-     *        corrupt it if this value contains references to the constant pool,
-     *        or has syntactic or semantic links with a class element that has
-     *        been transformed by a class adapter between the reader and the
-     *        writer</i>.
-     * @param flags option flags that can be used to modify the default behavior
-     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},
-     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.
-     */
-    public void accept(
-        final ClassVisitor classVisitor,
-        final Attribute[] attrs,
-        final int flags)
-    {
-        byte[] b = this.b; // the bytecode array
-        char[] c = new char[maxStringLength]; // buffer used to read strings
-        int i, j, k; // loop variables
-        int u, v, w; // indexes in b
-        Attribute attr;
-
-        int access;
-        String name;
-        String desc;
-        String attrName;
-        String signature;
-        int anns = 0;
-        int ianns = 0;
-        Attribute cattrs = null;
-
-        // visits the header
-        u = header;
-        access = readUnsignedShort(u);
-        name = readClass(u + 2, c);
-        v = items[readUnsignedShort(u + 4)];
-        String superClassName = v == 0 ? null : readUTF8(v, c);
-        String[] implementedItfs = new String[readUnsignedShort(u + 6)];
-        w = 0;
-        u += 8;
-        for (i = 0; i < implementedItfs.length; ++i) {
-            implementedItfs[i] = readClass(u, c);
-            u += 2;
-        }
-
-        boolean skipCode = (flags & SKIP_CODE) != 0;
-        boolean skipDebug = (flags & SKIP_DEBUG) != 0;
-        boolean unzip = (flags & EXPAND_FRAMES) != 0;
-
-        // skips fields and methods
-        v = u;
-        i = readUnsignedShort(v);
-        v += 2;
-        for (; i > 0; --i) {
-            j = readUnsignedShort(v + 6);
-            v += 8;
-            for (; j > 0; --j) {
-                v += 6 + readInt(v + 2);
-            }
-        }
-        i = readUnsignedShort(v);
-        v += 2;
-        for (; i > 0; --i) {
-            j = readUnsignedShort(v + 6);
-            v += 8;
-            for (; j > 0; --j) {
-                v += 6 + readInt(v + 2);
-            }
-        }
-        // reads the class's attributes
-        signature = null;
-        String sourceFile = null;
-        String sourceDebug = null;
-        String enclosingOwner = null;
-        String enclosingName = null;
-        String enclosingDesc = null;
-
-        i = readUnsignedShort(v);
-        v += 2;
-        for (; i > 0; --i) {
-            attrName = readUTF8(v, c);
-            // tests are sorted in decreasing frequency order
-            // (based on frequencies observed on typical classes)
-            if ("SourceFile".equals(attrName)) {
-                sourceFile = readUTF8(v + 6, c);
-            } else if ("InnerClasses".equals(attrName)) {
-                w = v + 6;
-            } else if ("EnclosingMethod".equals(attrName)) {
-                enclosingOwner = readClass(v + 6, c);
-                int item = readUnsignedShort(v + 8);
-                if (item != 0) {
-                    enclosingName = readUTF8(items[item], c);
-                    enclosingDesc = readUTF8(items[item] + 2, c);
-                }
-            } else if (SIGNATURES && "Signature".equals(attrName)) {
-                signature = readUTF8(v + 6, c);
-            } else if (ANNOTATIONS && "RuntimeVisibleAnnotations".equals(attrName)) {
-                anns = v + 6;
-            } else if ("Deprecated".equals(attrName)) {
-                access |= Opcodes.ACC_DEPRECATED;
-            } else if ("Synthetic".equals(attrName)) {
-                access |= Opcodes.ACC_SYNTHETIC | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE;
-            } else if ("SourceDebugExtension".equals(attrName)) {
-                int len = readInt(v + 2);
-                sourceDebug = readUTF(v + 6, len, new char[len]);
-            } else if (ANNOTATIONS && "RuntimeInvisibleAnnotations".equals(attrName)) {
-                ianns = v + 6;
-            } else {
-                attr = readAttribute(attrs,
-                        attrName,
-                        v + 6,
-                        readInt(v + 2),
-                        c,
-                        -1,
-                        null);
-                if (attr != null) {
-                    attr.next = cattrs;
-                    cattrs = attr;
-                }
-            }
-            v += 6 + readInt(v + 2);
-        }
-        // calls the visit method
-        classVisitor.visit(readInt(4),
-                access,
-                name,
-                signature,
-                superClassName,
-                implementedItfs);
-
-        // calls the visitSource method
-        if (!skipDebug && (sourceFile != null || sourceDebug != null)) {
-            classVisitor.visitSource(sourceFile, sourceDebug);
-        }
-
-        // calls the visitOuterClass method
-        if (enclosingOwner != null) {
-            classVisitor.visitOuterClass(enclosingOwner,
-                    enclosingName,
-                    enclosingDesc);
-        }
-
-        // visits the class annotations
-        if (ANNOTATIONS) {
-            for (i = 1; i >= 0; --i) {
-                v = i == 0 ? ianns : anns;
-                if (v != 0) {
-                    j = readUnsignedShort(v);
-                    v += 2;
-                    for (; j > 0; --j) {
-                        v = readAnnotationValues(v + 2,
-                                c,
-                                true,
-                                classVisitor.visitAnnotation(readUTF8(v, c), i != 0));
-                    }
-                }
-            }
-        }
-
-        // visits the class attributes
-        while (cattrs != null) {
-            attr = cattrs.next;
-            cattrs.next = null;
-            classVisitor.visitAttribute(cattrs);
-            cattrs = attr;
-        }
-
-        // calls the visitInnerClass method
-        if (w != 0) {
-            i = readUnsignedShort(w);
-            w += 2;
-            for (; i > 0; --i) {
-                classVisitor.visitInnerClass(readUnsignedShort(w) == 0
-                        ? null
-                        : readClass(w, c), readUnsignedShort(w + 2) == 0
-                        ? null
-                        : readClass(w + 2, c), readUnsignedShort(w + 4) == 0
-                        ? null
-                        : readUTF8(w + 4, c), readUnsignedShort(w + 6));
-                w += 8;
-            }
-        }
-
-        // visits the fields
-        i = readUnsignedShort(u);
-        u += 2;
-        for (; i > 0; --i) {
-            access = readUnsignedShort(u);
-            name = readUTF8(u + 2, c);
-            desc = readUTF8(u + 4, c);
-            // visits the field's attributes and looks for a ConstantValue
-            // attribute
-            int fieldValueItem = 0;
-            signature = null;
-            anns = 0;
-            ianns = 0;
-            cattrs = null;
-
-            j = readUnsignedShort(u + 6);
-            u += 8;
-            for (; j > 0; --j) {
-                attrName = readUTF8(u, c);
-                // tests are sorted in decreasing frequency order
-                // (based on frequencies observed on typical classes)
-                if ("ConstantValue".equals(attrName)) {
-                    fieldValueItem = readUnsignedShort(u + 6);
-                } else if (SIGNATURES && "Signature".equals(attrName)) {
-                    signature = readUTF8(u + 6, c);
-                } else if ("Deprecated".equals(attrName)) {
-                    access |= Opcodes.ACC_DEPRECATED;
-                } else if ("Synthetic".equals(attrName)) {
-                    access |= Opcodes.ACC_SYNTHETIC  | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE;
-                } else if (ANNOTATIONS && "RuntimeVisibleAnnotations".equals(attrName)) {
-                    anns = u + 6;
-                } else if (ANNOTATIONS && "RuntimeInvisibleAnnotations".equals(attrName)) {
-                    ianns = u + 6;
-                } else {
-                    attr = readAttribute(attrs,
-                            attrName,
-                            u + 6,
-                            readInt(u + 2),
-                            c,
-                            -1,
-                            null);
-                    if (attr != null) {
-                        attr.next = cattrs;
-                        cattrs = attr;
-                    }
-                }
-                u += 6 + readInt(u + 2);
-            }
-            // visits the field
-            FieldVisitor fv = classVisitor.visitField(access,
-                    name,
-                    desc,
-                    signature,
-                    fieldValueItem == 0 ? null : readConst(fieldValueItem, c));
-            // visits the field annotations and attributes
-            if (fv != null) {
-                if (ANNOTATIONS) {
-                    for (j = 1; j >= 0; --j) {
-                        v = j == 0 ? ianns : anns;
-                        if (v != 0) {
-                            k = readUnsignedShort(v);
-                            v += 2;
-                            for (; k > 0; --k) {
-                                v = readAnnotationValues(v + 2,
-                                        c,
-                                        true,
-                                        fv.visitAnnotation(readUTF8(v, c), j != 0));
-                            }
-                        }
-                    }
-                }
-                while (cattrs != null) {
-                    attr = cattrs.next;
-                    cattrs.next = null;
-                    fv.visitAttribute(cattrs);
-                    cattrs = attr;
-                }
-                fv.visitEnd();
-            }
-        }
-
-        // visits the methods
-        i = readUnsignedShort(u);
-        u += 2;
-        for (; i > 0; --i) {
-            int u0 = u + 6;
-            access = readUnsignedShort(u);
-            name = readUTF8(u + 2, c);
-            desc = readUTF8(u + 4, c);
-            signature = null;
-            anns = 0;
-            ianns = 0;
-            int dann = 0;
-            int mpanns = 0;
-            int impanns = 0;
-            cattrs = null;
-            v = 0;
-            w = 0;
-
-            // looks for Code and Exceptions attributes
-            j = readUnsignedShort(u + 6);
-            u += 8;
-            for (; j > 0; --j) {
-                attrName = readUTF8(u, c);
-                int attrSize = readInt(u + 2);
-                u += 6;
-                // tests are sorted in decreasing frequency order
-                // (based on frequencies observed on typical classes)
-                if ("Code".equals(attrName)) {
-                    if (!skipCode) {
-                        v = u;
-                    }
-                } else if ("Exceptions".equals(attrName)) {
-                    w = u;
-                } else if (SIGNATURES && "Signature".equals(attrName)) {
-                    signature = readUTF8(u, c);
-                } else if ("Deprecated".equals(attrName)) {
-                    access |= Opcodes.ACC_DEPRECATED;
-                } else if (ANNOTATIONS && "RuntimeVisibleAnnotations".equals(attrName)) {
-                    anns = u;
-                } else if (ANNOTATIONS && "AnnotationDefault".equals(attrName)) {
-                    dann = u;
-                } else if ("Synthetic".equals(attrName)) {
-                    access |= Opcodes.ACC_SYNTHETIC | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE;
-                } else if (ANNOTATIONS && "RuntimeInvisibleAnnotations".equals(attrName)) {
-                    ianns = u;
-                } else if (ANNOTATIONS && "RuntimeVisibleParameterAnnotations".equals(attrName))
-                {
-                    mpanns = u;
-                } else if (ANNOTATIONS && "RuntimeInvisibleParameterAnnotations".equals(attrName))
-                {
-                    impanns = u;
-                } else {
-                    attr = readAttribute(attrs,
-                            attrName,
-                            u,
-                            attrSize,
-                            c,
-                            -1,
-                            null);
-                    if (attr != null) {
-                        attr.next = cattrs;
-                        cattrs = attr;
-                    }
-                }
-                u += attrSize;
-            }
-            // reads declared exceptions
-            String[] exceptions;
-            if (w == 0) {
-                exceptions = null;
-            } else {
-                exceptions = new String[readUnsignedShort(w)];
-                w += 2;
-                for (j = 0; j < exceptions.length; ++j) {
-                    exceptions[j] = readClass(w, c);
-                    w += 2;
-                }
-            }
-
-            // visits the method's code, if any
-            MethodVisitor mv = classVisitor.visitMethod(access,
-                    name,
-                    desc,
-                    signature,
-                    exceptions);
-
-            if (mv != null) {
-                /*
-                 * if the returned MethodVisitor is in fact a MethodWriter, it
-                 * means there is no method adapter between the reader and the
-                 * writer. If, in addition, the writer's constant pool was
-                 * copied from this reader (mw.cw.cr == this), and the signature
-                 * and exceptions of the method have not been changed, then it
-                 * is possible to skip all visit events and just copy the
-                 * original code of the method to the writer (the access, name
-                 * and descriptor can have been changed, this is not important
-                 * since they are not copied as is from the reader).
-                 */
-                if (WRITER && mv instanceof MethodWriter) {
-                    MethodWriter mw = (MethodWriter) mv;
-                    if (mw.cw.cr == this) {
-                        if (signature == mw.signature) {
-                            boolean sameExceptions = false;
-                            if (exceptions == null) {
-                                sameExceptions = mw.exceptionCount == 0;
-                            } else {
-                                if (exceptions.length == mw.exceptionCount) {
-                                    sameExceptions = true;
-                                    for (j = exceptions.length - 1; j >= 0; --j)
-                                    {
-                                        w -= 2;
-                                        if (mw.exceptions[j] != readUnsignedShort(w))
-                                        {
-                                            sameExceptions = false;
-                                            break;
-                                        }
-                                    }
-                                }
-                            }
-                            if (sameExceptions) {
-                                /*
-                                 * we do not copy directly the code into
-                                 * MethodWriter to save a byte array copy
-                                 * operation. The real copy will be done in
-                                 * ClassWriter.toByteArray().
-                                 */
-                                mw.classReaderOffset = u0;
-                                mw.classReaderLength = u - u0;
-                                continue;
-                            }
-                        }
-                    }
-                }
-
-                if (ANNOTATIONS && dann != 0) {
-                    AnnotationVisitor dv = mv.visitAnnotationDefault();
-                    readAnnotationValue(dann, c, null, dv);
-                    if (dv != null) {
-                        dv.visitEnd();
-                    }
-                }
-                if (ANNOTATIONS) {
-                    for (j = 1; j >= 0; --j) {
-                        w = j == 0 ? ianns : anns;
-                        if (w != 0) {
-                            k = readUnsignedShort(w);
-                            w += 2;
-                            for (; k > 0; --k) {
-                                w = readAnnotationValues(w + 2,
-                                        c,
-                                        true,
-                                        mv.visitAnnotation(readUTF8(w, c), j != 0));
-                            }
-                        }
-                    }
-                }
-                if (ANNOTATIONS && mpanns != 0) {
-                    readParameterAnnotations(mpanns, desc, c, true, mv);
-                }
-                if (ANNOTATIONS && impanns != 0) {
-                    readParameterAnnotations(impanns, desc, c, false, mv);
-                }
-                while (cattrs != null) {
-                    attr = cattrs.next;
-                    cattrs.next = null;
-                    mv.visitAttribute(cattrs);
-                    cattrs = attr;
-                }
-            }
-
-            if (mv != null && v != 0) {
-                int maxStack = readUnsignedShort(v);
-                int maxLocals = readUnsignedShort(v + 2);
-                int codeLength = readInt(v + 4);
-                v += 8;
-
-                int codeStart = v;
-                int codeEnd = v + codeLength;
-
-                mv.visitCode();
-
-                // 1st phase: finds the labels
-                int label;
-                Label[] labels = new Label[codeLength + 2];
-                readLabel(codeLength + 1, labels);
-                while (v < codeEnd) {
-                    w = v - codeStart;
-                    int opcode = b[v] & 0xFF;
-                    switch (ClassWriter.TYPE[opcode]) {
-                        case ClassWriter.NOARG_INSN:
-                        case ClassWriter.IMPLVAR_INSN:
-                            v += 1;
-                            break;
-                        case ClassWriter.LABEL_INSN:
-                            readLabel(w + readShort(v + 1), labels);
-                            v += 3;
-                            break;
-                        case ClassWriter.LABELW_INSN:
-                            readLabel(w + readInt(v + 1), labels);
-                            v += 5;
-                            break;
-                        case ClassWriter.WIDE_INSN:
-                            opcode = b[v + 1] & 0xFF;
-                            if (opcode == Opcodes.IINC) {
-                                v += 6;
-                            } else {
-                                v += 4;
-                            }
-                            break;
-                        case ClassWriter.TABL_INSN:
-                            // skips 0 to 3 padding bytes*
-                            v = v + 4 - (w & 3);
-                            // reads instruction
-                            readLabel(w + readInt(v), labels);
-                            j = readInt(v + 8) - readInt(v + 4) + 1;
-                            v += 12;
-                            for (; j > 0; --j) {
-                                readLabel(w + readInt(v), labels);
-                                v += 4;
-                            }
-                            break;
-                        case ClassWriter.LOOK_INSN:
-                            // skips 0 to 3 padding bytes*
-                            v = v + 4 - (w & 3);
-                            // reads instruction
-                            readLabel(w + readInt(v), labels);
-                            j = readInt(v + 4);
-                            v += 8;
-                            for (; j > 0; --j) {
-                                readLabel(w + readInt(v + 4), labels);
-                                v += 8;
-                            }
-                            break;
-                        case ClassWriter.VAR_INSN:
-                        case ClassWriter.SBYTE_INSN:
-                        case ClassWriter.LDC_INSN:
-                            v += 2;
-                            break;
-                        case ClassWriter.SHORT_INSN:
-                        case ClassWriter.LDCW_INSN:
-                        case ClassWriter.FIELDORMETH_INSN:
-                        case ClassWriter.TYPE_INSN:
-                        case ClassWriter.IINC_INSN:
-                            v += 3;
-                            break;
-                        case ClassWriter.ITFDYNMETH_INSN:
-                            v += 5;
-                            break;
-                        // case MANA_INSN:
-                        default:
-                            v += 4;
-                            break;
-                    }
-                }
-                // parses the try catch entries
-                j = readUnsignedShort(v);
-                v += 2;
-                for (; j > 0; --j) {
-                    Label start = readLabel(readUnsignedShort(v), labels);
-                    Label end = readLabel(readUnsignedShort(v + 2), labels);
-                    Label handler = readLabel(readUnsignedShort(v + 4), labels);
-                    int type = readUnsignedShort(v + 6);
-                    if (type == 0) {
-                        mv.visitTryCatchBlock(start, end, handler, null);
-                    } else {
-                        mv.visitTryCatchBlock(start,
-                                end,
-                                handler,
-                                readUTF8(items[type], c));
-                    }
-                    v += 8;
-                }
-                // parses the local variable, line number tables, and code
-                // attributes
-                int varTable = 0;
-                int varTypeTable = 0;
-                int stackMap = 0;
-                int stackMapSize = 0;
-                int frameCount = 0;
-                int frameMode = 0;
-                int frameOffset = 0;
-                int frameLocalCount = 0;
-                int frameLocalDiff = 0;
-                int frameStackCount = 0;
-                Object[] frameLocal = null;
-                Object[] frameStack = null;
-                boolean zip = true;
-                cattrs = null;
-                j = readUnsignedShort(v);
-                v += 2;
-                for (; j > 0; --j) {
-                    attrName = readUTF8(v, c);
-                    if ("LocalVariableTable".equals(attrName)) {
-                        if (!skipDebug) {
-                            varTable = v + 6;
-                            k = readUnsignedShort(v + 6);
-                            w = v + 8;
-                            for (; k > 0; --k) {
-                                label = readUnsignedShort(w);
-                                if (labels[label] == null) {
-                                    readLabel(label, labels).status |= Label.DEBUG;
-                                }
-                                label += readUnsignedShort(w + 2);
-                                if (labels[label] == null) {
-                                    readLabel(label, labels).status |= Label.DEBUG;
-                                }
-                                w += 10;
-                            }
-                        }
-                    } else if ("LocalVariableTypeTable".equals(attrName)) {
-                        varTypeTable = v + 6;
-                    } else if ("LineNumberTable".equals(attrName)) {
-                        if (!skipDebug) {
-                            k = readUnsignedShort(v + 6);
-                            w = v + 8;
-                            for (; k > 0; --k) {
-                                label = readUnsignedShort(w);
-                                if (labels[label] == null) {
-                                    readLabel(label, labels).status |= Label.DEBUG;
-                                }
-                                labels[label].line = readUnsignedShort(w + 2);
-                                w += 4;
-                            }
-                        }
-                    } else if (FRAMES && "StackMapTable".equals(attrName)) {
-                        if ((flags & SKIP_FRAMES) == 0) {
-                            stackMap = v + 8;
-                            stackMapSize = readInt(v + 2);
-                            frameCount = readUnsignedShort(v + 6);
-                        }
-                        /*
-                         * here we do not extract the labels corresponding to
-                         * the attribute content. This would require a full
-                         * parsing of the attribute, which would need to be
-                         * repeated in the second phase (see below). Instead the
-                         * content of the attribute is read one frame at a time
-                         * (i.e. after a frame has been visited, the next frame
-                         * is read), and the labels it contains are also
-                         * extracted one frame at a time. Thanks to the ordering
-                         * of frames, having only a "one frame lookahead" is not
-                         * a problem, i.e. it is not possible to see an offset
-                         * smaller than the offset of the current insn and for
-                         * which no Label exist.
-                         */
-                        /*
-                         * This is not true for UNINITIALIZED type offsets. We
-                         * solve this by parsing the stack map table without a
-                         * full decoding (see below).
-                         */
-                    } else if (FRAMES && "StackMap".equals(attrName)) {
-                        if ((flags & SKIP_FRAMES) == 0) {
-                            stackMap = v + 8;
-                            stackMapSize = readInt(v + 2);
-                            frameCount = readUnsignedShort(v + 6);
-                            zip = false;
-                        }
-                        /*
-                         * IMPORTANT! here we assume that the frames are
-                         * ordered, as in the StackMapTable attribute, although
-                         * this is not guaranteed by the attribute format.
-                         */
-                    } else {
-                        for (k = 0; k < attrs.length; ++k) {
-                            if (attrs[k].type.equals(attrName)) {
-                                attr = attrs[k].read(this,
-                                        v + 6,
-                                        readInt(v + 2),
-                                        c,
-                                        codeStart - 8,
-                                        labels);
-                                if (attr != null) {
-                                    attr.next = cattrs;
-                                    cattrs = attr;
-                                }
-                            }
-                        }
-                    }
-                    v += 6 + readInt(v + 2);
-                }
-
-                // 2nd phase: visits each instruction
-                if (FRAMES && stackMap != 0) {
-                    // creates the very first (implicit) frame from the method
-                    // descriptor
-                    frameLocal = new Object[maxLocals];
-                    frameStack = new Object[maxStack];
-                    if (unzip) {
-                        int local = 0;
-                        if ((access & Opcodes.ACC_STATIC) == 0) {
-                            if ("<init>".equals(name)) {
-                                frameLocal[local++] = Opcodes.UNINITIALIZED_THIS;
-                            } else {
-                                frameLocal[local++] = readClass(header + 2, c);
-                            }
-                        }
-                        j = 1;
-                        loop: while (true) {
-                            k = j;
-                            switch (desc.charAt(j++)) {
-                                case 'Z':
-                                case 'C':
-                                case 'B':
-                                case 'S':
-                                case 'I':
-                                    frameLocal[local++] = Opcodes.INTEGER;
-                                    break;
-                                case 'F':
-                                    frameLocal[local++] = Opcodes.FLOAT;
-                                    break;
-                                case 'J':
-                                    frameLocal[local++] = Opcodes.LONG;
-                                    break;
-                                case 'D':
-                                    frameLocal[local++] = Opcodes.DOUBLE;
-                                    break;
-                                case '[':
-                                    while (desc.charAt(j) == '[') {
-                                        ++j;
-                                    }
-                                    if (desc.charAt(j) == 'L') {
-                                        ++j;
-                                        while (desc.charAt(j) != ';') {
-                                            ++j;
-                                        }
-                                    }
-                                    frameLocal[local++] = desc.substring(k, ++j);
-                                    break;
-                                case 'L':
-                                    while (desc.charAt(j) != ';') {
-                                        ++j;
-                                    }
-                                    frameLocal[local++] = desc.substring(k + 1,
-                                            j++);
-                                    break;
-                                default:
-                                    break loop;
-                            }
-                        }
-                        frameLocalCount = local;
-                    }
-                    /*
-                     * for the first explicit frame the offset is not
-                     * offset_delta + 1 but only offset_delta; setting the
-                     * implicit frame offset to -1 allow the use of the
-                     * "offset_delta + 1" rule in all cases
-                     */
-                    frameOffset = -1;
-                    /*
-                     * Finds labels for UNINITIALIZED frame types. Instead of
-                     * decoding each element of the stack map table, we look
-                     * for 3 consecutive bytes that "look like" an UNINITIALIZED
-                     * type (tag 8, offset within code bounds, NEW instruction
-                     * at this offset). We may find false positives (i.e. not 
-                     * real UNINITIALIZED types), but this should be rare, and 
-                     * the only consequence will be the creation of an unneeded 
-                     * label. This is better than creating a label for each NEW
-                     * instruction, and faster than fully decoding the whole 
-                     * stack map table.
-                     */
-                    for (j = stackMap; j < stackMap + stackMapSize - 2; ++j) {
-                        if (b[j] == 8) { // UNINITIALIZED FRAME TYPE
-                            k = readUnsignedShort(j + 1);
-                            if (k >= 0 && k < codeLength) { // potential offset
-                                if ((b[codeStart + k] & 0xFF) == Opcodes.NEW) { // NEW at this offset
-                                    readLabel(k, labels);
-                                }
-                            }
-                        }
-                    }
-                }
-                v = codeStart;
-                Label l;
-                while (v < codeEnd) {
-                    w = v - codeStart;
-
-                    l = labels[w];
-                    if (l != null) {
-                        mv.visitLabel(l);
-                        if (!skipDebug && l.line > 0) {
-                            mv.visitLineNumber(l.line, l);
-                        }
-                    }
-
-                    while (FRAMES && frameLocal != null
-                            && (frameOffset == w || frameOffset == -1))
-                    {
-                        // if there is a frame for this offset,
-                        // makes the visitor visit it,
-                        // and reads the next frame if there is one.
-                        if (!zip || unzip) {
-                            mv.visitFrame(Opcodes.F_NEW,
-                                    frameLocalCount,
-                                    frameLocal,
-                                    frameStackCount,
-                                    frameStack);
-                        } else if (frameOffset != -1) {
-                            mv.visitFrame(frameMode,
-                                    frameLocalDiff,
-                                    frameLocal,
-                                    frameStackCount,
-                                    frameStack);
-                        }
-
-                        if (frameCount > 0) {
-                            int tag, delta, n;
-                            if (zip) {
-                                tag = b[stackMap++] & 0xFF;
-                            } else {
-                                tag = MethodWriter.FULL_FRAME;
-                                frameOffset = -1;
-                            }
-                            frameLocalDiff = 0;
-                            if (tag < MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME)
-                            {
-                                delta = tag;
-                                frameMode = Opcodes.F_SAME;
-                                frameStackCount = 0;
-                            } else if (tag < MethodWriter.RESERVED) {
-                                delta = tag
-                                        - MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME;
-                                stackMap = readFrameType(frameStack,
-                                        0,
-                                        stackMap,
-                                        c,
-                                        labels);
-                                frameMode = Opcodes.F_SAME1;
-                                frameStackCount = 1;
-                            } else {
-                                delta = readUnsignedShort(stackMap);
-                                stackMap += 2;
-                                if (tag == MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)
-                                {
-                                    stackMap = readFrameType(frameStack,
-                                            0,
-                                            stackMap,
-                                            c,
-                                            labels);
-                                    frameMode = Opcodes.F_SAME1;
-                                    frameStackCount = 1;
-                                } else if (tag >= MethodWriter.CHOP_FRAME
-                                        && tag < MethodWriter.SAME_FRAME_EXTENDED)
-                                {
-                                    frameMode = Opcodes.F_CHOP;
-                                    frameLocalDiff = MethodWriter.SAME_FRAME_EXTENDED
-                                            - tag;
-                                    frameLocalCount -= frameLocalDiff;
-                                    frameStackCount = 0;
-                                } else if (tag == MethodWriter.SAME_FRAME_EXTENDED)
-                                {
-                                    frameMode = Opcodes.F_SAME;
-                                    frameStackCount = 0;
-                                } else if (tag < MethodWriter.FULL_FRAME) {
-                                    j = unzip ? frameLocalCount : 0;
-                                    for (k = tag
-                                            - MethodWriter.SAME_FRAME_EXTENDED; k > 0; k--)
-                                    {
-                                        stackMap = readFrameType(frameLocal,
-                                                j++,
-                                                stackMap,
-                                                c,
-                                                labels);
-                                    }
-                                    frameMode = Opcodes.F_APPEND;
-                                    frameLocalDiff = tag
-                                            - MethodWriter.SAME_FRAME_EXTENDED;
-                                    frameLocalCount += frameLocalDiff;
-                                    frameStackCount = 0;
-                                } else { // if (tag == FULL_FRAME) {
-                                    frameMode = Opcodes.F_FULL;
-                                    n = frameLocalDiff = frameLocalCount = readUnsignedShort(stackMap);
-                                    stackMap += 2;
-                                    for (j = 0; n > 0; n--) {
-                                        stackMap = readFrameType(frameLocal,
-                                                j++,
-                                                stackMap,
-                                                c,
-                                                labels);
-                                    }
-                                    n = frameStackCount = readUnsignedShort(stackMap);
-                                    stackMap += 2;
-                                    for (j = 0; n > 0; n--) {
-                                        stackMap = readFrameType(frameStack,
-                                                j++,
-                                                stackMap,
-                                                c,
-                                                labels);
-                                    }
-                                }
-                            }
-                            frameOffset += delta + 1;
-                            readLabel(frameOffset, labels);
-
-                            --frameCount;
-                        } else {
-                            frameLocal = null;
-                        }
-                    }
-
-                    int opcode = b[v] & 0xFF;
-                    switch (ClassWriter.TYPE[opcode]) {
-                        case ClassWriter.NOARG_INSN:
-                            mv.visitInsn(opcode);
-                            v += 1;
-                            break;
-                        case ClassWriter.IMPLVAR_INSN:
-                            if (opcode > Opcodes.ISTORE) {
-                                opcode -= 59; // ISTORE_0
-                                mv.visitVarInsn(Opcodes.ISTORE + (opcode >> 2),
-                                        opcode & 0x3);
-                            } else {
-                                opcode -= 26; // ILOAD_0
-                                mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2),
-                                        opcode & 0x3);
-                            }
-                            v += 1;
-                            break;
-                        case ClassWriter.LABEL_INSN:
-                            mv.visitJumpInsn(opcode, labels[w
-                                    + readShort(v + 1)]);
-                            v += 3;
-                            break;
-                        case ClassWriter.LABELW_INSN:
-                            mv.visitJumpInsn(opcode - 33, labels[w
-                                    + readInt(v + 1)]);
-                            v += 5;
-                            break;
-                        case ClassWriter.WIDE_INSN:
-                            opcode = b[v + 1] & 0xFF;
-                            if (opcode == Opcodes.IINC) {
-                                mv.visitIincInsn(readUnsignedShort(v + 2),
-                                        readShort(v + 4));
-                                v += 6;
-                            } else {
-                                mv.visitVarInsn(opcode,
-                                        readUnsignedShort(v + 2));
-                                v += 4;
-                            }
-                            break;
-                        case ClassWriter.TABL_INSN:
-                            // skips 0 to 3 padding bytes
-                            v = v + 4 - (w & 3);
-                            // reads instruction
-                            label = w + readInt(v);
-                            int min = readInt(v + 4);
-                            int max = readInt(v + 8);
-                            v += 12;
-                            Label[] table = new Label[max - min + 1];
-                            for (j = 0; j < table.length; ++j) {
-                                table[j] = labels[w + readInt(v)];
-                                v += 4;
-                            }
-                            mv.visitTableSwitchInsn(min,
-                                    max,
-                                    labels[label],
-                                    table);
-                            break;
-                        case ClassWriter.LOOK_INSN:
-                            // skips 0 to 3 padding bytes
-                            v = v + 4 - (w & 3);
-                            // reads instruction
-                            label = w + readInt(v);
-                            j = readInt(v + 4);
-                            v += 8;
-                            int[] keys = new int[j];
-                            Label[] values = new Label[j];
-                            for (j = 0; j < keys.length; ++j) {
-                                keys[j] = readInt(v);
-                                values[j] = labels[w + readInt(v + 4)];
-                                v += 8;
-                            }
-                            mv.visitLookupSwitchInsn(labels[label],
-                                    keys,
-                                    values);
-                            break;
-                        case ClassWriter.VAR_INSN:
-                            mv.visitVarInsn(opcode, b[v + 1] & 0xFF);
-                            v += 2;
-                            break;
-                        case ClassWriter.SBYTE_INSN:
-                            mv.visitIntInsn(opcode, b[v + 1]);
-                            v += 2;
-                            break;
-                        case ClassWriter.SHORT_INSN:
-                            mv.visitIntInsn(opcode, readShort(v + 1));
-                            v += 3;
-                            break;
-                        case ClassWriter.LDC_INSN:
-                            mv.visitLdcInsn(readConst(b[v + 1] & 0xFF, c));
-                            v += 2;
-                            break;
-                        case ClassWriter.LDCW_INSN:
-                            mv.visitLdcInsn(readConst(readUnsignedShort(v + 1),
-                                    c));
-                            v += 3;
-                            break;
-                        case ClassWriter.FIELDORMETH_INSN:
-                        case ClassWriter.ITFDYNMETH_INSN:
-                            int cpIndex = items[readUnsignedShort(v + 1)];
-                            String iowner;
-                            // INVOKEDYNAMIC is receiverless
-                            if (opcode == Opcodes.INVOKEDYNAMIC) {
-                                iowner = Opcodes.INVOKEDYNAMIC_OWNER;
-                            } else {
-                                iowner = readClass(cpIndex, c);
-                                cpIndex = items[readUnsignedShort(cpIndex + 2)];
-                            }
-                            String iname = readUTF8(cpIndex, c);
-                            String idesc = readUTF8(cpIndex + 2, c);
-                            if (opcode < Opcodes.INVOKEVIRTUAL) {
-                                mv.visitFieldInsn(opcode, iowner, iname, idesc);
-                            } else {
-                                mv.visitMethodInsn(opcode, iowner, iname, idesc);
-                            }
-                            if (opcode == Opcodes.INVOKEINTERFACE || opcode == Opcodes.INVOKEDYNAMIC) {
-                                v += 5;
-                            } else {
-                                v += 3;
-                            }
-                            break;
-                        case ClassWriter.TYPE_INSN:
-                            mv.visitTypeInsn(opcode, readClass(v + 1, c));
-                            v += 3;
-                            break;
-                        case ClassWriter.IINC_INSN:
-                            mv.visitIincInsn(b[v + 1] & 0xFF, b[v + 2]);
-                            v += 3;
-                            break;
-                        // case MANA_INSN:
-                        default:
-                            mv.visitMultiANewArrayInsn(readClass(v + 1, c),
-                                    b[v + 3] & 0xFF);
-                            v += 4;
-                            break;
-                    }
-                }
-                l = labels[codeEnd - codeStart];
-                if (l != null) {
-                    mv.visitLabel(l);
-                }
-                // visits the local variable tables
-                if (!skipDebug && varTable != 0) {
-                    int[] typeTable = null;
-                    if (varTypeTable != 0) {
-                        k = readUnsignedShort(varTypeTable) * 3;
-                        w = varTypeTable + 2;
-                        typeTable = new int[k];
-                        while (k > 0) {
-                            typeTable[--k] = w + 6; // signature
-                            typeTable[--k] = readUnsignedShort(w + 8); // index
-                            typeTable[--k] = readUnsignedShort(w); // start
-                            w += 10;
-                        }
-                    }
-                    k = readUnsignedShort(varTable);
-                    w = varTable + 2;
-                    for (; k > 0; --k) {
-                        int start = readUnsignedShort(w);
-                        int length = readUnsignedShort(w + 2);
-                        int index = readUnsignedShort(w + 8);
-                        String vsignature = null;
-                        if (typeTable != null) {
-                            for (int a = 0; a < typeTable.length; a += 3) {
-                                if (typeTable[a] == start
-                                        && typeTable[a + 1] == index)
-                                {
-                                    vsignature = readUTF8(typeTable[a + 2], c);
-                                    break;
-                                }
-                            }
-                        }
-                        mv.visitLocalVariable(readUTF8(w + 4, c),
-                                readUTF8(w + 6, c),
-                                vsignature,
-                                labels[start],
-                                labels[start + length],
-                                index);
-                        w += 10;
-                    }
-                }
-                // visits the other attributes
-                while (cattrs != null) {
-                    attr = cattrs.next;
-                    cattrs.next = null;
-                    mv.visitAttribute(cattrs);
-                    cattrs = attr;
-                }
-                // visits the max stack and max locals values
-                mv.visitMaxs(maxStack, maxLocals);
-            }
-
-            if (mv != null) {
-                mv.visitEnd();
-            }
-        }
-
-        // visits the end of the class
-        classVisitor.visitEnd();
-    }
-
-    /**
-     * Reads parameter annotations and makes the given visitor visit them.
-     * 
-     * @param v start offset in {@link #b b} of the annotations to be read.
-     * @param desc the method descriptor.
-     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},
-     *        {@link #readClass(int,char[]) readClass} or
-     *        {@link #readConst readConst}.
-     * @param visible <tt>true</tt> if the annotations to be read are visible
-     *        at runtime.
-     * @param mv the visitor that must visit the annotations.
-     */
-    private void readParameterAnnotations(
-        int v,
-        final String desc,
-        final char[] buf,
-        final boolean visible,
-        final MethodVisitor mv)
-    {
-        int i;
-        int n = b[v++] & 0xFF;
-        // workaround for a bug in javac (javac compiler generates a parameter
-        // annotation array whose size is equal to the number of parameters in
-        // the Java source file, while it should generate an array whose size is
-        // equal to the number of parameters in the method descriptor - which
-        // includes the synthetic parameters added by the compiler). This work-
-        // around supposes that the synthetic parameters are the first ones.
-        int synthetics = Type.getArgumentTypes(desc).length - n;
-        AnnotationVisitor av;
-        for (i = 0; i < synthetics; ++i) {
-            // virtual annotation to detect synthetic parameters in MethodWriter 
-            av = mv.visitParameterAnnotation(i, "Ljava/lang/Synthetic;", false);
-            if (av != null) {
-                av.visitEnd();
-            }
-        }
-        for (; i < n + synthetics; ++i) {
-            int j = readUnsignedShort(v);
-            v += 2;
-            for (; j > 0; --j) {
-                av = mv.visitParameterAnnotation(i, readUTF8(v, buf), visible);
-                v = readAnnotationValues(v + 2, buf, true, av);
-            }
-        }
-    }
-
-    /**
-     * Reads the values of an annotation and makes the given visitor visit them.
-     * 
-     * @param v the start offset in {@link #b b} of the values to be read
-     *        (including the unsigned short that gives the number of values).
-     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},
-     *        {@link #readClass(int,char[]) readClass} or
-     *        {@link #readConst readConst}.
-     * @param named if the annotation values are named or not.
-     * @param av the visitor that must visit the values.
-     * @return the end offset of the annotation values.
-     */
-    private int readAnnotationValues(
-        int v,
-        final char[] buf,
-        final boolean named,
-        final AnnotationVisitor av)
-    {
-        int i = readUnsignedShort(v);
-        v += 2;
-        if (named) {
-            for (; i > 0; --i) {
-                v = readAnnotationValue(v + 2, buf, readUTF8(v, buf), av);
-            }
-        } else {
-            for (; i > 0; --i) {
-                v = readAnnotationValue(v, buf, null, av);
-            }
-        }
-        if (av != null) {
-            av.visitEnd();
-        }
-        return v;
-    }
-
-    /**
-     * Reads a value of an annotation and makes the given visitor visit it.
-     * 
-     * @param v the start offset in {@link #b b} of the value to be read (<i>not
-     *        including the value name constant pool index</i>).
-     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},
-     *        {@link #readClass(int,char[]) readClass} or
-     *        {@link #readConst readConst}.
-     * @param name the name of the value to be read.
-     * @param av the visitor that must visit the value.
-     * @return the end offset of the annotation value.
-     */
-    private int readAnnotationValue(
-        int v,
-        final char[] buf,
-        final String name,
-        final AnnotationVisitor av)
-    {
-        int i;
-        if (av == null) {
-            switch (b[v] & 0xFF) {
-                case 'e': // enum_const_value
-                    return v + 5;
-                case '@': // annotation_value
-                    return readAnnotationValues(v + 3, buf, true, null);
-                case '[': // array_value
-                    return readAnnotationValues(v + 1, buf, false, null);
-                default:
-                    return v + 3;
-            }
-        }
-        switch (b[v++] & 0xFF) {
-            case 'I': // pointer to CONSTANT_Integer
-            case 'J': // pointer to CONSTANT_Long
-            case 'F': // pointer to CONSTANT_Float
-            case 'D': // pointer to CONSTANT_Double
-                av.visit(name, readConst(readUnsignedShort(v), buf));
-                v += 2;
-                break;
-            case 'B': // pointer to CONSTANT_Byte
-                av.visit(name,
-                        new Byte((byte) readInt(items[readUnsignedShort(v)])));
-                v += 2;
-                break;
-            case 'Z': // pointer to CONSTANT_Boolean
-                av.visit(name, readInt(items[readUnsignedShort(v)]) == 0
-                        ? Boolean.FALSE
-                        : Boolean.TRUE);
-                v += 2;
-                break;
-            case 'S': // pointer to CONSTANT_Short
-                av.visit(name,
-                        new Short((short) readInt(items[readUnsignedShort(v)])));
-                v += 2;
-                break;
-            case 'C': // pointer to CONSTANT_Char
-                av.visit(name,
-                        new Character((char) readInt(items[readUnsignedShort(v)])));
-                v += 2;
-                break;
-            case 's': // pointer to CONSTANT_Utf8
-                av.visit(name, readUTF8(v, buf));
-                v += 2;
-                break;
-            case 'e': // enum_const_value
-                av.visitEnum(name, readUTF8(v, buf), readUTF8(v + 2, buf));
-                v += 4;
-                break;
-            case 'c': // class_info
-                av.visit(name, Type.getType(readUTF8(v, buf)));
-                v += 2;
-                break;
-            case '@': // annotation_value
-                v = readAnnotationValues(v + 2,
-                        buf,
-                        true,
-                        av.visitAnnotation(name, readUTF8(v, buf)));
-                break;
-            case '[': // array_value
-                int size = readUnsignedShort(v);
-                v += 2;
-                if (size == 0) {
-                    return readAnnotationValues(v - 2,
-                            buf,
-                            false,
-                            av.visitArray(name));
-                }
-                switch (this.b[v++] & 0xFF) {
-                    case 'B':
-                        byte[] bv = new byte[size];
-                        for (i = 0; i < size; i++) {
-                            bv[i] = (byte) readInt(items[readUnsignedShort(v)]);
-                            v += 3;
-                        }
-                        av.visit(name, bv);
-                        --v;
-                        break;
-                    case 'Z':
-                        boolean[] zv = new boolean[size];
-                        for (i = 0; i < size; i++) {
-                            zv[i] = readInt(items[readUnsignedShort(v)]) != 0;
-                            v += 3;
-                        }
-                        av.visit(name, zv);
-                        --v;
-                        break;
-                    case 'S':
-                        short[] sv = new short[size];
-                        for (i = 0; i < size; i++) {
-                            sv[i] = (short) readInt(items[readUnsignedShort(v)]);
-                            v += 3;
-                        }
-                        av.visit(name, sv);
-                        --v;
-                        break;
-                    case 'C':
-                        char[] cv = new char[size];
-                        for (i = 0; i < size; i++) {
-                            cv[i] = (char) readInt(items[readUnsignedShort(v)]);
-                            v += 3;
-                        }
-                        av.visit(name, cv);
-                        --v;
-                        break;
-                    case 'I':
-                        int[] iv = new int[size];
-                        for (i = 0; i < size; i++) {
-                            iv[i] = readInt(items[readUnsignedShort(v)]);
-                            v += 3;
-                        }
-                        av.visit(name, iv);
-                        --v;
-                        break;
-                    case 'J':
-                        long[] lv = new long[size];
-                        for (i = 0; i < size; i++) {
-                            lv[i] = readLong(items[readUnsignedShort(v)]);
-                            v += 3;
-                        }
-                        av.visit(name, lv);
-                        --v;
-                        break;
-                    case 'F':
-                        float[] fv = new float[size];
-                        for (i = 0; i < size; i++) {
-                            fv[i] = Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));
-                            v += 3;
-                        }
-                        av.visit(name, fv);
-                        --v;
-                        break;
-                    case 'D':
-                        double[] dv = new double[size];
-                        for (i = 0; i < size; i++) {
-                            dv[i] = Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));
-                            v += 3;
-                        }
-                        av.visit(name, dv);
-                        --v;
-                        break;
-                    default:
-                        v = readAnnotationValues(v - 3,
-                                buf,
-                                false,
-                                av.visitArray(name));
-                }
-        }
-        return v;
-    }
-
-    private int readFrameType(
-        final Object[] frame,
-        final int index,
-        int v,
-        final char[] buf,
-        final Label[] labels)
-    {
-        int type = b[v++] & 0xFF;
-        switch (type) {
-            case 0:
-                frame[index] = Opcodes.TOP;
-                break;
-            case 1:
-                frame[index] = Opcodes.INTEGER;
-                break;
-            case 2:
-                frame[index] = Opcodes.FLOAT;
-                break;
-            case 3:
-                frame[index] = Opcodes.DOUBLE;
-                break;
-            case 4:
-                frame[index] = Opcodes.LONG;
-                break;
-            case 5:
-                frame[index] = Opcodes.NULL;
-                break;
-            case 6:
-                frame[index] = Opcodes.UNINITIALIZED_THIS;
-                break;
-            case 7: // Object
-                frame[index] = readClass(v, buf);
-                v += 2;
-                break;
-            default: // Uninitialized
-                frame[index] = readLabel(readUnsignedShort(v), labels);
-                v += 2;
-        }
-        return v;
-    }
-
-    /**
-     * Returns the label corresponding to the given offset. The default
-     * implementation of this method creates a label for the given offset if it
-     * has not been already created.
-     * 
-     * @param offset a bytecode offset in a method.
-     * @param labels the already created labels, indexed by their offset. If a
-     *        label already exists for offset this method must not create a new
-     *        one. Otherwise it must store the new label in this array.
-     * @return a non null Label, which must be equal to labels[offset].
-     */
-    protected Label readLabel(int offset, Label[] labels) {
-        if (labels[offset] == null) {
-            labels[offset] = new Label();
-        }
-        return labels[offset];
-    }
-
-    /**
-     * Reads an attribute in {@link #b b}.
-     * 
-     * @param attrs prototypes of the attributes that must be parsed during the
-     *        visit of the class. Any attribute whose type is not equal to the
-     *        type of one the prototypes is ignored (i.e. an empty
-     *        {@link Attribute} instance is returned).
-     * @param type the type of the attribute.
-     * @param off index of the first byte of the attribute's content in
-     *        {@link #b b}. The 6 attribute header bytes, containing the type
-     *        and the length of the attribute, are not taken into account here
-     *        (they have already been read).
-     * @param len the length of the attribute's content.
-     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},
-     *        {@link #readClass(int,char[]) readClass} or
-     *        {@link #readConst readConst}.
-     * @param codeOff index of the first byte of code's attribute content in
-     *        {@link #b b}, or -1 if the attribute to be read is not a code
-     *        attribute. The 6 attribute header bytes, containing the type and
-     *        the length of the attribute, are not taken into account here.
-     * @param labels the labels of the method's code, or <tt>null</tt> if the
-     *        attribute to be read is not a code attribute.
-     * @return the attribute that has been read, or <tt>null</tt> to skip this
-     *         attribute.
-     */
-    private Attribute readAttribute(
-        final Attribute[] attrs,
-        final String type,
-        final int off,
-        final int len,
-        final char[] buf,
-        final int codeOff,
-        final Label[] labels)
-    {
-        for (int i = 0; i < attrs.length; ++i) {
-            if (attrs[i].type.equals(type)) {
-                return attrs[i].read(this, off, len, buf, codeOff, labels);
-            }
-        }
-        return new Attribute(type).read(this, off, len, null, -1, null);
-    }
-
-    // ------------------------------------------------------------------------
-    // Utility methods: low level parsing
-    // ------------------------------------------------------------------------
-
-    /**
-     * Returns the start index of the constant pool item in {@link #b b}, plus
-     * one. <i>This method is intended for {@link Attribute} sub classes, and is
-     * normally not needed by class generators or adapters.</i>
-     * 
-     * @param item the index a constant pool item.
-     * @return the start index of the constant pool item in {@link #b b}, plus
-     *         one.
-     */
-    public int getItem(final int item) {
-        return items[item];
-    }
-
-    /**
-     * Reads a byte value in {@link #b b}. <i>This method is intended for
-     * {@link Attribute} sub classes, and is normally not needed by class
-     * generators or adapters.</i>
-     * 
-     * @param index the start index of the value to be read in {@link #b b}.
-     * @return the read value.
-     */
-    public int readByte(final int index) {
-        return b[index] & 0xFF;
-    }
-
-    /**
-     * Reads an unsigned short value in {@link #b b}. <i>This method is
-     * intended for {@link Attribute} sub classes, and is normally not needed by
-     * class generators or adapters.</i>
-     * 
-     * @param index the start index of the value to be read in {@link #b b}.
-     * @return the read value.
-     */
-    public int readUnsignedShort(final int index) {
-        byte[] b = this.b;
-        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);
-    }
-
-    /**
-     * Reads a signed short value in {@link #b b}. <i>This method is intended
-     * for {@link Attribute} sub classes, and is normally not needed by class
-     * generators or adapters.</i>
-     * 
-     * @param index the start index of the value to be read in {@link #b b}.
-     * @return the read value.
-     */
-    public short readShort(final int index) {
-        byte[] b = this.b;
-        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));
-    }
-
-    /**
-     * Reads a signed int value in {@link #b b}. <i>This method is intended for
-     * {@link Attribute} sub classes, and is normally not needed by class
-     * generators or adapters.</i>
-     * 
-     * @param index the start index of the value to be read in {@link #b b}.
-     * @return the read value.
-     */
-    public int readInt(final int index) {
-        byte[] b = this.b;
-        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16)
-                | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);
-    }
-
-    /**
-     * Reads a signed long value in {@link #b b}. <i>This method is intended
-     * for {@link Attribute} sub classes, and is normally not needed by class
-     * generators or adapters.</i>
-     * 
-     * @param index the start index of the value to be read in {@link #b b}.
-     * @return the read value.
-     */
-    public long readLong(final int index) {
-        long l1 = readInt(index);
-        long l0 = readInt(index + 4) & 0xFFFFFFFFL;
-        return (l1 << 32) | l0;
-    }
-
-    /**
-     * Reads an UTF8 string constant pool item in {@link #b b}. <i>This method
-     * is intended for {@link Attribute} sub classes, and is normally not needed
-     * by class generators or adapters.</i>
-     * 
-     * @param index the start index of an unsigned short value in {@link #b b},
-     *        whose value is the index of an UTF8 constant pool item.
-     * @param buf buffer to be used to read the item. This buffer must be
-     *        sufficiently large. It is not automatically resized.
-     * @return the String corresponding to the specified UTF8 item.
-     */
-    public String readUTF8(int index, final char[] buf) {
-        int item = readUnsignedShort(index);
-        String s = strings[item];
-        if (s != null) {
-            return s;
-        }
-        index = items[item];
-        return strings[item] = readUTF(index + 2, readUnsignedShort(index), buf);
-    }
-
-    /**
-     * Reads UTF8 string in {@link #b b}.
-     * 
-     * @param index start offset of the UTF8 string to be read.
-     * @param utfLen length of the UTF8 string to be read.
-     * @param buf buffer to be used to read the string. This buffer must be
-     *        sufficiently large. It is not automatically resized.
-     * @return the String corresponding to the specified UTF8 string.
-     */
-    private String readUTF(int index, final int utfLen, final char[] buf) {
-        int endIndex = index + utfLen;
-        byte[] b = this.b;
-        int strLen = 0;
-        int c;
-        int st = 0;
-        char cc = 0;
-        while (index < endIndex) {
-            c = b[index++];
-            switch (st) {
-                case 0:
-                    c = c & 0xFF;
-                    if (c < 0x80) {  // 0xxxxxxx
-                        buf[strLen++] = (char) c;
-                    } else if (c < 0xE0 && c > 0xBF) {  // 110x xxxx 10xx xxxx
-                        cc = (char) (c & 0x1F);
-                        st = 1;
-                    } else {  // 1110 xxxx 10xx xxxx 10xx xxxx
-                        cc = (char) (c & 0x0F);
-                        st = 2;
-                    }
-                    break;
-                    
-                case 1:  // byte 2 of 2-byte char or byte 3 of 3-byte char 
-                    buf[strLen++] = (char) ((cc << 6) | (c & 0x3F));
-                    st = 0;
-                    break;
-                    
-                case 2:  // byte 2 of 3-byte char
-                    cc = (char) ((cc << 6) | (c & 0x3F));
-                    st = 1;
-                    break;
-            }
-        }
-        return new String(buf, 0, strLen);
-    }
-    
-    /**
-     * Reads a class constant pool item in {@link #b b}. <i>This method is
-     * intended for {@link Attribute} sub classes, and is normally not needed by
-     * class generators or adapters.</i>
-     * 
-     * @param index the start index of an unsigned short value in {@link #b b},
-     *        whose value is the index of a class constant pool item.
-     * @param buf buffer to be used to read the item. This buffer must be
-     *        sufficiently large. It is not automatically resized.
-     * @return the String corresponding to the specified class item.
-     */
-    public String readClass(final int index, final char[] buf) {
-        // computes the start index of the CONSTANT_Class item in b
-        // and reads the CONSTANT_Utf8 item designated by
-        // the first two bytes of this CONSTANT_Class item
-        return readUTF8(items[readUnsignedShort(index)], buf);
-    }
-
-    /**
-     * Reads a numeric or string constant pool item in {@link #b b}. <i>This
-     * method is intended for {@link Attribute} sub classes, and is normally not
-     * needed by class generators or adapters.</i>
-     * 
-     * @param item the index of a constant pool item.
-     * @param buf buffer to be used to read the item. This buffer must be
-     *        sufficiently large. It is not automatically resized.
-     * @return the {@link Integer}, {@link Float}, {@link Long},
-     *         {@link Double}, {@link String} or {@link Type} corresponding to
-     *         the given constant pool item.
-     */
-    public Object readConst(final int item, final char[] buf) {
-        int index = items[item];
-        switch (b[index - 1]) {
-            case ClassWriter.INT:
-                return new Integer(readInt(index));
-            case ClassWriter.FLOAT:
-                return new Float(Float.intBitsToFloat(readInt(index)));
-            case ClassWriter.LONG:
-                return new Long(readLong(index));
-            case ClassWriter.DOUBLE:
-                return new Double(Double.longBitsToDouble(readLong(index)));
-            case ClassWriter.CLASS:
-                return Type.getObjectType(readUTF8(index, buf));
-                // case ClassWriter.STR:
-            default:
-                return readUTF8(index, buf);
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/ClassVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/ClassVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/ClassVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/ClassVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,196 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * A visitor to visit a Java class. The methods of this interface must be called
- * in the following order: <tt>visit</tt> [ <tt>visitSource</tt> ] [
- * <tt>visitOuterClass</tt> ] ( <tt>visitAnnotation</tt> |
- * <tt>visitAttribute</tt> )* (<tt>visitInnerClass</tt> |
- * <tt>visitField</tt> | <tt>visitMethod</tt> )* <tt>visitEnd</tt>.
- * 
- * @author Eric Bruneton
- */
-public interface ClassVisitor {
-
-    /**
-     * Visits the header of the class.
-     * 
-     * @param version the class version.
-     * @param access the class's access flags (see {@link Opcodes}). This
-     *        parameter also indicates if the class is deprecated.
-     * @param name the internal name of the class (see
-     *        {@link Type#getInternalName() getInternalName}).
-     * @param signature the signature of this class. May be <tt>null</tt> if
-     *        the class is not a generic one, and does not extend or implement
-     *        generic classes or interfaces.
-     * @param superName the internal of name of the super class (see
-     *        {@link Type#getInternalName() getInternalName}). For interfaces,
-     *        the super class is {@link Object}. May be <tt>null</tt>, but
-     *        only for the {@link Object} class.
-     * @param interfaces the internal names of the class's interfaces (see
-     *        {@link Type#getInternalName() getInternalName}). May be
-     *        <tt>null</tt>.
-     */
-    void visit(
-        int version,
-        int access,
-        String name,
-        String signature,
-        String superName,
-        String[] interfaces);
-
-    /**
-     * Visits the source of the class.
-     * 
-     * @param source the name of the source file from which the class was
-     *        compiled. May be <tt>null</tt>.
-     * @param debug additional debug information to compute the correspondance
-     *        between source and compiled elements of the class. May be
-     *        <tt>null</tt>.
-     */
-    void visitSource(String source, String debug);
-
-    /**
-     * Visits the enclosing class of the class. This method must be called only
-     * if the class has an enclosing class.
-     * 
-     * @param owner internal name of the enclosing class of the class.
-     * @param name the name of the method that contains the class, or
-     *        <tt>null</tt> if the class is not enclosed in a method of its
-     *        enclosing class.
-     * @param desc the descriptor of the method that contains the class, or
-     *        <tt>null</tt> if the class is not enclosed in a method of its
-     *        enclosing class.
-     */
-    void visitOuterClass(String owner, String name, String desc);
-
-    /**
-     * Visits an annotation of the class.
-     * 
-     * @param desc the class descriptor of the annotation class.
-     * @param visible <tt>true</tt> if the annotation is visible at runtime.
-     * @return a visitor to visit the annotation values, or <tt>null</tt> if
-     *         this visitor is not interested in visiting this annotation.
-     */
-    AnnotationVisitor visitAnnotation(String desc, boolean visible);
-
-    /**
-     * Visits a non standard attribute of the class.
-     * 
-     * @param attr an attribute.
-     */
-    void visitAttribute(Attribute attr);
-
-    /**
-     * Visits information about an inner class. This inner class is not
-     * necessarily a member of the class being visited.
-     * 
-     * @param name the internal name of an inner class (see
-     *        {@link Type#getInternalName() getInternalName}).
-     * @param outerName the internal name of the class to which the inner class
-     *        belongs (see {@link Type#getInternalName() getInternalName}). May
-     *        be <tt>null</tt> for not member classes.
-     * @param innerName the (simple) name of the inner class inside its
-     *        enclosing class. May be <tt>null</tt> for anonymous inner
-     *        classes.
-     * @param access the access flags of the inner class as originally declared
-     *        in the enclosing class.
-     */
-    void visitInnerClass(
-        String name,
-        String outerName,
-        String innerName,
-        int access);
-
-    /**
-     * Visits a field of the class.
-     * 
-     * @param access the field's access flags (see {@link Opcodes}). This
-     *        parameter also indicates if the field is synthetic and/or
-     *        deprecated.
-     * @param name the field's name.
-     * @param desc the field's descriptor (see {@link Type Type}).
-     * @param signature the field's signature. May be <tt>null</tt> if the
-     *        field's type does not use generic types.
-     * @param value the field's initial value. This parameter, which may be
-     *        <tt>null</tt> if the field does not have an initial value, must
-     *        be an {@link Integer}, a {@link Float}, a {@link Long}, a
-     *        {@link Double} or a {@link String} (for <tt>int</tt>,
-     *        <tt>float</tt>, <tt>long</tt> or <tt>String</tt> fields
-     *        respectively). <i>This parameter is only used for static fields</i>.
-     *        Its value is ignored for non static fields, which must be
-     *        initialized through bytecode instructions in constructors or
-     *        methods.
-     * @return a visitor to visit field annotations and attributes, or
-     *         <tt>null</tt> if this class visitor is not interested in
-     *         visiting these annotations and attributes.
-     */
-    FieldVisitor visitField(
-        int access,
-        String name,
-        String desc,
-        String signature,
-        Object value);
-
-    /**
-     * Visits a method of the class. This method <i>must</i> return a new
-     * {@link MethodVisitor} instance (or <tt>null</tt>) each time it is
-     * called, i.e., it should not return a previously returned visitor.
-     * 
-     * @param access the method's access flags (see {@link Opcodes}). This
-     *        parameter also indicates if the method is synthetic and/or
-     *        deprecated.
-     * @param name the method's name.
-     * @param desc the method's descriptor (see {@link Type Type}).
-     * @param signature the method's signature. May be <tt>null</tt> if the
-     *        method parameters, return type and exceptions do not use generic
-     *        types.
-     * @param exceptions the internal names of the method's exception classes
-     *        (see {@link Type#getInternalName() getInternalName}). May be
-     *        <tt>null</tt>.
-     * @return an object to visit the byte code of the method, or <tt>null</tt>
-     *         if this class visitor is not interested in visiting the code of
-     *         this method.
-     */
-    MethodVisitor visitMethod(
-        int access,
-        String name,
-        String desc,
-        String signature,
-        String[] exceptions);
-
-    /**
-     * Visits the end of the class. This method, which is the last one to be
-     * called, is used to inform the visitor that all the fields and methods of
-     * the class have been visited.
-     */
-    void visitEnd();
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/ClassWriter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/ClassWriter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/ClassWriter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/ClassWriter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,1369 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * A {@link ClassVisitor} that generates classes in bytecode form. More
- * precisely this visitor generates a byte array conforming to the Java class
- * file format. It can be used alone, to generate a Java class "from scratch",
- * or with one or more {@link ClassReader ClassReader} and adapter class visitor
- * to generate a modified class from one or more existing Java classes.
- *
- * @author Eric Bruneton
- */
-public class ClassWriter implements ClassVisitor {
-
-    /**
-     * Flag to automatically compute the maximum stack size and the maximum
-     * number of local variables of methods. If this flag is set, then the
-     * arguments of the {@link MethodVisitor#visitMaxs visitMaxs} method of the
-     * {@link MethodVisitor} returned by the {@link #visitMethod visitMethod}
-     * method will be ignored, and computed automatically from the signature and
-     * the bytecode of each method.
-     *
-     * @see #ClassWriter(int)
-     */
-    public static final int COMPUTE_MAXS = 1;
-
-    /**
-     * Flag to automatically compute the stack map frames of methods from
-     * scratch. If this flag is set, then the calls to the
-     * {@link MethodVisitor#visitFrame} method are ignored, and the stack map
-     * frames are recomputed from the methods bytecode. The arguments of the
-     * {@link MethodVisitor#visitMaxs visitMaxs} method are also ignored and
-     * recomputed from the bytecode. In other words, computeFrames implies
-     * computeMaxs.
-     *
-     * @see #ClassWriter(int)
-     */
-    public static final int COMPUTE_FRAMES = 2;
-
-    /**
-     * Pseudo access flag to distinguish between the synthetic attribute and
-     * the synthetic access flag.
-     */
-    static final int ACC_SYNTHETIC_ATTRIBUTE = 0x40000;
-    
-    /**
-     * The type of instructions without any argument.
-     */
-    static final int NOARG_INSN = 0;
-
-    /**
-     * The type of instructions with an signed byte argument.
-     */
-    static final int SBYTE_INSN = 1;
-
-    /**
-     * The type of instructions with an signed short argument.
-     */
-    static final int SHORT_INSN = 2;
-
-    /**
-     * The type of instructions with a local variable index argument.
-     */
-    static final int VAR_INSN = 3;
-
-    /**
-     * The type of instructions with an implicit local variable index argument.
-     */
-    static final int IMPLVAR_INSN = 4;
-
-    /**
-     * The type of instructions with a type descriptor argument.
-     */
-    static final int TYPE_INSN = 5;
-
-    /**
-     * The type of field and method invocations instructions.
-     */
-    static final int FIELDORMETH_INSN = 6;
-
-    /**
-     * The type of the INVOKEINTERFACE/INVOKEDYNAMIC instruction.
-     */
-    static final int ITFDYNMETH_INSN = 7;
-
-    /**
-     * The type of instructions with a 2 bytes bytecode offset label.
-     */
-    static final int LABEL_INSN = 8;
-
-    /**
-     * The type of instructions with a 4 bytes bytecode offset label.
-     */
-    static final int LABELW_INSN = 9;
-
-    /**
-     * The type of the LDC instruction.
-     */
-    static final int LDC_INSN = 10;
-
-    /**
-     * The type of the LDC_W and LDC2_W instructions.
-     */
-    static final int LDCW_INSN = 11;
-
-    /**
-     * The type of the IINC instruction.
-     */
-    static final int IINC_INSN = 12;
-
-    /**
-     * The type of the TABLESWITCH instruction.
-     */
-    static final int TABL_INSN = 13;
-
-    /**
-     * The type of the LOOKUPSWITCH instruction.
-     */
-    static final int LOOK_INSN = 14;
-
-    /**
-     * The type of the MULTIANEWARRAY instruction.
-     */
-    static final int MANA_INSN = 15;
-
-    /**
-     * The type of the WIDE instruction.
-     */
-    static final int WIDE_INSN = 16;
-
-    /**
-     * The instruction types of all JVM opcodes.
-     */
-    static final byte[] TYPE;
-
-    /**
-     * The type of CONSTANT_Class constant pool items.
-     */
-    static final int CLASS = 7;
-
-    /**
-     * The type of CONSTANT_Fieldref constant pool items.
-     */
-    static final int FIELD = 9;
-
-    /**
-     * The type of CONSTANT_Methodref constant pool items.
-     */
-    static final int METH = 10;
-
-    /**
-     * The type of CONSTANT_InterfaceMethodref constant pool items.
-     */
-    static final int IMETH = 11;
-
-    /**
-     * The type of CONSTANT_String constant pool items.
-     */
-    static final int STR = 8;
-
-    /**
-     * The type of CONSTANT_Integer constant pool items.
-     */
-    static final int INT = 3;
-
-    /**
-     * The type of CONSTANT_Float constant pool items.
-     */
-    static final int FLOAT = 4;
-
-    /**
-     * The type of CONSTANT_Long constant pool items.
-     */
-    static final int LONG = 5;
-
-    /**
-     * The type of CONSTANT_Double constant pool items.
-     */
-    static final int DOUBLE = 6;
-
-    /**
-     * The type of CONSTANT_NameAndType constant pool items.
-     */
-    static final int NAME_TYPE = 12;
-
-    /**
-     * The type of CONSTANT_Utf8 constant pool items.
-     */
-    static final int UTF8 = 1;
-
-    /**
-     * Normal type Item stored in the ClassWriter {@link ClassWriter#typeTable},
-     * instead of the constant pool, in order to avoid clashes with normal
-     * constant pool items in the ClassWriter constant pool's hash table.
-     */
-    static final int TYPE_NORMAL = 13;
-
-    /**
-     * Uninitialized type Item stored in the ClassWriter
-     * {@link ClassWriter#typeTable}, instead of the constant pool, in order to
-     * avoid clashes with normal constant pool items in the ClassWriter constant
-     * pool's hash table.
-     */
-    static final int TYPE_UNINIT = 14;
-
-    /**
-     * Merged type Item stored in the ClassWriter {@link ClassWriter#typeTable},
-     * instead of the constant pool, in order to avoid clashes with normal
-     * constant pool items in the ClassWriter constant pool's hash table.
-     */
-    static final int TYPE_MERGED = 15;
-
-    /**
-     * The class reader from which this class writer was constructed, if any.
-     */
-    ClassReader cr;
-
-    /**
-     * Minor and major version numbers of the class to be generated.
-     */
-    int version;
-
-    /**
-     * Index of the next item to be added in the constant pool.
-     */
-    int index;
-
-    /**
-     * The constant pool of this class.
-     */
-    final ByteVector pool;
-
-    /**
-     * The constant pool's hash table data.
-     */
-    Item[] items;
-
-    /**
-     * The threshold of the constant pool's hash table.
-     */
-    int threshold;
-
-    /**
-     * A reusable key used to look for items in the {@link #items} hash table.
-     */
-    final Item key;
-
-    /**
-     * A reusable key used to look for items in the {@link #items} hash table.
-     */
-    final Item key2;
-
-    /**
-     * A reusable key used to look for items in the {@link #items} hash table.
-     */
-    final Item key3;
-
-    /**
-     * A type table used to temporarily store internal names that will not
-     * necessarily be stored in the constant pool. This type table is used by
-     * the control flow and data flow analysis algorithm used to compute stack
-     * map frames from scratch. This array associates to each index <tt>i</tt>
-     * the Item whose index is <tt>i</tt>. All Item objects stored in this
-     * array are also stored in the {@link #items} hash table. These two arrays
-     * allow to retrieve an Item from its index or, conversely, to get the index
-     * of an Item from its value. Each Item stores an internal name in its
-     * {@link Item#strVal1} field.
-     */
-    Item[] typeTable;
-
-    /**
-     * Number of elements in the {@link #typeTable} array.
-     */
-    private short typeCount;
-
-    /**
-     * The access flags of this class.
-     */
-    private int access;
-
-    /**
-     * The constant pool item that contains the internal name of this class.
-     */
-    private int name;
-
-    /**
-     * The internal name of this class.
-     */
-    String thisName;
-
-    /**
-     * The constant pool item that contains the signature of this class.
-     */
-    private int signature;
-
-    /**
-     * The constant pool item that contains the internal name of the super class
-     * of this class.
-     */
-    private int superName;
-
-    /**
-     * Number of interfaces implemented or extended by this class or interface.
-     */
-    private int interfaceCount;
-
-    /**
-     * The interfaces implemented or extended by this class or interface. More
-     * precisely, this array contains the indexes of the constant pool items
-     * that contain the internal names of these interfaces.
-     */
-    private int[] interfaces;
-
-    /**
-     * The index of the constant pool item that contains the name of the source
-     * file from which this class was compiled.
-     */
-    private int sourceFile;
-
-    /**
-     * The SourceDebug attribute of this class.
-     */
-    private ByteVector sourceDebug;
-
-    /**
-     * The constant pool item that contains the name of the enclosing class of
-     * this class.
-     */
-    private int enclosingMethodOwner;
-
-    /**
-     * The constant pool item that contains the name and descriptor of the
-     * enclosing method of this class.
-     */
-    private int enclosingMethod;
-
-    /**
-     * The runtime visible annotations of this class.
-     */
-    private AnnotationWriter anns;
-
-    /**
-     * The runtime invisible annotations of this class.
-     */
-    private AnnotationWriter ianns;
-
-    /**
-     * The non standard attributes of this class.
-     */
-    private Attribute attrs;
-
-    /**
-     * The number of entries in the InnerClasses attribute.
-     */
-    private int innerClassesCount;
-
-    /**
-     * The InnerClasses attribute.
-     */
-    private ByteVector innerClasses;
-
-    /**
-     * The fields of this class. These fields are stored in a linked list of
-     * {@link FieldWriter} objects, linked to each other by their
-     * {@link FieldWriter#next} field. This field stores the first element of
-     * this list.
-     */
-    FieldWriter firstField;
-
-    /**
-     * The fields of this class. These fields are stored in a linked list of
-     * {@link FieldWriter} objects, linked to each other by their
-     * {@link FieldWriter#next} field. This field stores the last element of
-     * this list.
-     */
-    FieldWriter lastField;
-
-    /**
-     * The methods of this class. These methods are stored in a linked list of
-     * {@link MethodWriter} objects, linked to each other by their
-     * {@link MethodWriter#next} field. This field stores the first element of
-     * this list.
-     */
-    MethodWriter firstMethod;
-
-    /**
-     * The methods of this class. These methods are stored in a linked list of
-     * {@link MethodWriter} objects, linked to each other by their
-     * {@link MethodWriter#next} field. This field stores the last element of
-     * this list.
-     */
-    MethodWriter lastMethod;
-
-    /**
-     * <tt>true</tt> if the maximum stack size and number of local variables
-     * must be automatically computed.
-     */
-    private final boolean computeMaxs;
-
-    /**
-     * <tt>true</tt> if the stack map frames must be recomputed from scratch.
-     */
-    private final boolean computeFrames;
-
-    /**
-     * <tt>true</tt> if the stack map tables of this class are invalid. The
-     * {@link MethodWriter#resizeInstructions} method cannot transform existing
-     * stack map tables, and so produces potentially invalid classes when it is
-     * executed. In this case the class is reread and rewritten with the
-     * {@link #COMPUTE_FRAMES} option (the resizeInstructions method can resize
-     * stack map tables when this option is used).
-     */
-    boolean invalidFrames;
-
-    // ------------------------------------------------------------------------
-    // Static initializer
-    // ------------------------------------------------------------------------
-
-    /**
-     * Computes the instruction types of JVM opcodes.
-     */
-    static {
-        int i;
-        byte[] b = new byte[220];
-        String s = "AAAAAAAAAAAAAAAABCKLLDDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAADD"
-                + "DDDEEEEEEEEEEEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
-                + "AAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAIIIIIIIIIIIIIIIIDNOAA"
-                + "AAAAGGGGGGGHHFBFAAFFAAQPIIJJIIIIIIIIIIIIIIIIII";
-        for (i = 0; i < b.length; ++i) {
-            b[i] = (byte) (s.charAt(i) - 'A');
-        }
-        TYPE = b;
-
-        // code to generate the above string
-        //
-        // // SBYTE_INSN instructions
-        // b[Constants.NEWARRAY] = SBYTE_INSN;
-        // b[Constants.BIPUSH] = SBYTE_INSN;
-        //
-        // // SHORT_INSN instructions
-        // b[Constants.SIPUSH] = SHORT_INSN;
-        //
-        // // (IMPL)VAR_INSN instructions
-        // b[Constants.RET] = VAR_INSN;
-        // for (i = Constants.ILOAD; i <= Constants.ALOAD; ++i) {
-        // b[i] = VAR_INSN;
-        // }
-        // for (i = Constants.ISTORE; i <= Constants.ASTORE; ++i) {
-        // b[i] = VAR_INSN;
-        // }
-        // for (i = 26; i <= 45; ++i) { // ILOAD_0 to ALOAD_3
-        // b[i] = IMPLVAR_INSN;
-        // }
-        // for (i = 59; i <= 78; ++i) { // ISTORE_0 to ASTORE_3
-        // b[i] = IMPLVAR_INSN;
-        // }
-        //
-        // // TYPE_INSN instructions
-        // b[Constants.NEW] = TYPE_INSN;
-        // b[Constants.ANEWARRAY] = TYPE_INSN;
-        // b[Constants.CHECKCAST] = TYPE_INSN;
-        // b[Constants.INSTANCEOF] = TYPE_INSN;
-        //
-        // // (Set)FIELDORMETH_INSN instructions
-        // for (i = Constants.GETSTATIC; i <= Constants.INVOKESTATIC; ++i) {
-        // b[i] = FIELDORMETH_INSN;
-        // }
-        // b[Constants.INVOKEINTERFACE] = ITFDYNMETH_INSN;
-        // b[Constants.INVOKEDYNAMIC] = ITFDYNMETH_INSN;
-        //
-        // // LABEL(W)_INSN instructions
-        // for (i = Constants.IFEQ; i <= Constants.JSR; ++i) {
-        // b[i] = LABEL_INSN;
-        // }
-        // b[Constants.IFNULL] = LABEL_INSN;
-        // b[Constants.IFNONNULL] = LABEL_INSN;
-        // b[200] = LABELW_INSN; // GOTO_W
-        // b[201] = LABELW_INSN; // JSR_W
-        // // temporary opcodes used internally by ASM - see Label and
-        // MethodWriter
-        // for (i = 202; i < 220; ++i) {
-        // b[i] = LABEL_INSN;
-        // }
-        //
-        // // LDC(_W) instructions
-        // b[Constants.LDC] = LDC_INSN;
-        // b[19] = LDCW_INSN; // LDC_W
-        // b[20] = LDCW_INSN; // LDC2_W
-        //
-        // // special instructions
-        // b[Constants.IINC] = IINC_INSN;
-        // b[Constants.TABLESWITCH] = TABL_INSN;
-        // b[Constants.LOOKUPSWITCH] = LOOK_INSN;
-        // b[Constants.MULTIANEWARRAY] = MANA_INSN;
-        // b[196] = WIDE_INSN; // WIDE
-        //
-        // for (i = 0; i < b.length; ++i) {
-        // System.err.print((char)('A' + b[i]));
-        // }
-        // System.err.println();
-    }
-
-    // ------------------------------------------------------------------------
-    // Constructor
-    // ------------------------------------------------------------------------
-
-    /**
-     * Constructs a new {@link ClassWriter} object.
-     *
-     * @param flags option flags that can be used to modify the default behavior
-     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.
-     */
-    public ClassWriter(final int flags) {
-        index = 1;
-        pool = new ByteVector();
-        items = new Item[256];
-        threshold = (int) (0.75d * items.length);
-        key = new Item();
-        key2 = new Item();
-        key3 = new Item();
-        this.computeMaxs = (flags & COMPUTE_MAXS) != 0;
-        this.computeFrames = (flags & COMPUTE_FRAMES) != 0;
-    }
-
-    /**
-     * Constructs a new {@link ClassWriter} object and enables optimizations for
-     * "mostly add" bytecode transformations. These optimizations are the
-     * following:
-     *
-     * <ul> <li>The constant pool from the original class is copied as is in
-     * the new class, which saves time. New constant pool entries will be added
-     * at the end if necessary, but unused constant pool entries <i>won't be
-     * removed</i>.</li> <li>Methods that are not transformed are copied as
-     * is in the new class, directly from the original class bytecode (i.e.
-     * without emitting visit events for all the method instructions), which
-     * saves a <i>lot</i> of time. Untransformed methods are detected by the
-     * fact that the {@link ClassReader} receives {@link MethodVisitor} objects
-     * that come from a {@link ClassWriter} (and not from a custom
-     * {@link ClassAdapter} or any other {@link ClassVisitor} instance).</li>
-     * </ul>
-     *
-     * @param classReader the {@link ClassReader} used to read the original
-     *        class. It will be used to copy the entire constant pool from the
-     *        original class and also to copy other fragments of original
-     *        bytecode where applicable.
-     * @param flags option flags that can be used to modify the default behavior
-     *        of this class. <i>These option flags do not affect methods that
-     *        are copied as is in the new class. This means that the maximum
-     *        stack size nor the stack frames will be computed for these
-     *        methods</i>. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.
-     */
-    public ClassWriter(final ClassReader classReader, final int flags) {
-        this(flags);
-        classReader.copyPool(this);
-        this.cr = classReader;
-    }
-
-    // ------------------------------------------------------------------------
-    // Implementation of the ClassVisitor interface
-    // ------------------------------------------------------------------------
-
-    public void visit(
-        final int version,
-        final int access,
-        final String name,
-        final String signature,
-        final String superName,
-        final String[] interfaces)
-    {
-        this.version = version;
-        this.access = access;
-        this.name = newClass(name);
-        thisName = name;
-        if (ClassReader.SIGNATURES && signature != null) {
-            this.signature = newUTF8(signature);
-        }
-        this.superName = superName == null ? 0 : newClass(superName);
-        if (interfaces != null && interfaces.length > 0) {
-            interfaceCount = interfaces.length;
-            this.interfaces = new int[interfaceCount];
-            for (int i = 0; i < interfaceCount; ++i) {
-                this.interfaces[i] = newClass(interfaces[i]);
-            }
-        }
-    }
-
-    public void visitSource(final String file, final String debug) {
-        if (file != null) {
-            sourceFile = newUTF8(file);
-        }
-        if (debug != null) {
-            sourceDebug = new ByteVector().putUTF8(debug);
-        }
-    }
-
-    public void visitOuterClass(
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        enclosingMethodOwner = newClass(owner);
-        if (name != null && desc != null) {
-            enclosingMethod = newNameType(name, desc);
-        }
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        if (!ClassReader.ANNOTATIONS) {
-            return null;
-        }
-        ByteVector bv = new ByteVector();
-        // write type, and reserve space for values count
-        bv.putShort(newUTF8(desc)).putShort(0);
-        AnnotationWriter aw = new AnnotationWriter(this, true, bv, bv, 2);
-        if (visible) {
-            aw.next = anns;
-            anns = aw;
-        } else {
-            aw.next = ianns;
-            ianns = aw;
-        }
-        return aw;
-    }
-
-    public void visitAttribute(final Attribute attr) {
-        attr.next = attrs;
-        attrs = attr;
-    }
-
-    public void visitInnerClass(
-        final String name,
-        final String outerName,
-        final String innerName,
-        final int access)
-    {
-        if (innerClasses == null) {
-            innerClasses = new ByteVector();
-        }
-        ++innerClassesCount;
-        innerClasses.putShort(name == null ? 0 : newClass(name));
-        innerClasses.putShort(outerName == null ? 0 : newClass(outerName));
-        innerClasses.putShort(innerName == null ? 0 : newUTF8(innerName));
-        innerClasses.putShort(access);
-    }
-
-    public FieldVisitor visitField(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final Object value)
-    {
-        return new FieldWriter(this, access, name, desc, signature, value);
-    }
-
-    public MethodVisitor visitMethod(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final String[] exceptions)
-    {
-        return new MethodWriter(this,
-                access,
-                name,
-                desc,
-                signature,
-                exceptions,
-                computeMaxs,
-                computeFrames);
-    }
-
-    public void visitEnd() {
-    }
-
-    // ------------------------------------------------------------------------
-    // Other public methods
-    // ------------------------------------------------------------------------
-
-    /**
-     * Returns the bytecode of the class that was build with this class writer.
-     *
-     * @return the bytecode of the class that was build with this class writer.
-     */
-    public byte[] toByteArray() {
-        // computes the real size of the bytecode of this class
-        int size = 24 + 2 * interfaceCount;
-        int nbFields = 0;
-        FieldWriter fb = firstField;
-        while (fb != null) {
-            ++nbFields;
-            size += fb.getSize();
-            fb = fb.next;
-        }
-        int nbMethods = 0;
-        MethodWriter mb = firstMethod;
-        while (mb != null) {
-            ++nbMethods;
-            size += mb.getSize();
-            mb = mb.next;
-        }
-        int attributeCount = 0;
-        if (ClassReader.SIGNATURES && signature != 0) {
-            ++attributeCount;
-            size += 8;
-            newUTF8("Signature");
-        }
-        if (sourceFile != 0) {
-            ++attributeCount;
-            size += 8;
-            newUTF8("SourceFile");
-        }
-        if (sourceDebug != null) {
-            ++attributeCount;
-            size += sourceDebug.length + 4;
-            newUTF8("SourceDebugExtension");
-        }
-        if (enclosingMethodOwner != 0) {
-            ++attributeCount;
-            size += 10;
-            newUTF8("EnclosingMethod");
-        }
-        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
-            ++attributeCount;
-            size += 6;
-            newUTF8("Deprecated");
-        }
-        if ((access & Opcodes.ACC_SYNTHETIC) != 0
-                && ((version & 0xFFFF) < Opcodes.V1_5 || (access & ACC_SYNTHETIC_ATTRIBUTE) != 0))
-        {
-            ++attributeCount;
-            size += 6;
-            newUTF8("Synthetic");
-        }
-        if (innerClasses != null) {
-            ++attributeCount;
-            size += 8 + innerClasses.length;
-            newUTF8("InnerClasses");
-        }
-        if (ClassReader.ANNOTATIONS && anns != null) {
-            ++attributeCount;
-            size += 8 + anns.getSize();
-            newUTF8("RuntimeVisibleAnnotations");
-        }
-        if (ClassReader.ANNOTATIONS && ianns != null) {
-            ++attributeCount;
-            size += 8 + ianns.getSize();
-            newUTF8("RuntimeInvisibleAnnotations");
-        }
-        if (attrs != null) {
-            attributeCount += attrs.getCount();
-            size += attrs.getSize(this, null, 0, -1, -1);
-        }
-        size += pool.length;
-        // allocates a byte vector of this size, in order to avoid unnecessary
-        // arraycopy operations in the ByteVector.enlarge() method
-        ByteVector out = new ByteVector(size);
-        out.putInt(0xCAFEBABE).putInt(version);
-        out.putShort(index).putByteArray(pool.data, 0, pool.length);
-        int mask = Opcodes.ACC_DEPRECATED
-                | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE
-                | ((access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) / (ClassWriter.ACC_SYNTHETIC_ATTRIBUTE / Opcodes.ACC_SYNTHETIC));
-        out.putShort(access & ~mask).putShort(name).putShort(superName);
-        out.putShort(interfaceCount);
-        for (int i = 0; i < interfaceCount; ++i) {
-            out.putShort(interfaces[i]);
-        }
-        out.putShort(nbFields);
-        fb = firstField;
-        while (fb != null) {
-            fb.put(out);
-            fb = fb.next;
-        }
-        out.putShort(nbMethods);
-        mb = firstMethod;
-        while (mb != null) {
-            mb.put(out);
-            mb = mb.next;
-        }
-        out.putShort(attributeCount);
-        if (ClassReader.SIGNATURES && signature != 0) {
-            out.putShort(newUTF8("Signature")).putInt(2).putShort(signature);
-        }
-        if (sourceFile != 0) {
-            out.putShort(newUTF8("SourceFile")).putInt(2).putShort(sourceFile);
-        }
-        if (sourceDebug != null) {
-            int len = sourceDebug.length - 2;
-            out.putShort(newUTF8("SourceDebugExtension")).putInt(len);
-            out.putByteArray(sourceDebug.data, 2, len);
-        }
-        if (enclosingMethodOwner != 0) {
-            out.putShort(newUTF8("EnclosingMethod")).putInt(4);
-            out.putShort(enclosingMethodOwner).putShort(enclosingMethod);
-        }
-        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
-            out.putShort(newUTF8("Deprecated")).putInt(0);
-        }
-        if ((access & Opcodes.ACC_SYNTHETIC) != 0
-                && ((version & 0xFFFF) < Opcodes.V1_5 || (access & ACC_SYNTHETIC_ATTRIBUTE) != 0))
-        {
-            out.putShort(newUTF8("Synthetic")).putInt(0);
-        }
-        if (innerClasses != null) {
-            out.putShort(newUTF8("InnerClasses"));
-            out.putInt(innerClasses.length + 2).putShort(innerClassesCount);
-            out.putByteArray(innerClasses.data, 0, innerClasses.length);
-        }
-        if (ClassReader.ANNOTATIONS && anns != null) {
-            out.putShort(newUTF8("RuntimeVisibleAnnotations"));
-            anns.put(out);
-        }
-        if (ClassReader.ANNOTATIONS && ianns != null) {
-            out.putShort(newUTF8("RuntimeInvisibleAnnotations"));
-            ianns.put(out);
-        }
-        if (attrs != null) {
-            attrs.put(this, null, 0, -1, -1, out);
-        }
-        if (invalidFrames) {
-            ClassWriter cw = new ClassWriter(COMPUTE_FRAMES);
-            new ClassReader(out.data).accept(cw, ClassReader.SKIP_FRAMES);
-            return cw.toByteArray();
-        }
-        return out.data;
-    }
-
-    // ------------------------------------------------------------------------
-    // Utility methods: constant pool management
-    // ------------------------------------------------------------------------
-
-    /**
-     * Adds a number or string constant to the constant pool of the class being
-     * build. Does nothing if the constant pool already contains a similar item.
-     *
-     * @param cst the value of the constant to be added to the constant pool.
-     *        This parameter must be an {@link Integer}, a {@link Float}, a
-     *        {@link Long}, a {@link Double}, a {@link String} or a
-     *        {@link Type}.
-     * @return a new or already existing constant item with the given value.
-     */
-    Item newConstItem(final Object cst) {
-        if (cst instanceof Integer) {
-            int val = ((Integer) cst).intValue();
-            return newInteger(val);
-        } else if (cst instanceof Byte) {
-            int val = ((Byte) cst).intValue();
-            return newInteger(val);
-        } else if (cst instanceof Character) {
-            int val = ((Character) cst).charValue();
-            return newInteger(val);
-        } else if (cst instanceof Short) {
-            int val = ((Short) cst).intValue();
-            return newInteger(val);
-        } else if (cst instanceof Boolean) {
-            int val = ((Boolean) cst).booleanValue() ? 1 : 0;
-            return newInteger(val);
-        } else if (cst instanceof Float) {
-            float val = ((Float) cst).floatValue();
-            return newFloat(val);
-        } else if (cst instanceof Long) {
-            long val = ((Long) cst).longValue();
-            return newLong(val);
-        } else if (cst instanceof Double) {
-            double val = ((Double) cst).doubleValue();
-            return newDouble(val);
-        } else if (cst instanceof String) {
-            return newString((String) cst);
-        } else if (cst instanceof Type) {
-            Type t = (Type) cst;
-            return newClassItem(t.getSort() == Type.OBJECT
-                    ? t.getInternalName()
-                    : t.getDescriptor());
-        } else {
-            throw new IllegalArgumentException("value " + cst);
-        }
-    }
-
-    /**
-     * Adds a number or string constant to the constant pool of the class being
-     * build. Does nothing if the constant pool already contains a similar item.
-     * <i>This method is intended for {@link Attribute} sub classes, and is
-     * normally not needed by class generators or adapters.</i>
-     *
-     * @param cst the value of the constant to be added to the constant pool.
-     *        This parameter must be an {@link Integer}, a {@link Float}, a
-     *        {@link Long}, a {@link Double} or a {@link String}.
-     * @return the index of a new or already existing constant item with the
-     *         given value.
-     */
-    public int newConst(final Object cst) {
-        return newConstItem(cst).index;
-    }
-
-    /**
-     * Adds an UTF8 string to the constant pool of the class being build. Does
-     * nothing if the constant pool already contains a similar item. <i>This
-     * method is intended for {@link Attribute} sub classes, and is normally not
-     * needed by class generators or adapters.</i>
-     *
-     * @param value the String value.
-     * @return the index of a new or already existing UTF8 item.
-     */
-    public int newUTF8(final String value) {
-        key.set(UTF8, value, null, null);
-        Item result = get(key);
-        if (result == null) {
-            pool.putByte(UTF8).putUTF8(value);
-            result = new Item(index++, key);
-            put(result);
-        }
-        return result.index;
-    }
-
-    /**
-     * Adds a class reference to the constant pool of the class being build.
-     * Does nothing if the constant pool already contains a similar item.
-     * <i>This method is intended for {@link Attribute} sub classes, and is
-     * normally not needed by class generators or adapters.</i>
-     *
-     * @param value the internal name of the class.
-     * @return a new or already existing class reference item.
-     */
-    Item newClassItem(final String value) {
-        key2.set(CLASS, value, null, null);
-        Item result = get(key2);
-        if (result == null) {
-            pool.put12(CLASS, newUTF8(value));
-            result = new Item(index++, key2);
-            put(result);
-        }
-        return result;
-    }
-
-    /**
-     * Adds a class reference to the constant pool of the class being build.
-     * Does nothing if the constant pool already contains a similar item.
-     * <i>This method is intended for {@link Attribute} sub classes, and is
-     * normally not needed by class generators or adapters.</i>
-     *
-     * @param value the internal name of the class.
-     * @return the index of a new or already existing class reference item.
-     */
-    public int newClass(final String value) {
-        return newClassItem(value).index;
-    }
-
-    /**
-     * Adds a field reference to the constant pool of the class being build.
-     * Does nothing if the constant pool already contains a similar item.
-     *
-     * @param owner the internal name of the field's owner class.
-     * @param name the field's name.
-     * @param desc the field's descriptor.
-     * @return a new or already existing field reference item.
-     */
-    Item newFieldItem(final String owner, final String name, final String desc)
-    {
-        key3.set(FIELD, owner, name, desc);
-        Item result = get(key3);
-        if (result == null) {
-            put122(FIELD, newClass(owner), newNameType(name, desc));
-            result = new Item(index++, key3);
-            put(result);
-        }
-        return result;
-    }
-
-    /**
-     * Adds a field reference to the constant pool of the class being build.
-     * Does nothing if the constant pool already contains a similar item.
-     * <i>This method is intended for {@link Attribute} sub classes, and is
-     * normally not needed by class generators or adapters.</i>
-     *
-     * @param owner the internal name of the field's owner class.
-     * @param name the field's name.
-     * @param desc the field's descriptor.
-     * @return the index of a new or already existing field reference item.
-     */
-    public int newField(final String owner, final String name, final String desc)
-    {
-        return newFieldItem(owner, name, desc).index;
-    }
-
-    /**
-     * Adds a method reference to the constant pool of the class being build.
-     * Does nothing if the constant pool already contains a similar item.
-     *
-     * @param owner the internal name of the method's owner class.
-     * @param name the method's name.
-     * @param desc the method's descriptor.
-     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.
-     * @return a new or already existing method reference item.
-     */
-    Item newMethodItem(
-        final String owner,
-        final String name,
-        final String desc,
-        final boolean itf)
-    {
-        int type = itf ? IMETH : METH;
-        key3.set(type, owner, name, desc);
-        Item result = get(key3);
-        if (result == null) {
-            put122(type, newClass(owner), newNameType(name, desc));
-            result = new Item(index++, key3);
-            put(result);
-        }
-        return result;
-    }
-
-    /**
-     * Adds a method reference to the constant pool of the class being build.
-     * Does nothing if the constant pool already contains a similar item.
-     * <i>This method is intended for {@link Attribute} sub classes, and is
-     * normally not needed by class generators or adapters.</i>
-     *
-     * @param owner the internal name of the method's owner class.
-     * @param name the method's name.
-     * @param desc the method's descriptor.
-     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.
-     * @return the index of a new or already existing method reference item.
-     */
-    public int newMethod(
-        final String owner,
-        final String name,
-        final String desc,
-        final boolean itf)
-    {
-        return newMethodItem(owner, name, desc, itf).index;
-    }
-
-    /**
-     * Adds an integer to the constant pool of the class being build. Does
-     * nothing if the constant pool already contains a similar item.
-     *
-     * @param value the int value.
-     * @return a new or already existing int item.
-     */
-    Item newInteger(final int value) {
-        key.set(value);
-        Item result = get(key);
-        if (result == null) {
-            pool.putByte(INT).putInt(value);
-            result = new Item(index++, key);
-            put(result);
-        }
-        return result;
-    }
-
-    /**
-     * Adds a float to the constant pool of the class being build. Does nothing
-     * if the constant pool already contains a similar item.
-     *
-     * @param value the float value.
-     * @return a new or already existing float item.
-     */
-    Item newFloat(final float value) {
-        key.set(value);
-        Item result = get(key);
-        if (result == null) {
-            pool.putByte(FLOAT).putInt(key.intVal);
-            result = new Item(index++, key);
-            put(result);
-        }
-        return result;
-    }
-
-    /**
-     * Adds a long to the constant pool of the class being build. Does nothing
-     * if the constant pool already contains a similar item.
-     *
-     * @param value the long value.
-     * @return a new or already existing long item.
-     */
-    Item newLong(final long value) {
-        key.set(value);
-        Item result = get(key);
-        if (result == null) {
-            pool.putByte(LONG).putLong(value);
-            result = new Item(index, key);
-            put(result);
-            index += 2;
-        }
-        return result;
-    }
-
-    /**
-     * Adds a double to the constant pool of the class being build. Does nothing
-     * if the constant pool already contains a similar item.
-     *
-     * @param value the double value.
-     * @return a new or already existing double item.
-     */
-    Item newDouble(final double value) {
-        key.set(value);
-        Item result = get(key);
-        if (result == null) {
-            pool.putByte(DOUBLE).putLong(key.longVal);
-            result = new Item(index, key);
-            put(result);
-            index += 2;
-        }
-        return result;
-    }
-
-    /**
-     * Adds a string to the constant pool of the class being build. Does nothing
-     * if the constant pool already contains a similar item.
-     *
-     * @param value the String value.
-     * @return a new or already existing string item.
-     */
-    private Item newString(final String value) {
-        key2.set(STR, value, null, null);
-        Item result = get(key2);
-        if (result == null) {
-            pool.put12(STR, newUTF8(value));
-            result = new Item(index++, key2);
-            put(result);
-        }
-        return result;
-    }
-
-    /**
-     * Adds a name and type to the constant pool of the class being build. Does
-     * nothing if the constant pool already contains a similar item. <i>This
-     * method is intended for {@link Attribute} sub classes, and is normally not
-     * needed by class generators or adapters.</i>
-     *
-     * @param name a name.
-     * @param desc a type descriptor.
-     * @return the index of a new or already existing name and type item.
-     */
-    public int newNameType(final String name, final String desc) {
-        return newNameTypeItem(name, desc).index;
-    }
-    
-    /**
-     * Adds a name and type to the constant pool of the class being build. Does
-     * nothing if the constant pool already contains a similar item.
-     *
-     * @param name a name.
-     * @param desc a type descriptor.
-     * @return a new or already existing name and type item.
-     */
-    Item newNameTypeItem(final String name, final String desc) {
-        key2.set(NAME_TYPE, name, desc, null);
-        Item result = get(key2);
-        if (result == null) {
-            put122(NAME_TYPE, newUTF8(name), newUTF8(desc));
-            result = new Item(index++, key2);
-            put(result);
-        }
-        return result;
-    }
-
-    /**
-     * Adds the given internal name to {@link #typeTable} and returns its index.
-     * Does nothing if the type table already contains this internal name.
-     *
-     * @param type the internal name to be added to the type table.
-     * @return the index of this internal name in the type table.
-     */
-    int addType(final String type) {
-        key.set(TYPE_NORMAL, type, null, null);
-        Item result = get(key);
-        if (result == null) {
-            result = addType(key);
-        }
-        return result.index;
-    }
-
-    /**
-     * Adds the given "uninitialized" type to {@link #typeTable} and returns its
-     * index. This method is used for UNINITIALIZED types, made of an internal
-     * name and a bytecode offset.
-     *
-     * @param type the internal name to be added to the type table.
-     * @param offset the bytecode offset of the NEW instruction that created
-     *        this UNINITIALIZED type value.
-     * @return the index of this internal name in the type table.
-     */
-    int addUninitializedType(final String type, final int offset) {
-        key.type = TYPE_UNINIT;
-        key.intVal = offset;
-        key.strVal1 = type;
-        key.hashCode = 0x7FFFFFFF & (TYPE_UNINIT + type.hashCode() + offset);
-        Item result = get(key);
-        if (result == null) {
-            result = addType(key);
-        }
-        return result.index;
-    }
-
-    /**
-     * Adds the given Item to {@link #typeTable}.
-     *
-     * @param item the value to be added to the type table.
-     * @return the added Item, which a new Item instance with the same value as
-     *         the given Item.
-     */
-    private Item addType(final Item item) {
-        ++typeCount;
-        Item result = new Item(typeCount, key);
-        put(result);
-        if (typeTable == null) {
-            typeTable = new Item[16];
-        }
-        if (typeCount == typeTable.length) {
-            Item[] newTable = new Item[2 * typeTable.length];
-            System.arraycopy(typeTable, 0, newTable, 0, typeTable.length);
-            typeTable = newTable;
-        }
-        typeTable[typeCount] = result;
-        return result;
-    }
-
-    /**
-     * Returns the index of the common super type of the two given types. This
-     * method calls {@link #getCommonSuperClass} and caches the result in the
-     * {@link #items} hash table to speedup future calls with the same
-     * parameters.
-     *
-     * @param type1 index of an internal name in {@link #typeTable}.
-     * @param type2 index of an internal name in {@link #typeTable}.
-     * @return the index of the common super type of the two given types.
-     */
-    int getMergedType(final int type1, final int type2) {
-        key2.type = TYPE_MERGED;
-        key2.longVal = type1 | (((long) type2) << 32);
-        key2.hashCode = 0x7FFFFFFF & (TYPE_MERGED + type1 + type2);
-        Item result = get(key2);
-        if (result == null) {
-            String t = typeTable[type1].strVal1;
-            String u = typeTable[type2].strVal1;
-            key2.intVal = addType(getCommonSuperClass(t, u));
-            result = new Item((short) 0, key2);
-            put(result);
-        }
-        return result.intVal;
-    }
-
-    /**
-     * Returns the common super type of the two given types. The default
-     * implementation of this method <i>loads<i> the two given classes and uses
-     * the java.lang.Class methods to find the common super class. It can be
-     * overridden to compute this common super type in other ways, in particular
-     * without actually loading any class, or to take into account the class
-     * that is currently being generated by this ClassWriter, which can of
-     * course not be loaded since it is under construction.
-     *
-     * @param type1 the internal name of a class.
-     * @param type2 the internal name of another class.
-     * @return the internal name of the common super class of the two given
-     *         classes.
-     */
-    protected String getCommonSuperClass(final String type1, final String type2)
-    {
-        Class c, d;
-        try {
-            c = Class.forName(type1.replace('/', '.'));
-            d = Class.forName(type2.replace('/', '.'));
-        } catch (Exception e) {
-            throw new RuntimeException(e.toString());
-        }
-        if (c.isAssignableFrom(d)) {
-            return type1;
-        }
-        if (d.isAssignableFrom(c)) {
-            return type2;
-        }
-        if (c.isInterface() || d.isInterface()) {
-            return "java/lang/Object";
-        } else {
-            do {
-                c = c.getSuperclass();
-            } while (!c.isAssignableFrom(d));
-            return c.getName().replace('.', '/');
-        }
-    }
-
-    /**
-     * Returns the constant pool's hash table item which is equal to the given
-     * item.
-     *
-     * @param key a constant pool item.
-     * @return the constant pool's hash table item which is equal to the given
-     *         item, or <tt>null</tt> if there is no such item.
-     */
-    private Item get(final Item key) {
-        Item i = items[key.hashCode % items.length];
-        while (i != null && (i.type != key.type || !key.isEqualTo(i))) {
-            i = i.next;
-        }
-        return i;
-    }
-
-    /**
-     * Puts the given item in the constant pool's hash table. The hash table
-     * <i>must</i> not already contains this item.
-     *
-     * @param i the item to be added to the constant pool's hash table.
-     */
-    private void put(final Item i) {
-        if (index > threshold) {
-            int ll = items.length;
-            int nl = ll * 2 + 1;
-            Item[] newItems = new Item[nl];
-            for (int l = ll - 1; l >= 0; --l) {
-                Item j = items[l];
-                while (j != null) {
-                    int index = j.hashCode % newItems.length;
-                    Item k = j.next;
-                    j.next = newItems[index];
-                    newItems[index] = j;
-                    j = k;
-                }
-            }
-            items = newItems;
-            threshold = (int) (nl * 0.75);
-        }
-        int index = i.hashCode % items.length;
-        i.next = items[index];
-        items[index] = i;
-    }
-
-    /**
-     * Puts one byte and two shorts into the constant pool.
-     *
-     * @param b a byte.
-     * @param s1 a short.
-     * @param s2 another short.
-     */
-    private void put122(final int b, final int s1, final int s2) {
-        pool.put12(b, s1).putShort(s2);
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/AdviceAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/AdviceAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/AdviceAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/AdviceAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,613 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * A {@link org.eclipse.persistence.internal.libraries.asm.MethodAdapter} to insert before, after and around
- * advices in methods and constructors. <p> The behavior for constructors is
- * like this: <ol>
- *
- * <li>as long as the INVOKESPECIAL for the object initialization has not been
- * reached, every bytecode instruction is dispatched in the ctor code visitor</li>
- *
- * <li>when this one is reached, it is only added in the ctor code visitor and
- * a JP invoke is added</li>
- *
- * <li>after that, only the other code visitor receives the instructions</li>
- *
- * </ol>
- *
- * @author Eugene Kuleshov
- * @author Eric Bruneton
- */
-public abstract class AdviceAdapter extends GeneratorAdapter implements Opcodes
-{
-    private static final Object THIS = new Object();
-    private static final Object OTHER = new Object();
-
-    protected int methodAccess;
-    protected String methodDesc;
-
-    private boolean constructor;
-    private boolean superInitialized;
-    private List stackFrame;
-    private Map branches;
-
-    /**
-     * Creates a new {@link AdviceAdapter}.
-     *
-     * @param mv the method visitor to which this adapter delegates calls.
-     * @param access the method's access flags (see {@link Opcodes}).
-     * @param name the method's name.
-     * @param desc the method's descriptor (see {@link Type Type}).
-     */
-    protected AdviceAdapter(
-        final MethodVisitor mv,
-        final int access,
-        final String name,
-        final String desc)
-    {
-        super(mv, access, name, desc);
-        methodAccess = access;
-        methodDesc = desc;
-
-        constructor = "<init>".equals(name);
-    }
-
-    public void visitCode() {
-        mv.visitCode();
-        if (constructor) {
-            stackFrame = new ArrayList();
-            branches = new HashMap();
-        } else {
-            superInitialized = true;
-            onMethodEnter();
-        }
-    }
-
-    public void visitLabel(final Label label) {
-        mv.visitLabel(label);
-
-        if (constructor && branches != null) {
-            List frame = (List) branches.get(label);
-            if (frame != null) {
-                stackFrame = frame;
-                branches.remove(label);
-            }
-        }
-    }
-
-    public void visitInsn(final int opcode) {
-        if (constructor) {
-            int s;
-            switch (opcode) {
-                case RETURN: // empty stack
-                    onMethodExit(opcode);
-                    break;
-
-                case IRETURN: // 1 before n/a after
-                case FRETURN: // 1 before n/a after
-                case ARETURN: // 1 before n/a after
-                case ATHROW: // 1 before n/a after
-                    popValue();
-                    onMethodExit(opcode);
-                    break;
-
-                case LRETURN: // 2 before n/a after
-                case DRETURN: // 2 before n/a after
-                    popValue();
-                    popValue();
-                    onMethodExit(opcode);
-                    break;
-
-                case NOP:
-                case LALOAD: // remove 2 add 2
-                case DALOAD: // remove 2 add 2
-                case LNEG:
-                case DNEG:
-                case FNEG:
-                case INEG:
-                case L2D:
-                case D2L:
-                case F2I:
-                case I2B:
-                case I2C:
-                case I2S:
-                case I2F:
-                case ARRAYLENGTH:
-                    break;
-
-                case ACONST_NULL:
-                case ICONST_M1:
-                case ICONST_0:
-                case ICONST_1:
-                case ICONST_2:
-                case ICONST_3:
-                case ICONST_4:
-                case ICONST_5:
-                case FCONST_0:
-                case FCONST_1:
-                case FCONST_2:
-                case F2L: // 1 before 2 after
-                case F2D:
-                case I2L:
-                case I2D:
-                    pushValue(OTHER);
-                    break;
-
-                case LCONST_0:
-                case LCONST_1:
-                case DCONST_0:
-                case DCONST_1:
-                    pushValue(OTHER);
-                    pushValue(OTHER);
-                    break;
-
-                case IALOAD: // remove 2 add 1
-                case FALOAD: // remove 2 add 1
-                case AALOAD: // remove 2 add 1
-                case BALOAD: // remove 2 add 1
-                case CALOAD: // remove 2 add 1
-                case SALOAD: // remove 2 add 1
-                case POP:
-                case IADD:
-                case FADD:
-                case ISUB:
-                case LSHL: // 3 before 2 after
-                case LSHR: // 3 before 2 after
-                case LUSHR: // 3 before 2 after
-                case L2I: // 2 before 1 after
-                case L2F: // 2 before 1 after
-                case D2I: // 2 before 1 after
-                case D2F: // 2 before 1 after
-                case FSUB:
-                case FMUL:
-                case FDIV:
-                case FREM:
-                case FCMPL: // 2 before 1 after
-                case FCMPG: // 2 before 1 after
-                case IMUL:
-                case IDIV:
-                case IREM:
-                case ISHL:
-                case ISHR:
-                case IUSHR:
-                case IAND:
-                case IOR:
-                case IXOR:
-                case MONITORENTER:
-                case MONITOREXIT:
-                    popValue();
-                    break;
-
-                case POP2:
-                case LSUB:
-                case LMUL:
-                case LDIV:
-                case LREM:
-                case LADD:
-                case LAND:
-                case LOR:
-                case LXOR:
-                case DADD:
-                case DMUL:
-                case DSUB:
-                case DDIV:
-                case DREM:
-                    popValue();
-                    popValue();
-                    break;
-
-                case IASTORE:
-                case FASTORE:
-                case AASTORE:
-                case BASTORE:
-                case CASTORE:
-                case SASTORE:
-                case LCMP: // 4 before 1 after
-                case DCMPL:
-                case DCMPG:
-                    popValue();
-                    popValue();
-                    popValue();
-                    break;
-
-                case LASTORE:
-                case DASTORE:
-                    popValue();
-                    popValue();
-                    popValue();
-                    popValue();
-                    break;
-
-                case DUP:
-                    pushValue(peekValue());
-                    break;
-
-                case DUP_X1:
-                    s = stackFrame.size();
-                    stackFrame.add(s - 2, stackFrame.get(s - 1));
-                    break;
-
-                case DUP_X2:
-                    s = stackFrame.size();
-                    stackFrame.add(s - 3, stackFrame.get(s - 1));
-                    break;
-
-                case DUP2:
-                    s = stackFrame.size();
-                    stackFrame.add(s - 2, stackFrame.get(s - 1));
-                    stackFrame.add(s - 2, stackFrame.get(s - 1));
-                    break;
-
-                case DUP2_X1:
-                    s = stackFrame.size();
-                    stackFrame.add(s - 3, stackFrame.get(s - 1));
-                    stackFrame.add(s - 3, stackFrame.get(s - 1));
-                    break;
-
-                case DUP2_X2:
-                    s = stackFrame.size();
-                    stackFrame.add(s - 4, stackFrame.get(s - 1));
-                    stackFrame.add(s - 4, stackFrame.get(s - 1));
-                    break;
-
-                case SWAP:
-                    s = stackFrame.size();
-                    stackFrame.add(s - 2, stackFrame.get(s - 1));
-                    stackFrame.remove(s);
-                    break;
-            }
-        } else {
-            switch (opcode) {
-                case RETURN:
-                case IRETURN:
-                case FRETURN:
-                case ARETURN:
-                case LRETURN:
-                case DRETURN:
-                case ATHROW:
-                    onMethodExit(opcode);
-                    break;
-            }
-        }
-        mv.visitInsn(opcode);
-    }
-
-    public void visitVarInsn(final int opcode, final int var) {
-        super.visitVarInsn(opcode, var);
-
-        if (constructor) {
-            switch (opcode) {
-                case ILOAD:
-                case FLOAD:
-                    pushValue(OTHER);
-                    break;
-                case LLOAD:
-                case DLOAD:
-                    pushValue(OTHER);
-                    pushValue(OTHER);
-                    break;
-                case ALOAD:
-                    pushValue(var == 0 ? THIS : OTHER);
-                    break;
-                case ASTORE:
-                case ISTORE:
-                case FSTORE:
-                    popValue();
-                    break;
-                case LSTORE:
-                case DSTORE:
-                    popValue();
-                    popValue();
-                    break;
-            }
-        }
-    }
-
-    public void visitFieldInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        mv.visitFieldInsn(opcode, owner, name, desc);
-
-        if (constructor) {
-            char c = desc.charAt(0);
-            boolean longOrDouble = c == 'J' || c == 'D';
-            switch (opcode) {
-                case GETSTATIC:
-                    pushValue(OTHER);
-                    if (longOrDouble) {
-                        pushValue(OTHER);
-                    }
-                    break;
-                case PUTSTATIC:
-                    popValue();
-                    if (longOrDouble) {
-                        popValue();
-                    }
-                    break;
-                case PUTFIELD:
-                    popValue();
-                    if (longOrDouble) {
-                        popValue();
-                        popValue();
-                    }
-                    break;
-                // case GETFIELD:
-                default:
-                    if (longOrDouble) {
-                        pushValue(OTHER);
-                    }
-            }
-        }
-    }
-
-    public void visitIntInsn(final int opcode, final int operand) {
-        mv.visitIntInsn(opcode, operand);
-
-        if (constructor && opcode!=NEWARRAY) {
-            pushValue(OTHER);
-        }
-    }
-
-    public void visitLdcInsn(final Object cst) {
-        mv.visitLdcInsn(cst);
-
-        if (constructor) {
-            pushValue(OTHER);
-            if (cst instanceof Double || cst instanceof Long) {
-                pushValue(OTHER);
-            }
-        }
-    }
-
-    public void visitMultiANewArrayInsn(final String desc, final int dims) {
-        mv.visitMultiANewArrayInsn(desc, dims);
-
-        if (constructor) {
-            for (int i = 0; i < dims; i++) {
-                popValue();
-            }
-            pushValue(OTHER);
-        }
-    }
-
-    public void visitTypeInsn(final int opcode, final String type) {
-        mv.visitTypeInsn(opcode, type);
-
-        // ANEWARRAY, CHECKCAST or INSTANCEOF don't change stack
-        if (constructor && opcode == NEW) {
-            pushValue(OTHER);
-        }
-    }
-
-    public void visitMethodInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        mv.visitMethodInsn(opcode, owner, name, desc);
-
-        if (constructor) {
-            Type[] types = Type.getArgumentTypes(desc);
-            for (int i = 0; i < types.length; i++) {
-                popValue();
-                if (types[i].getSize() == 2) {
-                    popValue();
-                }
-            }
-            switch (opcode) {
-                // case INVOKESTATIC:
-                // case INVOKEDYNAMIC
-                // break;
-
-                case INVOKEINTERFACE:
-                case INVOKEVIRTUAL:
-                    popValue(); // objectref
-                    break;
-
-                case INVOKESPECIAL:
-                    Object type = popValue(); // objectref
-                    if (type == THIS && !superInitialized) {
-                        onMethodEnter();
-                        superInitialized = true;
-                        // once super has been initialized it is no longer
-                        // necessary to keep track of stack state
-                        constructor = false;
-                    }
-                    break;
-            }
-
-            Type returnType = Type.getReturnType(desc);
-            if (returnType != Type.VOID_TYPE) {
-                pushValue(OTHER);
-                if (returnType.getSize() == 2) {
-                    pushValue(OTHER);
-                }
-            }
-        }
-    }
-
-    public void visitJumpInsn(final int opcode, final Label label) {
-        mv.visitJumpInsn(opcode, label);
-
-        if (constructor) {
-            switch (opcode) {
-                case IFEQ:
-                case IFNE:
-                case IFLT:
-                case IFGE:
-                case IFGT:
-                case IFLE:
-                case IFNULL:
-                case IFNONNULL:
-                    popValue();
-                    break;
-
-                case IF_ICMPEQ:
-                case IF_ICMPNE:
-                case IF_ICMPLT:
-                case IF_ICMPGE:
-                case IF_ICMPGT:
-                case IF_ICMPLE:
-                case IF_ACMPEQ:
-                case IF_ACMPNE:
-                    popValue();
-                    popValue();
-                    break;
-
-                case JSR:
-                    pushValue(OTHER);
-                    break;
-            }
-            addBranch(label);
-        }
-    }
-
-    public void visitLookupSwitchInsn(
-        final Label dflt,
-        final int[] keys,
-        final Label[] labels)
-    {
-        mv.visitLookupSwitchInsn(dflt, keys, labels);
-
-        if (constructor) {
-            popValue();
-            addBranches(dflt, labels);
-        }
-    }
-
-    public void visitTableSwitchInsn(
-        final int min,
-        final int max,
-        final Label dflt,
-        final Label[] labels)
-    {
-        mv.visitTableSwitchInsn(min, max, dflt, labels);
-
-        if (constructor) {
-            popValue();
-            addBranches(dflt, labels);
-        }
-    }
-
-    private void addBranches(final Label dflt, final Label[] labels) {
-        addBranch(dflt);
-        for (int i = 0; i < labels.length; i++) {
-            addBranch(labels[i]);
-        }
-    }
-
-    private void addBranch(final Label label) {
-        if (branches.containsKey(label)) {
-            return;
-        }
-        branches.put(label, new ArrayList(stackFrame));
-    }
-
-    private Object popValue() {
-        return stackFrame.remove(stackFrame.size() - 1);
-    }
-
-    private Object peekValue() {
-        return stackFrame.get(stackFrame.size() - 1);
-    }
-
-    private void pushValue(final Object o) {
-        stackFrame.add(o);
-    }
-
-    /**
-     * Called at the beginning of the method or after super class class call in
-     * the constructor. <br><br>
-     *
-     * <i>Custom code can use or change all the local variables, but should not
-     * change state of the stack.</i>
-     */
-    protected void onMethodEnter() {
-    }
-
-    /**
-     * Called before explicit exit from the method using either return or throw.
-     * Top element on the stack contains the return value or exception instance.
-     * For example:
-     *
-     * <pre>
-     *   public void onMethodExit(int opcode) {
-     *     if(opcode==RETURN) {
-     *         visitInsn(ACONST_NULL);
-     *     } else if(opcode==ARETURN || opcode==ATHROW) {
-     *         dup();
-     *     } else {
-     *         if(opcode==LRETURN || opcode==DRETURN) {
-     *             dup2();
-     *         } else {
-     *             dup();
-     *         }
-     *         box(Type.getReturnType(this.methodDesc));
-     *     }
-     *     visitIntInsn(SIPUSH, opcode);
-     *     visitMethodInsn(INVOKESTATIC, owner, "onExit", "(Ljava/lang/Object;I)V");
-     *   }
-     *
-     *   // an actual call back method
-     *   public static void onExit(Object param, int opcode) {
-     *     ...
-     * </pre>
-     *
-     * <br><br>
-     *
-     * <i>Custom code can use or change all the local variables, but should not
-     * change state of the stack.</i>
-     *
-     * @param opcode one of the RETURN, IRETURN, FRETURN, ARETURN, LRETURN,
-     *        DRETURN or ATHROW
-     *
-     */
-    protected void onMethodExit(int opcode) {
-    }
-
-    // TODO onException, onMethodCall
-
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/AnalyzerAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/AnalyzerAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/AnalyzerAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/AnalyzerAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,877 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodAdapter;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-
-/**
- * A {@link MethodAdapter} that keeps track of stack map frame changes between
- * {@link #visitFrame(int, int, Object[], int, Object[]) visitFrame} calls. This
- * adapter must be used with the
- * {@link org.eclipse.persistence.internal.libraries.asm.ClassReader#EXPAND_FRAMES} option. Each visit<i>X</i>
- * instruction delegates to the next visitor in the chain, if any, and then
- * simulates the effect of this instruction on the stack map frame, represented
- * by {@link #locals} and {@link #stack}. The next visitor in the chain can get
- * the state of the stack map frame <i>before</i> each instruction by reading
- * the value of these fields in its visit<i>X</i> methods (this requires a
- * reference to the AnalyzerAdapter that is before it in the chain).
- * If this adapter is used with a class that does not contain stack map table
- * attributes (i.e., pre Java 6 classes) then this adapter may not be able to
- * compute the stack map frame for each instruction. In this case no exception
- * is thrown but the {@link #locals} and {@link #stack} fields will be null for
- * these instructions.
- * 
- * @author Eric Bruneton
- */
-public class AnalyzerAdapter extends MethodAdapter {
-
-    /**
-     * <code>List</code> of the local variable slots for current execution
-     * frame. Primitive types are represented by {@link Opcodes#TOP},
-     * {@link Opcodes#INTEGER}, {@link Opcodes#FLOAT}, {@link Opcodes#LONG},
-     * {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or
-     * {@link Opcodes#UNINITIALIZED_THIS} (long and double are represented by a
-     * two elements, the second one being TOP). Reference types are represented
-     * by String objects (representing internal names), and uninitialized types
-     * by Label objects (this label designates the NEW instruction that created
-     * this uninitialized value). This field is <tt>null</tt> for unreacheable
-     * instructions.
-     */
-    public List locals;
-
-    /**
-     * <code>List</code> of the operand stack slots for current execution
-     * frame. Primitive types are represented by {@link Opcodes#TOP},
-     * {@link Opcodes#INTEGER}, {@link Opcodes#FLOAT}, {@link Opcodes#LONG},
-     * {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or
-     * {@link Opcodes#UNINITIALIZED_THIS} (long and double are represented by a
-     * two elements, the second one being TOP). Reference types are represented
-     * by String objects (representing internal names), and uninitialized types
-     * by Label objects (this label designates the NEW instruction that created
-     * this uninitialized value). This field is <tt>null</tt> for unreacheable
-     * instructions.
-     */
-    public List stack;
-
-    /**
-     * The labels that designate the next instruction to be visited. May be
-     * <tt>null</tt>.
-     */
-    private List labels;
-
-    /**
-     * Information about uninitialized types in the current execution frame.
-     * This map associates internal names to Label objects. Each label
-     * designates a NEW instruction that created the currently uninitialized
-     * types, and the associated internal name represents the NEW operand, i.e.
-     * the final, initialized type value.
-     */
-    public Map uninitializedTypes;
-
-    /**
-     * The maximum stack size of this method.
-     */
-    private int maxStack;
-
-    /**
-     * The maximum number of local variables of this method.
-     */
-    private int maxLocals;
-
-    /**
-     * The owner's class name.
-     */
-    private String owner;
-    
-    /**
-     * Creates a new {@link AnalyzerAdapter}.
-     *
-     * @param owner the owner's class name.
-     * @param access the method's access flags (see {@link Opcodes}).
-     * @param name the method's name.
-     * @param desc the method's descriptor (see {@link Type Type}).
-     * @param mv the method visitor to which this adapter delegates calls. May
-     *        be <tt>null</tt>.
-     */
-    public AnalyzerAdapter(
-        final String owner,
-        final int access,
-        final String name,
-        final String desc,
-        final MethodVisitor mv)
-    {
-        super(mv);
-        this.owner = owner;
-        locals = new ArrayList();
-        stack = new ArrayList();
-        uninitializedTypes = new HashMap();
-
-        if ((access & Opcodes.ACC_STATIC) == 0) {
-            if ("<init>".equals(name)) {
-                locals.add(Opcodes.UNINITIALIZED_THIS);
-            } else {
-                locals.add(owner);
-            }
-        }
-        Type[] types = Type.getArgumentTypes(desc);
-        for (int i = 0; i < types.length; ++i) {
-            Type type = types[i];
-            switch (type.getSort()) {
-                case Type.BOOLEAN:
-                case Type.CHAR:
-                case Type.BYTE:
-                case Type.SHORT:
-                case Type.INT:
-                    locals.add(Opcodes.INTEGER);
-                    break;
-                case Type.FLOAT:
-                    locals.add(Opcodes.FLOAT);
-                    break;
-                case Type.LONG:
-                    locals.add(Opcodes.LONG);
-                    locals.add(Opcodes.TOP);
-                    break;
-                case Type.DOUBLE:
-                    locals.add(Opcodes.DOUBLE);
-                    locals.add(Opcodes.TOP);
-                    break;
-                case Type.ARRAY:
-                    locals.add(types[i].getDescriptor());
-                    break;
-                // case Type.OBJECT:
-                default:
-                    locals.add(types[i].getInternalName());
-            }
-        }
-    }
-
-    public void visitFrame(
-        final int type,
-        final int nLocal,
-        final Object[] local,
-        final int nStack,
-        final Object[] stack)
-    {
-        if (type != Opcodes.F_NEW) { // uncompressed frame
-            throw new IllegalStateException("ClassReader.accept() should be called with EXPAND_FRAMES flag");
-        }
-
-        if (mv != null) {
-            mv.visitFrame(type, nLocal, local, nStack, stack);
-        }
-
-        if (this.locals != null) {
-            this.locals.clear();
-            this.stack.clear();
-        } else {
-            this.locals = new ArrayList();
-            this.stack = new ArrayList();
-        }
-        visitFrameTypes(nLocal, local, this.locals);
-        visitFrameTypes(nStack, stack, this.stack);
-        maxStack = Math.max(maxStack, this.stack.size());
-    }
-
-    private static void visitFrameTypes(
-        final int n,
-        final Object[] types,
-        final List result)
-    {
-        for (int i = 0; i < n; ++i) {
-            Object type = types[i];
-            result.add(type);
-            if (type == Opcodes.LONG || type == Opcodes.DOUBLE) {
-                result.add(Opcodes.TOP);
-            }
-        }
-    }
-
-    public void visitInsn(final int opcode) {
-        if (mv != null) {
-            mv.visitInsn(opcode);
-        }
-        execute(opcode, 0, null);
-        if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN)
-                || opcode == Opcodes.ATHROW)
-        {
-            this.locals = null;
-            this.stack = null;
-        }
-    }
-
-    public void visitIntInsn(final int opcode, final int operand) {
-        if (mv != null) {
-            mv.visitIntInsn(opcode, operand);
-        }
-        execute(opcode, operand, null);
-    }
-
-    public void visitVarInsn(final int opcode, final int var) {
-        if (mv != null) {
-            mv.visitVarInsn(opcode, var);
-        }
-        execute(opcode, var, null);
-    }
-
-    public void visitTypeInsn(final int opcode, final String type) {
-        if (opcode == Opcodes.NEW) {
-            if (labels == null) {
-                Label l = new Label();
-                labels = new ArrayList(3);
-                labels.add(l);
-                if (mv != null) {
-                    mv.visitLabel(l);
-                }
-            }
-            for (int i = 0; i < labels.size(); ++i) {
-                uninitializedTypes.put(labels.get(i), type);
-            }
-        }
-        if (mv != null) {
-            mv.visitTypeInsn(opcode, type);
-        }
-        execute(opcode, 0, type);
-    }
-
-    public void visitFieldInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        if (mv != null) {
-            mv.visitFieldInsn(opcode, owner, name, desc);
-        }
-        execute(opcode, 0, desc);
-    }
-
-    public void visitMethodInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        if (mv != null) {
-            mv.visitMethodInsn(opcode, owner, name, desc);
-        }
-        if (this.locals == null) {
-            labels = null;
-            return;
-        }
-        pop(desc);
-        if (opcode != Opcodes.INVOKESTATIC && opcode != Opcodes.INVOKEDYNAMIC) {
-            Object t = pop();
-            if (opcode == Opcodes.INVOKESPECIAL && name.charAt(0) == '<') {
-                Object u;
-                if (t == Opcodes.UNINITIALIZED_THIS) {
-                    u = this.owner;
-                } else {
-                    u = uninitializedTypes.get(t);
-                }
-                for (int i = 0; i < locals.size(); ++i) {
-                    if (locals.get(i) == t) {
-                        locals.set(i, u);
-                    }
-                }
-                for (int i = 0; i < stack.size(); ++i) {
-                    if (stack.get(i) == t) {
-                        stack.set(i, u);
-                    }
-                }
-            }
-        }
-        pushDesc(desc);
-        labels = null;
-    }
-
-    public void visitJumpInsn(final int opcode, final Label label) {
-        if (mv != null) {
-            mv.visitJumpInsn(opcode, label);
-        }
-        execute(opcode, 0, null);
-        if (opcode == Opcodes.GOTO) {
-            this.locals = null;
-            this.stack = null;
-        }
-    }
-
-    public void visitLabel(final Label label) {
-        if (mv != null) {
-            mv.visitLabel(label);
-        }
-        if (labels == null) {
-            labels = new ArrayList(3);
-        }
-        labels.add(label);
-    }
-
-    public void visitLdcInsn(final Object cst) {
-        if (mv != null) {
-            mv.visitLdcInsn(cst);
-        }
-        if (this.locals == null) {
-            labels = null;
-            return;
-        }
-        if (cst instanceof Integer) {
-            push(Opcodes.INTEGER);
-        } else if (cst instanceof Long) {
-            push(Opcodes.LONG);
-            push(Opcodes.TOP);
-        } else if (cst instanceof Float) {
-            push(Opcodes.FLOAT);
-        } else if (cst instanceof Double) {
-            push(Opcodes.DOUBLE);
-            push(Opcodes.TOP);
-        } else if (cst instanceof String) {
-            push("java/lang/String");
-        } else if (cst instanceof Type) {
-            push("java/lang/Class");
-        } else {
-            throw new IllegalArgumentException();
-        }
-        labels = null;
-    }
-
-    public void visitIincInsn(final int var, final int increment) {
-        if (mv != null) {
-            mv.visitIincInsn(var, increment);
-        }
-        execute(Opcodes.IINC, var, null);
-    }
-
-    public void visitTableSwitchInsn(
-        final int min,
-        final int max,
-        final Label dflt,
-        final Label[] labels)
-    {
-        if (mv != null) {
-            mv.visitTableSwitchInsn(min, max, dflt, labels);
-        }
-        execute(Opcodes.TABLESWITCH, 0, null);
-        this.locals = null;
-        this.stack = null;
-    }
-
-    public void visitLookupSwitchInsn(
-        final Label dflt,
-        final int[] keys,
-        final Label[] labels)
-    {
-        if (mv != null) {
-            mv.visitLookupSwitchInsn(dflt, keys, labels);
-        }
-        execute(Opcodes.LOOKUPSWITCH, 0, null);
-        this.locals = null;
-        this.stack = null;
-    }
-
-    public void visitMultiANewArrayInsn(final String desc, final int dims) {
-        if (mv != null) {
-            mv.visitMultiANewArrayInsn(desc, dims);
-        }
-        execute(Opcodes.MULTIANEWARRAY, dims, desc);
-    }
-
-    public void visitMaxs(final int maxStack, final int maxLocals) {
-        if (mv != null) {
-            this.maxStack = Math.max(this.maxStack, maxStack);
-            this.maxLocals = Math.max(this.maxLocals, maxLocals);
-            mv.visitMaxs(this.maxStack, this.maxLocals);
-        }
-    }
-
-    // ------------------------------------------------------------------------
-
-    private Object get(final int local) {
-        maxLocals = Math.max(maxLocals, local);
-        return local < locals.size() ? locals.get(local) : Opcodes.TOP;
-    }
-
-    private void set(final int local, final Object type) {
-        maxLocals = Math.max(maxLocals, local);
-        while (local >= locals.size()) {
-            locals.add(Opcodes.TOP);
-        }
-        locals.set(local, type);
-    }
-
-    private void push(final Object type) {
-        stack.add(type);
-        maxStack = Math.max(maxStack, stack.size());
-    }
-
-    private void pushDesc(final String desc) {
-        int index = desc.charAt(0) == '(' ? desc.indexOf(')') + 1 : 0;
-        switch (desc.charAt(index)) {
-            case 'V':
-                return;
-            case 'Z':
-            case 'C':
-            case 'B':
-            case 'S':
-            case 'I':
-                push(Opcodes.INTEGER);
-                return;
-            case 'F':
-                push(Opcodes.FLOAT);
-                return;
-            case 'J':
-                push(Opcodes.LONG);
-                push(Opcodes.TOP);
-                return;
-            case 'D':
-                push(Opcodes.DOUBLE);
-                push(Opcodes.TOP);
-                return;
-            case '[':
-                if (index == 0) {
-                    push(desc);
-                } else {
-                    push(desc.substring(index, desc.length()));
-                }
-                break;
-            // case 'L':
-            default:
-                if (index == 0) {
-                    push(desc.substring(1, desc.length() - 1));
-                } else {
-                    push(desc.substring(index + 1, desc.length() - 1));
-                }
-        }
-    }
-
-    private Object pop() {
-        return stack.remove(stack.size() - 1);
-    }
-
-    private void pop(final int n) {
-        int size = stack.size();
-        int end = size - n;
-        for (int i = size - 1; i >= end; --i) {
-            stack.remove(i);
-        }
-    }
-
-    private void pop(final String desc) {
-        char c = desc.charAt(0);
-        if (c == '(') {
-            int n = 0;
-            Type[] types = Type.getArgumentTypes(desc);
-            for (int i = 0; i < types.length; ++i) {
-                n += types[i].getSize();
-            }
-            pop(n);
-        } else if (c == 'J' || c == 'D') {
-            pop(2);
-        } else {
-            pop(1);
-        }
-    }
-
-    private void execute(final int opcode, final int iarg, final String sarg) {
-        if (this.locals == null) {
-            labels = null;
-            return;
-        }
-        Object t1, t2, t3, t4;
-        switch (opcode) {
-            case Opcodes.NOP:
-            case Opcodes.INEG:
-            case Opcodes.LNEG:
-            case Opcodes.FNEG:
-            case Opcodes.DNEG:
-            case Opcodes.I2B:
-            case Opcodes.I2C:
-            case Opcodes.I2S:
-            case Opcodes.GOTO:
-            case Opcodes.RETURN:
-                break;
-            case Opcodes.ACONST_NULL:
-                push(Opcodes.NULL);
-                break;
-            case Opcodes.ICONST_M1:
-            case Opcodes.ICONST_0:
-            case Opcodes.ICONST_1:
-            case Opcodes.ICONST_2:
-            case Opcodes.ICONST_3:
-            case Opcodes.ICONST_4:
-            case Opcodes.ICONST_5:
-            case Opcodes.BIPUSH:
-            case Opcodes.SIPUSH:
-                push(Opcodes.INTEGER);
-                break;
-            case Opcodes.LCONST_0:
-            case Opcodes.LCONST_1:
-                push(Opcodes.LONG);
-                push(Opcodes.TOP);
-                break;
-            case Opcodes.FCONST_0:
-            case Opcodes.FCONST_1:
-            case Opcodes.FCONST_2:
-                push(Opcodes.FLOAT);
-                break;
-            case Opcodes.DCONST_0:
-            case Opcodes.DCONST_1:
-                push(Opcodes.DOUBLE);
-                push(Opcodes.TOP);
-                break;
-            case Opcodes.ILOAD:
-            case Opcodes.FLOAD:
-            case Opcodes.ALOAD:
-                push(get(iarg));
-                break;
-            case Opcodes.LLOAD:
-            case Opcodes.DLOAD:
-                push(get(iarg));
-                push(Opcodes.TOP);
-                break;
-            case Opcodes.IALOAD:
-            case Opcodes.BALOAD:
-            case Opcodes.CALOAD:
-            case Opcodes.SALOAD:
-                pop(2);
-                push(Opcodes.INTEGER);
-                break;
-            case Opcodes.LALOAD:
-            case Opcodes.D2L:
-                pop(2);
-                push(Opcodes.LONG);
-                push(Opcodes.TOP);
-                break;
-            case Opcodes.FALOAD:
-                pop(2);
-                push(Opcodes.FLOAT);
-                break;
-            case Opcodes.DALOAD:
-            case Opcodes.L2D:
-                pop(2);
-                push(Opcodes.DOUBLE);
-                push(Opcodes.TOP);
-                break;
-            case Opcodes.AALOAD:
-                pop(1);
-                t1 = pop();
-                if (t1 instanceof String) {
-                    pushDesc(((String) t1).substring(1));
-                } else {
-                    push("java/lang/Object");
-                }
-                break;
-            case Opcodes.ISTORE:
-            case Opcodes.FSTORE:
-            case Opcodes.ASTORE:
-                t1 = pop();
-                set(iarg, t1);
-                if (iarg > 0) {
-                    t2 = get(iarg - 1);
-                    if (t2 == Opcodes.LONG || t2 == Opcodes.DOUBLE) {
-                        set(iarg - 1, Opcodes.TOP);
-                    }
-                }
-                break;
-            case Opcodes.LSTORE:
-            case Opcodes.DSTORE:
-                pop(1);
-                t1 = pop();
-                set(iarg, t1);
-                set(iarg + 1, Opcodes.TOP);
-                if (iarg > 0) {
-                    t2 = get(iarg - 1);
-                    if (t2 == Opcodes.LONG || t2 == Opcodes.DOUBLE) {
-                        set(iarg - 1, Opcodes.TOP);
-                    }
-                }
-                break;
-            case Opcodes.IASTORE:
-            case Opcodes.BASTORE:
-            case Opcodes.CASTORE:
-            case Opcodes.SASTORE:
-            case Opcodes.FASTORE:
-            case Opcodes.AASTORE:
-                pop(3);
-                break;
-            case Opcodes.LASTORE:
-            case Opcodes.DASTORE:
-                pop(4);
-                break;
-            case Opcodes.POP:
-            case Opcodes.IFEQ:
-            case Opcodes.IFNE:
-            case Opcodes.IFLT:
-            case Opcodes.IFGE:
-            case Opcodes.IFGT:
-            case Opcodes.IFLE:
-            case Opcodes.IRETURN:
-            case Opcodes.FRETURN:
-            case Opcodes.ARETURN:
-            case Opcodes.TABLESWITCH:
-            case Opcodes.LOOKUPSWITCH:
-            case Opcodes.ATHROW:
-            case Opcodes.MONITORENTER:
-            case Opcodes.MONITOREXIT:
-            case Opcodes.IFNULL:
-            case Opcodes.IFNONNULL:
-                pop(1);
-                break;
-            case Opcodes.POP2:
-            case Opcodes.IF_ICMPEQ:
-            case Opcodes.IF_ICMPNE:
-            case Opcodes.IF_ICMPLT:
-            case Opcodes.IF_ICMPGE:
-            case Opcodes.IF_ICMPGT:
-            case Opcodes.IF_ICMPLE:
-            case Opcodes.IF_ACMPEQ:
-            case Opcodes.IF_ACMPNE:
-            case Opcodes.LRETURN:
-            case Opcodes.DRETURN:
-                pop(2);
-                break;
-            case Opcodes.DUP:
-                t1 = pop();
-                push(t1);
-                push(t1);
-                break;
-            case Opcodes.DUP_X1:
-                t1 = pop();
-                t2 = pop();
-                push(t1);
-                push(t2);
-                push(t1);
-                break;
-            case Opcodes.DUP_X2:
-                t1 = pop();
-                t2 = pop();
-                t3 = pop();
-                push(t1);
-                push(t3);
-                push(t2);
-                push(t1);
-                break;
-            case Opcodes.DUP2:
-                t1 = pop();
-                t2 = pop();
-                push(t2);
-                push(t1);
-                push(t2);
-                push(t1);
-                break;
-            case Opcodes.DUP2_X1:
-                t1 = pop();
-                t2 = pop();
-                t3 = pop();
-                push(t2);
-                push(t1);
-                push(t3);
-                push(t2);
-                push(t1);
-                break;
-            case Opcodes.DUP2_X2:
-                t1 = pop();
-                t2 = pop();
-                t3 = pop();
-                t4 = pop();
-                push(t2);
-                push(t1);
-                push(t4);
-                push(t3);
-                push(t2);
-                push(t1);
-                break;
-            case Opcodes.SWAP:
-                t1 = pop();
-                t2 = pop();
-                push(t1);
-                push(t2);
-                break;
-            case Opcodes.IADD:
-            case Opcodes.ISUB:
-            case Opcodes.IMUL:
-            case Opcodes.IDIV:
-            case Opcodes.IREM:
-            case Opcodes.IAND:
-            case Opcodes.IOR:
-            case Opcodes.IXOR:
-            case Opcodes.ISHL:
-            case Opcodes.ISHR:
-            case Opcodes.IUSHR:
-            case Opcodes.L2I:
-            case Opcodes.D2I:
-            case Opcodes.FCMPL:
-            case Opcodes.FCMPG:
-                pop(2);
-                push(Opcodes.INTEGER);
-                break;
-            case Opcodes.LADD:
-            case Opcodes.LSUB:
-            case Opcodes.LMUL:
-            case Opcodes.LDIV:
-            case Opcodes.LREM:
-            case Opcodes.LAND:
-            case Opcodes.LOR:
-            case Opcodes.LXOR:
-                pop(4);
-                push(Opcodes.LONG);
-                push(Opcodes.TOP);
-                break;
-            case Opcodes.FADD:
-            case Opcodes.FSUB:
-            case Opcodes.FMUL:
-            case Opcodes.FDIV:
-            case Opcodes.FREM:
-            case Opcodes.L2F:
-            case Opcodes.D2F:
-                pop(2);
-                push(Opcodes.FLOAT);
-                break;
-            case Opcodes.DADD:
-            case Opcodes.DSUB:
-            case Opcodes.DMUL:
-            case Opcodes.DDIV:
-            case Opcodes.DREM:
-                pop(4);
-                push(Opcodes.DOUBLE);
-                push(Opcodes.TOP);
-                break;
-            case Opcodes.LSHL:
-            case Opcodes.LSHR:
-            case Opcodes.LUSHR:
-                pop(3);
-                push(Opcodes.LONG);
-                push(Opcodes.TOP);
-                break;
-            case Opcodes.IINC:
-                set(iarg, Opcodes.INTEGER);
-                break;
-            case Opcodes.I2L:
-            case Opcodes.F2L:
-                pop(1);
-                push(Opcodes.LONG);
-                push(Opcodes.TOP);
-                break;
-            case Opcodes.I2F:
-                pop(1);
-                push(Opcodes.FLOAT);
-                break;
-            case Opcodes.I2D:
-            case Opcodes.F2D:
-                pop(1);
-                push(Opcodes.DOUBLE);
-                push(Opcodes.TOP);
-                break;
-            case Opcodes.F2I:
-            case Opcodes.ARRAYLENGTH:
-            case Opcodes.INSTANCEOF:
-                pop(1);
-                push(Opcodes.INTEGER);
-                break;
-            case Opcodes.LCMP:
-            case Opcodes.DCMPL:
-            case Opcodes.DCMPG:
-                pop(4);
-                push(Opcodes.INTEGER);
-                break;
-            case Opcodes.JSR:
-            case Opcodes.RET:
-                throw new RuntimeException("JSR/RET are not supported");
-            case Opcodes.GETSTATIC:
-                pushDesc(sarg);
-                break;
-            case Opcodes.PUTSTATIC:
-                pop(sarg);
-                break;
-            case Opcodes.GETFIELD:
-                pop(1);
-                pushDesc(sarg);
-                break;
-            case Opcodes.PUTFIELD:
-                pop(sarg);
-                pop();
-                break;
-            case Opcodes.NEW:
-                push(labels.get(0));
-                break;
-            case Opcodes.NEWARRAY:
-                pop();
-                switch (iarg) {
-                    case Opcodes.T_BOOLEAN:
-                        pushDesc("[Z");
-                        break;
-                    case Opcodes.T_CHAR:
-                        pushDesc("[C");
-                        break;
-                    case Opcodes.T_BYTE:
-                        pushDesc("[B");
-                        break;
-                    case Opcodes.T_SHORT:
-                        pushDesc("[S");
-                        break;
-                    case Opcodes.T_INT:
-                        pushDesc("[I");
-                        break;
-                    case Opcodes.T_FLOAT:
-                        pushDesc("[F");
-                        break;
-                    case Opcodes.T_DOUBLE:
-                        pushDesc("[D");
-                        break;
-                    // case Opcodes.T_LONG:
-                    default:
-                        pushDesc("[J");
-                        break;
-                }
-                break;
-            case Opcodes.ANEWARRAY:
-                pop();
-                pushDesc("[" + Type.getObjectType(sarg));
-                break;
-            case Opcodes.CHECKCAST:
-                pop();
-                pushDesc(Type.getObjectType(sarg).getDescriptor());
-                break;
-            // case Opcodes.MULTIANEWARRAY:
-            default:
-                pop(iarg);
-                pushDesc(sarg);
-                break;
-        }
-        labels = null;
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/CodeSizeEvaluator.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/CodeSizeEvaluator.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/CodeSizeEvaluator.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/CodeSizeEvaluator.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,206 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodAdapter;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-
-/**
- * A {@link MethodAdapter} that can be used to approximate method size.
- * 
- * @author Eugene Kuleshov
- */
-public class CodeSizeEvaluator extends MethodAdapter implements Opcodes {
-
-    private int minSize;
-
-    private int maxSize;
-
-    public CodeSizeEvaluator(final MethodVisitor mv) {
-        super(mv);
-    }
-
-    public int getMinSize() {
-        return this.minSize;
-    }
-
-    public int getMaxSize() {
-        return this.maxSize;
-    }
-
-    public void visitInsn(final int opcode) {
-        minSize += 1;
-        maxSize += 1;
-        if (mv != null) {
-            mv.visitInsn(opcode);
-        }
-    }
-
-    public void visitIntInsn(final int opcode, final int operand) {
-        if (opcode == SIPUSH) {
-            minSize += 3;
-            maxSize += 3;
-        } else {
-            minSize += 2;
-            maxSize += 2;
-        }
-        if (mv != null) {
-            mv.visitIntInsn(opcode, operand);
-        }
-    }
-
-    public void visitVarInsn(final int opcode, final int var) {
-        if (var < 4 && opcode != RET) {
-            minSize += 1;
-            maxSize += 1;
-        } else if (var >= 256) {
-            minSize += 4;
-            maxSize += 4;
-        } else {
-            minSize += 2;
-            maxSize += 2;
-        }
-        if (mv != null) {
-            mv.visitVarInsn(opcode, var);
-        }
-    }
-
-    public void visitTypeInsn(final int opcode, final String type) {
-        minSize += 3;
-        maxSize += 3;
-        if (mv != null) {
-            mv.visitTypeInsn(opcode, type);
-        }
-    }
-
-    public void visitFieldInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        minSize += 3;
-        maxSize += 3;
-        if (mv != null) {
-            mv.visitFieldInsn(opcode, owner, name, desc);
-        }
-    }
-
-    public void visitMethodInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        if (opcode == INVOKEINTERFACE || opcode == INVOKEDYNAMIC) {
-            minSize += 5;
-            maxSize += 5;
-        } else {
-            minSize += 3;
-            maxSize += 3;
-        }
-        if (mv != null) {
-            mv.visitMethodInsn(opcode, owner, name, desc);
-        }
-    }
-
-    public void visitJumpInsn(final int opcode, final Label label) {
-        minSize += 3;
-        if (opcode == GOTO || opcode == JSR) {
-            maxSize += 5;
-        } else {
-            maxSize += 8;
-        }
-        if (mv != null) {
-            mv.visitJumpInsn(opcode, label);
-        }
-    }
-
-    public void visitLdcInsn(final Object cst) {
-        if (cst instanceof Long || cst instanceof Double) {
-            minSize += 3;
-            maxSize += 3;
-        } else {
-            minSize += 2;
-            maxSize += 3;
-        }
-        if (mv != null) {
-            mv.visitLdcInsn(cst);
-        }
-    }
-
-    public void visitIincInsn(final int var, final int increment) {
-        if (var > 255 || increment > 127 || increment < -128) {
-            minSize += 6;
-            maxSize += 6;
-        } else {
-            minSize += 3;
-            maxSize += 3;
-        }
-        if (mv != null) {
-            mv.visitIincInsn(var, increment);
-        }
-    }
-
-    public void visitTableSwitchInsn(
-        final int min,
-        final int max,
-        final Label dflt,
-        final Label[] labels)
-    {
-        minSize += 13 + labels.length * 4;
-        maxSize += 16 + labels.length * 4;
-        if (mv != null) {
-            mv.visitTableSwitchInsn(min, max, dflt, labels);
-        }
-    }
-
-    public void visitLookupSwitchInsn(
-        final Label dflt,
-        final int[] keys,
-        final Label[] labels)
-    {
-        minSize += 9 + keys.length * 8;
-        maxSize += 12 + keys.length * 8;
-        if (mv != null) {
-            mv.visitLookupSwitchInsn(dflt, keys, labels);
-        }
-    }
-
-    public void visitMultiANewArrayInsn(final String desc, final int dims) {
-        minSize += 4;
-        maxSize += 4;
-        if (mv != null) {
-            mv.visitMultiANewArrayInsn(desc, dims);
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/EmptyVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/EmptyVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/EmptyVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/EmptyVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,238 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-import org.eclipse.persistence.internal.libraries.asm.ClassVisitor;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-/**
- * An empty implementation of the ASM visitor interfaces.
- * 
- * @author Eric Bruneton
- */
-public class EmptyVisitor implements
-        ClassVisitor,
-        FieldVisitor,
-        MethodVisitor,
-        AnnotationVisitor
-{
-
-    public void visit(
-        final int version,
-        final int access,
-        final String name,
-        final String signature,
-        final String superName,
-        final String[] interfaces)
-    {
-    }
-
-    public void visitSource(final String source, final String debug) {
-    }
-
-    public void visitOuterClass(
-        final String owner,
-        final String name,
-        final String desc)
-    {
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        return this;
-    }
-
-    public void visitAttribute(final Attribute attr) {
-    }
-
-    public void visitInnerClass(
-        final String name,
-        final String outerName,
-        final String innerName,
-        final int access)
-    {
-    }
-
-    public FieldVisitor visitField(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final Object value)
-    {
-        return this;
-    }
-
-    public MethodVisitor visitMethod(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final String[] exceptions)
-    {
-        return this;
-    }
-
-    public void visitEnd() {
-    }
-
-    public AnnotationVisitor visitAnnotationDefault() {
-        return this;
-    }
-
-    public AnnotationVisitor visitParameterAnnotation(
-        final int parameter,
-        final String desc,
-        final boolean visible)
-    {
-        return this;
-    }
-
-    public void visitCode() {
-    }
-
-    public void visitFrame(
-        final int type,
-        final int nLocal,
-        final Object[] local,
-        final int nStack,
-        final Object[] stack)
-    {
-    }
-
-    public void visitInsn(final int opcode) {
-    }
-
-    public void visitIntInsn(final int opcode, final int operand) {
-    }
-
-    public void visitVarInsn(final int opcode, final int var) {
-    }
-
-    public void visitTypeInsn(final int opcode, final String type) {
-    }
-
-    public void visitFieldInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-    }
-
-    public void visitMethodInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-    }
-
-    public void visitJumpInsn(final int opcode, final Label label) {
-    }
-
-    public void visitLabel(final Label label) {
-    }
-
-    public void visitLdcInsn(final Object cst) {
-    }
-
-    public void visitIincInsn(final int var, final int increment) {
-    }
-
-    public void visitTableSwitchInsn(
-        final int min,
-        final int max,
-        final Label dflt,
-        final Label[] labels)
-    {
-    }
-
-    public void visitLookupSwitchInsn(
-        final Label dflt,
-        final int[] keys,
-        final Label[] labels)
-    {
-    }
-
-    public void visitMultiANewArrayInsn(final String desc, final int dims) {
-    }
-
-    public void visitTryCatchBlock(
-        final Label start,
-        final Label end,
-        final Label handler,
-        final String type)
-    {
-    }
-
-    public void visitLocalVariable(
-        final String name,
-        final String desc,
-        final String signature,
-        final Label start,
-        final Label end,
-        final int index)
-    {
-    }
-
-    public void visitLineNumber(final int line, final Label start) {
-    }
-
-    public void visitMaxs(final int maxStack, final int maxLocals) {
-    }
-
-    public void visit(final String name, final Object value) {
-    }
-
-    public void visitEnum(
-        final String name,
-        final String desc,
-        final String value)
-    {
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String name,
-        final String desc)
-    {
-        return this;
-    }
-
-    public AnnotationVisitor visitArray(final String name) {
-        return this;
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/GeneratorAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/GeneratorAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/GeneratorAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/GeneratorAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,1506 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import org.eclipse.persistence.internal.libraries.asm.ClassVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-
-/**
- * A {@link org.eclipse.persistence.internal.libraries.asm.MethodAdapter} with convenient methods to generate
- * code. For example, using this adapter, the class below
- * 
- * <pre>
- * public class Example {
- *     public static void main(String[] args) {
- *         System.out.println(&quot;Hello world!&quot;);
- *     }
- * }
- * </pre>
- * 
- * can be generated as follows:
- * 
- * <pre>
- * ClassWriter cw = new ClassWriter(true);
- * cw.visit(V1_1, ACC_PUBLIC, &quot;Example&quot;, null, &quot;java/lang/Object&quot;, null);
- * 
- * Method m = Method.getMethod(&quot;void &lt;init&gt; ()&quot;);
- * GeneratorAdapter mg = new GeneratorAdapter(ACC_PUBLIC, m, null, null, cw);
- * mg.loadThis();
- * mg.invokeConstructor(Type.getType(Object.class), m);
- * mg.returnValue();
- * mg.endMethod();
- * 
- * m = Method.getMethod(&quot;void main (String[])&quot;);
- * mg = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, m, null, null, cw);
- * mg.getStatic(Type.getType(System.class), &quot;out&quot;, Type.getType(PrintStream.class));
- * mg.push(&quot;Hello world!&quot;);
- * mg.invokeVirtual(Type.getType(PrintStream.class), Method.getMethod(&quot;void println (String)&quot;));
- * mg.returnValue();
- * mg.endMethod();
- * 
- * cw.visitEnd();
- * </pre>
- * 
- * @author Juozas Baliuka
- * @author Chris Nokleberg
- * @author Eric Bruneton
- */
-public class GeneratorAdapter extends LocalVariablesSorter {
-
-    private static final String CLDESC = "Ljava/lang/Class;";
-
-    private static final Type BYTE_TYPE = Type.getObjectType("java/lang/Byte");
-
-    private static final Type BOOLEAN_TYPE = Type.getObjectType("java/lang/Boolean");
-
-    private static final Type SHORT_TYPE = Type.getObjectType("java/lang/Short");
-
-    private static final Type CHARACTER_TYPE = Type.getObjectType("java/lang/Character");
-
-    private static final Type INTEGER_TYPE = Type.getObjectType("java/lang/Integer");
-
-    private static final Type FLOAT_TYPE = Type.getObjectType("java/lang/Float");
-
-    private static final Type LONG_TYPE = Type.getObjectType("java/lang/Long");
-
-    private static final Type DOUBLE_TYPE = Type.getObjectType("java/lang/Double");
-
-    private static final Type NUMBER_TYPE = Type.getObjectType("java/lang/Number");
-
-    private static final Type OBJECT_TYPE = Type.getObjectType("java/lang/Object");
-
-    private static final Method BOOLEAN_VALUE = Method.getMethod("boolean booleanValue()");
-
-    private static final Method CHAR_VALUE = Method.getMethod("char charValue()");
-
-    private static final Method INT_VALUE = Method.getMethod("int intValue()");
-
-    private static final Method FLOAT_VALUE = Method.getMethod("float floatValue()");
-
-    private static final Method LONG_VALUE = Method.getMethod("long longValue()");
-
-    private static final Method DOUBLE_VALUE = Method.getMethod("double doubleValue()");
-
-    /**
-     * Constant for the {@link #math math} method.
-     */
-    public static final int ADD = Opcodes.IADD;
-
-    /**
-     * Constant for the {@link #math math} method.
-     */
-    public static final int SUB = Opcodes.ISUB;
-
-    /**
-     * Constant for the {@link #math math} method.
-     */
-    public static final int MUL = Opcodes.IMUL;
-
-    /**
-     * Constant for the {@link #math math} method.
-     */
-    public static final int DIV = Opcodes.IDIV;
-
-    /**
-     * Constant for the {@link #math math} method.
-     */
-    public static final int REM = Opcodes.IREM;
-
-    /**
-     * Constant for the {@link #math math} method.
-     */
-    public static final int NEG = Opcodes.INEG;
-
-    /**
-     * Constant for the {@link #math math} method.
-     */
-    public static final int SHL = Opcodes.ISHL;
-
-    /**
-     * Constant for the {@link #math math} method.
-     */
-    public static final int SHR = Opcodes.ISHR;
-
-    /**
-     * Constant for the {@link #math math} method.
-     */
-    public static final int USHR = Opcodes.IUSHR;
-
-    /**
-     * Constant for the {@link #math math} method.
-     */
-    public static final int AND = Opcodes.IAND;
-
-    /**
-     * Constant for the {@link #math math} method.
-     */
-    public static final int OR = Opcodes.IOR;
-
-    /**
-     * Constant for the {@link #math math} method.
-     */
-    public static final int XOR = Opcodes.IXOR;
-
-    /**
-     * Constant for the {@link #ifCmp ifCmp} method.
-     */
-    public static final int EQ = Opcodes.IFEQ;
-
-    /**
-     * Constant for the {@link #ifCmp ifCmp} method.
-     */
-    public static final int NE = Opcodes.IFNE;
-
-    /**
-     * Constant for the {@link #ifCmp ifCmp} method.
-     */
-    public static final int LT = Opcodes.IFLT;
-
-    /**
-     * Constant for the {@link #ifCmp ifCmp} method.
-     */
-    public static final int GE = Opcodes.IFGE;
-
-    /**
-     * Constant for the {@link #ifCmp ifCmp} method.
-     */
-    public static final int GT = Opcodes.IFGT;
-
-    /**
-     * Constant for the {@link #ifCmp ifCmp} method.
-     */
-    public static final int LE = Opcodes.IFLE;
-
-    /**
-     * Access flags of the method visited by this adapter.
-     */
-    private final int access;
-
-    /**
-     * Return type of the method visited by this adapter.
-     */
-    private final Type returnType;
-
-    /**
-     * Argument types of the method visited by this adapter.
-     */
-    private final Type[] argumentTypes;
-
-    /**
-     * Types of the local variables of the method visited by this adapter.
-     */
-    private final List localTypes = new ArrayList();
-
-    /**
-     * Creates a new {@link GeneratorAdapter}.
-     * 
-     * @param mv the method visitor to which this adapter delegates calls.
-     * @param access the method's access flags (see {@link Opcodes}).
-     * @param name the method's name.
-     * @param desc the method's descriptor (see {@link Type Type}).
-     */
-    public GeneratorAdapter(
-        final MethodVisitor mv,
-        final int access,
-        final String name,
-        final String desc)
-    {
-        super(access, desc, mv);
-        this.access = access;
-        this.returnType = Type.getReturnType(desc);
-        this.argumentTypes = Type.getArgumentTypes(desc);
-    }
-
-    /**
-     * Creates a new {@link GeneratorAdapter}.
-     * 
-     * @param access access flags of the adapted method.
-     * @param method the adapted method.
-     * @param mv the method visitor to which this adapter delegates calls.
-     */
-    public GeneratorAdapter(
-        final int access,
-        final Method method,
-        final MethodVisitor mv)
-    {
-        super(access, method.getDescriptor(), mv);
-        this.access = access;
-        this.returnType = method.getReturnType();
-        this.argumentTypes = method.getArgumentTypes();
-    }
-
-    /**
-     * Creates a new {@link GeneratorAdapter}.
-     * 
-     * @param access access flags of the adapted method.
-     * @param method the adapted method.
-     * @param signature the signature of the adapted method (may be
-     *        <tt>null</tt>).
-     * @param exceptions the exceptions thrown by the adapted method (may be
-     *        <tt>null</tt>).
-     * @param cv the class visitor to which this adapter delegates calls.
-     */
-    public GeneratorAdapter(
-        final int access,
-        final Method method,
-        final String signature,
-        final Type[] exceptions,
-        final ClassVisitor cv)
-    {
-        this(access, method, cv.visitMethod(access,
-                method.getName(),
-                method.getDescriptor(),
-                signature,
-                getInternalNames(exceptions)));
-    }
-
-    /**
-     * Returns the internal names of the given types.
-     * 
-     * @param types a set of types.
-     * @return the internal names of the given types.
-     */
-    private static String[] getInternalNames(final Type[] types) {
-        if (types == null) {
-            return null;
-        }
-        String[] names = new String[types.length];
-        for (int i = 0; i < names.length; ++i) {
-            names[i] = types[i].getInternalName();
-        }
-        return names;
-    }
-
-    // ------------------------------------------------------------------------
-    // Instructions to push constants on the stack
-    // ------------------------------------------------------------------------
-
-    /**
-     * Generates the instruction to push the given value on the stack.
-     * 
-     * @param value the value to be pushed on the stack.
-     */
-    public void push(final boolean value) {
-        push(value ? 1 : 0);
-    }
-
-    /**
-     * Generates the instruction to push the given value on the stack.
-     * 
-     * @param value the value to be pushed on the stack.
-     */
-    public void push(final int value) {
-        if (value >= -1 && value <= 5) {
-            mv.visitInsn(Opcodes.ICONST_0 + value);
-        } else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {
-            mv.visitIntInsn(Opcodes.BIPUSH, value);
-        } else if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {
-            mv.visitIntInsn(Opcodes.SIPUSH, value);
-        } else {
-            mv.visitLdcInsn(new Integer(value));
-        }
-    }
-
-    /**
-     * Generates the instruction to push the given value on the stack.
-     * 
-     * @param value the value to be pushed on the stack.
-     */
-    public void push(final long value) {
-        if (value == 0L || value == 1L) {
-            mv.visitInsn(Opcodes.LCONST_0 + (int) value);
-        } else {
-            mv.visitLdcInsn(new Long(value));
-        }
-    }
-
-    /**
-     * Generates the instruction to push the given value on the stack.
-     * 
-     * @param value the value to be pushed on the stack.
-     */
-    public void push(final float value) {
-        int bits = Float.floatToIntBits(value);
-        if (bits == 0L || bits == 0x3f800000 || bits == 0x40000000) { // 0..2
-            mv.visitInsn(Opcodes.FCONST_0 + (int) value);
-        } else {
-            mv.visitLdcInsn(new Float(value));
-        }
-    }
-
-    /**
-     * Generates the instruction to push the given value on the stack.
-     * 
-     * @param value the value to be pushed on the stack.
-     */
-    public void push(final double value) {
-        long bits = Double.doubleToLongBits(value);
-        if (bits == 0L || bits == 0x3ff0000000000000L) { // +0.0d and 1.0d
-            mv.visitInsn(Opcodes.DCONST_0 + (int) value);
-        } else {
-            mv.visitLdcInsn(new Double(value));
-        }
-    }
-
-    /**
-     * Generates the instruction to push the given value on the stack.
-     * 
-     * @param value the value to be pushed on the stack. May be <tt>null</tt>.
-     */
-    public void push(final String value) {
-        if (value == null) {
-            mv.visitInsn(Opcodes.ACONST_NULL);
-        } else {
-            mv.visitLdcInsn(value);
-        }
-    }
-
-    /**
-     * Generates the instruction to push the given value on the stack.
-     * 
-     * @param value the value to be pushed on the stack.
-     */
-    public void push(final Type value) {
-        if (value == null) {
-            mv.visitInsn(Opcodes.ACONST_NULL);
-        } else {
-            switch (value.getSort()) {
-                case Type.BOOLEAN:
-                    mv.visitFieldInsn(Opcodes.GETSTATIC,
-                            "java/lang/Boolean",
-                            "TYPE",
-                            CLDESC);
-                    break;
-                case Type.CHAR:
-                    mv.visitFieldInsn(Opcodes.GETSTATIC,
-                            "java/lang/Character",
-                            "TYPE",
-                            CLDESC);
-                    break;
-                case Type.BYTE:
-                    mv.visitFieldInsn(Opcodes.GETSTATIC,
-                            "java/lang/Byte",
-                            "TYPE",
-                            CLDESC);
-                    break;
-                case Type.SHORT:
-                    mv.visitFieldInsn(Opcodes.GETSTATIC,
-                            "java/lang/Short",
-                            "TYPE",
-                            CLDESC);
-                    break;
-                case Type.INT:
-                    mv.visitFieldInsn(Opcodes.GETSTATIC,
-                            "java/lang/Integer",
-                            "TYPE",
-                            CLDESC);
-                    break;
-                case Type.FLOAT:
-                    mv.visitFieldInsn(Opcodes.GETSTATIC,
-                            "java/lang/Float",
-                            "TYPE",
-                            CLDESC);
-                    break;
-                case Type.LONG:
-                    mv.visitFieldInsn(Opcodes.GETSTATIC,
-                            "java/lang/Long",
-                            "TYPE",
-                            CLDESC);
-                    break;
-                case Type.DOUBLE:
-                    mv.visitFieldInsn(Opcodes.GETSTATIC,
-                            "java/lang/Double",
-                            "TYPE",
-                            CLDESC);
-                    break;
-                default:
-                    mv.visitLdcInsn(value);
-            }
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Instructions to load and store method arguments
-    // ------------------------------------------------------------------------
-
-    /**
-     * Returns the index of the given method argument in the frame's local
-     * variables array.
-     * 
-     * @param arg the index of a method argument.
-     * @return the index of the given method argument in the frame's local
-     *         variables array.
-     */
-    private int getArgIndex(final int arg) {
-        int index = (access & Opcodes.ACC_STATIC) == 0 ? 1 : 0;
-        for (int i = 0; i < arg; i++) {
-            index += argumentTypes[i].getSize();
-        }
-        return index;
-    }
-
-    /**
-     * Generates the instruction to push a local variable on the stack.
-     * 
-     * @param type the type of the local variable to be loaded.
-     * @param index an index in the frame's local variables array.
-     */
-    private void loadInsn(final Type type, final int index) {
-        mv.visitVarInsn(type.getOpcode(Opcodes.ILOAD), index);
-    }
-
-    /**
-     * Generates the instruction to store the top stack value in a local
-     * variable.
-     * 
-     * @param type the type of the local variable to be stored.
-     * @param index an index in the frame's local variables array.
-     */
-    private void storeInsn(final Type type, final int index) {
-        mv.visitVarInsn(type.getOpcode(Opcodes.ISTORE), index);
-    }
-
-    /**
-     * Generates the instruction to load 'this' on the stack.
-     */
-    public void loadThis() {
-        if ((access & Opcodes.ACC_STATIC) != 0) {
-            throw new IllegalStateException("no 'this' pointer within static method");
-        }
-        mv.visitVarInsn(Opcodes.ALOAD, 0);
-    }
-
-    /**
-     * Generates the instruction to load the given method argument on the stack.
-     * 
-     * @param arg the index of a method argument.
-     */
-    public void loadArg(final int arg) {
-        loadInsn(argumentTypes[arg], getArgIndex(arg));
-    }
-
-    /**
-     * Generates the instructions to load the given method arguments on the
-     * stack.
-     * 
-     * @param arg the index of the first method argument to be loaded.
-     * @param count the number of method arguments to be loaded.
-     */
-    public void loadArgs(final int arg, final int count) {
-        int index = getArgIndex(arg);
-        for (int i = 0; i < count; ++i) {
-            Type t = argumentTypes[arg + i];
-            loadInsn(t, index);
-            index += t.getSize();
-        }
-    }
-
-    /**
-     * Generates the instructions to load all the method arguments on the stack.
-     */
-    public void loadArgs() {
-        loadArgs(0, argumentTypes.length);
-    }
-
-    /**
-     * Generates the instructions to load all the method arguments on the stack,
-     * as a single object array.
-     */
-    public void loadArgArray() {
-        push(argumentTypes.length);
-        newArray(OBJECT_TYPE);
-        for (int i = 0; i < argumentTypes.length; i++) {
-            dup();
-            push(i);
-            loadArg(i);
-            box(argumentTypes[i]);
-            arrayStore(OBJECT_TYPE);
-        }
-    }
-
-    /**
-     * Generates the instruction to store the top stack value in the given
-     * method argument.
-     * 
-     * @param arg the index of a method argument.
-     */
-    public void storeArg(final int arg) {
-        storeInsn(argumentTypes[arg], getArgIndex(arg));
-    }
-
-    // ------------------------------------------------------------------------
-    // Instructions to load and store local variables
-    // ------------------------------------------------------------------------
-
-    /**
-     * Returns the type of the given local variable.
-     * 
-     * @param local a local variable identifier, as returned by
-     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.
-     * @return the type of the given local variable.
-     */
-    public Type getLocalType(final int local) {
-        return (Type) localTypes.get(local - firstLocal);
-    }
-
-    protected void setLocalType(final int local, final Type type) {
-        int index = local - firstLocal;
-        while (localTypes.size() < index + 1) {
-            localTypes.add(null);
-        }
-        localTypes.set(index, type);
-    }
-
-    /**
-     * Generates the instruction to load the given local variable on the stack.
-     * 
-     * @param local a local variable identifier, as returned by
-     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.
-     */
-    public void loadLocal(final int local) {
-        loadInsn(getLocalType(local), local);
-    }
-
-    /**
-     * Generates the instruction to load the given local variable on the stack.
-     * 
-     * @param local a local variable identifier, as returned by
-     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.
-     * @param type the type of this local variable.
-     */
-    public void loadLocal(final int local, final Type type) {
-        setLocalType(local, type);
-        loadInsn(type, local);
-    }
-
-    /**
-     * Generates the instruction to store the top stack value in the given local
-     * variable.
-     * 
-     * @param local a local variable identifier, as returned by
-     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.
-     */
-    public void storeLocal(final int local) {
-        storeInsn(getLocalType(local), local);
-    }
-
-    /**
-     * Generates the instruction to store the top stack value in the given local
-     * variable.
-     * 
-     * @param local a local variable identifier, as returned by
-     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.
-     * @param type the type of this local variable.
-     */
-    public void storeLocal(final int local, final Type type) {
-        setLocalType(local, type);
-        storeInsn(type, local);
-    }
-
-    /**
-     * Generates the instruction to load an element from an array.
-     * 
-     * @param type the type of the array element to be loaded.
-     */
-    public void arrayLoad(final Type type) {
-        mv.visitInsn(type.getOpcode(Opcodes.IALOAD));
-    }
-
-    /**
-     * Generates the instruction to store an element in an array.
-     * 
-     * @param type the type of the array element to be stored.
-     */
-    public void arrayStore(final Type type) {
-        mv.visitInsn(type.getOpcode(Opcodes.IASTORE));
-    }
-
-    // ------------------------------------------------------------------------
-    // Instructions to manage the stack
-    // ------------------------------------------------------------------------
-
-    /**
-     * Generates a POP instruction.
-     */
-    public void pop() {
-        mv.visitInsn(Opcodes.POP);
-    }
-
-    /**
-     * Generates a POP2 instruction.
-     */
-    public void pop2() {
-        mv.visitInsn(Opcodes.POP2);
-    }
-
-    /**
-     * Generates a DUP instruction.
-     */
-    public void dup() {
-        mv.visitInsn(Opcodes.DUP);
-    }
-
-    /**
-     * Generates a DUP2 instruction.
-     */
-    public void dup2() {
-        mv.visitInsn(Opcodes.DUP2);
-    }
-
-    /**
-     * Generates a DUP_X1 instruction.
-     */
-    public void dupX1() {
-        mv.visitInsn(Opcodes.DUP_X1);
-    }
-
-    /**
-     * Generates a DUP_X2 instruction.
-     */
-    public void dupX2() {
-        mv.visitInsn(Opcodes.DUP_X2);
-    }
-
-    /**
-     * Generates a DUP2_X1 instruction.
-     */
-    public void dup2X1() {
-        mv.visitInsn(Opcodes.DUP2_X1);
-    }
-
-    /**
-     * Generates a DUP2_X2 instruction.
-     */
-    public void dup2X2() {
-        mv.visitInsn(Opcodes.DUP2_X2);
-    }
-
-    /**
-     * Generates a SWAP instruction.
-     */
-    public void swap() {
-        mv.visitInsn(Opcodes.SWAP);
-    }
-
-    /**
-     * Generates the instructions to swap the top two stack values.
-     * 
-     * @param prev type of the top - 1 stack value.
-     * @param type type of the top stack value.
-     */
-    public void swap(final Type prev, final Type type) {
-        if (type.getSize() == 1) {
-            if (prev.getSize() == 1) {
-                swap(); // same as dupX1(), pop();
-            } else {
-                dupX2();
-                pop();
-            }
-        } else {
-            if (prev.getSize() == 1) {
-                dup2X1();
-                pop2();
-            } else {
-                dup2X2();
-                pop2();
-            }
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Instructions to do mathematical and logical operations
-    // ------------------------------------------------------------------------
-
-    /**
-     * Generates the instruction to do the specified mathematical or logical
-     * operation.
-     * 
-     * @param op a mathematical or logical operation. Must be one of ADD, SUB,
-     *        MUL, DIV, REM, NEG, SHL, SHR, USHR, AND, OR, XOR.
-     * @param type the type of the operand(s) for this operation.
-     */
-    public void math(final int op, final Type type) {
-        mv.visitInsn(type.getOpcode(op));
-    }
-
-    /**
-     * Generates the instructions to compute the bitwise negation of the top
-     * stack value.
-     */
-    public void not() {
-        mv.visitInsn(Opcodes.ICONST_1);
-        mv.visitInsn(Opcodes.IXOR);
-    }
-
-    /**
-     * Generates the instruction to increment the given local variable.
-     * 
-     * @param local the local variable to be incremented.
-     * @param amount the amount by which the local variable must be incremented.
-     */
-    public void iinc(final int local, final int amount) {
-        mv.visitIincInsn(local, amount);
-    }
-
-    /**
-     * Generates the instructions to cast a numerical value from one type to
-     * another.
-     * 
-     * @param from the type of the top stack value
-     * @param to the type into which this value must be cast.
-     */
-    public void cast(final Type from, final Type to) {
-        if (from != to) {
-            if (from == Type.DOUBLE_TYPE) {
-                if (to == Type.FLOAT_TYPE) {
-                    mv.visitInsn(Opcodes.D2F);
-                } else if (to == Type.LONG_TYPE) {
-                    mv.visitInsn(Opcodes.D2L);
-                } else {
-                    mv.visitInsn(Opcodes.D2I);
-                    cast(Type.INT_TYPE, to);
-                }
-            } else if (from == Type.FLOAT_TYPE) {
-                if (to == Type.DOUBLE_TYPE) {
-                    mv.visitInsn(Opcodes.F2D);
-                } else if (to == Type.LONG_TYPE) {
-                    mv.visitInsn(Opcodes.F2L);
-                } else {
-                    mv.visitInsn(Opcodes.F2I);
-                    cast(Type.INT_TYPE, to);
-                }
-            } else if (from == Type.LONG_TYPE) {
-                if (to == Type.DOUBLE_TYPE) {
-                    mv.visitInsn(Opcodes.L2D);
-                } else if (to == Type.FLOAT_TYPE) {
-                    mv.visitInsn(Opcodes.L2F);
-                } else {
-                    mv.visitInsn(Opcodes.L2I);
-                    cast(Type.INT_TYPE, to);
-                }
-            } else {
-                if (to == Type.BYTE_TYPE) {
-                    mv.visitInsn(Opcodes.I2B);
-                } else if (to == Type.CHAR_TYPE) {
-                    mv.visitInsn(Opcodes.I2C);
-                } else if (to == Type.DOUBLE_TYPE) {
-                    mv.visitInsn(Opcodes.I2D);
-                } else if (to == Type.FLOAT_TYPE) {
-                    mv.visitInsn(Opcodes.I2F);
-                } else if (to == Type.LONG_TYPE) {
-                    mv.visitInsn(Opcodes.I2L);
-                } else if (to == Type.SHORT_TYPE) {
-                    mv.visitInsn(Opcodes.I2S);
-                }
-            }
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Instructions to do boxing and unboxing operations
-    // ------------------------------------------------------------------------
-
-    private static Type getBoxedType(final Type type) {
-        switch (type.getSort()) {
-            case Type.BYTE:
-                return BYTE_TYPE;
-            case Type.BOOLEAN:
-                return BOOLEAN_TYPE;
-            case Type.SHORT:
-                return SHORT_TYPE;
-            case Type.CHAR:
-                return CHARACTER_TYPE;
-            case Type.INT:
-                return INTEGER_TYPE;
-            case Type.FLOAT:
-                return FLOAT_TYPE;
-            case Type.LONG:
-                return LONG_TYPE;
-            case Type.DOUBLE:
-                return DOUBLE_TYPE;
-        }
-        return type;
-    }
-    
-    /**
-     * Generates the instructions to box the top stack value. This value is
-     * replaced by its boxed equivalent on top of the stack.
-     * 
-     * @param type the type of the top stack value.
-     */
-    public void box(final Type type) {
-        if (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) {
-            return;
-        }
-        if (type == Type.VOID_TYPE) {
-            push((String) null);
-        } else {
-            Type boxed = getBoxedType(type);
-            newInstance(boxed);
-            if (type.getSize() == 2) {
-                // Pp -> Ppo -> oPpo -> ooPpo -> ooPp -> o
-                dupX2();
-                dupX2();
-                pop();
-            } else {
-                // p -> po -> opo -> oop -> o
-                dupX1();
-                swap();
-            }
-            invokeConstructor(boxed, new Method("<init>",
-                    Type.VOID_TYPE,
-                    new Type[] { type }));
-        }
-    }
-
-    /**
-     * Generates the instructions to box the top stack value using Java 5's
-     * valueOf() method. This value is replaced by its boxed equivalent on top
-     * of the stack.
-     * 
-     * @param type the type of the top stack value.
-     * @author Prashant Deva
-     */
-    public void valueOf(final Type type) {
-        if (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) {
-            return;
-        }
-        if (type == Type.VOID_TYPE) {
-            push((String) null);
-        } else {
-            Type boxed = getBoxedType(type);
-            invokeStatic(boxed, new Method("valueOf",
-                    boxed,
-                    new Type[] { type }));
-        }
-    }
-    
-    /**
-     * Generates the instructions to unbox the top stack value. This value is
-     * replaced by its unboxed equivalent on top of the stack.
-     * 
-     * @param type the type of the top stack value.
-     */
-    public void unbox(final Type type) {
-        Type t = NUMBER_TYPE;
-        Method sig = null;
-        switch (type.getSort()) {
-            case Type.VOID:
-                return;
-            case Type.CHAR:
-                t = CHARACTER_TYPE;
-                sig = CHAR_VALUE;
-                break;
-            case Type.BOOLEAN:
-                t = BOOLEAN_TYPE;
-                sig = BOOLEAN_VALUE;
-                break;
-            case Type.DOUBLE:
-                sig = DOUBLE_VALUE;
-                break;
-            case Type.FLOAT:
-                sig = FLOAT_VALUE;
-                break;
-            case Type.LONG:
-                sig = LONG_VALUE;
-                break;
-            case Type.INT:
-            case Type.SHORT:
-            case Type.BYTE:
-                sig = INT_VALUE;
-        }
-        if (sig == null) {
-            checkCast(type);
-        } else {
-            checkCast(t);
-            invokeVirtual(t, sig);
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Instructions to jump to other instructions
-    // ------------------------------------------------------------------------
-
-    /**
-     * Creates a new {@link Label}.
-     * 
-     * @return a new {@link Label}.
-     */
-    public Label newLabel() {
-        return new Label();
-    }
-
-    /**
-     * Marks the current code position with the given label.
-     * 
-     * @param label a label.
-     */
-    public void mark(final Label label) {
-        mv.visitLabel(label);
-    }
-
-    /**
-     * Marks the current code position with a new label.
-     * 
-     * @return the label that was created to mark the current code position.
-     */
-    public Label mark() {
-        Label label = new Label();
-        mv.visitLabel(label);
-        return label;
-    }
-
-    /**
-     * Generates the instructions to jump to a label based on the comparison of
-     * the top two stack values.
-     * 
-     * @param type the type of the top two stack values.
-     * @param mode how these values must be compared. One of EQ, NE, LT, GE, GT,
-     *        LE.
-     * @param label where to jump if the comparison result is <tt>true</tt>.
-     */
-    public void ifCmp(final Type type, final int mode, final Label label) {
-        switch (type.getSort()) {
-            case Type.LONG:
-                mv.visitInsn(Opcodes.LCMP);
-                break;
-            case Type.DOUBLE:
-                mv.visitInsn(mode == GE || mode == GT ? Opcodes.DCMPG : Opcodes.DCMPL);
-                break;
-            case Type.FLOAT:
-                mv.visitInsn(mode == GE || mode == GT ? Opcodes.FCMPG : Opcodes.FCMPL);
-                break;
-            case Type.ARRAY:
-            case Type.OBJECT:
-                switch (mode) {
-                    case EQ:
-                        mv.visitJumpInsn(Opcodes.IF_ACMPEQ, label);
-                        return;
-                    case NE:
-                        mv.visitJumpInsn(Opcodes.IF_ACMPNE, label);
-                        return;
-                }
-                throw new IllegalArgumentException("Bad comparison for type "
-                        + type);
-            default:
-                int intOp = -1;
-                switch (mode) {
-                    case EQ:
-                        intOp = Opcodes.IF_ICMPEQ;
-                        break;
-                    case NE:
-                        intOp = Opcodes.IF_ICMPNE;
-                        break;
-                    case GE:
-                        intOp = Opcodes.IF_ICMPGE;
-                        break;
-                    case LT:
-                        intOp = Opcodes.IF_ICMPLT;
-                        break;
-                    case LE:
-                        intOp = Opcodes.IF_ICMPLE;
-                        break;
-                    case GT:
-                        intOp = Opcodes.IF_ICMPGT;
-                        break;
-                }
-                mv.visitJumpInsn(intOp, label);
-                return;
-        }
-        mv.visitJumpInsn(mode, label);
-    }
-
-    /**
-     * Generates the instructions to jump to a label based on the comparison of
-     * the top two integer stack values.
-     * 
-     * @param mode how these values must be compared. One of EQ, NE, LT, GE, GT,
-     *        LE.
-     * @param label where to jump if the comparison result is <tt>true</tt>.
-     */
-    public void ifICmp(final int mode, final Label label) {
-        ifCmp(Type.INT_TYPE, mode, label);
-    }
-
-    /**
-     * Generates the instructions to jump to a label based on the comparison of
-     * the top integer stack value with zero.
-     * 
-     * @param mode how these values must be compared. One of EQ, NE, LT, GE, GT,
-     *        LE.
-     * @param label where to jump if the comparison result is <tt>true</tt>.
-     */
-    public void ifZCmp(final int mode, final Label label) {
-        mv.visitJumpInsn(mode, label);
-    }
-
-    /**
-     * Generates the instruction to jump to the given label if the top stack
-     * value is null.
-     * 
-     * @param label where to jump if the condition is <tt>true</tt>.
-     */
-    public void ifNull(final Label label) {
-        mv.visitJumpInsn(Opcodes.IFNULL, label);
-    }
-
-    /**
-     * Generates the instruction to jump to the given label if the top stack
-     * value is not null.
-     * 
-     * @param label where to jump if the condition is <tt>true</tt>.
-     */
-    public void ifNonNull(final Label label) {
-        mv.visitJumpInsn(Opcodes.IFNONNULL, label);
-    }
-
-    /**
-     * Generates the instruction to jump to the given label.
-     * 
-     * @param label where to jump if the condition is <tt>true</tt>.
-     */
-    public void goTo(final Label label) {
-        mv.visitJumpInsn(Opcodes.GOTO, label);
-    }
-
-    /**
-     * Generates a RET instruction.
-     * 
-     * @param local a local variable identifier, as returned by
-     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.
-     */
-    public void ret(final int local) {
-        mv.visitVarInsn(Opcodes.RET, local);
-    }
-
-    /**
-     * Generates the instructions for a switch statement.
-     * 
-     * @param keys the switch case keys.
-     * @param generator a generator to generate the code for the switch cases.
-     */
-    public void tableSwitch(
-        final int[] keys,
-        final TableSwitchGenerator generator)
-    {
-        float density;
-        if (keys.length == 0) {
-            density = 0;
-        } else {
-            density = (float) keys.length
-                    / (keys[keys.length - 1] - keys[0] + 1);
-        }
-        tableSwitch(keys, generator, density >= 0.5f);
-    }
-
-    /**
-     * Generates the instructions for a switch statement.
-     * 
-     * @param keys the switch case keys.
-     * @param generator a generator to generate the code for the switch cases.
-     * @param useTable <tt>true</tt> to use a TABLESWITCH instruction, or
-     *        <tt>false</tt> to use a LOOKUPSWITCH instruction.
-     */
-    public void tableSwitch(
-        final int[] keys,
-        final TableSwitchGenerator generator,
-        final boolean useTable)
-    {
-        for (int i = 1; i < keys.length; ++i) {
-            if (keys[i] < keys[i - 1]) {
-                throw new IllegalArgumentException("keys must be sorted ascending");
-            }
-        }
-        Label def = newLabel();
-        Label end = newLabel();
-        if (keys.length > 0) {
-            int len = keys.length;
-            int min = keys[0];
-            int max = keys[len - 1];
-            int range = max - min + 1;
-            if (useTable) {
-                Label[] labels = new Label[range];
-                Arrays.fill(labels, def);
-                for (int i = 0; i < len; ++i) {
-                    labels[keys[i] - min] = newLabel();
-                }
-                mv.visitTableSwitchInsn(min, max, def, labels);
-                for (int i = 0; i < range; ++i) {
-                    Label label = labels[i];
-                    if (label != def) {
-                        mark(label);
-                        generator.generateCase(i + min, end);
-                    }
-                }
-            } else {
-                Label[] labels = new Label[len];
-                for (int i = 0; i < len; ++i) {
-                    labels[i] = newLabel();
-                }
-                mv.visitLookupSwitchInsn(def, keys, labels);
-                for (int i = 0; i < len; ++i) {
-                    mark(labels[i]);
-                    generator.generateCase(keys[i], end);
-                }
-            }
-        }
-        mark(def);
-        generator.generateDefault();
-        mark(end);
-    }
-
-    /**
-     * Generates the instruction to return the top stack value to the caller.
-     */
-    public void returnValue() {
-        mv.visitInsn(returnType.getOpcode(Opcodes.IRETURN));
-    }
-
-    // ------------------------------------------------------------------------
-    // Instructions to load and store fields
-    // ------------------------------------------------------------------------
-
-    /**
-     * Generates a get field or set field instruction.
-     * 
-     * @param opcode the instruction's opcode.
-     * @param ownerType the class in which the field is defined.
-     * @param name the name of the field.
-     * @param fieldType the type of the field.
-     */
-    private void fieldInsn(
-        final int opcode,
-        final Type ownerType,
-        final String name,
-        final Type fieldType)
-    {
-        mv.visitFieldInsn(opcode,
-                ownerType.getInternalName(),
-                name,
-                fieldType.getDescriptor());
-    }
-
-    /**
-     * Generates the instruction to push the value of a static field on the
-     * stack.
-     * 
-     * @param owner the class in which the field is defined.
-     * @param name the name of the field.
-     * @param type the type of the field.
-     */
-    public void getStatic(final Type owner, final String name, final Type type)
-    {
-        fieldInsn(Opcodes.GETSTATIC, owner, name, type);
-    }
-
-    /**
-     * Generates the instruction to store the top stack value in a static field.
-     * 
-     * @param owner the class in which the field is defined.
-     * @param name the name of the field.
-     * @param type the type of the field.
-     */
-    public void putStatic(final Type owner, final String name, final Type type)
-    {
-        fieldInsn(Opcodes.PUTSTATIC, owner, name, type);
-    }
-
-    /**
-     * Generates the instruction to push the value of a non static field on the
-     * stack.
-     * 
-     * @param owner the class in which the field is defined.
-     * @param name the name of the field.
-     * @param type the type of the field.
-     */
-    public void getField(final Type owner, final String name, final Type type) {
-        fieldInsn(Opcodes.GETFIELD, owner, name, type);
-    }
-
-    /**
-     * Generates the instruction to store the top stack value in a non static
-     * field.
-     * 
-     * @param owner the class in which the field is defined.
-     * @param name the name of the field.
-     * @param type the type of the field.
-     */
-    public void putField(final Type owner, final String name, final Type type) {
-        fieldInsn(Opcodes.PUTFIELD, owner, name, type);
-    }
-
-    // ------------------------------------------------------------------------
-    // Instructions to invoke methods
-    // ------------------------------------------------------------------------
-
-    /**
-     * Generates an invoke method instruction.
-     * 
-     * @param opcode the instruction's opcode.
-     * @param type the class in which the method is defined.
-     * @param method the method to be invoked.
-     */
-    private void invokeInsn(
-        final int opcode,
-        final Type type,
-        final Method method)
-    {
-        String owner = type.getSort() == Type.ARRAY
-                ? type.getDescriptor()
-                : type.getInternalName();
-        mv.visitMethodInsn(opcode,
-                owner,
-                method.getName(),
-                method.getDescriptor());
-    }
-
-    /**
-     * Generates the instruction to invoke a normal method.
-     * 
-     * @param owner the class in which the method is defined.
-     * @param method the method to be invoked.
-     */
-    public void invokeVirtual(final Type owner, final Method method) {
-        invokeInsn(Opcodes.INVOKEVIRTUAL, owner, method);
-    }
-
-    /**
-     * Generates the instruction to invoke a constructor.
-     * 
-     * @param type the class in which the constructor is defined.
-     * @param method the constructor to be invoked.
-     */
-    public void invokeConstructor(final Type type, final Method method) {
-        invokeInsn(Opcodes.INVOKESPECIAL, type, method);
-    }
-
-    /**
-     * Generates the instruction to invoke a static method.
-     * 
-     * @param owner the class in which the method is defined.
-     * @param method the method to be invoked.
-     */
-    public void invokeStatic(final Type owner, final Method method) {
-        invokeInsn(Opcodes.INVOKESTATIC, owner, method);
-    }
-
-    /**
-     * Generates the instruction to invoke an interface method.
-     * 
-     * @param owner the class in which the method is defined.
-     * @param method the method to be invoked.
-     */
-    public void invokeInterface(final Type owner, final Method method) {
-        invokeInsn(Opcodes.INVOKEINTERFACE, owner, method);
-    }
-    
-    /**
-     * Generates the instruction to invoke a dynamic method.
-     * 
-     * @param method the method to be invoked.
-     */
-    public void invokeDynamic(final Method method) {
-        invokeInsn(Opcodes.INVOKEDYNAMIC,
-                Type.getObjectType(Opcodes.INVOKEDYNAMIC_OWNER),
-                method);
-    }
-
-    // ------------------------------------------------------------------------
-    // Instructions to create objects and arrays
-    // ------------------------------------------------------------------------
-
-    /**
-     * Generates a type dependent instruction.
-     * 
-     * @param opcode the instruction's opcode.
-     * @param type the instruction's operand.
-     */
-    private void typeInsn(final int opcode, final Type type) {
-        mv.visitTypeInsn(opcode, type.getInternalName());
-    }
-
-    /**
-     * Generates the instruction to create a new object.
-     * 
-     * @param type the class of the object to be created.
-     */
-    public void newInstance(final Type type) {
-        typeInsn(Opcodes.NEW, type);
-    }
-
-    /**
-     * Generates the instruction to create a new array.
-     * 
-     * @param type the type of the array elements.
-     */
-    public void newArray(final Type type) {
-        int typ;
-        switch (type.getSort()) {
-            case Type.BOOLEAN:
-                typ = Opcodes.T_BOOLEAN;
-                break;
-            case Type.CHAR:
-                typ = Opcodes.T_CHAR;
-                break;
-            case Type.BYTE:
-                typ = Opcodes.T_BYTE;
-                break;
-            case Type.SHORT:
-                typ = Opcodes.T_SHORT;
-                break;
-            case Type.INT:
-                typ = Opcodes.T_INT;
-                break;
-            case Type.FLOAT:
-                typ = Opcodes.T_FLOAT;
-                break;
-            case Type.LONG:
-                typ = Opcodes.T_LONG;
-                break;
-            case Type.DOUBLE:
-                typ = Opcodes.T_DOUBLE;
-                break;
-            default:
-                typeInsn(Opcodes.ANEWARRAY, type);
-                return;
-        }
-        mv.visitIntInsn(Opcodes.NEWARRAY, typ);
-    }
-
-    // ------------------------------------------------------------------------
-    // Miscelaneous instructions
-    // ------------------------------------------------------------------------
-
-    /**
-     * Generates the instruction to compute the length of an array.
-     */
-    public void arrayLength() {
-        mv.visitInsn(Opcodes.ARRAYLENGTH);
-    }
-
-    /**
-     * Generates the instruction to throw an exception.
-     */
-    public void throwException() {
-        mv.visitInsn(Opcodes.ATHROW);
-    }
-
-    /**
-     * Generates the instructions to create and throw an exception. The
-     * exception class must have a constructor with a single String argument.
-     * 
-     * @param type the class of the exception to be thrown.
-     * @param msg the detailed message of the exception.
-     */
-    public void throwException(final Type type, final String msg) {
-        newInstance(type);
-        dup();
-        push(msg);
-        invokeConstructor(type, Method.getMethod("void <init> (String)"));
-        throwException();
-    }
-
-    /**
-     * Generates the instruction to check that the top stack value is of the
-     * given type.
-     * 
-     * @param type a class or interface type.
-     */
-    public void checkCast(final Type type) {
-        if (!type.equals(OBJECT_TYPE)) {
-            typeInsn(Opcodes.CHECKCAST, type);
-        }
-    }
-
-    /**
-     * Generates the instruction to test if the top stack value is of the given
-     * type.
-     * 
-     * @param type a class or interface type.
-     */
-    public void instanceOf(final Type type) {
-        typeInsn(Opcodes.INSTANCEOF, type);
-    }
-
-    /**
-     * Generates the instruction to get the monitor of the top stack value.
-     */
-    public void monitorEnter() {
-        mv.visitInsn(Opcodes.MONITORENTER);
-    }
-
-    /**
-     * Generates the instruction to release the monitor of the top stack value.
-     */
-    public void monitorExit() {
-        mv.visitInsn(Opcodes.MONITOREXIT);
-    }
-
-    // ------------------------------------------------------------------------
-    // Non instructions
-    // ------------------------------------------------------------------------
-
-    /**
-     * Marks the end of the visited method.
-     */
-    public void endMethod() {
-        if ((access & Opcodes.ACC_ABSTRACT) == 0) {
-            mv.visitMaxs(0, 0);
-        }
-        mv.visitEnd();
-    }
-
-    /**
-     * Marks the start of an exception handler.
-     * 
-     * @param start beginning of the exception handler's scope (inclusive).
-     * @param end end of the exception handler's scope (exclusive).
-     * @param exception internal name of the type of exceptions handled by the
-     *        handler.
-     */
-    public void catchException(
-        final Label start,
-        final Label end,
-        final Type exception)
-    {
-        if (exception == null) {
-            mv.visitTryCatchBlock(start, end, mark(), null);            
-        } else {
-            mv.visitTryCatchBlock(start, end, mark(), exception.getInternalName());
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/InstructionAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/InstructionAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/InstructionAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/InstructionAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,1079 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2005 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodAdapter;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-
-public class InstructionAdapter extends MethodAdapter {
-
-    public final static Type OBJECT_TYPE = Type.getType("Ljava/lang/Object;");
-
-    public InstructionAdapter(MethodVisitor mv) {
-        super(mv);
-    }
-
-    public void visitInsn(final int opcode) {
-        switch (opcode) {
-            case Opcodes.NOP:
-                nop();
-                break;
-            case Opcodes.ACONST_NULL:
-                aconst(null);
-                break;
-            case Opcodes.ICONST_M1:
-            case Opcodes.ICONST_0:
-            case Opcodes.ICONST_1:
-            case Opcodes.ICONST_2:
-            case Opcodes.ICONST_3:
-            case Opcodes.ICONST_4:
-            case Opcodes.ICONST_5:
-                iconst(opcode - Opcodes.ICONST_0);
-                break;
-            case Opcodes.LCONST_0:
-            case Opcodes.LCONST_1:
-                lconst(opcode - Opcodes.LCONST_0);
-                break;
-            case Opcodes.FCONST_0:
-            case Opcodes.FCONST_1:
-            case Opcodes.FCONST_2:
-                fconst(opcode - Opcodes.FCONST_0);
-                break;
-            case Opcodes.DCONST_0:
-            case Opcodes.DCONST_1:
-                dconst(opcode - Opcodes.DCONST_0);
-                break;
-            case Opcodes.IALOAD:
-                aload(Type.INT_TYPE);
-                break;
-            case Opcodes.LALOAD:
-                aload(Type.LONG_TYPE);
-                break;
-            case Opcodes.FALOAD:
-                aload(Type.FLOAT_TYPE);
-                break;
-            case Opcodes.DALOAD:
-                aload(Type.DOUBLE_TYPE);
-                break;
-            case Opcodes.AALOAD:
-                aload(OBJECT_TYPE);
-                break;
-            case Opcodes.BALOAD:
-                aload(Type.BYTE_TYPE);
-                break;
-            case Opcodes.CALOAD:
-                aload(Type.CHAR_TYPE);
-                break;
-            case Opcodes.SALOAD:
-                aload(Type.SHORT_TYPE);
-                break;
-            case Opcodes.IASTORE:
-                astore(Type.INT_TYPE);
-                break;
-            case Opcodes.LASTORE:
-                astore(Type.LONG_TYPE);
-                break;
-            case Opcodes.FASTORE:
-                astore(Type.FLOAT_TYPE);
-                break;
-            case Opcodes.DASTORE:
-                astore(Type.DOUBLE_TYPE);
-                break;
-            case Opcodes.AASTORE:
-                astore(OBJECT_TYPE);
-                break;
-            case Opcodes.BASTORE:
-                astore(Type.BYTE_TYPE);
-                break;
-            case Opcodes.CASTORE:
-                astore(Type.CHAR_TYPE);
-                break;
-            case Opcodes.SASTORE:
-                astore(Type.SHORT_TYPE);
-                break;
-            case Opcodes.POP:
-                pop();
-                break;
-            case Opcodes.POP2:
-                pop2();
-                break;
-            case Opcodes.DUP:
-                dup();
-                break;
-            case Opcodes.DUP_X1:
-                dupX1();
-                break;
-            case Opcodes.DUP_X2:
-                dupX2();
-                break;
-            case Opcodes.DUP2:
-                dup2();
-                break;
-            case Opcodes.DUP2_X1:
-                dup2X1();
-                break;
-            case Opcodes.DUP2_X2:
-                dup2X2();
-                break;
-            case Opcodes.SWAP:
-                swap();
-                break;
-            case Opcodes.IADD:
-                add(Type.INT_TYPE);
-                break;
-            case Opcodes.LADD:
-                add(Type.LONG_TYPE);
-                break;
-            case Opcodes.FADD:
-                add(Type.FLOAT_TYPE);
-                break;
-            case Opcodes.DADD:
-                add(Type.DOUBLE_TYPE);
-                break;
-            case Opcodes.ISUB:
-                sub(Type.INT_TYPE);
-                break;
-            case Opcodes.LSUB:
-                sub(Type.LONG_TYPE);
-                break;
-            case Opcodes.FSUB:
-                sub(Type.FLOAT_TYPE);
-                break;
-            case Opcodes.DSUB:
-                sub(Type.DOUBLE_TYPE);
-                break;
-            case Opcodes.IMUL:
-                mul(Type.INT_TYPE);
-                break;
-            case Opcodes.LMUL:
-                mul(Type.LONG_TYPE);
-                break;
-            case Opcodes.FMUL:
-                mul(Type.FLOAT_TYPE);
-                break;
-            case Opcodes.DMUL:
-                mul(Type.DOUBLE_TYPE);
-                break;
-            case Opcodes.IDIV:
-                div(Type.INT_TYPE);
-                break;
-            case Opcodes.LDIV:
-                div(Type.LONG_TYPE);
-                break;
-            case Opcodes.FDIV:
-                div(Type.FLOAT_TYPE);
-                break;
-            case Opcodes.DDIV:
-                div(Type.DOUBLE_TYPE);
-                break;
-            case Opcodes.IREM:
-                rem(Type.INT_TYPE);
-                break;
-            case Opcodes.LREM:
-                rem(Type.LONG_TYPE);
-                break;
-            case Opcodes.FREM:
-                rem(Type.FLOAT_TYPE);
-                break;
-            case Opcodes.DREM:
-                rem(Type.DOUBLE_TYPE);
-                break;
-            case Opcodes.INEG:
-                neg(Type.INT_TYPE);
-                break;
-            case Opcodes.LNEG:
-                neg(Type.LONG_TYPE);
-                break;
-            case Opcodes.FNEG:
-                neg(Type.FLOAT_TYPE);
-                break;
-            case Opcodes.DNEG:
-                neg(Type.DOUBLE_TYPE);
-                break;
-            case Opcodes.ISHL:
-                shl(Type.INT_TYPE);
-                break;
-            case Opcodes.LSHL:
-                shl(Type.LONG_TYPE);
-                break;
-            case Opcodes.ISHR:
-                shr(Type.INT_TYPE);
-                break;
-            case Opcodes.LSHR:
-                shr(Type.LONG_TYPE);
-                break;
-            case Opcodes.IUSHR:
-                ushr(Type.INT_TYPE);
-                break;
-            case Opcodes.LUSHR:
-                ushr(Type.LONG_TYPE);
-                break;
-            case Opcodes.IAND:
-                and(Type.INT_TYPE);
-                break;
-            case Opcodes.LAND:
-                and(Type.LONG_TYPE);
-                break;
-            case Opcodes.IOR:
-                or(Type.INT_TYPE);
-                break;
-            case Opcodes.LOR:
-                or(Type.LONG_TYPE);
-                break;
-            case Opcodes.IXOR:
-                xor(Type.INT_TYPE);
-                break;
-            case Opcodes.LXOR:
-                xor(Type.LONG_TYPE);
-                break;
-            case Opcodes.I2L:
-                cast(Type.INT_TYPE, Type.LONG_TYPE);
-                break;
-            case Opcodes.I2F:
-                cast(Type.INT_TYPE, Type.FLOAT_TYPE);
-                break;
-            case Opcodes.I2D:
-                cast(Type.INT_TYPE, Type.DOUBLE_TYPE);
-                break;
-            case Opcodes.L2I:
-                cast(Type.LONG_TYPE, Type.INT_TYPE);
-                break;
-            case Opcodes.L2F:
-                cast(Type.LONG_TYPE, Type.FLOAT_TYPE);
-                break;
-            case Opcodes.L2D:
-                cast(Type.LONG_TYPE, Type.DOUBLE_TYPE);
-                break;
-            case Opcodes.F2I:
-                cast(Type.FLOAT_TYPE, Type.INT_TYPE);
-                break;
-            case Opcodes.F2L:
-                cast(Type.FLOAT_TYPE, Type.LONG_TYPE);
-                break;
-            case Opcodes.F2D:
-                cast(Type.FLOAT_TYPE, Type.DOUBLE_TYPE);
-                break;
-            case Opcodes.D2I:
-                cast(Type.DOUBLE_TYPE, Type.INT_TYPE);
-                break;
-            case Opcodes.D2L:
-                cast(Type.DOUBLE_TYPE, Type.LONG_TYPE);
-                break;
-            case Opcodes.D2F:
-                cast(Type.DOUBLE_TYPE, Type.FLOAT_TYPE);
-                break;
-            case Opcodes.I2B:
-                cast(Type.INT_TYPE, Type.BYTE_TYPE);
-                break;
-            case Opcodes.I2C:
-                cast(Type.INT_TYPE, Type.CHAR_TYPE);
-                break;
-            case Opcodes.I2S:
-                cast(Type.INT_TYPE, Type.SHORT_TYPE);
-                break;
-            case Opcodes.LCMP:
-                lcmp();
-                break;
-            case Opcodes.FCMPL:
-                cmpl(Type.FLOAT_TYPE);
-                break;
-            case Opcodes.FCMPG:
-                cmpg(Type.FLOAT_TYPE);
-                break;
-            case Opcodes.DCMPL:
-                cmpl(Type.DOUBLE_TYPE);
-                break;
-            case Opcodes.DCMPG:
-                cmpg(Type.DOUBLE_TYPE);
-                break;
-            case Opcodes.IRETURN:
-                areturn(Type.INT_TYPE);
-                break;
-            case Opcodes.LRETURN:
-                areturn(Type.LONG_TYPE);
-                break;
-            case Opcodes.FRETURN:
-                areturn(Type.FLOAT_TYPE);
-                break;
-            case Opcodes.DRETURN:
-                areturn(Type.DOUBLE_TYPE);
-                break;
-            case Opcodes.ARETURN:
-                areturn(OBJECT_TYPE);
-                break;
-            case Opcodes.RETURN:
-                areturn(Type.VOID_TYPE);
-                break;
-            case Opcodes.ARRAYLENGTH:
-                arraylength();
-                break;
-            case Opcodes.ATHROW:
-                athrow();
-                break;
-            case Opcodes.MONITORENTER:
-                monitorenter();
-                break;
-            case Opcodes.MONITOREXIT:
-                monitorexit();
-                break;
-            default:
-                throw new IllegalArgumentException();
-        }
-    }
-
-    public void visitIntInsn(final int opcode, final int operand) {
-        switch (opcode) {
-            case Opcodes.BIPUSH:
-                iconst(operand);
-                break;
-            case Opcodes.SIPUSH:
-                iconst(operand);
-                break;
-            case Opcodes.NEWARRAY:
-                switch (operand) {
-                    case Opcodes.T_BOOLEAN:
-                        newarray(Type.BOOLEAN_TYPE);
-                        break;
-                    case Opcodes.T_CHAR:
-                        newarray(Type.CHAR_TYPE);
-                        break;
-                    case Opcodes.T_BYTE:
-                        newarray(Type.BYTE_TYPE);
-                        break;
-                    case Opcodes.T_SHORT:
-                        newarray(Type.SHORT_TYPE);
-                        break;
-                    case Opcodes.T_INT:
-                        newarray(Type.INT_TYPE);
-                        break;
-                    case Opcodes.T_FLOAT:
-                        newarray(Type.FLOAT_TYPE);
-                        break;
-                    case Opcodes.T_LONG:
-                        newarray(Type.LONG_TYPE);
-                        break;
-                    case Opcodes.T_DOUBLE:
-                        newarray(Type.DOUBLE_TYPE);
-                        break;
-                    default:
-                        throw new IllegalArgumentException();
-                }
-                break;
-            default:
-                throw new IllegalArgumentException();
-        }
-    }
-
-    public void visitVarInsn(final int opcode, final int var) {
-        switch (opcode) {
-            case Opcodes.ILOAD:
-                load(var, Type.INT_TYPE);
-                break;
-            case Opcodes.LLOAD:
-                load(var, Type.LONG_TYPE);
-                break;
-            case Opcodes.FLOAD:
-                load(var, Type.FLOAT_TYPE);
-                break;
-            case Opcodes.DLOAD:
-                load(var, Type.DOUBLE_TYPE);
-                break;
-            case Opcodes.ALOAD:
-                load(var, OBJECT_TYPE);
-                break;
-            case Opcodes.ISTORE:
-                store(var, Type.INT_TYPE);
-                break;
-            case Opcodes.LSTORE:
-                store(var, Type.LONG_TYPE);
-                break;
-            case Opcodes.FSTORE:
-                store(var, Type.FLOAT_TYPE);
-                break;
-            case Opcodes.DSTORE:
-                store(var, Type.DOUBLE_TYPE);
-                break;
-            case Opcodes.ASTORE:
-                store(var, OBJECT_TYPE);
-                break;
-            case Opcodes.RET:
-                ret(var);
-                break;
-            default:
-                throw new IllegalArgumentException();
-        }
-    }
-
-    public void visitTypeInsn(final int opcode, final String type) {
-        Type t = Type.getObjectType(type);
-        switch (opcode) {
-            case Opcodes.NEW:
-                anew(t);
-                break;
-            case Opcodes.ANEWARRAY:
-                newarray(t);
-                break;
-            case Opcodes.CHECKCAST:
-                checkcast(t);
-                break;
-            case Opcodes.INSTANCEOF:
-                instanceOf(t);
-                break;
-            default:
-                throw new IllegalArgumentException();
-        }
-    }
-
-    public void visitFieldInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        switch (opcode) {
-            case Opcodes.GETSTATIC:
-                getstatic(owner, name, desc);
-                break;
-            case Opcodes.PUTSTATIC:
-                putstatic(owner, name, desc);
-                break;
-            case Opcodes.GETFIELD:
-                getfield(owner, name, desc);
-                break;
-            case Opcodes.PUTFIELD:
-                putfield(owner, name, desc);
-                break;
-            default:
-                throw new IllegalArgumentException();
-        }
-    }
-
-    public void visitMethodInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        switch (opcode) {
-            case Opcodes.INVOKESPECIAL:
-                invokespecial(owner, name, desc);
-                break;
-            case Opcodes.INVOKEVIRTUAL:
-                invokevirtual(owner, name, desc);
-                break;
-            case Opcodes.INVOKESTATIC:
-                invokestatic(owner, name, desc);
-                break;
-            case Opcodes.INVOKEINTERFACE:
-                invokeinterface(owner, name, desc);
-                break;
-            default:
-                throw new IllegalArgumentException();
-        }
-    }
-
-    public void visitJumpInsn(final int opcode, final Label label) {
-        switch (opcode) {
-            case Opcodes.IFEQ:
-                ifeq(label);
-                break;
-            case Opcodes.IFNE:
-                ifne(label);
-                break;
-            case Opcodes.IFLT:
-                iflt(label);
-                break;
-            case Opcodes.IFGE:
-                ifge(label);
-                break;
-            case Opcodes.IFGT:
-                ifgt(label);
-                break;
-            case Opcodes.IFLE:
-                ifle(label);
-                break;
-            case Opcodes.IF_ICMPEQ:
-                ificmpeq(label);
-                break;
-            case Opcodes.IF_ICMPNE:
-                ificmpne(label);
-                break;
-            case Opcodes.IF_ICMPLT:
-                ificmplt(label);
-                break;
-            case Opcodes.IF_ICMPGE:
-                ificmpge(label);
-                break;
-            case Opcodes.IF_ICMPGT:
-                ificmpgt(label);
-                break;
-            case Opcodes.IF_ICMPLE:
-                ificmple(label);
-                break;
-            case Opcodes.IF_ACMPEQ:
-                ifacmpeq(label);
-                break;
-            case Opcodes.IF_ACMPNE:
-                ifacmpne(label);
-                break;
-            case Opcodes.GOTO:
-                goTo(label);
-                break;
-            case Opcodes.JSR:
-                jsr(label);
-                break;
-            case Opcodes.IFNULL:
-                ifnull(label);
-                break;
-            case Opcodes.IFNONNULL:
-                ifnonnull(label);
-                break;
-            default:
-                throw new IllegalArgumentException();
-        }
-    }
-
-    public void visitLabel(final Label label) {
-        mark(label);
-    }
-
-    public void visitLdcInsn(final Object cst) {
-        if (cst instanceof Integer) {
-            int val = ((Integer) cst).intValue();
-            iconst(val);
-        } else if (cst instanceof Byte) {
-            int val = ((Byte) cst).intValue();
-            iconst(val);
-        } else if (cst instanceof Character) {
-            int val = ((Character) cst).charValue();
-            iconst(val);
-        } else if (cst instanceof Short) {
-            int val = ((Short) cst).intValue();
-            iconst(val);
-        } else if (cst instanceof Boolean) {
-            int val = ((Boolean) cst).booleanValue() ? 1 : 0;
-            iconst(val);
-        } else if (cst instanceof Float) {
-            float val = ((Float) cst).floatValue();
-            fconst(val);
-        } else if (cst instanceof Long) {
-            long val = ((Long) cst).longValue();
-            lconst(val);
-        } else if (cst instanceof Double) {
-            double val = ((Double) cst).doubleValue();
-            dconst(val);
-        } else if (cst instanceof String) {
-            aconst(cst);
-        } else if (cst instanceof Type) {
-            tconst((Type) cst);
-        } else {
-            throw new IllegalArgumentException();
-        }
-    }
-
-    public void visitIincInsn(final int var, final int increment) {
-        iinc(var, increment);
-    }
-
-    public void visitTableSwitchInsn(
-        final int min,
-        final int max,
-        final Label dflt,
-        final Label[] labels)
-    {
-        tableswitch(min, max, dflt, labels);
-    }
-
-    public void visitLookupSwitchInsn(
-        final Label dflt,
-        final int[] keys,
-        final Label[] labels)
-    {
-        lookupswitch(dflt, keys, labels);
-    }
-
-    public void visitMultiANewArrayInsn(final String desc, final int dims) {
-        multianewarray(desc, dims);
-    }
-
-    // -----------------------------------------------------------------------
-
-    public void nop() {
-        mv.visitInsn(Opcodes.NOP);
-    }
-
-    public void aconst(final Object cst) {
-        if (cst == null) {
-            mv.visitInsn(Opcodes.ACONST_NULL);
-        } else {
-            mv.visitLdcInsn(cst);
-        }
-    }
-
-    public void iconst(final int cst) {
-        if (cst >= -1 && cst <= 5) {
-            mv.visitInsn(Opcodes.ICONST_0 + cst);
-        } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {
-            mv.visitIntInsn(Opcodes.BIPUSH, cst);
-        } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {
-            mv.visitIntInsn(Opcodes.SIPUSH, cst);
-        } else {
-            mv.visitLdcInsn(new Integer(cst));
-        }
-    }
-
-    public void lconst(final long cst) {
-        if (cst == 0L || cst == 1L) {
-            mv.visitInsn(Opcodes.LCONST_0 + (int) cst);
-        } else {
-            mv.visitLdcInsn(new Long(cst));
-        }
-    }
-
-    public void fconst(final float cst) {
-        int bits = Float.floatToIntBits(cst);
-        if (bits == 0L || bits == 0x3f800000 || bits == 0x40000000) { // 0..2
-            mv.visitInsn(Opcodes.FCONST_0 + (int) cst);
-        } else {
-            mv.visitLdcInsn(new Float(cst));
-        }
-    }
-
-    public void dconst(final double cst) {
-        long bits = Double.doubleToLongBits(cst);
-        if (bits == 0L || bits == 0x3ff0000000000000L) { // +0.0d and 1.0d
-            mv.visitInsn(Opcodes.DCONST_0 + (int) cst);
-        } else {
-            mv.visitLdcInsn(new Double(cst));
-        }
-    }
-
-    public void tconst(final Type type) {
-        mv.visitLdcInsn(type);
-    }
-
-    public void load(final int var, final Type type) {
-        mv.visitVarInsn(type.getOpcode(Opcodes.ILOAD), var);
-    }
-
-    public void aload(final Type type) {
-        mv.visitInsn(type.getOpcode(Opcodes.IALOAD));
-    }
-
-    public void store(final int var, final Type type) {
-        mv.visitVarInsn(type.getOpcode(Opcodes.ISTORE), var);
-    }
-
-    public void astore(final Type type) {
-        mv.visitInsn(type.getOpcode(Opcodes.IASTORE));
-    }
-
-    public void pop() {
-        mv.visitInsn(Opcodes.POP);
-    }
-
-    public void pop2() {
-        mv.visitInsn(Opcodes.POP2);
-    }
-
-    public void dup() {
-        mv.visitInsn(Opcodes.DUP);
-    }
-
-    public void dup2() {
-        mv.visitInsn(Opcodes.DUP2);
-    }
-
-    public void dupX1() {
-        mv.visitInsn(Opcodes.DUP_X1);
-    }
-
-    public void dupX2() {
-        mv.visitInsn(Opcodes.DUP_X2);
-    }
-
-    public void dup2X1() {
-        mv.visitInsn(Opcodes.DUP2_X1);
-    }
-
-    public void dup2X2() {
-        mv.visitInsn(Opcodes.DUP2_X2);
-    }
-
-    public void swap() {
-        mv.visitInsn(Opcodes.SWAP);
-    }
-
-    public void add(final Type type) {
-        mv.visitInsn(type.getOpcode(Opcodes.IADD));
-    }
-
-    public void sub(final Type type) {
-        mv.visitInsn(type.getOpcode(Opcodes.ISUB));
-    }
-
-    public void mul(final Type type) {
-        mv.visitInsn(type.getOpcode(Opcodes.IMUL));
-    }
-
-    public void div(final Type type) {
-        mv.visitInsn(type.getOpcode(Opcodes.IDIV));
-    }
-
-    public void rem(final Type type) {
-        mv.visitInsn(type.getOpcode(Opcodes.IREM));
-    }
-
-    public void neg(final Type type) {
-        mv.visitInsn(type.getOpcode(Opcodes.INEG));
-    }
-
-    public void shl(final Type type) {
-        mv.visitInsn(type.getOpcode(Opcodes.ISHL));
-    }
-
-    public void shr(final Type type) {
-        mv.visitInsn(type.getOpcode(Opcodes.ISHR));
-    }
-
-    public void ushr(final Type type) {
-        mv.visitInsn(type.getOpcode(Opcodes.IUSHR));
-    }
-
-    public void and(final Type type) {
-        mv.visitInsn(type.getOpcode(Opcodes.IAND));
-    }
-
-    public void or(final Type type) {
-        mv.visitInsn(type.getOpcode(Opcodes.IOR));
-    }
-
-    public void xor(final Type type) {
-        mv.visitInsn(type.getOpcode(Opcodes.IXOR));
-    }
-
-    public void iinc(final int var, final int increment) {
-        mv.visitIincInsn(var, increment);
-    }
-
-    public void cast(final Type from, final Type to) {
-        if (from != to) {
-            if (from == Type.DOUBLE_TYPE) {
-                if (to == Type.FLOAT_TYPE) {
-                    mv.visitInsn(Opcodes.D2F);
-                } else if (to == Type.LONG_TYPE) {
-                    mv.visitInsn(Opcodes.D2L);
-                } else {
-                    mv.visitInsn(Opcodes.D2I);
-                    cast(Type.INT_TYPE, to);
-                }
-            } else if (from == Type.FLOAT_TYPE) {
-                if (to == Type.DOUBLE_TYPE) {
-                    mv.visitInsn(Opcodes.F2D);
-                } else if (to == Type.LONG_TYPE) {
-                    mv.visitInsn(Opcodes.F2L);
-                } else {
-                    mv.visitInsn(Opcodes.F2I);
-                    cast(Type.INT_TYPE, to);
-                }
-            } else if (from == Type.LONG_TYPE) {
-                if (to == Type.DOUBLE_TYPE) {
-                    mv.visitInsn(Opcodes.L2D);
-                } else if (to == Type.FLOAT_TYPE) {
-                    mv.visitInsn(Opcodes.L2F);
-                } else {
-                    mv.visitInsn(Opcodes.L2I);
-                    cast(Type.INT_TYPE, to);
-                }
-            } else {
-                if (to == Type.BYTE_TYPE) {
-                    mv.visitInsn(Opcodes.I2B);
-                } else if (to == Type.CHAR_TYPE) {
-                    mv.visitInsn(Opcodes.I2C);
-                } else if (to == Type.DOUBLE_TYPE) {
-                    mv.visitInsn(Opcodes.I2D);
-                } else if (to == Type.FLOAT_TYPE) {
-                    mv.visitInsn(Opcodes.I2F);
-                } else if (to == Type.LONG_TYPE) {
-                    mv.visitInsn(Opcodes.I2L);
-                } else if (to == Type.SHORT_TYPE) {
-                    mv.visitInsn(Opcodes.I2S);
-                }
-            }
-        }
-    }
-
-    public void lcmp() {
-        mv.visitInsn(Opcodes.LCMP);
-    }
-
-    public void cmpl(final Type type) {
-        mv.visitInsn(type == Type.FLOAT_TYPE ? Opcodes.FCMPL : Opcodes.DCMPL);
-    }
-
-    public void cmpg(final Type type) {
-        mv.visitInsn(type == Type.FLOAT_TYPE ? Opcodes.FCMPG : Opcodes.DCMPG);
-    }
-
-    public void ifeq(final Label label) {
-        mv.visitJumpInsn(Opcodes.IFEQ, label);
-    }
-
-    public void ifne(final Label label) {
-        mv.visitJumpInsn(Opcodes.IFNE, label);
-    }
-
-    public void iflt(final Label label) {
-        mv.visitJumpInsn(Opcodes.IFLT, label);
-    }
-
-    public void ifge(final Label label) {
-        mv.visitJumpInsn(Opcodes.IFGE, label);
-    }
-
-    public void ifgt(final Label label) {
-        mv.visitJumpInsn(Opcodes.IFGT, label);
-    }
-
-    public void ifle(final Label label) {
-        mv.visitJumpInsn(Opcodes.IFLE, label);
-    }
-
-    public void ificmpeq(final Label label) {
-        mv.visitJumpInsn(Opcodes.IF_ICMPEQ, label);
-    }
-
-    public void ificmpne(final Label label) {
-        mv.visitJumpInsn(Opcodes.IF_ICMPNE, label);
-    }
-
-    public void ificmplt(final Label label) {
-        mv.visitJumpInsn(Opcodes.IF_ICMPLT, label);
-    }
-
-    public void ificmpge(final Label label) {
-        mv.visitJumpInsn(Opcodes.IF_ICMPGE, label);
-    }
-
-    public void ificmpgt(final Label label) {
-        mv.visitJumpInsn(Opcodes.IF_ICMPGT, label);
-    }
-
-    public void ificmple(final Label label) {
-        mv.visitJumpInsn(Opcodes.IF_ICMPLE, label);
-    }
-
-    public void ifacmpeq(final Label label) {
-        mv.visitJumpInsn(Opcodes.IF_ACMPEQ, label);
-    }
-
-    public void ifacmpne(final Label label) {
-        mv.visitJumpInsn(Opcodes.IF_ACMPNE, label);
-    }
-
-    public void goTo(final Label label) {
-        mv.visitJumpInsn(Opcodes.GOTO, label);
-    }
-
-    public void jsr(final Label label) {
-        mv.visitJumpInsn(Opcodes.JSR, label);
-    }
-
-    public void ret(final int var) {
-        mv.visitVarInsn(Opcodes.RET, var);
-    }
-
-    public void tableswitch(
-        final int min,
-        final int max,
-        final Label dflt,
-        final Label[] labels)
-    {
-        mv.visitTableSwitchInsn(min, max, dflt, labels);
-    }
-
-    public void lookupswitch(
-        final Label dflt,
-        final int[] keys,
-        final Label[] labels)
-    {
-        mv.visitLookupSwitchInsn(dflt, keys, labels);
-    }
-
-    public void areturn(final Type t) {
-        mv.visitInsn(t.getOpcode(Opcodes.IRETURN));
-    }
-
-    public void getstatic(
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        mv.visitFieldInsn(Opcodes.GETSTATIC, owner, name, desc);
-    }
-
-    public void putstatic(
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        mv.visitFieldInsn(Opcodes.PUTSTATIC, owner, name, desc);
-    }
-
-    public void getfield(
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        mv.visitFieldInsn(Opcodes.GETFIELD, owner, name, desc);
-    }
-
-    public void putfield(
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        mv.visitFieldInsn(Opcodes.PUTFIELD, owner, name, desc);
-    }
-
-    public void invokevirtual(
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, owner, name, desc);
-    }
-
-    public void invokespecial(
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, owner, name, desc);
-    }
-
-    public void invokestatic(
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, owner, name, desc);
-    }
-
-    public void invokeinterface(
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, owner, name, desc);
-    }
-
-    public void anew(final Type type) {
-        mv.visitTypeInsn(Opcodes.NEW, type.getInternalName());
-    }
-
-    public void newarray(final Type type) {
-        int typ;
-        switch (type.getSort()) {
-            case Type.BOOLEAN:
-                typ = Opcodes.T_BOOLEAN;
-                break;
-            case Type.CHAR:
-                typ = Opcodes.T_CHAR;
-                break;
-            case Type.BYTE:
-                typ = Opcodes.T_BYTE;
-                break;
-            case Type.SHORT:
-                typ = Opcodes.T_SHORT;
-                break;
-            case Type.INT:
-                typ = Opcodes.T_INT;
-                break;
-            case Type.FLOAT:
-                typ = Opcodes.T_FLOAT;
-                break;
-            case Type.LONG:
-                typ = Opcodes.T_LONG;
-                break;
-            case Type.DOUBLE:
-                typ = Opcodes.T_DOUBLE;
-                break;
-            default:
-                mv.visitTypeInsn(Opcodes.ANEWARRAY, type.getInternalName());
-                return;
-        }
-        mv.visitIntInsn(Opcodes.NEWARRAY, typ);
-    }
-
-    public void arraylength() {
-        mv.visitInsn(Opcodes.ARRAYLENGTH);
-    }
-
-    public void athrow() {
-        mv.visitInsn(Opcodes.ATHROW);
-    }
-
-    public void checkcast(final Type type) {
-        mv.visitTypeInsn(Opcodes.CHECKCAST, type.getInternalName());
-    }
-
-    public void instanceOf(final Type type) {
-        mv.visitTypeInsn(Opcodes.INSTANCEOF, type.getInternalName());
-    }
-
-    public void monitorenter() {
-        mv.visitInsn(Opcodes.MONITORENTER);
-    }
-
-    public void monitorexit() {
-        mv.visitInsn(Opcodes.MONITOREXIT);
-    }
-
-    public void multianewarray(final String desc, final int dims) {
-        mv.visitMultiANewArrayInsn(desc, dims);
-    }
-
-    public void ifnull(final Label label) {
-        mv.visitJumpInsn(Opcodes.IFNULL, label);
-    }
-
-    public void ifnonnull(final Label label) {
-        mv.visitJumpInsn(Opcodes.IFNONNULL, label);
-    }
-
-    public void mark(final Label label) {
-        mv.visitLabel(label);
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/JSRInlinerAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/JSRInlinerAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/JSRInlinerAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/JSRInlinerAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,728 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import java.util.AbstractMap;
-import java.util.ArrayList;
-import java.util.BitSet;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-import org.eclipse.persistence.internal.libraries.asm.tree.AbstractInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.InsnList;
-import org.eclipse.persistence.internal.libraries.asm.tree.InsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.JumpInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.LabelNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.LocalVariableNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.LookupSwitchInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.MethodNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.TableSwitchInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.TryCatchBlockNode;
-
-/**
- * A {@link org.eclipse.persistence.internal.libraries.asm.MethodAdapter} that removes JSR instructions and
- * inlines the referenced subroutines.
- * 
- * <b>Explanation of how it works</b> TODO
- * 
- * @author Niko Matsakis
- */
-public class JSRInlinerAdapter extends MethodNode implements Opcodes {
-
-    private static final boolean LOGGING = false;
-
-    /**
-     * The visitor to which we will emit a translation of this method without
-     * internal subroutines.
-     */
-    private final MethodVisitor mv;
-
-    /**
-     * For each label that is jumped to by a JSR, we create a Subroutine
-     * instance. Map<LabelNode,Subroutine> is the generic type.
-     */
-    private final Map subroutineHeads = new HashMap();
-
-    /**
-     * This subroutine instance denotes the line of execution that is not
-     * contained within any subroutine; i.e., the "subroutine" that is executing
-     * when a method first begins.
-     */
-    private final Subroutine mainSubroutine = new Subroutine();
-
-    /**
-     * This BitSet contains the index of every instruction that belongs to more
-     * than one subroutine. This should not happen often.
-     */
-    final BitSet dualCitizens = new BitSet();
-
-    /**
-     * Creates a new JSRInliner.
-     * 
-     * @param mv the <code>MethodVisitor</code> to send the resulting inlined
-     *        method code to (use <code>null</code> for none).
-     * @param access the method's access flags (see {@link Opcodes}). This
-     *        parameter also indicates if the method is synthetic and/or
-     *        deprecated.
-     * @param name the method's name.
-     * @param desc the method's descriptor (see {@link Type}).
-     * @param signature the method's signature. May be <tt>null</tt>.
-     * @param exceptions the internal names of the method's exception classes
-     *        (see {@link Type#getInternalName() getInternalName}). May be
-     *        <tt>null</tt>.
-     */
-    public JSRInlinerAdapter(
-        final MethodVisitor mv,
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final String[] exceptions)
-    {
-        super(access, name, desc, signature, exceptions);
-        this.mv = mv;
-    }
-
-    /**
-     * Detects a JSR instruction and sets a flag to indicate we will need to do
-     * inlining.
-     */
-    public void visitJumpInsn(final int opcode, final Label lbl) {
-        super.visitJumpInsn(opcode, lbl);
-        LabelNode ln = ((JumpInsnNode) instructions.getLast()).label;
-        if (opcode == JSR && !subroutineHeads.containsKey(ln)) {
-            subroutineHeads.put(ln, new Subroutine());
-        }
-    }
-
-    /**
-     * If any JSRs were seen, triggers the inlining process. Otherwise, forwards
-     * the byte codes untouched.
-     */
-    public void visitEnd() {
-        if (!subroutineHeads.isEmpty()) {
-            markSubroutines();
-            if (LOGGING) {
-                log(mainSubroutine.toString());
-                Iterator it = subroutineHeads.values().iterator();
-                while (it.hasNext()) {
-                    Subroutine sub = (Subroutine) it.next();
-                    log(sub.toString());
-                }
-            }
-            emitCode();
-        }
-
-        // Forward the translate opcodes on if appropriate:
-        if (mv != null) {
-            accept(mv);
-        }
-    }
-
-    /**
-     * Walks the method and determines which internal subroutine(s), if any,
-     * each instruction is a method of.
-     */
-    private void markSubroutines() {
-        BitSet anyvisited = new BitSet();
-
-        // First walk the main subroutine and find all those instructions which
-        // can be reached without invoking any JSR at all
-        markSubroutineWalk(mainSubroutine, 0, anyvisited);
-
-        // Go through the head of each subroutine and find any nodes reachable
-        // to that subroutine without following any JSR links.
-        for (Iterator it = subroutineHeads.entrySet().iterator(); it.hasNext();)
-        {
-            Map.Entry entry = (Map.Entry) it.next();
-            LabelNode lab = (LabelNode) entry.getKey();
-            Subroutine sub = (Subroutine) entry.getValue();
-            int index = instructions.indexOf(lab);
-            markSubroutineWalk(sub, index, anyvisited);
-        }
-    }
-
-    /**
-     * Performs a depth first search walking the normal byte code path starting
-     * at <code>index</code>, and adding each instruction encountered into
-     * the subroutine <code>sub</code>. After this walk is complete, iterates
-     * over the exception handlers to ensure that we also include those byte
-     * codes which are reachable through an exception that may be thrown during
-     * the execution of the subroutine. Invoked from
-     * <code>markSubroutines()</code>.
-     * 
-     * @param sub the subroutine whose instructions must be computed.
-     * @param index an instruction of this subroutine.
-     * @param anyvisited indexes of the already visited instructions, i.e.
-     *        marked as part of this subroutine or any previously computed
-     *        subroutine.
-     */
-    private void markSubroutineWalk(
-        final Subroutine sub,
-        final int index,
-        final BitSet anyvisited)
-    {
-        if (LOGGING) {
-            log("markSubroutineWalk: sub=" + sub + " index=" + index);
-        }
-
-        // First find those instructions reachable via normal execution
-        markSubroutineWalkDFS(sub, index, anyvisited);
-
-        // Now, make sure we also include any applicable exception handlers
-        boolean loop = true;
-        while (loop) {
-            loop = false;
-            for (Iterator it = tryCatchBlocks.iterator(); it.hasNext();) {
-                TryCatchBlockNode trycatch = (TryCatchBlockNode) it.next();
-
-                if (LOGGING) {
-                    // TODO use of default toString().
-                    log("Scanning try/catch " + trycatch);
-                }
-
-                // If the handler has already been processed, skip it.
-                int handlerindex = instructions.indexOf(trycatch.handler);
-                if (sub.instructions.get(handlerindex)) {
-                    continue;
-                }
-
-                int startindex = instructions.indexOf(trycatch.start);
-                int endindex = instructions.indexOf(trycatch.end);
-                int nextbit = sub.instructions.nextSetBit(startindex);
-                if (nextbit != -1 && nextbit < endindex) {
-                    if (LOGGING) {
-                        log("Adding exception handler: " + startindex + '-'
-                                + endindex + " due to " + nextbit + " handler "
-                                + handlerindex);
-                    }
-                    markSubroutineWalkDFS(sub, handlerindex, anyvisited);
-                    loop = true;
-                }
-            }
-        }
-    }
-
-    /**
-     * Performs a simple DFS of the instructions, assigning each to the
-     * subroutine <code>sub</code>. Starts from <code>index</code>.
-     * Invoked only by <code>markSubroutineWalk()</code>.
-     * 
-     * @param sub the subroutine whose instructions must be computed.
-     * @param index an instruction of this subroutine.
-     * @param anyvisited indexes of the already visited instructions, i.e.
-     *        marked as part of this subroutine or any previously computed
-     *        subroutine.
-     */
-    private void markSubroutineWalkDFS(
-        final Subroutine sub,
-        int index,
-        final BitSet anyvisited)
-    {
-        while (true) {
-            AbstractInsnNode node = instructions.get(index);
-
-            // don't visit a node twice
-            if (sub.instructions.get(index)) {
-                return;
-            }
-            sub.instructions.set(index);
-
-            // check for those nodes already visited by another subroutine
-            if (anyvisited.get(index)) {
-                dualCitizens.set(index);
-                if (LOGGING) {
-                    log("Instruction #" + index + " is dual citizen.");
-                }
-            }
-            anyvisited.set(index);
-
-            if (node.getType() == AbstractInsnNode.JUMP_INSN
-                    && node.getOpcode() != JSR)
-            {
-                // we do not follow recursively called subroutines here; but any
-                // other sort of branch we do follow
-                JumpInsnNode jnode = (JumpInsnNode) node;
-                int destidx = instructions.indexOf(jnode.label);
-                markSubroutineWalkDFS(sub, destidx, anyvisited);
-            }
-            if (node.getType() == AbstractInsnNode.TABLESWITCH_INSN) {
-                TableSwitchInsnNode tsnode = (TableSwitchInsnNode) node;
-                int destidx = instructions.indexOf(tsnode.dflt);
-                markSubroutineWalkDFS(sub, destidx, anyvisited);
-                for (int i = tsnode.labels.size() - 1; i >= 0; --i) {
-                    LabelNode l = (LabelNode) tsnode.labels.get(i);
-                    destidx = instructions.indexOf(l);
-                    markSubroutineWalkDFS(sub, destidx, anyvisited);
-                }
-            }
-            if (node.getType() == AbstractInsnNode.LOOKUPSWITCH_INSN) {
-                LookupSwitchInsnNode lsnode = (LookupSwitchInsnNode) node;
-                int destidx = instructions.indexOf(lsnode.dflt);
-                markSubroutineWalkDFS(sub, destidx, anyvisited);
-                for (int i = lsnode.labels.size() - 1; i >= 0; --i) {
-                    LabelNode l = (LabelNode) lsnode.labels.get(i);
-                    destidx = instructions.indexOf(l);
-                    markSubroutineWalkDFS(sub, destidx, anyvisited);
-                }
-            }
-
-            // check to see if this opcode falls through to the next instruction
-            // or not; if not, return.
-            switch (instructions.get(index).getOpcode()) {
-                case GOTO:
-                case RET:
-                case TABLESWITCH:
-                case LOOKUPSWITCH:
-                case IRETURN:
-                case LRETURN:
-                case FRETURN:
-                case DRETURN:
-                case ARETURN:
-                case RETURN:
-                case ATHROW:
-                    /*
-                     * note: this either returns from this subroutine, or a
-                     * parent subroutine which invoked it
-                     */
-                    return;
-            }
-
-            // Use tail recursion here in the form of an outer while loop to
-            // avoid our stack growing needlessly:
-            index++;
-        }
-    }
-
-    /**
-     * Creates the new instructions, inlining each instantiation of each
-     * subroutine until the code is fully elaborated.
-     */
-    private void emitCode() {
-        LinkedList worklist = new LinkedList();
-        // Create an instantiation of the "root" subroutine, which is just the
-        // main routine
-        worklist.add(new Instantiation(null, mainSubroutine));
-
-        // Emit instantiations of each subroutine we encounter, including the
-        // main subroutine
-        InsnList newInstructions = new InsnList();
-        List newTryCatchBlocks = new ArrayList();
-        List newLocalVariables = new ArrayList();
-        while (!worklist.isEmpty()) {
-            Instantiation inst = (Instantiation) worklist.removeFirst();
-            emitSubroutine(inst,
-                    worklist,
-                    newInstructions,
-                    newTryCatchBlocks,
-                    newLocalVariables);
-        }
-        instructions = newInstructions;
-        tryCatchBlocks = newTryCatchBlocks;
-        localVariables = newLocalVariables;
-    }
-
-    /**
-     * Emits one instantiation of one subroutine, specified by
-     * <code>instant</code>. May add new instantiations that are invoked by
-     * this one to the <code>worklist</code> parameter, and new try/catch
-     * blocks to <code>newTryCatchBlocks</code>.
-     * 
-     * @param instant the instantiation that must be performed.
-     * @param worklist list of the instantiations that remain to be done.
-     * @param newInstructions the instruction list to which the instantiated
-     *        code must be appended.
-     * @param newTryCatchBlocks the exception handler list to which the
-     *        instantiated handlers must be appended.
-     */
-    private void emitSubroutine(
-        final Instantiation instant,
-        final List worklist,
-        final InsnList newInstructions,
-        final List newTryCatchBlocks,
-        final List newLocalVariables)
-    {
-        LabelNode duplbl = null;
-
-        if (LOGGING) {
-            log("--------------------------------------------------------");
-            log("Emitting instantiation of subroutine " + instant.subroutine);
-        }
-
-        // Emit the relevant instructions for this instantiation, translating
-        // labels and jump targets as we go:
-        for (int i = 0, c = instructions.size(); i < c; i++) {
-            AbstractInsnNode insn = instructions.get(i);
-            Instantiation owner = instant.findOwner(i);
-
-            // Always remap labels:
-            if (insn.getType() == AbstractInsnNode.LABEL) {
-                // Translate labels into their renamed equivalents.
-                // Avoid adding the same label more than once. Note
-                // that because we own this instruction the gotoTable
-                // and the rangeTable will always agree.
-                LabelNode ilbl = (LabelNode) insn;
-                LabelNode remap = instant.rangeLabel(ilbl);
-                if (LOGGING) {
-                    // TODO use of default toString().
-                    log("Translating lbl #" + i + ':' + ilbl + " to " + remap);
-                }
-                if (remap != duplbl) {
-                    newInstructions.add(remap);
-                    duplbl = remap;
-                }
-                continue;
-            }
-
-            // We don't want to emit instructions that were already
-            // emitted by a subroutine higher on the stack. Note that
-            // it is still possible for a given instruction to be
-            // emitted twice because it may belong to two subroutines
-            // that do not invoke each other.
-            if (owner != instant) {
-                continue;
-            }
-
-            if (LOGGING) {
-                log("Emitting inst #" + i);
-            }
-
-            if (insn.getOpcode() == RET) {
-                // Translate RET instruction(s) to a jump to the return label
-                // for the appropriate instantiation. The problem is that the
-                // subroutine may "fall through" to the ret of a parent
-                // subroutine; therefore, to find the appropriate ret label we
-                // find the lowest subroutine on the stack that claims to own
-                // this instruction. See the class javadoc comment for an
-                // explanation on why this technique is safe (note: it is only
-                // safe if the input is verifiable).
-                LabelNode retlabel = null;
-                for (Instantiation p = instant; p != null; p = p.previous) {
-                    if (p.subroutine.ownsInstruction(i)) {
-                        retlabel = p.returnLabel;
-                    }
-                }
-                if (retlabel == null) {
-                    // This is only possible if the mainSubroutine owns a RET
-                    // instruction, which should never happen for verifiable
-                    // code.
-                    throw new RuntimeException("Instruction #" + i
-                            + " is a RET not owned by any subroutine");
-                }
-                newInstructions.add(new JumpInsnNode(GOTO, retlabel));
-            } else if (insn.getOpcode() == JSR) {
-                LabelNode lbl = ((JumpInsnNode) insn).label;
-                Subroutine sub = (Subroutine) subroutineHeads.get(lbl);
-                Instantiation newinst = new Instantiation(instant, sub);
-                LabelNode startlbl = newinst.gotoLabel(lbl);
-
-                if (LOGGING) {
-                    log(" Creating instantiation of subr " + sub);
-                }
-
-                // Rather than JSRing, we will jump to the inline version and
-                // push NULL for what was once the return value. This hack
-                // allows us to avoid doing any sort of data flow analysis to
-                // figure out which instructions manipulate the old return value
-                // pointer which is now known to be unneeded.
-                newInstructions.add(new InsnNode(ACONST_NULL));
-                newInstructions.add(new JumpInsnNode(GOTO, startlbl));
-                newInstructions.add(newinst.returnLabel);
-
-                // Insert this new instantiation into the queue to be emitted
-                // later.
-                worklist.add(newinst);
-            } else {
-                newInstructions.add(insn.clone(instant));
-            }
-        }
-
-        // Emit try/catch blocks that are relevant to this method.
-        for (Iterator it = tryCatchBlocks.iterator(); it.hasNext();) {
-            TryCatchBlockNode trycatch = (TryCatchBlockNode) it.next();
-
-            if (LOGGING) {
-                // TODO use of default toString().
-                log("try catch block original labels=" + trycatch.start + '-'
-                        + trycatch.end + "->" + trycatch.handler);
-            }
-
-            final LabelNode start = instant.rangeLabel(trycatch.start);
-            final LabelNode end = instant.rangeLabel(trycatch.end);
-
-            // Ignore empty try/catch regions
-            if (start == end) {
-                if (LOGGING) {
-                    log(" try catch block empty in this subroutine");
-                }
-                continue;
-            }
-
-            final LabelNode handler = instant.gotoLabel(trycatch.handler);
-
-            if (LOGGING) {
-                // TODO use of default toString().
-                log(" try catch block new labels=" + start + '-' + end + "->"
-                        + handler);
-            }
-
-            if (start == null || end == null || handler == null) {
-                throw new RuntimeException("Internal error!");
-            }
-
-            newTryCatchBlocks.add(new TryCatchBlockNode(start,
-                    end,
-                    handler,
-                    trycatch.type));
-        }
-
-        for (Iterator it = localVariables.iterator(); it.hasNext();) {
-            LocalVariableNode lvnode = (LocalVariableNode) it.next();
-            if (LOGGING) {
-                log("local var " + lvnode.name);
-            }
-            final LabelNode start = instant.rangeLabel(lvnode.start);
-            final LabelNode end = instant.rangeLabel(lvnode.end);
-            if (start == end) {
-                if (LOGGING) {
-                    log("  local variable empty in this sub");
-                }
-                continue;
-            }
-            newLocalVariables.add(new LocalVariableNode(lvnode.name,
-                    lvnode.desc,
-                    lvnode.signature,
-                    start,
-                    end,
-                    lvnode.index));
-        }
-    }
-
-    private static void log(final String str) {
-        System.err.println(str);
-    }
-
-    protected static class Subroutine {
-
-        public final BitSet instructions = new BitSet();
-
-        public void addInstruction(final int idx) {
-            instructions.set(idx);
-        }
-
-        public boolean ownsInstruction(final int idx) {
-            return instructions.get(idx);
-        }
-
-        public String toString() {
-            return "Subroutine: " + instructions;
-        }
-    }
-
-    /**
-     * A class that represents an instantiation of a subroutine. Each
-     * instantiation has an associate "stack" --- which is a listing of those
-     * instantiations that were active when this particular instance of this
-     * subroutine was invoked. Each instantiation also has a map from the
-     * original labels of the program to the labels appropriate for this
-     * instantiation, and finally a label to return to.
-     */
-    private class Instantiation extends AbstractMap {
-
-        /**
-         * Previous instantiations; the stack must be statically predictable to
-         * be inlinable.
-         */
-        final Instantiation previous;
-
-        /**
-         * The subroutine this is an instantiation of.
-         */
-        public final Subroutine subroutine;
-
-        /**
-         * This table maps Labels from the original source to Labels pointing at
-         * code specific to this instantiation, for use in remapping try/catch
-         * blocks,as well as gotos.
-         * 
-         * Note that in the presence of dual citizens instructions, that is,
-         * instructions which belong to more than one subroutine due to the
-         * merging of control flow without a RET instruction, we will map the
-         * target label of a GOTO to the label used by the instantiation lowest
-         * on the stack. This avoids code duplication during inlining in most
-         * cases.
-         * 
-         * @see #findOwner(int)
-         */
-        public final Map rangeTable = new HashMap();
-
-        /**
-         * All returns for this instantiation will be mapped to this label
-         */
-        public final LabelNode returnLabel;
-
-        Instantiation(final Instantiation prev, final Subroutine sub) {
-            previous = prev;
-            subroutine = sub;
-            for (Instantiation p = prev; p != null; p = p.previous) {
-                if (p.subroutine == sub) {
-                    throw new RuntimeException("Recursive invocation of " + sub);
-                }
-            }
-
-            // Determine the label to return to when this subroutine terminates
-            // via RET: note that the main subroutine never terminates via RET.
-            if (prev != null) {
-                returnLabel = new LabelNode();
-            } else {
-                returnLabel = null;
-            }
-
-            // Each instantiation will remap the labels from the code above to
-            // refer to its particular copy of its own instructions. Note that
-            // we collapse labels which point at the same instruction into one:
-            // this is fairly common as we are often ignoring large chunks of
-            // instructions, so what were previously distinct labels become
-            // duplicates.
-            LabelNode duplbl = null;
-            for (int i = 0, c = instructions.size(); i < c; i++) {
-                AbstractInsnNode insn = instructions.get(i);
-
-                if (insn.getType() == AbstractInsnNode.LABEL) {
-                    LabelNode ilbl = (LabelNode) insn;
-
-                    if (duplbl == null) {
-                        // if we already have a label pointing at this spot,
-                        // don't recreate it.
-                        duplbl = new LabelNode();
-                    }
-
-                    // Add an entry in the rangeTable for every label
-                    // in the original code which points at the next
-                    // instruction of our own to be emitted.
-                    rangeTable.put(ilbl, duplbl);
-                } else if (findOwner(i) == this) {
-                    // We will emit this instruction, so clear the 'duplbl' flag
-                    // since the next Label will refer to a distinct
-                    // instruction.
-                    duplbl = null;
-                }
-            }
-        }
-
-        /**
-         * Returns the "owner" of a particular instruction relative to this
-         * instantiation: the owner referes to the Instantiation which will emit
-         * the version of this instruction that we will execute.
-         * 
-         * Typically, the return value is either <code>this</code> or
-         * <code>null</code>. <code>this</code> indicates that this
-         * instantiation will generate the version of this instruction that we
-         * will execute, and <code>null</code> indicates that this
-         * instantiation never executes the given instruction.
-         * 
-         * Sometimes, however, an instruction can belong to multiple
-         * subroutines; this is called a "dual citizen" instruction (though it
-         * may belong to more than 2 subroutines), and occurs when multiple
-         * subroutines branch to common points of control. In this case, the
-         * owner is the subroutine that appears lowest on the stack, and which
-         * also owns the instruction in question.
-         * 
-         * @param i the index of the instruction in the original code
-         * @return the "owner" of a particular instruction relative to this
-         *         instantiation.
-         */
-        public Instantiation findOwner(final int i) {
-            if (!subroutine.ownsInstruction(i)) {
-                return null;
-            }
-            if (!dualCitizens.get(i)) {
-                return this;
-            }
-            Instantiation own = this;
-            for (Instantiation p = previous; p != null; p = p.previous) {
-                if (p.subroutine.ownsInstruction(i)) {
-                    own = p;
-                }
-            }
-            return own;
-        }
-
-        /**
-         * Looks up the label <code>l</code> in the <code>gotoTable</code>,
-         * thus translating it from a Label in the original code, to a Label in
-         * the inlined code that is appropriate for use by an instruction that
-         * branched to the original label.
-         * 
-         * @param l The label we will be translating
-         * @return a label for use by a branch instruction in the inlined code
-         * @see #rangeLabel
-         */
-        public LabelNode gotoLabel(final LabelNode l) {
-            // owner should never be null, because owner is only null
-            // if an instruction cannot be reached from this subroutine
-            Instantiation owner = findOwner(instructions.indexOf(l));
-            return (LabelNode) owner.rangeTable.get(l);
-        }
-
-        /**
-         * Looks up the label <code>l</code> in the <code>rangeTable</code>,
-         * thus translating it from a Label in the original code, to a Label in
-         * the inlined code that is appropriate for use by an try/catch or
-         * variable use annotation.
-         * 
-         * @param l The label we will be translating
-         * @return a label for use by a try/catch or variable annotation in the
-         *         original code
-         * @see #rangeTable
-         */
-        public LabelNode rangeLabel(final LabelNode l) {
-            return (LabelNode) rangeTable.get(l);
-        }
-
-        // AbstractMap implementation
-
-        public Set entrySet() {
-            return null;
-        }
-
-        public Object get(final Object o) {
-            return gotoLabel((LabelNode) o);
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/LocalVariablesSorter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/LocalVariablesSorter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/LocalVariablesSorter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/LocalVariablesSorter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,318 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodAdapter;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-
-/**
- * A {@link MethodAdapter} that renumbers local variables in their order of
- * appearance. This adapter allows one to easily add new local variables to a
- * method. It may be used by inheriting from this class, but the preferred way
- * of using it is via delegation: the next visitor in the chain can indeed add
- * new locals when needed by calling {@link #newLocal} on this adapter (this
- * requires a reference back to this {@link LocalVariablesSorter}).
- *
- * @author Chris Nokleberg
- * @author Eugene Kuleshov
- * @author Eric Bruneton
- */
-public class LocalVariablesSorter extends MethodAdapter {
-
-    private static final Type OBJECT_TYPE = Type.getObjectType("java/lang/Object");
-
-    /**
-     * Mapping from old to new local variable indexes. A local variable at index
-     * i of size 1 is remapped to 'mapping[2*i]', while a local variable at
-     * index i of size 2 is remapped to 'mapping[2*i+1]'.
-     */
-    private int[] mapping = new int[40];
-
-    /**
-     * Array used to store stack map local variable types after remapping.
-     */
-    private Object[] newLocals = new Object[20];
-
-    /**
-     * Index of the first local variable, after formal parameters.
-     */
-    protected final int firstLocal;
-
-    /**
-     * Index of the next local variable to be created by {@link #newLocal}.
-     */
-    protected int nextLocal;
-
-    /**
-     * Indicates if at least one local variable has moved due to remapping.
-     */
-    private boolean changed;
-
-    /**
-     * Creates a new {@link LocalVariablesSorter}.
-     *
-     * @param access access flags of the adapted method.
-     * @param desc the method's descriptor (see {@link Type Type}).
-     * @param mv the method visitor to which this adapter delegates calls.
-     */
-    public LocalVariablesSorter(
-        final int access,
-        final String desc,
-        final MethodVisitor mv)
-    {
-        super(mv);
-        Type[] args = Type.getArgumentTypes(desc);
-        nextLocal = (Opcodes.ACC_STATIC & access) == 0 ? 1 : 0;
-        for (int i = 0; i < args.length; i++) {
-            nextLocal += args[i].getSize();
-        }
-        firstLocal = nextLocal;
-    }
-
-    public void visitVarInsn(final int opcode, final int var) {
-        Type type;
-        switch (opcode) {
-            case Opcodes.LLOAD:
-            case Opcodes.LSTORE:
-                type = Type.LONG_TYPE;
-                break;
-
-            case Opcodes.DLOAD:
-            case Opcodes.DSTORE:
-                type = Type.DOUBLE_TYPE;
-                break;
-
-            case Opcodes.FLOAD:
-            case Opcodes.FSTORE:
-                type = Type.FLOAT_TYPE;
-                break;
-
-            case Opcodes.ILOAD:
-            case Opcodes.ISTORE:
-                type = Type.INT_TYPE;
-                break;
-
-            default:
-            // case Opcodes.ALOAD:
-            // case Opcodes.ASTORE:
-            // case RET:
-                type = OBJECT_TYPE;
-                break;
-        }
-        mv.visitVarInsn(opcode, remap(var, type));
-    }
-
-    public void visitIincInsn(final int var, final int increment) {
-        mv.visitIincInsn(remap(var, Type.INT_TYPE), increment);
-    }
-
-    public void visitMaxs(final int maxStack, final int maxLocals) {
-        mv.visitMaxs(maxStack, nextLocal);
-    }
-
-    public void visitLocalVariable(
-        final String name,
-        final String desc,
-        final String signature,
-        final Label start,
-        final Label end,
-        final int index)
-    {
-        int newIndex = remap(index, Type.getType(desc));
-        mv.visitLocalVariable(name, desc, signature, start, end, newIndex);
-    }
-
-    public void visitFrame(
-        final int type,
-        final int nLocal,
-        final Object[] local,
-        final int nStack,
-        final Object[] stack)
-    {
-        if (type != Opcodes.F_NEW) { // uncompressed frame
-            throw new IllegalStateException("ClassReader.accept() should be called with EXPAND_FRAMES flag");
-        }
-
-        if (!changed) { // optimization for the case where mapping = identity
-            mv.visitFrame(type, nLocal, local, nStack, stack);
-            return;
-        }
-
-        // creates a copy of newLocals
-        Object[] oldLocals = new Object[newLocals.length];
-        System.arraycopy(newLocals, 0, oldLocals, 0, oldLocals.length);
-
-        // copies types from 'local' to 'newLocals'
-        // 'newLocals' already contains the variables added with 'newLocal'
-
-        int index = 0; // old local variable index
-        int number = 0; // old local variable number
-        for (; number < nLocal; ++number) {
-            Object t = local[number];
-            int size = t == Opcodes.LONG || t == Opcodes.DOUBLE ? 2 : 1;
-            if (t != Opcodes.TOP) {
-                Type typ = OBJECT_TYPE;
-                if (t == Opcodes.INTEGER) {
-                    typ = Type.INT_TYPE;
-                } else if (t == Opcodes.FLOAT) {
-                    typ = Type.FLOAT_TYPE;
-                } else if (t == Opcodes.LONG) {
-                    typ = Type.LONG_TYPE;
-                } else if (t == Opcodes.DOUBLE) {
-                    typ = Type.DOUBLE_TYPE;
-                } else if (t instanceof String) {
-                    typ = Type.getObjectType((String) t);
-                }
-                setFrameLocal(remap(index, typ), t);
-            }
-            index += size;
-        }
-
-        // removes TOP after long and double types as well as trailing TOPs
-
-        index = 0;
-        number = 0;
-        for (int i = 0; index < newLocals.length; ++i) {
-            Object t = newLocals[index++];
-            if (t != null && t != Opcodes.TOP) {
-                newLocals[i] = t;
-                number = i + 1;
-                if (t == Opcodes.LONG || t == Opcodes.DOUBLE) {
-                    index += 1;
-                }
-            } else {
-                newLocals[i] = Opcodes.TOP;
-            }
-        }
-
-        // visits remapped frame
-        mv.visitFrame(type, number, newLocals, nStack, stack);
-
-        // restores original value of 'newLocals'
-        newLocals = oldLocals;
-    }
-
-    // -------------
-
-    /**
-     * Creates a new local variable of the given type.
-     *
-     * @param type the type of the local variable to be created.
-     * @return the identifier of the newly created local variable.
-     */
-    public int newLocal(final Type type) {
-        Object t;
-        switch (type.getSort()) {
-            case Type.BOOLEAN:
-            case Type.CHAR:
-            case Type.BYTE:
-            case Type.SHORT:
-            case Type.INT:
-                t = Opcodes.INTEGER;
-                break;
-            case Type.FLOAT:
-                t = Opcodes.FLOAT;
-                break;
-            case Type.LONG:
-                t = Opcodes.LONG;
-                break;
-            case Type.DOUBLE:
-                t = Opcodes.DOUBLE;
-                break;
-            case Type.ARRAY:
-                t = type.getDescriptor();
-                break;
-            // case Type.OBJECT:
-            default:
-                t = type.getInternalName();
-                break;
-        }
-        int local = nextLocal;
-        nextLocal += type.getSize();
-        setLocalType(local, type);
-        setFrameLocal(local, t);
-        return local;
-    }
-
-    /**
-     * Sets the current type of the given local variable. The default
-     * implementation of this method does nothing.
-     *
-     * @param local a local variable identifier, as returned by {@link #newLocal
-     *        newLocal()}.
-     * @param type the type of the value being stored in the local variable
-     */
-    protected void setLocalType(final int local, final Type type) {
-    }
-
-    private void setFrameLocal(final int local, final Object type) {
-        int l = newLocals.length;
-        if (local >= l) {
-            Object[] a = new Object[Math.max(2 * l, local + 1)];
-            System.arraycopy(newLocals, 0, a, 0, l);
-            newLocals = a;
-        }
-        newLocals[local] = type;
-    }
-
-    private int remap(final int var, final Type type) {
-        if (var + type.getSize() <= firstLocal) {
-            return var;
-        }
-        int key = 2 * var + type.getSize() - 1;
-        int size = mapping.length;
-        if (key >= size) {
-            int[] newMapping = new int[Math.max(2 * size, key + 1)];
-            System.arraycopy(mapping, 0, newMapping, 0, size);
-            mapping = newMapping;
-        }
-        int value = mapping[key];
-        if (value == 0) {
-            value = newLocalMapping(type);
-            setLocalType(value, type);
-            mapping[key] = value + 1;
-        } else {
-            value--;
-        }
-        if (value != var) {
-            changed = true;
-        }
-        return value;
-    }
-
-    protected int newLocalMapping(final Type type) {
-        int local = nextLocal;
-        nextLocal += type.getSize();
-        return local;
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/Method.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/Method.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/Method.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/Method.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,275 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.Type;
-
-/**
- * A named method descriptor.
- * 
- * @author Juozas Baliuka
- * @author Chris Nokleberg
- * @author Eric Bruneton
- */
-public class Method {
-
-    /**
-     * The method name.
-     */
-    private final String name;
-
-    /**
-     * The method descriptor.
-     */
-    private final String desc;
-
-    /**
-     * Maps primitive Java type names to their descriptors.
-     */
-    private static final Map DESCRIPTORS;
-
-    static {
-        DESCRIPTORS = new HashMap();
-        DESCRIPTORS.put("void", "V");
-        DESCRIPTORS.put("byte", "B");
-        DESCRIPTORS.put("char", "C");
-        DESCRIPTORS.put("double", "D");
-        DESCRIPTORS.put("float", "F");
-        DESCRIPTORS.put("int", "I");
-        DESCRIPTORS.put("long", "J");
-        DESCRIPTORS.put("short", "S");
-        DESCRIPTORS.put("boolean", "Z");
-    }
-
-    /**
-     * Creates a new {@link Method}.
-     * 
-     * @param name the method's name.
-     * @param desc the method's descriptor.
-     */
-    public Method(final String name, final String desc) {
-        this.name = name;
-        this.desc = desc;
-    }
-
-    /**
-     * Creates a new {@link Method}.
-     * 
-     * @param name the method's name.
-     * @param returnType the method's return type.
-     * @param argumentTypes the method's argument types.
-     */
-    public Method(
-        final String name,
-        final Type returnType,
-        final Type[] argumentTypes)
-    {
-        this(name, Type.getMethodDescriptor(returnType, argumentTypes));
-    }
-    
-    /**
-     * Creates a new {@link Method}.
-     * 
-     * @param m a java.lang.reflect method descriptor
-     * @return a {@link Method} corresponding to the given Java method
-     *         declaration.
-     */
-    public static Method getMethod(java.lang.reflect.Method m) {
-        return new Method(m.getName(), Type.getMethodDescriptor(m));
-    }
-
-    /**
-     * Creates a new {@link Method}.
-     * 
-     * @param c a java.lang.reflect constructor descriptor
-     * @return a {@link Method} corresponding to the given Java constructor
-     *         declaration.
-     */
-    public static Method getMethod(java.lang.reflect.Constructor c) {
-        return new Method("<init>", Type.getConstructorDescriptor(c));
-    }
-    
-    /**
-     * Returns a {@link Method} corresponding to the given Java method
-     * declaration.
-     * 
-     * @param method a Java method declaration, without argument names, of the
-     *        form "returnType name (argumentType1, ... argumentTypeN)", where
-     *        the types are in plain Java (e.g. "int", "float",
-     *        "java.util.List", ...). Classes of the java.lang package can be
-     *        specified by their unqualified name; all other classes names must
-     *        be fully qualified.
-     * @return a {@link Method} corresponding to the given Java method
-     *         declaration.
-     * @throws IllegalArgumentException if <code>method</code> could not get
-     *         parsed.
-     */
-    public static Method getMethod(final String method)
-            throws IllegalArgumentException
-    {
-        return getMethod(method, false);
-    }
-
-    /**
-     * Returns a {@link Method} corresponding to the given Java method
-     * declaration.
-     * 
-     * @param method a Java method declaration, without argument names, of the
-     *        form "returnType name (argumentType1, ... argumentTypeN)", where
-     *        the types are in plain Java (e.g. "int", "float",
-     *        "java.util.List", ...). Classes of the java.lang package may be
-     *        specified by their unqualified name, depending on the
-     *        defaultPackage argument; all other classes names must be fully
-     *        qualified.
-     * @param defaultPackage true if unqualified class names belong to the
-     *        default package, or false if they correspond to java.lang classes.
-     *        For instance "Object" means "Object" if this option is true, or
-     *        "java.lang.Object" otherwise.
-     * @return a {@link Method} corresponding to the given Java method
-     *         declaration.
-     * @throws IllegalArgumentException if <code>method</code> could not get
-     *         parsed.
-     */
-    public static Method getMethod(
-        final String method,
-        final boolean defaultPackage) throws IllegalArgumentException
-    {
-        int space = method.indexOf(' ');
-        int start = method.indexOf('(', space) + 1;
-        int end = method.indexOf(')', start);
-        if (space == -1 || start == -1 || end == -1) {
-            throw new IllegalArgumentException();
-        }
-        String returnType = method.substring(0, space);
-        String methodName = method.substring(space + 1, start - 1).trim();
-        StringBuffer sb = new StringBuffer();
-        sb.append('(');
-        int p;
-        do {
-            String s;
-            p = method.indexOf(',', start);
-            if (p == -1) {
-                s = map(method.substring(start, end).trim(), defaultPackage);
-            } else {
-                s = map(method.substring(start, p).trim(), defaultPackage);
-                start = p + 1;
-            }
-            sb.append(s);
-        } while (p != -1);
-        sb.append(')');
-        sb.append(map(returnType, defaultPackage));
-        return new Method(methodName, sb.toString());
-    }
-
-    private static String map(final String type, final boolean defaultPackage) {
-        if ("".equals(type)) {
-            return type;
-        }
-
-        StringBuffer sb = new StringBuffer();
-        int index = 0;
-        while ((index = type.indexOf("[]", index) + 1) > 0) {
-            sb.append('[');
-        }
-
-        String t = type.substring(0, type.length() - sb.length() * 2);
-        String desc = (String) DESCRIPTORS.get(t);
-        if (desc != null) {
-            sb.append(desc);
-        } else {
-            sb.append('L');
-            if (t.indexOf('.') < 0) {
-                if (!defaultPackage) {
-                    sb.append("java/lang/");
-                }
-                sb.append(t);
-            } else {
-                sb.append(t.replace('.', '/'));
-            }
-            sb.append(';');
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Returns the name of the method described by this object.
-     * 
-     * @return the name of the method described by this object.
-     */
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Returns the descriptor of the method described by this object.
-     * 
-     * @return the descriptor of the method described by this object.
-     */
-    public String getDescriptor() {
-        return desc;
-    }
-
-    /**
-     * Returns the return type of the method described by this object.
-     * 
-     * @return the return type of the method described by this object.
-     */
-    public Type getReturnType() {
-        return Type.getReturnType(desc);
-    }
-
-    /**
-     * Returns the argument types of the method described by this object.
-     * 
-     * @return the argument types of the method described by this object.
-     */
-    public Type[] getArgumentTypes() {
-        return Type.getArgumentTypes(desc);
-    }
-
-    public String toString() {
-        return name + desc;
-    }
-
-    public boolean equals(final Object o) {
-        if (!(o instanceof Method)) {
-            return false;
-        }
-        Method other = (Method) o;
-        return name.equals(other.name) && desc.equals(other.desc);
-    }
-
-    public int hashCode() {
-        return name.hashCode() ^ desc.hashCode();
-    }
-}
\ Manca newline alla fine del file
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/package.html eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/package.html
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/package.html	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/package.html	1970-01-01 01:00:00.000000000 +0100
@@ -1,48 +0,0 @@
-<html>
-<!--
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2005 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
--->
-<body>
-Provides some useful class and method adapters. <i>The preferred way of using 
-these adapters is by chaining them together and to custom adapters (instead of
-inheriting from them)</i>. Indeed this approach provides more combination 
-possibilities than inheritance. For instance, suppose you want to implement an
-adapter MyAdapter than needs sorted local variables and intermediate stack map
-frame values taking into account the local variables sort. By using inheritance,
-this would require MyAdapter to extend AnalyzerAdapter, itself extending 
-LocalVariablesSorter. But AnalyzerAdapter is not a subclass of 
-LocalVariablesSorter, so this is not possible. On the contrary, by using 
-delegation, you can make LocalVariablesSorter delegate to AnalyzerAdapter, 
-itself delegating to MyAdapter. In this case AnalyzerAdapter computes 
-intermediate frames based on the output of LocalVariablesSorter, and MyAdapter
-can add new locals by calling the newLocal method on LocalVariablesSorter, and
-can get the stack map frame state before each instruction by reading the locals
-and stack fields in AnalyzerAdapter (this requires references from MyAdapter 
-back to LocalVariablesSorter and AnalyzerAdapter).
-</body>
\ Manca newline alla fine del file
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/Remapper.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/Remapper.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/Remapper.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/Remapper.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,187 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import org.eclipse.persistence.internal.libraries.asm.Type;
-import org.eclipse.persistence.internal.libraries.asm.signature.SignatureReader;
-import org.eclipse.persistence.internal.libraries.asm.signature.SignatureVisitor;
-import org.eclipse.persistence.internal.libraries.asm.signature.SignatureWriter;
-
-/**
- * A class responsible for remapping types and names.
- * Subclasses can override the following methods:
- * 
- * <ul>
- * <li>{@link #map(String)} - map type</li>
- * <li>{@link #mapFieldName(String, String, String)} - map field name</li>
- * <li>{@link #mapMethodName(String, String, String)} - map method name</li>
- * </ul>
- * 
- * @author Eugene Kuleshov
- */
-public abstract class Remapper {
-
-    public String mapDesc(String desc) {
-        Type t = Type.getType(desc);
-        switch (t.getSort()) {
-            case Type.ARRAY:
-                String s = mapDesc(t.getElementType().getDescriptor());
-                for (int i = 0; i < t.getDimensions(); ++i) {
-                    s = '[' + s;
-                }
-                return s;
-            case Type.OBJECT:
-                String newType = map(t.getInternalName());
-                if (newType != null) {
-                    return 'L' + newType + ';';
-                }
-        }
-        return desc;
-    }
-
-    private Type mapType(Type t) {
-        switch (t.getSort()) {
-            case Type.ARRAY:
-                String s = mapDesc(t.getElementType().getDescriptor());
-                for (int i = 0; i < t.getDimensions(); ++i) {
-                    s = '[' + s;
-                }
-                return Type.getType(s);
-            case Type.OBJECT:
-                s = map(t.getInternalName());
-                if(s != null) {
-                    return Type.getObjectType(s);
-                }
-        }
-        return t;
-    }
-
-    public String mapType(String type) {
-        if (type == null) {
-            return null;
-        }
-        return mapType(Type.getObjectType(type)).getInternalName();
-    }
-
-    public String[] mapTypes(String[] types) {
-        String[] newTypes = null;
-        boolean needMapping = false;
-        for (int i = 0; i < types.length; i++) {
-            String type = types[i];
-            String newType = map(type);
-            if (newType != null && newTypes == null) {
-                newTypes = new String[types.length];
-                if (i > 0) {
-                    System.arraycopy(types, 0, newTypes, 0, i);
-                }
-                needMapping = true;
-            }
-            if (needMapping) {
-                newTypes[i] = newType == null 
-                    ? type 
-                    : newType;
-            }
-        }
-        return needMapping 
-           ? newTypes 
-           : types;
-    }
-
-    public String mapMethodDesc(String desc) {
-        if("()V".equals(desc)) {
-            return desc;
-        }
-        
-        Type[] args = Type.getArgumentTypes(desc);
-        String s = "(";
-        for (int i = 0; i < args.length; i++) {
-            s += mapDesc(args[i].getDescriptor());
-        }
-        Type returnType = Type.getReturnType(desc);
-        if(returnType == Type.VOID_TYPE) {
-            return s + ")V";
-        }
-        return s + ')' + mapDesc(returnType.getDescriptor());
-    }
-
-    public Object mapValue(Object value) {
-        return value instanceof Type ? mapType((Type) value) : value;
-    }
-
-    /**
-     * 
-     * @param typeSignature true if signature is a FieldTypeSignature, such as
-     *        the signature parameter of the ClassVisitor.visitField or
-     *        MethodVisitor.visitLocalVariable methods
-     */
-    public String mapSignature(String signature, boolean typeSignature) {
-        if (signature == null) {
-            return null;
-        }
-        SignatureReader r = new SignatureReader(signature);
-        SignatureWriter w = new SignatureWriter();
-        SignatureVisitor a = createRemappingSignatureAdapter(w);
-        if (typeSignature) {
-            r.acceptType(a);
-        } else {
-            r.accept(a);
-        }
-        return w.toString();
-    }
-
-    protected SignatureVisitor createRemappingSignatureAdapter(
-        SignatureVisitor v)
-    {
-        return new RemappingSignatureAdapter(v, this);
-    }
-    
-    /**
-     * Map method name to the new name. Subclasses can override. 
-     */
-    public String mapMethodName(String owner, String name, String desc) {
-        return name;
-    }
-
-    /**
-     * Map field name to the new name. Subclasses can override. 
-     */
-    public String mapFieldName(String owner, String name, String desc) {
-        return name;
-    }
-    
-    /**
-     * Map type name to the new name. Subclasses can override. 
-     */
-    public String map(String typeName) {
-        return typeName;
-    }
-
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/RemappingAnnotationAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/RemappingAnnotationAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/RemappingAnnotationAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/RemappingAnnotationAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-
-/**
- * An <code>AnnotationVisitor</code> adapter for type remapping.
- * 
- * @author Eugene Kuleshov
- */
-public class RemappingAnnotationAdapter implements AnnotationVisitor {
-    
-    private final AnnotationVisitor av;
-    
-    private final Remapper renamer;
-
-    public RemappingAnnotationAdapter(AnnotationVisitor av, Remapper renamer) {
-        this.av = av;
-        this.renamer = renamer;
-    }
-
-    public void visit(String name, Object value) {
-        av.visit(name, renamer.mapValue(value));
-    }
-
-    public void visitEnum(String name, String desc, String value) {
-        av.visitEnum(name, renamer.mapDesc(desc), value);
-    }
-
-    public AnnotationVisitor visitAnnotation(String name, String desc) {
-        AnnotationVisitor v = av.visitAnnotation(name, renamer.mapDesc(desc));
-        return v == null ? null : (v == av
-                ? this
-                : new RemappingAnnotationAdapter(v, renamer));
-    }
-
-    public AnnotationVisitor visitArray(String name) {
-        AnnotationVisitor v = av.visitArray(name);
-        return v == null ? null : (v == av
-                ? this
-                : new RemappingAnnotationAdapter(v, renamer));
-    }
-
-    public void visitEnd() {
-        av.visitEnd();
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/RemappingClassAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/RemappingClassAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/RemappingClassAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/RemappingClassAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,145 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.ClassAdapter;
-import org.eclipse.persistence.internal.libraries.asm.ClassVisitor;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-/**
- * A <code>ClassAdapter</code> for type remapping.
- * 
- * @author Eugene Kuleshov
- */
-public class RemappingClassAdapter extends ClassAdapter {
-
-    protected final Remapper remapper;
-    
-    protected String className;
-
-    public RemappingClassAdapter(ClassVisitor cv, Remapper remapper) {
-        super(cv);
-        this.remapper = remapper;
-    }
-
-    public void visit(
-        int version,
-        int access,
-        String name,
-        String signature,
-        String superName,
-        String[] interfaces)
-    {
-        this.className = name;
-        super.visit(version,
-                access,
-                remapper.mapType(name),
-                remapper.mapSignature(signature, false),
-                remapper.mapType(superName),
-                interfaces == null ? null 
-                        : remapper.mapTypes(interfaces));
-    }
-
-    public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
-        AnnotationVisitor av;
-        av = super.visitAnnotation(remapper.mapDesc(desc), visible);
-        return av == null ? null : createRemappingAnnotationAdapter(av);
-    }
-
-    public FieldVisitor visitField(
-        int access,
-        String name,
-        String desc,
-        String signature,
-        Object value)
-    {
-        FieldVisitor fv = super.visitField(access,
-                remapper.mapFieldName(className, name, desc),
-                remapper.mapDesc(desc),
-                remapper.mapSignature(signature, true),
-                remapper.mapValue(value));
-        return fv == null ? null : createRemappingFieldAdapter(fv);
-    }
-
-    public MethodVisitor visitMethod(
-        int access,
-        String name,
-        String desc,
-        String signature,
-        String[] exceptions)
-    {
-        String newDesc = remapper.mapMethodDesc(desc);
-        MethodVisitor mv = super.visitMethod(access,
-                remapper.mapMethodName(className, name, desc),
-                newDesc,
-                remapper.mapSignature(signature, false),
-                exceptions == null ? null : remapper.mapTypes(exceptions));
-        return mv == null ? null : createRemappingMethodAdapter(access, newDesc, mv);
-    }
-
-    public void visitInnerClass(
-        String name,
-        String outerName,
-        String innerName,
-        int access)
-    {
-        super.visitInnerClass(remapper.mapType(name),
-                outerName == null ? null : remapper.mapType(outerName),
-                innerName, // TODO should it be changed?
-                access);
-    }
-
-    public void visitOuterClass(String owner, String name, String desc) {
-        super.visitOuterClass(remapper.mapType(owner), 
-                name == null ? null : remapper.mapMethodName(owner, name, desc), 
-                desc == null ? null : remapper.mapMethodDesc(desc));
-    }
-
-    protected FieldVisitor createRemappingFieldAdapter(FieldVisitor fv) {
-        return new RemappingFieldAdapter(fv, remapper);
-    }
-    
-    protected MethodVisitor createRemappingMethodAdapter(
-        int access,
-        String newDesc,
-        MethodVisitor mv)
-    {
-        return new RemappingMethodAdapter(access, newDesc, mv, remapper);
-    }
-
-    protected AnnotationVisitor createRemappingAnnotationAdapter(
-        AnnotationVisitor av)
-    {
-        return new RemappingAnnotationAdapter(av, remapper);
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/RemappingFieldAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/RemappingFieldAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/RemappingFieldAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/RemappingFieldAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,65 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-
-/**
- * A <code>FieldVisitor</code> adapter for type remapping.
- * 
- * @author Eugene Kuleshov
- */
-public class RemappingFieldAdapter implements FieldVisitor {
-
-    private final FieldVisitor fv;
-    
-    private final Remapper remapper;
-
-    public RemappingFieldAdapter(FieldVisitor fv, Remapper remapper) {
-        this.fv = fv;
-        this.remapper = remapper;
-    }
-
-    public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
-        AnnotationVisitor av = fv.visitAnnotation(remapper.mapDesc(desc), visible);
-        return av == null ? null : new RemappingAnnotationAdapter(av, remapper);
-    }
-
-    public void visitAttribute(Attribute attr) {
-        fv.visitAttribute(attr);
-    }
-
-    public void visitEnd() {
-        fv.visitEnd();
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/RemappingMethodAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/RemappingMethodAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/RemappingMethodAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/RemappingMethodAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,168 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-/**
- * A <code>MethodAdapter</code> for type mapping.
- * 
- * @author Eugene Kuleshov
- */
-public class RemappingMethodAdapter extends LocalVariablesSorter {
-
-    protected final Remapper remapper;
-
-    public RemappingMethodAdapter(
-        int access,
-        String desc,
-        MethodVisitor mv,
-        Remapper renamer)
-    {
-        super(access, desc, mv);
-        this.remapper = renamer;
-    }
-
-    public void visitFieldInsn(
-        int opcode,
-        String owner,
-        String name,
-        String desc)
-    {
-        super.visitFieldInsn(opcode,
-                remapper.mapType(owner),
-                remapper.mapFieldName(owner, name, desc),
-                remapper.mapDesc(desc));
-    }
-
-    public void visitMethodInsn(
-        int opcode,
-        String owner,
-        String name,
-        String desc)
-    {
-        super.visitMethodInsn(opcode,
-                remapper.mapType(owner),
-                remapper.mapMethodName(owner, name, desc),
-                remapper.mapMethodDesc(desc));
-    }
-
-    public void visitTypeInsn(int opcode, String type) {
-        super.visitTypeInsn(opcode, remapper.mapType(type));
-    }
-
-    public void visitLdcInsn(Object cst) {
-        super.visitLdcInsn(remapper.mapValue(cst));
-    }
-
-    public void visitMultiANewArrayInsn(String desc, int dims) {
-        super.visitMultiANewArrayInsn(remapper.mapDesc(desc), dims);
-    }
-
-    public void visitTryCatchBlock(
-        Label start,
-        Label end,
-        Label handler,
-        String type)
-    {
-        super.visitTryCatchBlock(start, end, handler, // 
-                type == null ? null : remapper.mapType(type));
-    }
-    
-    public void visitLocalVariable(
-        String name,
-        String desc,
-        String signature,
-        Label start,
-        Label end,
-        int index)
-    {
-        super.visitLocalVariable(name,
-                remapper.mapDesc(desc),
-                remapper.mapSignature(signature, true),
-                start,
-                end,
-                index);
-    }
-
-    public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
-        AnnotationVisitor av = mv.visitAnnotation(remapper.mapDesc(desc), visible);
-        return av == null ? av : new RemappingAnnotationAdapter(av, remapper);
-    }
-    
-    public AnnotationVisitor visitAnnotationDefault() {
-        AnnotationVisitor av = mv.visitAnnotationDefault();
-        return av == null ? av : new RemappingAnnotationAdapter(av, remapper);
-    }
-    
-    public AnnotationVisitor visitParameterAnnotation(
-        int parameter,
-        String desc,
-        boolean visible)
-    {
-        AnnotationVisitor av = mv.visitParameterAnnotation(parameter,
-                remapper.mapDesc(desc),
-                visible);
-        return av == null ? av : new RemappingAnnotationAdapter(av, remapper);
-    }
-    
-    public void visitFrame(
-        int type,
-        int nLocal,
-        Object[] local,
-        int nStack,
-        Object[] stack)
-    {
-        super.visitFrame(type, nLocal, remapEntries(nLocal, local), nStack, remapEntries(nStack, stack));
-    }
-
-    private Object[] remapEntries(int n, Object[] entries) {
-        for (int i = 0; i < n; i++) {
-            if (entries[i] instanceof String) {
-                Object[] newEntries = new Object[n];
-                if (i > 0) {
-                    System.arraycopy(entries, 0, newEntries, 0, i);
-                }
-                do {
-                    Object t = entries[i];
-                    newEntries[i++] = t instanceof String
-                            ? remapper.mapType((String) t)
-                            : t;
-                } while (i < n);
-                return newEntries;
-            }
-        }
-        return entries;
-    }
-    
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/RemappingSignatureAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/RemappingSignatureAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/RemappingSignatureAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/RemappingSignatureAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,126 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import org.eclipse.persistence.internal.libraries.asm.signature.SignatureVisitor;
-
-/**
- * A <code>SignatureVisitor</code> adapter for type mapping.
- * 
- * @author Eugene Kuleshov
- */
-public class RemappingSignatureAdapter implements SignatureVisitor {
-    private final SignatureVisitor v;
-    private final Remapper remapper;
-    private String className;
-    
-    public RemappingSignatureAdapter(SignatureVisitor v, Remapper remapper) {
-        this.v = v;
-        this.remapper = remapper;
-    }
-
-    public void visitClassType(String name) {
-        className = name;
-        v.visitClassType(remapper.mapType(name));
-    }
-
-    public void visitInnerClassType(String name) {
-        className = className + '$' + name;
-        String remappedName = remapper.mapType(className);
-        v.visitInnerClassType(remappedName.substring(remappedName.lastIndexOf('$') + 1));
-    }
-
-    public void visitFormalTypeParameter(String name) {
-        v.visitFormalTypeParameter(name);
-    }
-
-    public void visitTypeVariable(String name) {
-        v.visitTypeVariable(name);
-    }
-
-    public SignatureVisitor visitArrayType() {
-        v.visitArrayType();
-        return this;
-    }
-
-    public void visitBaseType(char descriptor) {
-        v.visitBaseType(descriptor);
-    }
-
-    public SignatureVisitor visitClassBound() {
-        v.visitClassBound();
-        return this;
-    }
-
-    public SignatureVisitor visitExceptionType() {
-        v.visitExceptionType();
-        return this;
-    }
-
-    public SignatureVisitor visitInterface() {
-        v.visitInterface();
-        return this;
-    }
-
-    public SignatureVisitor visitInterfaceBound() {
-        v.visitInterfaceBound();
-        return this;
-    }
-
-    public SignatureVisitor visitParameterType() {
-        v.visitParameterType();
-        return this;
-    }
-
-    public SignatureVisitor visitReturnType() {
-        v.visitReturnType();
-        return this;
-    }
-
-    public SignatureVisitor visitSuperclass() {
-        v.visitSuperclass();
-        return this;
-    }
-
-    public void visitTypeArgument() {
-        v.visitTypeArgument();
-    }
-
-    public SignatureVisitor visitTypeArgument(char wildcard) {
-        v.visitTypeArgument(wildcard);
-        return this;
-    }
-
-    public void visitEnd() {
-        v.visitEnd();
-    }
-
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/SerialVersionUIDAdder.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/SerialVersionUIDAdder.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/SerialVersionUIDAdder.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/SerialVersionUIDAdder.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,499 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutput;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.security.MessageDigest;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-
-import org.eclipse.persistence.internal.libraries.asm.ClassAdapter;
-import org.eclipse.persistence.internal.libraries.asm.ClassVisitor;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-
-/**
- * A {@link ClassAdapter} that adds a serial version unique identifier to a
- * class if missing. Here is typical usage of this class:
- * 
- * <pre>
- *   ClassWriter cw = new ClassWriter(...);
- *   ClassVisitor sv = new SerialVersionUIDAdder(cw);
- *   ClassVisitor ca = new MyClassAdapter(sv);
- *   new ClassReader(orginalClass).accept(ca, false);
- * </pre>
- * 
- * The SVUID algorithm can be found <a href=
- * "http://java.sun.com/j2se/1.4.2/docs/guide/serialization/spec/class.html"
- * >http://java.sun.com/j2se/1.4.2/docs/guide/serialization/spec/class.html</a>:
- * 
- * <pre>
- * The serialVersionUID is computed using the signature of a stream of bytes
- * that reflect the class definition. The National Institute of Standards and
- * Technology (NIST) Secure Hash Algorithm (SHA-1) is used to compute a
- * signature for the stream. The first two 32-bit quantities are used to form a
- * 64-bit hash. A java.lang.DataOutputStream is used to convert primitive data
- * types to a sequence of bytes. The values input to the stream are defined by
- * the Java Virtual Machine (VM) specification for classes.
- *
- * The sequence of items in the stream is as follows:
- *
- * 1. The class name written using UTF encoding.
- * 2. The class modifiers written as a 32-bit integer.
- * 3. The name of each interface sorted by name written using UTF encoding.
- * 4. For each field of the class sorted by field name (except private static
- * and private transient fields):
- * 1. The name of the field in UTF encoding.
- * 2. The modifiers of the field written as a 32-bit integer.
- * 3. The descriptor of the field in UTF encoding
- * 5. If a class initializer exists, write out the following:
- * 1. The name of the method, &lt;clinit&gt;, in UTF encoding.
- * 2. The modifier of the method, java.lang.reflect.Modifier.STATIC,
- * written as a 32-bit integer.
- * 3. The descriptor of the method, ()V, in UTF encoding.
- * 6. For each non-private constructor sorted by method name and signature:
- * 1. The name of the method, &lt;init&gt;, in UTF encoding.
- * 2. The modifiers of the method written as a 32-bit integer.
- * 3. The descriptor of the method in UTF encoding.
- * 7. For each non-private method sorted by method name and signature:
- * 1. The name of the method in UTF encoding.
- * 2. The modifiers of the method written as a 32-bit integer.
- * 3. The descriptor of the method in UTF encoding.
- * 8. The SHA-1 algorithm is executed on the stream of bytes produced by
- * DataOutputStream and produces five 32-bit values sha[0..4].
- *
- * 9. The hash value is assembled from the first and second 32-bit values of 
- * the SHA-1 message digest. If the result of the message digest, the five
- * 32-bit words H0 H1 H2 H3 H4, is in an array of five int values named 
- * sha, the hash value would be computed as follows:
- *
- * long hash = ((sha[0] &gt;&gt;&gt; 24) &amp; 0xFF) |
- * ((sha[0] &gt;&gt;&gt; 16) &amp; 0xFF) &lt;&lt; 8 |
- * ((sha[0] &gt;&gt;&gt; 8) &amp; 0xFF) &lt;&lt; 16 |
- * ((sha[0] &gt;&gt;&gt; 0) &amp; 0xFF) &lt;&lt; 24 |
- * ((sha[1] &gt;&gt;&gt; 24) &amp; 0xFF) &lt;&lt; 32 |
- * ((sha[1] &gt;&gt;&gt; 16) &amp; 0xFF) &lt;&lt; 40 |
- * ((sha[1] &gt;&gt;&gt; 8) &amp; 0xFF) &lt;&lt; 48 |
- * ((sha[1] &gt;&gt;&gt; 0) &amp; 0xFF) &lt;&lt; 56;
- * </pre>
- * 
- * @author Rajendra Inamdar, Vishal Vishnoi
- */
-public class SerialVersionUIDAdder extends ClassAdapter {
-
-    /**
-     * Flag that indicates if we need to compute SVUID.
-     */
-    protected boolean computeSVUID;
-
-    /**
-     * Set to true if the class already has SVUID.
-     */
-    protected boolean hasSVUID;
-
-    /**
-     * Classes access flags.
-     */
-    protected int access;
-
-    /**
-     * Internal name of the class
-     */
-    protected String name;
-
-    /**
-     * Interfaces implemented by the class.
-     */
-    protected String[] interfaces;
-
-    /**
-     * Collection of fields. (except private static and private transient
-     * fields)
-     */
-    protected Collection svuidFields;
-
-    /**
-     * Set to true if the class has static initializer.
-     */
-    protected boolean hasStaticInitializer;
-
-    /**
-     * Collection of non-private constructors.
-     */
-    protected Collection svuidConstructors;
-
-    /**
-     * Collection of non-private methods.
-     */
-    protected Collection svuidMethods;
-
-    /**
-     * Creates a new {@link SerialVersionUIDAdder}.
-     * 
-     * @param cv a {@link ClassVisitor} to which this visitor will delegate
-     *        calls.
-     */
-    public SerialVersionUIDAdder(final ClassVisitor cv) {
-        super(cv);
-        svuidFields = new ArrayList();
-        svuidConstructors = new ArrayList();
-        svuidMethods = new ArrayList();
-    }
-
-    // ------------------------------------------------------------------------
-    // Overriden methods
-    // ------------------------------------------------------------------------
-
-    /*
-     * Visit class header and get class name, access , and interfaces
-     * information (step 1,2, and 3) for SVUID computation.
-     */
-    public void visit(
-        final int version,
-        final int access,
-        final String name,
-        final String signature,
-        final String superName,
-        final String[] interfaces)
-    {
-        computeSVUID = (access & Opcodes.ACC_INTERFACE) == 0;
-
-        if (computeSVUID) {
-            this.name = name;
-            this.access = access;
-            this.interfaces = interfaces;
-        }
-
-        super.visit(version, access, name, signature, superName, interfaces);
-    }
-
-    /*
-     * Visit the methods and get constructor and method information (step 5 and
-     * 7). Also determine if there is a class initializer (step 6).
-     */
-    public MethodVisitor visitMethod(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final String[] exceptions)
-    {
-        if (computeSVUID) {
-            if ("<clinit>".equals(name)) {
-                hasStaticInitializer = true;
-            }
-            /*
-             * Remembers non private constructors and methods for SVUID
-             * computation For constructor and method modifiers, only the
-             * ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,
-             * ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT and ACC_STRICT flags
-             * are used.
-             */
-            int mods = access
-                    & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PRIVATE
-                            | Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC
-                            | Opcodes.ACC_FINAL | Opcodes.ACC_SYNCHRONIZED
-                            | Opcodes.ACC_NATIVE | Opcodes.ACC_ABSTRACT | Opcodes.ACC_STRICT);
-
-            // all non private methods
-            if ((access & Opcodes.ACC_PRIVATE) == 0) {
-                if ("<init>".equals(name)) {
-                    svuidConstructors.add(new Item(name, mods, desc));
-                } else if (!"<clinit>".equals(name)) {
-                    svuidMethods.add(new Item(name, mods, desc));
-                }
-            }
-        }
-
-        return cv.visitMethod(access, name, desc, signature, exceptions);
-    }
-
-    /*
-     * Gets class field information for step 4 of the algorithm. Also determines
-     * if the class already has a SVUID.
-     */
-    public FieldVisitor visitField(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final Object value)
-    {
-        if (computeSVUID) {
-            if ("serialVersionUID".equals(name)) {
-                // since the class already has SVUID, we won't be computing it.
-                computeSVUID = false;
-                hasSVUID = true;
-            }
-            /*
-             * Remember field for SVUID computation For field modifiers, only
-             * the ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC,
-             * ACC_FINAL, ACC_VOLATILE, and ACC_TRANSIENT flags are used when
-             * computing serialVersionUID values.
-             */
-            if ((access & Opcodes.ACC_PRIVATE) == 0
-                    || (access & (Opcodes.ACC_STATIC | Opcodes.ACC_TRANSIENT)) == 0)
-            {
-                int mods = access
-                & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PRIVATE
-                        | Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC
-                        | Opcodes.ACC_FINAL | Opcodes.ACC_VOLATILE | Opcodes.ACC_TRANSIENT);
-                svuidFields.add(new Item(name, mods, desc));
-            }
-        }
-
-        return super.visitField(access, name, desc, signature, value);
-    }
-
-    /**
-     * Handle a bizarre special case. Nested classes (static classes declared
-     * inside another class) that are protected have their access bit set to
-     * public in their class files to deal with some odd reflection situation.
-     * Our SVUID computation must do as the JVM does and ignore access bits in
-     * the class file in favor of the access bits InnerClass attribute.
-     */
-    public void visitInnerClass(final String aname, final String outerName, final String innerName, final int attr_access) {
-        if ((name != null) && name.equals(aname)) {
-            this.access = attr_access;
-        }
-        super.visitInnerClass(aname, outerName, innerName, attr_access);
-    }
-    
-    /*
-     * Add the SVUID if class doesn't have one
-     */
-    public void visitEnd() {
-        // compute SVUID and add it to the class
-        if (computeSVUID && !hasSVUID) {
-            try {
-                cv.visitField(Opcodes.ACC_FINAL + Opcodes.ACC_STATIC,
-                        "serialVersionUID",
-                        "J",
-                        null,
-                        new Long(computeSVUID()));
-            } catch (Throwable e) {
-                throw new RuntimeException("Error while computing SVUID for "
-                        + name, e);
-            }
-        }
-
-        super.visitEnd();
-    }
-
-    // ------------------------------------------------------------------------
-    // Utility methods
-    // ------------------------------------------------------------------------
-
-    /**
-     * Returns the value of SVUID if the class doesn't have one already. Please
-     * note that 0 is returned if the class already has SVUID, thus use
-     * <code>isHasSVUID</code> to determine if the class already had an SVUID.
-     * 
-     * @return Returns the serial version UID
-     */
-    protected long computeSVUID() throws IOException {
-        ByteArrayOutputStream bos;
-        DataOutputStream dos = null;
-        long svuid = 0;
-
-        try {
-            bos = new ByteArrayOutputStream();
-            dos = new DataOutputStream(bos);
-
-            /*
-             * 1. The class name written using UTF encoding.
-             */
-            dos.writeUTF(name.replace('/', '.'));
-
-            /*
-             * 2. The class modifiers written as a 32-bit integer.
-             */
-            dos.writeInt(access
-                    & (Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL
-                            | Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT));
-
-            /*
-             * 3. The name of each interface sorted by name written using UTF
-             * encoding.
-             */
-            Arrays.sort(interfaces);
-            for (int i = 0; i < interfaces.length; i++) {
-                dos.writeUTF(interfaces[i].replace('/', '.'));
-            }
-
-            /*
-             * 4. For each field of the class sorted by field name (except
-             * private static and private transient fields):
-             * 
-             * 1. The name of the field in UTF encoding. 2. The modifiers of the
-             * field written as a 32-bit integer. 3. The descriptor of the field
-             * in UTF encoding
-             * 
-             * Note that field signatures are not dot separated. Method and
-             * constructor signatures are dot separated. Go figure...
-             */
-            writeItems(svuidFields, dos, false);
-
-            /*
-             * 5. If a class initializer exists, write out the following: 1. The
-             * name of the method, <clinit>, in UTF encoding. 2. The modifier of
-             * the method, java.lang.reflect.Modifier.STATIC, written as a
-             * 32-bit integer. 3. The descriptor of the method, ()V, in UTF
-             * encoding.
-             */
-            if (hasStaticInitializer) {
-                dos.writeUTF("<clinit>");
-                dos.writeInt(Opcodes.ACC_STATIC);
-                dos.writeUTF("()V");
-            } // if..
-
-            /*
-             * 6. For each non-private constructor sorted by method name and
-             * signature: 1. The name of the method, <init>, in UTF encoding. 2.
-             * The modifiers of the method written as a 32-bit integer. 3. The
-             * descriptor of the method in UTF encoding.
-             */
-            writeItems(svuidConstructors, dos, true);
-
-            /*
-             * 7. For each non-private method sorted by method name and
-             * signature: 1. The name of the method in UTF encoding. 2. The
-             * modifiers of the method written as a 32-bit integer. 3. The
-             * descriptor of the method in UTF encoding.
-             */
-            writeItems(svuidMethods, dos, true);
-
-            dos.flush();
-
-            /*
-             * 8. The SHA-1 algorithm is executed on the stream of bytes
-             * produced by DataOutputStream and produces five 32-bit values
-             * sha[0..4].
-             */
-            byte[] hashBytes = computeSHAdigest(bos.toByteArray());
-
-            /*
-             * 9. The hash value is assembled from the first and second 32-bit
-             * values of the SHA-1 message digest. If the result of the message
-             * digest, the five 32-bit words H0 H1 H2 H3 H4, is in an array of
-             * five int values named sha, the hash value would be computed as
-             * follows:
-             * 
-             * long hash = ((sha[0] >>> 24) & 0xFF) | ((sha[0] >>> 16) & 0xFF) <<
-             * 8 | ((sha[0] >>> 8) & 0xFF) << 16 | ((sha[0] >>> 0) & 0xFF) <<
-             * 24 | ((sha[1] >>> 24) & 0xFF) << 32 | ((sha[1] >>> 16) & 0xFF) <<
-             * 40 | ((sha[1] >>> 8) & 0xFF) << 48 | ((sha[1] >>> 0) & 0xFF) <<
-             * 56;
-             */
-            for (int i = Math.min(hashBytes.length, 8) - 1; i >= 0; i--) {
-                svuid = (svuid << 8) | (hashBytes[i] & 0xFF);
-            }
-        } finally {
-            // close the stream (if open)
-            if (dos != null) {
-                dos.close();
-            }
-        }
-
-        return svuid;
-    }
-
-    /**
-     * Returns the SHA-1 message digest of the given value.
-     * 
-     * @param value the value whose SHA message digest must be computed.
-     * @return the SHA-1 message digest of the given value.
-     */
-    protected byte[] computeSHAdigest(final byte[] value) {
-        try {
-            return MessageDigest.getInstance("SHA").digest(value);
-        } catch (Exception e) {
-            throw new UnsupportedOperationException(e.toString());
-        }
-    }
-
-    /**
-     * Sorts the items in the collection and writes it to the data output stream
-     * 
-     * @param itemCollection collection of items
-     * @param dos a <code>DataOutputStream</code> value
-     * @param dotted a <code>boolean</code> value
-     * @exception IOException if an error occurs
-     */
-    private static void writeItems(
-        final Collection itemCollection,
-        final DataOutput dos,
-        final boolean dotted) throws IOException
-    {
-        int size = itemCollection.size();
-        Item[] items = (Item[]) itemCollection.toArray(new Item[size]);
-        Arrays.sort(items);
-        for (int i = 0; i < size; i++) {
-            dos.writeUTF(items[i].name);
-            dos.writeInt(items[i].access);
-            dos.writeUTF(dotted
-                    ? items[i].desc.replace('/', '.')
-                    : items[i].desc);
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Inner classes
-    // ------------------------------------------------------------------------
-
-    static class Item implements Comparable {
-
-        final String name;
-
-        final int access;
-
-        final String desc;
-
-        Item(final String name, final int access, final String desc) {
-            this.name = name;
-            this.access = access;
-            this.desc = desc;
-        }
-
-        public int compareTo(final Object o) {
-            Item other = (Item) o;
-            int retVal = name.compareTo(other.name);
-            if (retVal == 0) {
-                retVal = desc.compareTo(other.desc);
-            }
-            return retVal;
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/SimpleRemapper.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/SimpleRemapper.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/SimpleRemapper.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/SimpleRemapper.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,62 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import java.util.Collections;
-import java.util.Map;
-
-public class SimpleRemapper extends Remapper {
-
-    private final Map mapping;
-
-    public SimpleRemapper(Map mapping) {
-        this.mapping = mapping;
-    }
-
-    public SimpleRemapper(String oldName, String newName) {
-        this.mapping = Collections.singletonMap(oldName, newName);
-    }
-
-    public String mapMethodName(String owner, String name, String desc) {
-        String s = map(owner + '.' + name + desc);
-        return s == null ? name : s;
-    }
-
-    public String mapFieldName(String owner, String name, String desc) {
-        String s = map(owner + '.' + name);
-        return s == null ? name : s;
-    }
-    
-    public String map(String key) {
-        return (String) mapping.get(key);
-    }
-    
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/StaticInitMerger.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/StaticInitMerger.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/StaticInitMerger.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/StaticInitMerger.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,99 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import org.eclipse.persistence.internal.libraries.asm.ClassAdapter;
-import org.eclipse.persistence.internal.libraries.asm.ClassVisitor;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-
-/**
- * A {@link ClassAdapter} that merges clinit methods into a single one.
- * 
- * @author Eric Bruneton
- */
-public class StaticInitMerger extends ClassAdapter {
-
-    private String name;
-
-    private MethodVisitor clinit;
-
-    private final String prefix;
-
-    private int counter;
-
-    public StaticInitMerger(final String prefix, final ClassVisitor cv) {
-        super(cv);
-        this.prefix = prefix;
-    }
-
-    public void visit(
-        final int version,
-        final int access,
-        final String name,
-        final String signature,
-        final String superName,
-        final String[] interfaces)
-    {
-        cv.visit(version, access, name, signature, superName, interfaces);
-        this.name = name;
-    }
-
-    public MethodVisitor visitMethod(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final String[] exceptions)
-    {
-        MethodVisitor mv;
-        if ("<clinit>".equals(name)) {
-            int a = Opcodes.ACC_PRIVATE + Opcodes.ACC_STATIC;
-            String n = prefix + counter++;
-            mv = cv.visitMethod(a, n, desc, signature, exceptions);
-
-            if (clinit == null) {
-                clinit = cv.visitMethod(a, name, desc, null, null);
-            }
-            clinit.visitMethodInsn(Opcodes.INVOKESTATIC, this.name, n, desc);
-        } else {
-            mv = cv.visitMethod(access, name, desc, signature, exceptions);
-        }
-        return mv;
-    }
-
-    public void visitEnd() {
-        if (clinit != null) {
-            clinit.visitInsn(Opcodes.RETURN);
-            clinit.visitMaxs(0, 0);
-        }
-        cv.visitEnd();
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/TableSwitchGenerator.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/TableSwitchGenerator.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/TableSwitchGenerator.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/TableSwitchGenerator.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,55 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import org.eclipse.persistence.internal.libraries.asm.Label;
-
-/**
- * A code generator for switch statements.
- * 
- * @author Juozas Baliuka
- * @author Chris Nokleberg
- * @author Eric Bruneton
- */
-public interface TableSwitchGenerator {
-
-    /**
-     * Generates the code for a switch case.
-     * 
-     * @param key the switch case key.
-     * @param end a label that corresponds to the end of the switch statement.
-     */
-    void generateCase(int key, Label end);
-
-    /**
-     * Generates the code for the default switch case.
-     */
-    void generateDefault();
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/TryCatchBlockSorter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/TryCatchBlockSorter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/commons/TryCatchBlockSorter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/commons/TryCatchBlockSorter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,60 +0,0 @@
-package org.eclipse.persistence.internal.libraries.asm.commons;
-
-import java.util.Collections;
-import java.util.Comparator;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.tree.MethodNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.TryCatchBlockNode;
-
-/**
- * Sorts the exception handlers in a method innermost-to-outermost. This allows
- * the programmer to add handlers without worrying about ordering them correctly
- * with respect to existing, in-code handlers.
- * 
- * Behavior is only defined for properly-nested handlers. If any "try" blocks
- * overlap (something that isn't possible in Java code) then this may not do
- * what you want. In fact, this adapter just sorts by the length of the "try"
- * block, taking advantage of the fact that a given try block must be larger
- * than any block it contains).
- * 
- * @author Adrian Sampson
- */
-public class TryCatchBlockSorter extends MethodNode {
-
-    private final MethodVisitor mv;
-
-    public TryCatchBlockSorter(
-        final MethodVisitor mv,
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final String[] exceptions)
-    {
-        super(access, name, desc, signature, exceptions);
-        this.mv = mv;
-    }
-
-    public void visitEnd() {
-        // Compares TryCatchBlockNodes by the length of their "try" block.
-        Comparator comp = new Comparator() {
-
-            public int compare(Object o1, Object o2) {
-                int len1 = blockLength((TryCatchBlockNode) o1);
-                int len2 = blockLength((TryCatchBlockNode) o2);
-                return len1 - len2;
-            }
-
-            private int blockLength(TryCatchBlockNode block) {
-                int startidx = instructions.indexOf(block.start);
-                int endidx = instructions.indexOf(block.end);
-                return endidx - startidx;
-            }
-        };
-        Collections.sort(tryCatchBlocks, comp);
-        if (mv != null) {
-            accept(mv);
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/Edge.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/Edge.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/Edge.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/Edge.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * An edge in the control flow graph of a method body. See {@link Label Label}.
- * 
- * @author Eric Bruneton
- */
-class Edge {
-
-    /**
-     * Denotes a normal control flow graph edge.
-     */
-    static final int NORMAL = 0;
-
-    /**
-     * Denotes a control flow graph edge corresponding to an exception handler.
-     * More precisely any {@link Edge} whose {@link #info} is strictly positive
-     * corresponds to an exception handler. The actual value of {@link #info} is
-     * the index, in the {@link ClassWriter} type table, of the exception that
-     * is catched.
-     */
-    static final int EXCEPTION = 0x7FFFFFFF;
-
-    /**
-     * Information about this control flow graph edge. If
-     * {@link ClassWriter#COMPUTE_MAXS} is used this field is the (relative)
-     * stack size in the basic block from which this edge originates. This size
-     * is equal to the stack size at the "jump" instruction to which this edge
-     * corresponds, relatively to the stack size at the beginning of the
-     * originating basic block. If {@link ClassWriter#COMPUTE_FRAMES} is used,
-     * this field is the kind of this control flow graph edge (i.e. NORMAL or
-     * EXCEPTION).
-     */
-    int info;
-
-    /**
-     * The successor block of the basic block from which this edge originates.
-     */
-    Label successor;
-
-    /**
-     * The next edge in the list of successors of the originating basic block.
-     * See {@link Label#successors successors}.
-     */
-    Edge next;
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/FieldVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/FieldVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/FieldVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/FieldVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,64 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * A visitor to visit a Java field. The methods of this interface must be called
- * in the following order: ( <tt>visitAnnotation</tt> |
- * <tt>visitAttribute</tt> )* <tt>visitEnd</tt>.
- * 
- * @author Eric Bruneton
- */
-public interface FieldVisitor {
-
-    /**
-     * Visits an annotation of the field.
-     * 
-     * @param desc the class descriptor of the annotation class.
-     * @param visible <tt>true</tt> if the annotation is visible at runtime.
-     * @return a visitor to visit the annotation values, or <tt>null</tt> if
-     *         this visitor is not interested in visiting this annotation.
-     */
-    AnnotationVisitor visitAnnotation(String desc, boolean visible);
-
-    /**
-     * Visits a non standard attribute of the field.
-     * 
-     * @param attr an attribute.
-     */
-    void visitAttribute(Attribute attr);
-
-    /**
-     * Visits the end of the field. This method, which is the last one to be
-     * called, is used to inform the visitor that all the annotations and
-     * attributes of the field have been visited.
-     */
-    void visitEnd();
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/FieldWriter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/FieldWriter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/FieldWriter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/FieldWriter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,272 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * An {@link FieldVisitor} that generates Java fields in bytecode form.
- * 
- * @author Eric Bruneton
- */
-final class FieldWriter implements FieldVisitor {
-
-    /**
-     * Next field writer (see {@link ClassWriter#firstField firstField}).
-     */
-    FieldWriter next;
-
-    /**
-     * The class writer to which this field must be added.
-     */
-    private final ClassWriter cw;
-
-    /**
-     * Access flags of this field.
-     */
-    private final int access;
-
-    /**
-     * The index of the constant pool item that contains the name of this
-     * method.
-     */
-    private final int name;
-
-    /**
-     * The index of the constant pool item that contains the descriptor of this
-     * field.
-     */
-    private final int desc;
-
-    /**
-     * The index of the constant pool item that contains the signature of this
-     * field.
-     */
-    private int signature;
-
-    /**
-     * The index of the constant pool item that contains the constant value of
-     * this field.
-     */
-    private int value;
-
-    /**
-     * The runtime visible annotations of this field. May be <tt>null</tt>.
-     */
-    private AnnotationWriter anns;
-
-    /**
-     * The runtime invisible annotations of this field. May be <tt>null</tt>.
-     */
-    private AnnotationWriter ianns;
-
-    /**
-     * The non standard attributes of this field. May be <tt>null</tt>.
-     */
-    private Attribute attrs;
-
-    // ------------------------------------------------------------------------
-    // Constructor
-    // ------------------------------------------------------------------------
-
-    /**
-     * Constructs a new {@link FieldWriter}.
-     * 
-     * @param cw the class writer to which this field must be added.
-     * @param access the field's access flags (see {@link Opcodes}).
-     * @param name the field's name.
-     * @param desc the field's descriptor (see {@link Type}).
-     * @param signature the field's signature. May be <tt>null</tt>.
-     * @param value the field's constant value. May be <tt>null</tt>.
-     */
-    FieldWriter(
-        final ClassWriter cw,
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final Object value)
-    {
-        if (cw.firstField == null) {
-            cw.firstField = this;
-        } else {
-            cw.lastField.next = this;
-        }
-        cw.lastField = this;
-        this.cw = cw;
-        this.access = access;
-        this.name = cw.newUTF8(name);
-        this.desc = cw.newUTF8(desc);
-        if (ClassReader.SIGNATURES && signature != null) {
-            this.signature = cw.newUTF8(signature);
-        }
-        if (value != null) {
-            this.value = cw.newConstItem(value).index;
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Implementation of the FieldVisitor interface
-    // ------------------------------------------------------------------------
-
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        if (!ClassReader.ANNOTATIONS) {
-            return null;
-        }
-        ByteVector bv = new ByteVector();
-        // write type, and reserve space for values count
-        bv.putShort(cw.newUTF8(desc)).putShort(0);
-        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);
-        if (visible) {
-            aw.next = anns;
-            anns = aw;
-        } else {
-            aw.next = ianns;
-            ianns = aw;
-        }
-        return aw;
-    }
-
-    public void visitAttribute(final Attribute attr) {
-        attr.next = attrs;
-        attrs = attr;
-    }
-
-    public void visitEnd() {
-    }
-
-    // ------------------------------------------------------------------------
-    // Utility methods
-    // ------------------------------------------------------------------------
-
-    /**
-     * Returns the size of this field.
-     * 
-     * @return the size of this field.
-     */
-    int getSize() {
-        int size = 8;
-        if (value != 0) {
-            cw.newUTF8("ConstantValue");
-            size += 8;
-        }
-        if ((access & Opcodes.ACC_SYNTHETIC) != 0
-                && ((cw.version & 0xFFFF) < Opcodes.V1_5 || (access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) != 0))
-        {
-            cw.newUTF8("Synthetic");
-            size += 6;
-        }
-        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
-            cw.newUTF8("Deprecated");
-            size += 6;
-        }
-        if (ClassReader.SIGNATURES && signature != 0) {
-            cw.newUTF8("Signature");
-            size += 8;
-        }
-        if (ClassReader.ANNOTATIONS && anns != null) {
-            cw.newUTF8("RuntimeVisibleAnnotations");
-            size += 8 + anns.getSize();
-        }
-        if (ClassReader.ANNOTATIONS && ianns != null) {
-            cw.newUTF8("RuntimeInvisibleAnnotations");
-            size += 8 + ianns.getSize();
-        }
-        if (attrs != null) {
-            size += attrs.getSize(cw, null, 0, -1, -1);
-        }
-        return size;
-    }
-
-    /**
-     * Puts the content of this field into the given byte vector.
-     * 
-     * @param out where the content of this field must be put.
-     */
-    void put(final ByteVector out) {
-        int mask = Opcodes.ACC_DEPRECATED
-                | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE
-                | ((access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) / (ClassWriter.ACC_SYNTHETIC_ATTRIBUTE / Opcodes.ACC_SYNTHETIC));
-        out.putShort(access & ~mask).putShort(name).putShort(desc);
-        int attributeCount = 0;
-        if (value != 0) {
-            ++attributeCount;
-        }
-        if ((access & Opcodes.ACC_SYNTHETIC) != 0
-                && ((cw.version & 0xFFFF) < Opcodes.V1_5 || (access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) != 0))
-        {
-            ++attributeCount;
-        }
-        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
-            ++attributeCount;
-        }
-        if (ClassReader.SIGNATURES && signature != 0) {
-            ++attributeCount;
-        }
-        if (ClassReader.ANNOTATIONS && anns != null) {
-            ++attributeCount;
-        }
-        if (ClassReader.ANNOTATIONS && ianns != null) {
-            ++attributeCount;
-        }
-        if (attrs != null) {
-            attributeCount += attrs.getCount();
-        }
-        out.putShort(attributeCount);
-        if (value != 0) {
-            out.putShort(cw.newUTF8("ConstantValue"));
-            out.putInt(2).putShort(value);
-        }
-        if ((access & Opcodes.ACC_SYNTHETIC) != 0
-                && ((cw.version & 0xFFFF) < Opcodes.V1_5 || (access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) != 0))
-        {
-            out.putShort(cw.newUTF8("Synthetic")).putInt(0);
-        }
-        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
-            out.putShort(cw.newUTF8("Deprecated")).putInt(0);
-        }
-        if (ClassReader.SIGNATURES && signature != 0) {
-            out.putShort(cw.newUTF8("Signature"));
-            out.putInt(2).putShort(signature);
-        }
-        if (ClassReader.ANNOTATIONS && anns != null) {
-            out.putShort(cw.newUTF8("RuntimeVisibleAnnotations"));
-            anns.put(out);
-        }
-        if (ClassReader.ANNOTATIONS && ianns != null) {
-            out.putShort(cw.newUTF8("RuntimeInvisibleAnnotations"));
-            ianns.put(out);
-        }
-        if (attrs != null) {
-            attrs.put(cw, null, 0, -1, -1, out);
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/Frame.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/Frame.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/Frame.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/Frame.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,1429 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * Information about the input and output stack map frames of a basic block.
- * 
- * @author Eric Bruneton
- */
-final class Frame {
-
-    /*
-     * Frames are computed in a two steps process: during the visit of each
-     * instruction, the state of the frame at the end of current basic block is
-     * updated by simulating the action of the instruction on the previous state
-     * of this so called "output frame". In visitMaxs, a fix point algorithm is
-     * used to compute the "input frame" of each basic block, i.e. the stack map
-     * frame at the beginning of the basic block, starting from the input frame
-     * of the first basic block (which is computed from the method descriptor),
-     * and by using the previously computed output frames to compute the input
-     * state of the other blocks.
-     * 
-     * All output and input frames are stored as arrays of integers. Reference
-     * and array types are represented by an index into a type table (which is
-     * not the same as the constant pool of the class, in order to avoid adding
-     * unnecessary constants in the pool - not all computed frames will end up
-     * being stored in the stack map table). This allows very fast type
-     * comparisons.
-     * 
-     * Output stack map frames are computed relatively to the input frame of the
-     * basic block, which is not yet known when output frames are computed. It
-     * is therefore necessary to be able to represent abstract types such as
-     * "the type at position x in the input frame locals" or "the type at
-     * position x from the top of the input frame stack" or even "the type at
-     * position x in the input frame, with y more (or less) array dimensions".
-     * This explains the rather complicated type format used in output frames.
-     * 
-     * This format is the following: DIM KIND VALUE (4, 4 and 24 bits). DIM is a
-     * signed number of array dimensions (from -8 to 7). KIND is either BASE,
-     * LOCAL or STACK. BASE is used for types that are not relative to the input
-     * frame. LOCAL is used for types that are relative to the input local
-     * variable types. STACK is used for types that are relative to the input
-     * stack types. VALUE depends on KIND. For LOCAL types, it is an index in
-     * the input local variable types. For STACK types, it is a position
-     * relatively to the top of input frame stack. For BASE types, it is either
-     * one of the constants defined in FrameVisitor, or for OBJECT and
-     * UNINITIALIZED types, a tag and an index in the type table.
-     * 
-     * Output frames can contain types of any kind and with a positive or
-     * negative dimension (and even unassigned types, represented by 0 - which
-     * does not correspond to any valid type value). Input frames can only
-     * contain BASE types of positive or null dimension. In all cases the type
-     * table contains only internal type names (array type descriptors are
-     * forbidden - dimensions must be represented through the DIM field).
-     * 
-     * The LONG and DOUBLE types are always represented by using two slots (LONG +
-     * TOP or DOUBLE + TOP), for local variable types as well as in the operand
-     * stack. This is necessary to be able to simulate DUPx_y instructions,
-     * whose effect would be dependent on the actual type values if types were
-     * always represented by a single slot in the stack (and this is not
-     * possible, since actual type values are not always known - cf LOCAL and
-     * STACK type kinds).
-     */
-
-    /**
-     * Mask to get the dimension of a frame type. This dimension is a signed
-     * integer between -8 and 7.
-     */
-    static final int DIM = 0xF0000000;
-
-    /**
-     * Constant to be added to a type to get a type with one more dimension.
-     */
-    static final int ARRAY_OF = 0x10000000;
-
-    /**
-     * Constant to be added to a type to get a type with one less dimension.
-     */
-    static final int ELEMENT_OF = 0xF0000000;
-
-    /**
-     * Mask to get the kind of a frame type.
-     * 
-     * @see #BASE
-     * @see #LOCAL
-     * @see #STACK
-     */
-    static final int KIND = 0xF000000;
-
-    /**
-     * Flag used for LOCAL and STACK types. Indicates that if this type happens
-     * to be a long or double type (during the computations of input frames), 
-     * then it must be set to TOP because the second word of this value has
-     * been reused to store other data in the basic block. Hence the first word 
-     * no longer stores a valid long or double value.
-     */
-    static final int TOP_IF_LONG_OR_DOUBLE = 0x800000;
-
-    /**
-     * Mask to get the value of a frame type.
-     */
-    static final int VALUE = 0x7FFFFF;
-
-    /**
-     * Mask to get the kind of base types.
-     */
-    static final int BASE_KIND = 0xFF00000;
-
-    /**
-     * Mask to get the value of base types.
-     */
-    static final int BASE_VALUE = 0xFFFFF;
-
-    /**
-     * Kind of the types that are not relative to an input stack map frame.
-     */
-    static final int BASE = 0x1000000;
-
-    /**
-     * Base kind of the base reference types. The BASE_VALUE of such types is an
-     * index into the type table.
-     */
-    static final int OBJECT = BASE | 0x700000;
-
-    /**
-     * Base kind of the uninitialized base types. The BASE_VALUE of such types
-     * in an index into the type table (the Item at that index contains both an
-     * instruction offset and an internal class name).
-     */
-    static final int UNINITIALIZED = BASE | 0x800000;
-
-    /**
-     * Kind of the types that are relative to the local variable types of an
-     * input stack map frame. The value of such types is a local variable index.
-     */
-    private static final int LOCAL = 0x2000000;
-
-    /**
-     * Kind of the the types that are relative to the stack of an input stack
-     * map frame. The value of such types is a position relatively to the top of
-     * this stack.
-     */
-    private static final int STACK = 0x3000000;
-
-    /**
-     * The TOP type. This is a BASE type.
-     */
-    static final int TOP = BASE | 0;
-
-    /**
-     * The BOOLEAN type. This is a BASE type mainly used for array types.
-     */
-    static final int BOOLEAN = BASE | 9;
-
-    /**
-     * The BYTE type. This is a BASE type mainly used for array types.
-     */
-    static final int BYTE = BASE | 10;
-
-    /**
-     * The CHAR type. This is a BASE type mainly used for array types.
-     */
-    static final int CHAR = BASE | 11;
-
-    /**
-     * The SHORT type. This is a BASE type mainly used for array types.
-     */
-    static final int SHORT = BASE | 12;
-
-    /**
-     * The INTEGER type. This is a BASE type.
-     */
-    static final int INTEGER = BASE | 1;
-
-    /**
-     * The FLOAT type. This is a BASE type.
-     */
-    static final int FLOAT = BASE | 2;
-
-    /**
-     * The DOUBLE type. This is a BASE type.
-     */
-    static final int DOUBLE = BASE | 3;
-
-    /**
-     * The LONG type. This is a BASE type.
-     */
-    static final int LONG = BASE | 4;
-
-    /**
-     * The NULL type. This is a BASE type.
-     */
-    static final int NULL = BASE | 5;
-
-    /**
-     * The UNINITIALIZED_THIS type. This is a BASE type.
-     */
-    static final int UNINITIALIZED_THIS = BASE | 6;
-
-    /**
-     * The stack size variation corresponding to each JVM instruction. This
-     * stack variation is equal to the size of the values produced by an
-     * instruction, minus the size of the values consumed by this instruction.
-     */
-    static final int[] SIZE;
-
-    /**
-     * Computes the stack size variation corresponding to each JVM instruction.
-     */
-    static {
-        int i;
-        int[] b = new int[202];
-        String s = "EFFFFFFFFGGFFFGGFFFEEFGFGFEEEEEEEEEEEEEEEEEEEEDEDEDDDDD"
-                + "CDCDEEEEEEEEEEEEEEEEEEEEBABABBBBDCFFFGGGEDCDCDCDCDCDCDCDCD"
-                + "CDCEEEEDDDDDDDCDCDCEFEFDDEEFFDEDEEEBDDBBDDDDDDCCCCCCCCEFED"
-                + "DDCDCDEEEEEEEEEEFEEEEEEDDEEDDEE";
-        for (i = 0; i < b.length; ++i) {
-            b[i] = s.charAt(i) - 'E';
-        }
-        SIZE = b;
-
-        // code to generate the above string
-        //
-        // int NA = 0; // not applicable (unused opcode or variable size opcode)
-        //
-        // b = new int[] {
-        // 0, //NOP, // visitInsn
-        // 1, //ACONST_NULL, // -
-        // 1, //ICONST_M1, // -
-        // 1, //ICONST_0, // -
-        // 1, //ICONST_1, // -
-        // 1, //ICONST_2, // -
-        // 1, //ICONST_3, // -
-        // 1, //ICONST_4, // -
-        // 1, //ICONST_5, // -
-        // 2, //LCONST_0, // -
-        // 2, //LCONST_1, // -
-        // 1, //FCONST_0, // -
-        // 1, //FCONST_1, // -
-        // 1, //FCONST_2, // -
-        // 2, //DCONST_0, // -
-        // 2, //DCONST_1, // -
-        // 1, //BIPUSH, // visitIntInsn
-        // 1, //SIPUSH, // -
-        // 1, //LDC, // visitLdcInsn
-        // NA, //LDC_W, // -
-        // NA, //LDC2_W, // -
-        // 1, //ILOAD, // visitVarInsn
-        // 2, //LLOAD, // -
-        // 1, //FLOAD, // -
-        // 2, //DLOAD, // -
-        // 1, //ALOAD, // -
-        // NA, //ILOAD_0, // -
-        // NA, //ILOAD_1, // -
-        // NA, //ILOAD_2, // -
-        // NA, //ILOAD_3, // -
-        // NA, //LLOAD_0, // -
-        // NA, //LLOAD_1, // -
-        // NA, //LLOAD_2, // -
-        // NA, //LLOAD_3, // -
-        // NA, //FLOAD_0, // -
-        // NA, //FLOAD_1, // -
-        // NA, //FLOAD_2, // -
-        // NA, //FLOAD_3, // -
-        // NA, //DLOAD_0, // -
-        // NA, //DLOAD_1, // -
-        // NA, //DLOAD_2, // -
-        // NA, //DLOAD_3, // -
-        // NA, //ALOAD_0, // -
-        // NA, //ALOAD_1, // -
-        // NA, //ALOAD_2, // -
-        // NA, //ALOAD_3, // -
-        // -1, //IALOAD, // visitInsn
-        // 0, //LALOAD, // -
-        // -1, //FALOAD, // -
-        // 0, //DALOAD, // -
-        // -1, //AALOAD, // -
-        // -1, //BALOAD, // -
-        // -1, //CALOAD, // -
-        // -1, //SALOAD, // -
-        // -1, //ISTORE, // visitVarInsn
-        // -2, //LSTORE, // -
-        // -1, //FSTORE, // -
-        // -2, //DSTORE, // -
-        // -1, //ASTORE, // -
-        // NA, //ISTORE_0, // -
-        // NA, //ISTORE_1, // -
-        // NA, //ISTORE_2, // -
-        // NA, //ISTORE_3, // -
-        // NA, //LSTORE_0, // -
-        // NA, //LSTORE_1, // -
-        // NA, //LSTORE_2, // -
-        // NA, //LSTORE_3, // -
-        // NA, //FSTORE_0, // -
-        // NA, //FSTORE_1, // -
-        // NA, //FSTORE_2, // -
-        // NA, //FSTORE_3, // -
-        // NA, //DSTORE_0, // -
-        // NA, //DSTORE_1, // -
-        // NA, //DSTORE_2, // -
-        // NA, //DSTORE_3, // -
-        // NA, //ASTORE_0, // -
-        // NA, //ASTORE_1, // -
-        // NA, //ASTORE_2, // -
-        // NA, //ASTORE_3, // -
-        // -3, //IASTORE, // visitInsn
-        // -4, //LASTORE, // -
-        // -3, //FASTORE, // -
-        // -4, //DASTORE, // -
-        // -3, //AASTORE, // -
-        // -3, //BASTORE, // -
-        // -3, //CASTORE, // -
-        // -3, //SASTORE, // -
-        // -1, //POP, // -
-        // -2, //POP2, // -
-        // 1, //DUP, // -
-        // 1, //DUP_X1, // -
-        // 1, //DUP_X2, // -
-        // 2, //DUP2, // -
-        // 2, //DUP2_X1, // -
-        // 2, //DUP2_X2, // -
-        // 0, //SWAP, // -
-        // -1, //IADD, // -
-        // -2, //LADD, // -
-        // -1, //FADD, // -
-        // -2, //DADD, // -
-        // -1, //ISUB, // -
-        // -2, //LSUB, // -
-        // -1, //FSUB, // -
-        // -2, //DSUB, // -
-        // -1, //IMUL, // -
-        // -2, //LMUL, // -
-        // -1, //FMUL, // -
-        // -2, //DMUL, // -
-        // -1, //IDIV, // -
-        // -2, //LDIV, // -
-        // -1, //FDIV, // -
-        // -2, //DDIV, // -
-        // -1, //IREM, // -
-        // -2, //LREM, // -
-        // -1, //FREM, // -
-        // -2, //DREM, // -
-        // 0, //INEG, // -
-        // 0, //LNEG, // -
-        // 0, //FNEG, // -
-        // 0, //DNEG, // -
-        // -1, //ISHL, // -
-        // -1, //LSHL, // -
-        // -1, //ISHR, // -
-        // -1, //LSHR, // -
-        // -1, //IUSHR, // -
-        // -1, //LUSHR, // -
-        // -1, //IAND, // -
-        // -2, //LAND, // -
-        // -1, //IOR, // -
-        // -2, //LOR, // -
-        // -1, //IXOR, // -
-        // -2, //LXOR, // -
-        // 0, //IINC, // visitIincInsn
-        // 1, //I2L, // visitInsn
-        // 0, //I2F, // -
-        // 1, //I2D, // -
-        // -1, //L2I, // -
-        // -1, //L2F, // -
-        // 0, //L2D, // -
-        // 0, //F2I, // -
-        // 1, //F2L, // -
-        // 1, //F2D, // -
-        // -1, //D2I, // -
-        // 0, //D2L, // -
-        // -1, //D2F, // -
-        // 0, //I2B, // -
-        // 0, //I2C, // -
-        // 0, //I2S, // -
-        // -3, //LCMP, // -
-        // -1, //FCMPL, // -
-        // -1, //FCMPG, // -
-        // -3, //DCMPL, // -
-        // -3, //DCMPG, // -
-        // -1, //IFEQ, // visitJumpInsn
-        // -1, //IFNE, // -
-        // -1, //IFLT, // -
-        // -1, //IFGE, // -
-        // -1, //IFGT, // -
-        // -1, //IFLE, // -
-        // -2, //IF_ICMPEQ, // -
-        // -2, //IF_ICMPNE, // -
-        // -2, //IF_ICMPLT, // -
-        // -2, //IF_ICMPGE, // -
-        // -2, //IF_ICMPGT, // -
-        // -2, //IF_ICMPLE, // -
-        // -2, //IF_ACMPEQ, // -
-        // -2, //IF_ACMPNE, // -
-        // 0, //GOTO, // -
-        // 1, //JSR, // -
-        // 0, //RET, // visitVarInsn
-        // -1, //TABLESWITCH, // visiTableSwitchInsn
-        // -1, //LOOKUPSWITCH, // visitLookupSwitch
-        // -1, //IRETURN, // visitInsn
-        // -2, //LRETURN, // -
-        // -1, //FRETURN, // -
-        // -2, //DRETURN, // -
-        // -1, //ARETURN, // -
-        // 0, //RETURN, // -
-        // NA, //GETSTATIC, // visitFieldInsn
-        // NA, //PUTSTATIC, // -
-        // NA, //GETFIELD, // -
-        // NA, //PUTFIELD, // -
-        // NA, //INVOKEVIRTUAL, // visitMethodInsn
-        // NA, //INVOKESPECIAL, // -
-        // NA, //INVOKESTATIC, // -
-        // NA, //INVOKEINTERFACE, // -
-        // NA, //INVOKEDYNAMIC, // -
-        // 1, //NEW, // visitTypeInsn
-        // 0, //NEWARRAY, // visitIntInsn
-        // 0, //ANEWARRAY, // visitTypeInsn
-        // 0, //ARRAYLENGTH, // visitInsn
-        // NA, //ATHROW, // -
-        // 0, //CHECKCAST, // visitTypeInsn
-        // 0, //INSTANCEOF, // -
-        // -1, //MONITORENTER, // visitInsn
-        // -1, //MONITOREXIT, // -
-        // NA, //WIDE, // NOT VISITED
-        // NA, //MULTIANEWARRAY, // visitMultiANewArrayInsn
-        // -1, //IFNULL, // visitJumpInsn
-        // -1, //IFNONNULL, // -
-        // NA, //GOTO_W, // -
-        // NA, //JSR_W, // -
-        // };
-        // for (i = 0; i < b.length; ++i) {
-        // System.err.print((char)('E' + b[i]));
-        // }
-        // System.err.println();
-    }
-
-    /**
-     * The label (i.e. basic block) to which these input and output stack map
-     * frames correspond.
-     */
-    Label owner;
-
-    /**
-     * The input stack map frame locals.
-     */
-    int[] inputLocals;
-
-    /**
-     * The input stack map frame stack.
-     */
-    int[] inputStack;
-
-    /**
-     * The output stack map frame locals.
-     */
-    private int[] outputLocals;
-
-    /**
-     * The output stack map frame stack.
-     */
-    private int[] outputStack;
-
-    /**
-     * Relative size of the output stack. The exact semantics of this field
-     * depends on the algorithm that is used.
-     * 
-     * When only the maximum stack size is computed, this field is the size of
-     * the output stack relatively to the top of the input stack.
-     * 
-     * When the stack map frames are completely computed, this field is the
-     * actual number of types in {@link #outputStack}.
-     */
-    private int outputStackTop;
-
-    /**
-     * Number of types that are initialized in the basic block.
-     * 
-     * @see #initializations
-     */
-    private int initializationCount;
-
-    /**
-     * The types that are initialized in the basic block. A constructor
-     * invocation on an UNINITIALIZED or UNINITIALIZED_THIS type must replace
-     * <i>every occurence</i> of this type in the local variables and in the
-     * operand stack. This cannot be done during the first phase of the
-     * algorithm since, during this phase, the local variables and the operand
-     * stack are not completely computed. It is therefore necessary to store the
-     * types on which constructors are invoked in the basic block, in order to
-     * do this replacement during the second phase of the algorithm, where the
-     * frames are fully computed. Note that this array can contain types that
-     * are relative to input locals or to the input stack (see below for the
-     * description of the algorithm).
-     */
-    private int[] initializations;
-
-    /**
-     * Returns the output frame local variable type at the given index.
-     * 
-     * @param local the index of the local that must be returned.
-     * @return the output frame local variable type at the given index.
-     */
-    private int get(final int local) {
-        if (outputLocals == null || local >= outputLocals.length) {
-            // this local has never been assigned in this basic block,
-            // so it is still equal to its value in the input frame
-            return LOCAL | local;
-        } else {
-            int type = outputLocals[local];
-            if (type == 0) {
-                // this local has never been assigned in this basic block,
-                // so it is still equal to its value in the input frame
-                type = outputLocals[local] = LOCAL | local;
-            }
-            return type;
-        }
-    }
-
-    /**
-     * Sets the output frame local variable type at the given index.
-     * 
-     * @param local the index of the local that must be set.
-     * @param type the value of the local that must be set.
-     */
-    private void set(final int local, final int type) {
-        // creates and/or resizes the output local variables array if necessary
-        if (outputLocals == null) {
-            outputLocals = new int[10];
-        }
-        int n = outputLocals.length;
-        if (local >= n) {
-            int[] t = new int[Math.max(local + 1, 2 * n)];
-            System.arraycopy(outputLocals, 0, t, 0, n);
-            outputLocals = t;
-        }
-        // sets the local variable
-        outputLocals[local] = type;
-    }
-
-    /**
-     * Pushes a new type onto the output frame stack.
-     * 
-     * @param type the type that must be pushed.
-     */
-    private void push(final int type) {
-        // creates and/or resizes the output stack array if necessary
-        if (outputStack == null) {
-            outputStack = new int[10];
-        }
-        int n = outputStack.length;
-        if (outputStackTop >= n) {
-            int[] t = new int[Math.max(outputStackTop + 1, 2 * n)];
-            System.arraycopy(outputStack, 0, t, 0, n);
-            outputStack = t;
-        }
-        // pushes the type on the output stack
-        outputStack[outputStackTop++] = type;
-        // updates the maximun height reached by the output stack, if needed
-        int top = owner.inputStackTop + outputStackTop;
-        if (top > owner.outputStackMax) {
-            owner.outputStackMax = top;
-        }
-    }
-
-    /**
-     * Pushes a new type onto the output frame stack.
-     * 
-     * @param cw the ClassWriter to which this label belongs.
-     * @param desc the descriptor of the type to be pushed. Can also be a method
-     *        descriptor (in this case this method pushes its return type onto
-     *        the output frame stack).
-     */
-    private void push(final ClassWriter cw, final String desc) {
-        int type = type(cw, desc);
-        if (type != 0) {
-            push(type);
-            if (type == LONG || type == DOUBLE) {
-                push(TOP);
-            }
-        }
-    }
-
-    /**
-     * Returns the int encoding of the given type.
-     * 
-     * @param cw the ClassWriter to which this label belongs.
-     * @param desc a type descriptor.
-     * @return the int encoding of the given type.
-     */
-    private static int type(final ClassWriter cw, final String desc) {
-        String t;
-        int index = desc.charAt(0) == '(' ? desc.indexOf(')') + 1 : 0;
-        switch (desc.charAt(index)) {
-            case 'V':
-                return 0;
-            case 'Z':
-            case 'C':
-            case 'B':
-            case 'S':
-            case 'I':
-                return INTEGER;
-            case 'F':
-                return FLOAT;
-            case 'J':
-                return LONG;
-            case 'D':
-                return DOUBLE;
-            case 'L':
-                // stores the internal name, not the descriptor!
-                t = desc.substring(index + 1, desc.length() - 1);
-                return OBJECT | cw.addType(t);
-                // case '[':
-            default:
-                // extracts the dimensions and the element type
-                int data;
-                int dims = index + 1;
-                while (desc.charAt(dims) == '[') {
-                    ++dims;
-                }
-                switch (desc.charAt(dims)) {
-                    case 'Z':
-                        data = BOOLEAN;
-                        break;
-                    case 'C':
-                        data = CHAR;
-                        break;
-                    case 'B':
-                        data = BYTE;
-                        break;
-                    case 'S':
-                        data = SHORT;
-                        break;
-                    case 'I':
-                        data = INTEGER;
-                        break;
-                    case 'F':
-                        data = FLOAT;
-                        break;
-                    case 'J':
-                        data = LONG;
-                        break;
-                    case 'D':
-                        data = DOUBLE;
-                        break;
-                    // case 'L':
-                    default:
-                        // stores the internal name, not the descriptor
-                        t = desc.substring(dims + 1, desc.length() - 1);
-                        data = OBJECT | cw.addType(t);
-                }
-                return (dims - index) << 28 | data;
-        }
-    }
-
-    /**
-     * Pops a type from the output frame stack and returns its value.
-     * 
-     * @return the type that has been popped from the output frame stack.
-     */
-    private int pop() {
-        if (outputStackTop > 0) {
-            return outputStack[--outputStackTop];
-        } else {
-            // if the output frame stack is empty, pops from the input stack
-            return STACK | -(--owner.inputStackTop);
-        }
-    }
-
-    /**
-     * Pops the given number of types from the output frame stack.
-     * 
-     * @param elements the number of types that must be popped.
-     */
-    private void pop(final int elements) {
-        if (outputStackTop >= elements) {
-            outputStackTop -= elements;
-        } else {
-            // if the number of elements to be popped is greater than the number
-            // of elements in the output stack, clear it, and pops the remaining
-            // elements from the input stack.
-            owner.inputStackTop -= elements - outputStackTop;
-            outputStackTop = 0;
-        }
-    }
-
-    /**
-     * Pops a type from the output frame stack.
-     * 
-     * @param desc the descriptor of the type to be popped. Can also be a method
-     *        descriptor (in this case this method pops the types corresponding
-     *        to the method arguments).
-     */
-    private void pop(final String desc) {
-        char c = desc.charAt(0);
-        if (c == '(') {
-            pop((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
-        } else if (c == 'J' || c == 'D') {
-            pop(2);
-        } else {
-            pop(1);
-        }
-    }
-
-    /**
-     * Adds a new type to the list of types on which a constructor is invoked in
-     * the basic block.
-     * 
-     * @param var a type on a which a constructor is invoked.
-     */
-    private void init(final int var) {
-        // creates and/or resizes the initializations array if necessary
-        if (initializations == null) {
-            initializations = new int[2];
-        }
-        int n = initializations.length;
-        if (initializationCount >= n) {
-            int[] t = new int[Math.max(initializationCount + 1, 2 * n)];
-            System.arraycopy(initializations, 0, t, 0, n);
-            initializations = t;
-        }
-        // stores the type to be initialized
-        initializations[initializationCount++] = var;
-    }
-
-    /**
-     * Replaces the given type with the appropriate type if it is one of the
-     * types on which a constructor is invoked in the basic block.
-     * 
-     * @param cw the ClassWriter to which this label belongs.
-     * @param t a type
-     * @return t or, if t is one of the types on which a constructor is invoked
-     *         in the basic block, the type corresponding to this constructor.
-     */
-    private int init(final ClassWriter cw, final int t) {
-        int s;
-        if (t == UNINITIALIZED_THIS) {
-            s = OBJECT | cw.addType(cw.thisName);
-        } else if ((t & (DIM | BASE_KIND)) == UNINITIALIZED) {
-            String type = cw.typeTable[t & BASE_VALUE].strVal1;
-            s = OBJECT | cw.addType(type);
-        } else {
-            return t;
-        }
-        for (int j = 0; j < initializationCount; ++j) {
-            int u = initializations[j];
-            int dim = u & DIM;
-            int kind = u & KIND;
-            if (kind == LOCAL) {
-                u = dim + inputLocals[u & VALUE];
-            } else if (kind == STACK) {
-                u = dim + inputStack[inputStack.length - (u & VALUE)];
-            }
-            if (t == u) {
-                return s;
-            }
-        }
-        return t;
-    }
-
-    /**
-     * Initializes the input frame of the first basic block from the method
-     * descriptor.
-     * 
-     * @param cw the ClassWriter to which this label belongs.
-     * @param access the access flags of the method to which this label belongs.
-     * @param args the formal parameter types of this method.
-     * @param maxLocals the maximum number of local variables of this method.
-     */
-    void initInputFrame(
-        final ClassWriter cw,
-        final int access,
-        final Type[] args,
-        final int maxLocals)
-    {
-        inputLocals = new int[maxLocals];
-        inputStack = new int[0];
-        int i = 0;
-        if ((access & Opcodes.ACC_STATIC) == 0) {
-            if ((access & MethodWriter.ACC_CONSTRUCTOR) == 0) {
-                inputLocals[i++] = OBJECT | cw.addType(cw.thisName);
-            } else {
-                inputLocals[i++] = UNINITIALIZED_THIS;
-            }
-        }
-        for (int j = 0; j < args.length; ++j) {
-            int t = type(cw, args[j].getDescriptor());
-            inputLocals[i++] = t;
-            if (t == LONG || t == DOUBLE) {
-                inputLocals[i++] = TOP;
-            }
-        }
-        while (i < maxLocals) {
-            inputLocals[i++] = TOP;
-        }
-    }
-
-    /**
-     * Simulates the action of the given instruction on the output stack frame.
-     * 
-     * @param opcode the opcode of the instruction.
-     * @param arg the operand of the instruction, if any.
-     * @param cw the class writer to which this label belongs.
-     * @param item the operand of the instructions, if any.
-     */
-    void execute(
-        final int opcode,
-        final int arg,
-        final ClassWriter cw,
-        final Item item)
-    {
-        int t1, t2, t3, t4;
-        switch (opcode) {
-            case Opcodes.NOP:
-            case Opcodes.INEG:
-            case Opcodes.LNEG:
-            case Opcodes.FNEG:
-            case Opcodes.DNEG:
-            case Opcodes.I2B:
-            case Opcodes.I2C:
-            case Opcodes.I2S:
-            case Opcodes.GOTO:
-            case Opcodes.RETURN:
-                break;
-            case Opcodes.ACONST_NULL:
-                push(NULL);
-                break;
-            case Opcodes.ICONST_M1:
-            case Opcodes.ICONST_0:
-            case Opcodes.ICONST_1:
-            case Opcodes.ICONST_2:
-            case Opcodes.ICONST_3:
-            case Opcodes.ICONST_4:
-            case Opcodes.ICONST_5:
-            case Opcodes.BIPUSH:
-            case Opcodes.SIPUSH:
-            case Opcodes.ILOAD:
-                push(INTEGER);
-                break;
-            case Opcodes.LCONST_0:
-            case Opcodes.LCONST_1:
-            case Opcodes.LLOAD:
-                push(LONG);
-                push(TOP);
-                break;
-            case Opcodes.FCONST_0:
-            case Opcodes.FCONST_1:
-            case Opcodes.FCONST_2:
-            case Opcodes.FLOAD:
-                push(FLOAT);
-                break;
-            case Opcodes.DCONST_0:
-            case Opcodes.DCONST_1:
-            case Opcodes.DLOAD:
-                push(DOUBLE);
-                push(TOP);
-                break;
-            case Opcodes.LDC:
-                switch (item.type) {
-                    case ClassWriter.INT:
-                        push(INTEGER);
-                        break;
-                    case ClassWriter.LONG:
-                        push(LONG);
-                        push(TOP);
-                        break;
-                    case ClassWriter.FLOAT:
-                        push(FLOAT);
-                        break;
-                    case ClassWriter.DOUBLE:
-                        push(DOUBLE);
-                        push(TOP);
-                        break;
-                    case ClassWriter.CLASS:
-                        push(OBJECT | cw.addType("java/lang/Class"));
-                        break;
-                    // case ClassWriter.STR:
-                    default:
-                        push(OBJECT | cw.addType("java/lang/String"));
-                }
-                break;
-            case Opcodes.ALOAD:
-                push(get(arg));
-                break;
-            case Opcodes.IALOAD:
-            case Opcodes.BALOAD:
-            case Opcodes.CALOAD:
-            case Opcodes.SALOAD:
-                pop(2);
-                push(INTEGER);
-                break;
-            case Opcodes.LALOAD:
-            case Opcodes.D2L:
-                pop(2);
-                push(LONG);
-                push(TOP);
-                break;
-            case Opcodes.FALOAD:
-                pop(2);
-                push(FLOAT);
-                break;
-            case Opcodes.DALOAD:
-            case Opcodes.L2D:
-                pop(2);
-                push(DOUBLE);
-                push(TOP);
-                break;
-            case Opcodes.AALOAD:
-                pop(1);
-                t1 = pop();
-                push(ELEMENT_OF + t1);
-                break;
-            case Opcodes.ISTORE:
-            case Opcodes.FSTORE:
-            case Opcodes.ASTORE:
-                t1 = pop();
-                set(arg, t1);
-                if (arg > 0) {
-                    t2 = get(arg - 1);
-                    // if t2 is of kind STACK or LOCAL we cannot know its size!
-                    if (t2 == LONG || t2 == DOUBLE) {
-                        set(arg - 1, TOP);
-                    } else if ((t2 & KIND) != BASE) {
-                        set(arg - 1, t2 | TOP_IF_LONG_OR_DOUBLE);
-                    }
-                }
-                break;
-            case Opcodes.LSTORE:
-            case Opcodes.DSTORE:
-                pop(1);
-                t1 = pop();
-                set(arg, t1);
-                set(arg + 1, TOP);
-                if (arg > 0) {
-                    t2 = get(arg - 1);
-                    // if t2 is of kind STACK or LOCAL we cannot know its size!
-                    if (t2 == LONG || t2 == DOUBLE) {
-                        set(arg - 1, TOP);
-                    } else if ((t2 & KIND) != BASE) {
-                        set(arg - 1, t2 | TOP_IF_LONG_OR_DOUBLE);
-                    }
-                }
-                break;
-            case Opcodes.IASTORE:
-            case Opcodes.BASTORE:
-            case Opcodes.CASTORE:
-            case Opcodes.SASTORE:
-            case Opcodes.FASTORE:
-            case Opcodes.AASTORE:
-                pop(3);
-                break;
-            case Opcodes.LASTORE:
-            case Opcodes.DASTORE:
-                pop(4);
-                break;
-            case Opcodes.POP:
-            case Opcodes.IFEQ:
-            case Opcodes.IFNE:
-            case Opcodes.IFLT:
-            case Opcodes.IFGE:
-            case Opcodes.IFGT:
-            case Opcodes.IFLE:
-            case Opcodes.IRETURN:
-            case Opcodes.FRETURN:
-            case Opcodes.ARETURN:
-            case Opcodes.TABLESWITCH:
-            case Opcodes.LOOKUPSWITCH:
-            case Opcodes.ATHROW:
-            case Opcodes.MONITORENTER:
-            case Opcodes.MONITOREXIT:
-            case Opcodes.IFNULL:
-            case Opcodes.IFNONNULL:
-                pop(1);
-                break;
-            case Opcodes.POP2:
-            case Opcodes.IF_ICMPEQ:
-            case Opcodes.IF_ICMPNE:
-            case Opcodes.IF_ICMPLT:
-            case Opcodes.IF_ICMPGE:
-            case Opcodes.IF_ICMPGT:
-            case Opcodes.IF_ICMPLE:
-            case Opcodes.IF_ACMPEQ:
-            case Opcodes.IF_ACMPNE:
-            case Opcodes.LRETURN:
-            case Opcodes.DRETURN:
-                pop(2);
-                break;
-            case Opcodes.DUP:
-                t1 = pop();
-                push(t1);
-                push(t1);
-                break;
-            case Opcodes.DUP_X1:
-                t1 = pop();
-                t2 = pop();
-                push(t1);
-                push(t2);
-                push(t1);
-                break;
-            case Opcodes.DUP_X2:
-                t1 = pop();
-                t2 = pop();
-                t3 = pop();
-                push(t1);
-                push(t3);
-                push(t2);
-                push(t1);
-                break;
-            case Opcodes.DUP2:
-                t1 = pop();
-                t2 = pop();
-                push(t2);
-                push(t1);
-                push(t2);
-                push(t1);
-                break;
-            case Opcodes.DUP2_X1:
-                t1 = pop();
-                t2 = pop();
-                t3 = pop();
-                push(t2);
-                push(t1);
-                push(t3);
-                push(t2);
-                push(t1);
-                break;
-            case Opcodes.DUP2_X2:
-                t1 = pop();
-                t2 = pop();
-                t3 = pop();
-                t4 = pop();
-                push(t2);
-                push(t1);
-                push(t4);
-                push(t3);
-                push(t2);
-                push(t1);
-                break;
-            case Opcodes.SWAP:
-                t1 = pop();
-                t2 = pop();
-                push(t1);
-                push(t2);
-                break;
-            case Opcodes.IADD:
-            case Opcodes.ISUB:
-            case Opcodes.IMUL:
-            case Opcodes.IDIV:
-            case Opcodes.IREM:
-            case Opcodes.IAND:
-            case Opcodes.IOR:
-            case Opcodes.IXOR:
-            case Opcodes.ISHL:
-            case Opcodes.ISHR:
-            case Opcodes.IUSHR:
-            case Opcodes.L2I:
-            case Opcodes.D2I:
-            case Opcodes.FCMPL:
-            case Opcodes.FCMPG:
-                pop(2);
-                push(INTEGER);
-                break;
-            case Opcodes.LADD:
-            case Opcodes.LSUB:
-            case Opcodes.LMUL:
-            case Opcodes.LDIV:
-            case Opcodes.LREM:
-            case Opcodes.LAND:
-            case Opcodes.LOR:
-            case Opcodes.LXOR:
-                pop(4);
-                push(LONG);
-                push(TOP);
-                break;
-            case Opcodes.FADD:
-            case Opcodes.FSUB:
-            case Opcodes.FMUL:
-            case Opcodes.FDIV:
-            case Opcodes.FREM:
-            case Opcodes.L2F:
-            case Opcodes.D2F:
-                pop(2);
-                push(FLOAT);
-                break;
-            case Opcodes.DADD:
-            case Opcodes.DSUB:
-            case Opcodes.DMUL:
-            case Opcodes.DDIV:
-            case Opcodes.DREM:
-                pop(4);
-                push(DOUBLE);
-                push(TOP);
-                break;
-            case Opcodes.LSHL:
-            case Opcodes.LSHR:
-            case Opcodes.LUSHR:
-                pop(3);
-                push(LONG);
-                push(TOP);
-                break;
-            case Opcodes.IINC:
-                set(arg, INTEGER);
-                break;
-            case Opcodes.I2L:
-            case Opcodes.F2L:
-                pop(1);
-                push(LONG);
-                push(TOP);
-                break;
-            case Opcodes.I2F:
-                pop(1);
-                push(FLOAT);
-                break;
-            case Opcodes.I2D:
-            case Opcodes.F2D:
-                pop(1);
-                push(DOUBLE);
-                push(TOP);
-                break;
-            case Opcodes.F2I:
-            case Opcodes.ARRAYLENGTH:
-            case Opcodes.INSTANCEOF:
-                pop(1);
-                push(INTEGER);
-                break;
-            case Opcodes.LCMP:
-            case Opcodes.DCMPL:
-            case Opcodes.DCMPG:
-                pop(4);
-                push(INTEGER);
-                break;
-            case Opcodes.JSR:
-            case Opcodes.RET:
-                throw new RuntimeException("JSR/RET are not supported with computeFrames option");
-            case Opcodes.GETSTATIC:
-                push(cw, item.strVal3);
-                break;
-            case Opcodes.PUTSTATIC:
-                pop(item.strVal3);
-                break;
-            case Opcodes.GETFIELD:
-                pop(1);
-                push(cw, item.strVal3);
-                break;
-            case Opcodes.PUTFIELD:
-                pop(item.strVal3);
-                pop();
-                break;
-            case Opcodes.INVOKEVIRTUAL:
-            case Opcodes.INVOKESPECIAL:
-            case Opcodes.INVOKESTATIC:
-            case Opcodes.INVOKEINTERFACE:
-                pop(item.strVal3);
-                if (opcode != Opcodes.INVOKESTATIC) {
-                    t1 = pop();
-                    if (opcode == Opcodes.INVOKESPECIAL
-                            && item.strVal2.charAt(0) == '<')
-                    {
-                        init(t1);
-                    }
-                }
-                push(cw, item.strVal3);
-                break;
-            case Opcodes.INVOKEDYNAMIC:
-                pop(item.strVal2);
-                push(cw, item.strVal2);
-                break;
-            case Opcodes.NEW:
-                push(UNINITIALIZED | cw.addUninitializedType(item.strVal1, arg));
-                break;
-            case Opcodes.NEWARRAY:
-                pop();
-                switch (arg) {
-                    case Opcodes.T_BOOLEAN:
-                        push(ARRAY_OF | BOOLEAN);
-                        break;
-                    case Opcodes.T_CHAR:
-                        push(ARRAY_OF | CHAR);
-                        break;
-                    case Opcodes.T_BYTE:
-                        push(ARRAY_OF | BYTE);
-                        break;
-                    case Opcodes.T_SHORT:
-                        push(ARRAY_OF | SHORT);
-                        break;
-                    case Opcodes.T_INT:
-                        push(ARRAY_OF | INTEGER);
-                        break;
-                    case Opcodes.T_FLOAT:
-                        push(ARRAY_OF | FLOAT);
-                        break;
-                    case Opcodes.T_DOUBLE:
-                        push(ARRAY_OF | DOUBLE);
-                        break;
-                    // case Opcodes.T_LONG:
-                    default:
-                        push(ARRAY_OF | LONG);
-                        break;
-                }
-                break;
-            case Opcodes.ANEWARRAY:
-                String s = item.strVal1;
-                pop();
-                if (s.charAt(0) == '[') {
-                    push(cw, '[' + s);
-                } else {
-                    push(ARRAY_OF | OBJECT | cw.addType(s));
-                }
-                break;
-            case Opcodes.CHECKCAST:
-                s = item.strVal1;
-                pop();
-                if (s.charAt(0) == '[') {
-                    push(cw, s);
-                } else {
-                    push(OBJECT | cw.addType(s));
-                }
-                break;
-            // case Opcodes.MULTIANEWARRAY:
-            default:
-                pop(arg);
-                push(cw, item.strVal1);
-                break;
-        }
-    }
-
-    /**
-     * Merges the input frame of the given basic block with the input and output
-     * frames of this basic block. Returns <tt>true</tt> if the input frame of
-     * the given label has been changed by this operation.
-     * 
-     * @param cw the ClassWriter to which this label belongs.
-     * @param frame the basic block whose input frame must be updated.
-     * @param edge the kind of the {@link Edge} between this label and 'label'.
-     *        See {@link Edge#info}.
-     * @return <tt>true</tt> if the input frame of the given label has been
-     *         changed by this operation.
-     */
-    boolean merge(final ClassWriter cw, final Frame frame, final int edge) {
-        boolean changed = false;
-        int i, s, dim, kind, t;
-
-        int nLocal = inputLocals.length;
-        int nStack = inputStack.length;
-        if (frame.inputLocals == null) {
-            frame.inputLocals = new int[nLocal];
-            changed = true;
-        }
-
-        for (i = 0; i < nLocal; ++i) {
-            if (outputLocals != null && i < outputLocals.length) {
-                s = outputLocals[i];
-                if (s == 0) {
-                    t = inputLocals[i];
-                } else {
-                    dim = s & DIM;
-                    kind = s & KIND;
-                    if (kind == BASE) {
-                        t = s;
-                    } else {
-                        if (kind == LOCAL) {
-                            t = dim + inputLocals[s & VALUE];
-                        } else {
-                            t = dim + inputStack[nStack - (s & VALUE)];
-                        }
-                        if ((s & TOP_IF_LONG_OR_DOUBLE) != 0 && (t == LONG || t == DOUBLE)) {
-                            t = TOP;
-                        }
-                    }
-                }
-            } else {
-                t = inputLocals[i];
-            }
-            if (initializations != null) {
-                t = init(cw, t);
-            }
-            changed |= merge(cw, t, frame.inputLocals, i);
-        }
-
-        if (edge > 0) {
-            for (i = 0; i < nLocal; ++i) {
-                t = inputLocals[i];
-                changed |= merge(cw, t, frame.inputLocals, i);
-            }
-            if (frame.inputStack == null) {
-                frame.inputStack = new int[1];
-                changed = true;
-            }
-            changed |= merge(cw, edge, frame.inputStack, 0);
-            return changed;
-        }
-
-        int nInputStack = inputStack.length + owner.inputStackTop;
-        if (frame.inputStack == null) {
-            frame.inputStack = new int[nInputStack + outputStackTop];
-            changed = true;
-        }
-
-        for (i = 0; i < nInputStack; ++i) {
-            t = inputStack[i];
-            if (initializations != null) {
-                t = init(cw, t);
-            }
-            changed |= merge(cw, t, frame.inputStack, i);
-        }
-        for (i = 0; i < outputStackTop; ++i) {
-            s = outputStack[i];
-            dim = s & DIM;
-            kind = s & KIND;
-            if (kind == BASE) {
-                t = s;
-            } else {
-                if (kind == LOCAL) {
-                    t = dim + inputLocals[s & VALUE];
-                } else {
-                    t = dim + inputStack[nStack - (s & VALUE)];
-                }
-                if ((s & TOP_IF_LONG_OR_DOUBLE) != 0 && (t == LONG || t == DOUBLE)) {
-                    t = TOP;
-                }
-            }
-            if (initializations != null) {
-                t = init(cw, t);
-            }
-            changed |= merge(cw, t, frame.inputStack, nInputStack + i);
-        }
-        return changed;
-    }
-
-    /**
-     * Merges the type at the given index in the given type array with the given
-     * type. Returns <tt>true</tt> if the type array has been modified by this
-     * operation.
-     * 
-     * @param cw the ClassWriter to which this label belongs.
-     * @param t the type with which the type array element must be merged.
-     * @param types an array of types.
-     * @param index the index of the type that must be merged in 'types'.
-     * @return <tt>true</tt> if the type array has been modified by this
-     *         operation.
-     */
-    private static boolean merge(
-        final ClassWriter cw,
-        int t,
-        final int[] types,
-        final int index)
-    {
-        int u = types[index];
-        if (u == t) {
-            // if the types are equal, merge(u,t)=u, so there is no change
-            return false;
-        }
-        if ((t & ~DIM) == NULL) {
-            if (u == NULL) {
-                return false;
-            }
-            t = NULL;
-        }
-        if (u == 0) {
-            // if types[index] has never been assigned, merge(u,t)=t
-            types[index] = t;
-            return true;
-        }
-        int v;
-        if ((u & BASE_KIND) == OBJECT || (u & DIM) != 0) {
-            // if u is a reference type of any dimension
-            if (t == NULL) {
-                // if t is the NULL type, merge(u,t)=u, so there is no change
-                return false;
-            } else if ((t & (DIM | BASE_KIND)) == (u & (DIM | BASE_KIND))) {
-                if ((u & BASE_KIND) == OBJECT) {
-                    // if t is also a reference type, and if u and t have the
-                    // same dimension merge(u,t) = dim(t) | common parent of the
-                    // element types of u and t
-                    v = (t & DIM) | OBJECT
-                            | cw.getMergedType(t & BASE_VALUE, u & BASE_VALUE);
-                } else {
-                    // if u and t are array types, but not with the same element
-                    // type, merge(u,t)=java/lang/Object
-                    v = OBJECT | cw.addType("java/lang/Object");
-                }
-            } else if ((t & BASE_KIND) == OBJECT || (t & DIM) != 0) {
-                // if t is any other reference or array type,
-                // merge(u,t)=java/lang/Object
-                v = OBJECT | cw.addType("java/lang/Object");
-            } else {
-                // if t is any other type, merge(u,t)=TOP
-                v = TOP;
-            }
-        } else if (u == NULL) {
-            // if u is the NULL type, merge(u,t)=t,
-            // or TOP if t is not a reference type
-            v = (t & BASE_KIND) == OBJECT || (t & DIM) != 0 ? t : TOP;
-        } else {
-            // if u is any other type, merge(u,t)=TOP whatever t
-            v = TOP;
-        }
-        if (u != v) {
-            types[index] = v;
-            return true;
-        }
-        return false;
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/Handler.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/Handler.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/Handler.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/Handler.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,70 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * Information about an exception handler block.
- * 
- * @author Eric Bruneton
- */
-class Handler {
-
-    /**
-     * Beginning of the exception handler's scope (inclusive).
-     */
-    Label start;
-
-    /**
-     * End of the exception handler's scope (exclusive).
-     */
-    Label end;
-
-    /**
-     * Beginning of the exception handler's code.
-     */
-    Label handler;
-
-    /**
-     * Internal name of the type of exceptions handled by this handler, or
-     * <tt>null</tt> to catch any exceptions.
-     */
-    String desc;
-
-    /**
-     * Constant pool index of the internal name of the type of exceptions
-     * handled by this handler, or 0 to catch any exceptions.
-     */
-    int type;
-
-    /**
-     * Next exception handler block info.
-     */
-    Handler next;
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/Item.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/Item.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/Item.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/Item.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,254 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * A constant pool item. Constant pool items can be created with the 'newXXX'
- * methods in the {@link ClassWriter} class.
- * 
- * @author Eric Bruneton
- */
-final class Item {
-
-    /**
-     * Index of this item in the constant pool.
-     */
-    int index;
-
-    /**
-     * Type of this constant pool item. A single class is used to represent all
-     * constant pool item types, in order to minimize the bytecode size of this
-     * package. The value of this field is one of {@link ClassWriter#INT},
-     * {@link ClassWriter#LONG}, {@link ClassWriter#FLOAT},
-     * {@link ClassWriter#DOUBLE}, {@link ClassWriter#UTF8},
-     * {@link ClassWriter#STR}, {@link ClassWriter#CLASS},
-     * {@link ClassWriter#NAME_TYPE}, {@link ClassWriter#FIELD},
-     * {@link ClassWriter#METH}, {@link ClassWriter#IMETH}.
-     * 
-     * Special Item types are used for Items that are stored in the ClassWriter
-     * {@link ClassWriter#typeTable}, instead of the constant pool, in order to
-     * avoid clashes with normal constant pool items in the ClassWriter constant
-     * pool's hash table. These special item types are
-     * {@link ClassWriter#TYPE_NORMAL}, {@link ClassWriter#TYPE_UNINIT} and
-     * {@link ClassWriter#TYPE_MERGED}.
-     */
-    int type;
-
-    /**
-     * Value of this item, for an integer item.
-     */
-    int intVal;
-
-    /**
-     * Value of this item, for a long item.
-     */
-    long longVal;
-
-    /**
-     * First part of the value of this item, for items that do not hold a
-     * primitive value.
-     */
-    String strVal1;
-
-    /**
-     * Second part of the value of this item, for items that do not hold a
-     * primitive value.
-     */
-    String strVal2;
-
-    /**
-     * Third part of the value of this item, for items that do not hold a
-     * primitive value.
-     */
-    String strVal3;
-
-    /**
-     * The hash code value of this constant pool item.
-     */
-    int hashCode;
-
-    /**
-     * Link to another constant pool item, used for collision lists in the
-     * constant pool's hash table.
-     */
-    Item next;
-
-    /**
-     * Constructs an uninitialized {@link Item}.
-     */
-    Item() {
-    }
-
-    /**
-     * Constructs an uninitialized {@link Item} for constant pool element at
-     * given position.
-     * 
-     * @param index index of the item to be constructed.
-     */
-    Item(final int index) {
-        this.index = index;
-    }
-
-    /**
-     * Constructs a copy of the given item.
-     * 
-     * @param index index of the item to be constructed.
-     * @param i the item that must be copied into the item to be constructed.
-     */
-    Item(final int index, final Item i) {
-        this.index = index;
-        type = i.type;
-        intVal = i.intVal;
-        longVal = i.longVal;
-        strVal1 = i.strVal1;
-        strVal2 = i.strVal2;
-        strVal3 = i.strVal3;
-        hashCode = i.hashCode;
-    }
-
-    /**
-     * Sets this item to an integer item.
-     * 
-     * @param intVal the value of this item.
-     */
-    void set(final int intVal) {
-        this.type = ClassWriter.INT;
-        this.intVal = intVal;
-        this.hashCode = 0x7FFFFFFF & (type + intVal);
-    }
-
-    /**
-     * Sets this item to a long item.
-     * 
-     * @param longVal the value of this item.
-     */
-    void set(final long longVal) {
-        this.type = ClassWriter.LONG;
-        this.longVal = longVal;
-        this.hashCode = 0x7FFFFFFF & (type + (int) longVal);
-    }
-
-    /**
-     * Sets this item to a float item.
-     * 
-     * @param floatVal the value of this item.
-     */
-    void set(final float floatVal) {
-        this.type = ClassWriter.FLOAT;
-        this.intVal = Float.floatToRawIntBits(floatVal);
-        this.hashCode = 0x7FFFFFFF & (type + (int) floatVal);
-    }
-
-    /**
-     * Sets this item to a double item.
-     * 
-     * @param doubleVal the value of this item.
-     */
-    void set(final double doubleVal) {
-        this.type = ClassWriter.DOUBLE;
-        this.longVal = Double.doubleToRawLongBits(doubleVal);
-        this.hashCode = 0x7FFFFFFF & (type + (int) doubleVal);
-    }
-
-    /**
-     * Sets this item to an item that do not hold a primitive value.
-     * 
-     * @param type the type of this item.
-     * @param strVal1 first part of the value of this item.
-     * @param strVal2 second part of the value of this item.
-     * @param strVal3 third part of the value of this item.
-     */
-    void set(
-        final int type,
-        final String strVal1,
-        final String strVal2,
-        final String strVal3)
-    {
-        this.type = type;
-        this.strVal1 = strVal1;
-        this.strVal2 = strVal2;
-        this.strVal3 = strVal3;
-        switch (type) {
-            case ClassWriter.UTF8:
-            case ClassWriter.STR:
-            case ClassWriter.CLASS:
-            case ClassWriter.TYPE_NORMAL:
-                hashCode = 0x7FFFFFFF & (type + strVal1.hashCode());
-                return;
-            case ClassWriter.NAME_TYPE:
-                hashCode = 0x7FFFFFFF & (type + strVal1.hashCode()
-                        * strVal2.hashCode());
-                return;
-                // ClassWriter.FIELD:
-                // ClassWriter.METH:
-                // ClassWriter.IMETH:
-            default:
-                hashCode = 0x7FFFFFFF & (type + strVal1.hashCode()
-                        * strVal2.hashCode() * strVal3.hashCode());
-        }
-    }
-
-    /**
-     * Indicates if the given item is equal to this one. <i>This method assumes
-     * that the two items have the same {@link #type}</i>. 
-     * 
-     * @param i the item to be compared to this one. Both items must have the
-     *       same {@link #type}.
-     * @return <tt>true</tt> if the given item if equal to this one,
-     *         <tt>false</tt> otherwise.
-     */
-    boolean isEqualTo(final Item i) {
-        switch (type) {
-            case ClassWriter.UTF8:
-            case ClassWriter.STR:
-            case ClassWriter.CLASS:
-            case ClassWriter.TYPE_NORMAL:
-                return i.strVal1.equals(strVal1);
-            case ClassWriter.TYPE_MERGED:
-            case ClassWriter.LONG:
-            case ClassWriter.DOUBLE:
-                return i.longVal == longVal;
-            case ClassWriter.INT:
-            case ClassWriter.FLOAT:
-                return i.intVal == intVal;
-            case ClassWriter.TYPE_UNINIT:
-                return i.intVal == intVal && i.strVal1.equals(strVal1);
-            case ClassWriter.NAME_TYPE:
-                return i.strVal1.equals(strVal1) && i.strVal2.equals(strVal2);
-            // case ClassWriter.FIELD:
-            // case ClassWriter.METH:
-            // case ClassWriter.IMETH:
-            default:    
-                return i.strVal1.equals(strVal1) && i.strVal2.equals(strVal2)
-                        && i.strVal3.equals(strVal3);
-        }
-    }
-
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/Label.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/Label.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/Label.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/Label.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,554 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * A label represents a position in the bytecode of a method. Labels are used
- * for jump, goto, and switch instructions, and for try catch blocks. A label
- * designates the <i>instruction</i> that is just after. Note however that
- * there can be other elements between a label and the instruction it 
- * designates (such as other labels, stack map frames, line numbers, etc.).
- * 
- * @author Eric Bruneton
- */
-public class Label {
-
-    /**
-     * Indicates if this label is only used for debug attributes. Such a label
-     * is not the start of a basic block, the target of a jump instruction, or
-     * an exception handler. It can be safely ignored in control flow graph
-     * analysis algorithms (for optimization purposes).
-     */
-    static final int DEBUG = 1;
-
-    /**
-     * Indicates if the position of this label is known.
-     */
-    static final int RESOLVED = 2;
-
-    /**
-     * Indicates if this label has been updated, after instruction resizing.
-     */
-    static final int RESIZED = 4;
-
-    /**
-     * Indicates if this basic block has been pushed in the basic block stack.
-     * See {@link MethodWriter#visitMaxs visitMaxs}.
-     */
-    static final int PUSHED = 8;
-
-    /**
-     * Indicates if this label is the target of a jump instruction, or the start
-     * of an exception handler.
-     */
-    static final int TARGET = 16;
-
-    /**
-     * Indicates if a stack map frame must be stored for this label.
-     */
-    static final int STORE = 32;
-
-    /**
-     * Indicates if this label corresponds to a reachable basic block.
-     */
-    static final int REACHABLE = 64;
-
-    /**
-     * Indicates if this basic block ends with a JSR instruction.
-     */
-    static final int JSR = 128;
-
-    /**
-     * Indicates if this basic block ends with a RET instruction.
-     */
-    static final int RET = 256;
-
-    /**
-     * Indicates if this basic block is the start of a subroutine.
-     */
-    static final int SUBROUTINE = 512;
-
-    /**
-     * Indicates if this subroutine basic block has been visited by a 
-     * visitSubroutine(null, ...) call.
-     */
-    static final int VISITED = 1024;
-
-    /**
-     * Indicates if this subroutine basic block has been visited by a
-     * visitSubroutine(!null, ...) call.
-     */
-    static final int VISITED2 = 2048;
-
-    /**
-     * Field used to associate user information to a label. Warning: this field
-     * is used by the ASM tree package. In order to use it with the ASM tree
-     * package you must override the {@link 
-     * org.eclipse.persistence.internal.libraries.asm.tree.MethodNode#getLabelNode} method.
-     */
-    public Object info;
-
-    /**
-     * Flags that indicate the status of this label.
-     * 
-     * @see #DEBUG
-     * @see #RESOLVED
-     * @see #RESIZED
-     * @see #PUSHED
-     * @see #TARGET
-     * @see #STORE
-     * @see #REACHABLE
-     * @see #JSR
-     * @see #RET
-     */
-    int status;
-
-    /**
-     * The line number corresponding to this label, if known.
-     */
-    int line;
-
-    /**
-     * The position of this label in the code, if known.
-     */
-    int position;
-
-    /**
-     * Number of forward references to this label, times two.
-     */
-    private int referenceCount;
-
-    /**
-     * Informations about forward references. Each forward reference is
-     * described by two consecutive integers in this array: the first one is the
-     * position of the first byte of the bytecode instruction that contains the
-     * forward reference, while the second is the position of the first byte of
-     * the forward reference itself. In fact the sign of the first integer
-     * indicates if this reference uses 2 or 4 bytes, and its absolute value
-     * gives the position of the bytecode instruction. This array is also used
-     * as a bitset to store the subroutines to which a basic block belongs. This
-     * information is needed in {@linked  MethodWriter#visitMaxs}, after all
-     * forward references have been resolved. Hence the same array can be used
-     * for both purposes without problems.
-     */
-    private int[] srcAndRefPositions;
-
-    // ------------------------------------------------------------------------
-
-    /*
-     * Fields for the control flow and data flow graph analysis algorithms (used
-     * to compute the maximum stack size or the stack map frames). A control
-     * flow graph contains one node per "basic block", and one edge per "jump"
-     * from one basic block to another. Each node (i.e., each basic block) is
-     * represented by the Label object that corresponds to the first instruction
-     * of this basic block. Each node also stores the list of its successors in
-     * the graph, as a linked list of Edge objects.
-     * 
-     * The control flow analysis algorithms used to compute the maximum stack
-     * size or the stack map frames are similar and use two steps. The first
-     * step, during the visit of each instruction, builds information about the
-     * state of the local variables and the operand stack at the end of each
-     * basic block, called the "output frame", <i>relatively</i> to the frame
-     * state at the beginning of the basic block, which is called the "input
-     * frame", and which is <i>unknown</i> during this step. The second step,
-     * in {@link MethodWriter#visitMaxs}, is a fix point algorithm that
-     * computes information about the input frame of each basic block, from the
-     * input state of the first basic block (known from the method signature),
-     * and by the using the previously computed relative output frames.
-     * 
-     * The algorithm used to compute the maximum stack size only computes the
-     * relative output and absolute input stack heights, while the algorithm
-     * used to compute stack map frames computes relative output frames and
-     * absolute input frames.
-     */
-
-    /**
-     * Start of the output stack relatively to the input stack. The exact
-     * semantics of this field depends on the algorithm that is used.
-     * 
-     * When only the maximum stack size is computed, this field is the number of
-     * elements in the input stack.
-     * 
-     * When the stack map frames are completely computed, this field is the
-     * offset of the first output stack element relatively to the top of the
-     * input stack. This offset is always negative or null. A null offset means
-     * that the output stack must be appended to the input stack. A -n offset
-     * means that the first n output stack elements must replace the top n input
-     * stack elements, and that the other elements must be appended to the input
-     * stack.
-     */
-    int inputStackTop;
-
-    /**
-     * Maximum height reached by the output stack, relatively to the top of the
-     * input stack. This maximum is always positive or null.
-     */
-    int outputStackMax;
-
-    /**
-     * Information about the input and output stack map frames of this basic
-     * block. This field is only used when {@link ClassWriter#COMPUTE_FRAMES}
-     * option is used.
-     */
-    Frame frame;
-
-    /**
-     * The successor of this label, in the order they are visited. This linked
-     * list does not include labels used for debug info only. If
-     * {@link ClassWriter#COMPUTE_FRAMES} option is used then, in addition, it
-     * does not contain successive labels that denote the same bytecode position
-     * (in this case only the first label appears in this list).
-     */
-    Label successor;
-
-    /**
-     * The successors of this node in the control flow graph. These successors
-     * are stored in a linked list of {@link Edge Edge} objects, linked to each
-     * other by their {@link Edge#next} field.
-     */
-    Edge successors;
-
-    /**
-     * The next basic block in the basic block stack. This stack is used in the
-     * main loop of the fix point algorithm used in the second step of the
-     * control flow analysis algorithms. It is also used in 
-     * {@link #visitSubroutine} to avoid using a recursive method.
-     * 
-     * @see MethodWriter#visitMaxs
-     */
-    Label next;
-
-    // ------------------------------------------------------------------------
-    // Constructor
-    // ------------------------------------------------------------------------
-
-    /**
-     * Constructs a new label.
-     */
-    public Label() {
-    }
-
-    // ------------------------------------------------------------------------
-    // Methods to compute offsets and to manage forward references
-    // ------------------------------------------------------------------------
-
-    /**
-     * Returns the offset corresponding to this label. This offset is computed
-     * from the start of the method's bytecode. <i>This method is intended for
-     * {@link Attribute} sub classes, and is normally not needed by class
-     * generators or adapters.</i>
-     * 
-     * @return the offset corresponding to this label.
-     * @throws IllegalStateException if this label is not resolved yet.
-     */
-    public int getOffset() {
-        if ((status & RESOLVED) == 0) {
-            throw new IllegalStateException("Label offset position has not been resolved yet");
-        }
-        return position;
-    }
-
-    /**
-     * Puts a reference to this label in the bytecode of a method. If the
-     * position of the label is known, the offset is computed and written
-     * directly. Otherwise, a null offset is written and a new forward reference
-     * is declared for this label.
-     * 
-     * @param owner the code writer that calls this method.
-     * @param out the bytecode of the method.
-     * @param source the position of first byte of the bytecode instruction that
-     *        contains this label.
-     * @param wideOffset <tt>true</tt> if the reference must be stored in 4
-     *        bytes, or <tt>false</tt> if it must be stored with 2 bytes.
-     * @throws IllegalArgumentException if this label has not been created by
-     *         the given code writer.
-     */
-    void put(
-        final MethodWriter owner,
-        final ByteVector out,
-        final int source,
-        final boolean wideOffset)
-    {
-        if ((status & RESOLVED) == 0) {
-            if (wideOffset) {
-                addReference(-1 - source, out.length);
-                out.putInt(-1);
-            } else {
-                addReference(source, out.length);
-                out.putShort(-1);
-            }
-        } else {
-            if (wideOffset) {
-                out.putInt(position - source);
-            } else {
-                out.putShort(position - source);
-            }
-        }
-    }
-
-    /**
-     * Adds a forward reference to this label. This method must be called only
-     * for a true forward reference, i.e. only if this label is not resolved
-     * yet. For backward references, the offset of the reference can be, and
-     * must be, computed and stored directly.
-     * 
-     * @param sourcePosition the position of the referencing instruction. This
-     *        position will be used to compute the offset of this forward
-     *        reference.
-     * @param referencePosition the position where the offset for this forward
-     *        reference must be stored.
-     */
-    private void addReference(
-        final int sourcePosition,
-        final int referencePosition)
-    {
-        if (srcAndRefPositions == null) {
-            srcAndRefPositions = new int[6];
-        }
-        if (referenceCount >= srcAndRefPositions.length) {
-            int[] a = new int[srcAndRefPositions.length + 6];
-            System.arraycopy(srcAndRefPositions,
-                    0,
-                    a,
-                    0,
-                    srcAndRefPositions.length);
-            srcAndRefPositions = a;
-        }
-        srcAndRefPositions[referenceCount++] = sourcePosition;
-        srcAndRefPositions[referenceCount++] = referencePosition;
-    }
-
-    /**
-     * Resolves all forward references to this label. This method must be called
-     * when this label is added to the bytecode of the method, i.e. when its
-     * position becomes known. This method fills in the blanks that where left
-     * in the bytecode by each forward reference previously added to this label.
-     * 
-     * @param owner the code writer that calls this method.
-     * @param position the position of this label in the bytecode.
-     * @param data the bytecode of the method.
-     * @return <tt>true</tt> if a blank that was left for this label was to
-     *         small to store the offset. In such a case the corresponding jump
-     *         instruction is replaced with a pseudo instruction (using unused
-     *         opcodes) using an unsigned two bytes offset. These pseudo
-     *         instructions will need to be replaced with true instructions with
-     *         wider offsets (4 bytes instead of 2). This is done in
-     *         {@link MethodWriter#resizeInstructions}.
-     * @throws IllegalArgumentException if this label has already been resolved,
-     *         or if it has not been created by the given code writer.
-     */
-    boolean resolve(
-        final MethodWriter owner,
-        final int position,
-        final byte[] data)
-    {
-        boolean needUpdate = false;
-        this.status |= RESOLVED;
-        this.position = position;
-        int i = 0;
-        while (i < referenceCount) {
-            int source = srcAndRefPositions[i++];
-            int reference = srcAndRefPositions[i++];
-            int offset;
-            if (source >= 0) {
-                offset = position - source;
-                if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {
-                    /*
-                     * changes the opcode of the jump instruction, in order to
-                     * be able to find it later (see resizeInstructions in
-                     * MethodWriter). These temporary opcodes are similar to
-                     * jump instruction opcodes, except that the 2 bytes offset
-                     * is unsigned (and can therefore represent values from 0 to
-                     * 65535, which is sufficient since the size of a method is
-                     * limited to 65535 bytes).
-                     */
-                    int opcode = data[reference - 1] & 0xFF;
-                    if (opcode <= Opcodes.JSR) {
-                        // changes IFEQ ... JSR to opcodes 202 to 217
-                        data[reference - 1] = (byte) (opcode + 49);
-                    } else {
-                        // changes IFNULL and IFNONNULL to opcodes 218 and 219
-                        data[reference - 1] = (byte) (opcode + 20);
-                    }
-                    needUpdate = true;
-                }
-                data[reference++] = (byte) (offset >>> 8);
-                data[reference] = (byte) offset;
-            } else {
-                offset = position + source + 1;
-                data[reference++] = (byte) (offset >>> 24);
-                data[reference++] = (byte) (offset >>> 16);
-                data[reference++] = (byte) (offset >>> 8);
-                data[reference] = (byte) offset;
-            }
-        }
-        return needUpdate;
-    }
-
-    /**
-     * Returns the first label of the series to which this label belongs. For an
-     * isolated label or for the first label in a series of successive labels,
-     * this method returns the label itself. For other labels it returns the
-     * first label of the series.
-     * 
-     * @return the first label of the series to which this label belongs.
-     */
-    Label getFirst() {
-        return !ClassReader.FRAMES || frame == null ? this : frame.owner;
-    }
-
-    // ------------------------------------------------------------------------
-    // Methods related to subroutines
-    // ------------------------------------------------------------------------
-
-    /**
-     * Returns true is this basic block belongs to the given subroutine.
-     * 
-     * @param id a subroutine id.
-     * @return true is this basic block belongs to the given subroutine.
-     */
-    boolean inSubroutine(final long id) {
-        if ((status & Label.VISITED) != 0) {
-            return (srcAndRefPositions[(int) (id >>> 32)] & (int) id) != 0;
-        }
-        return false;
-    }
-
-    /**
-     * Returns true if this basic block and the given one belong to a common
-     * subroutine.
-     * 
-     * @param block another basic block.
-     * @return true if this basic block and the given one belong to a common
-     *         subroutine.
-     */
-    boolean inSameSubroutine(final Label block) {
-        if ((status & VISITED) == 0 || (block.status & VISITED) == 0) {
-            return false;
-        }
-        for (int i = 0; i < srcAndRefPositions.length; ++i) {
-            if ((srcAndRefPositions[i] & block.srcAndRefPositions[i]) != 0) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Marks this basic block as belonging to the given subroutine.
-     * 
-     * @param id a subroutine id.
-     * @param nbSubroutines the total number of subroutines in the method.
-     */
-    void addToSubroutine(final long id, final int nbSubroutines) {
-        if ((status & VISITED) == 0) {
-            status |= VISITED;
-            srcAndRefPositions = new int[(nbSubroutines - 1) / 32 + 1];
-        }
-        srcAndRefPositions[(int) (id >>> 32)] |= (int) id;
-    }
-    
-    /**
-     * Finds the basic blocks that belong to a given subroutine, and marks these
-     * blocks as belonging to this subroutine. This method follows the control
-     * flow graph to find all the blocks that are reachable from the current
-     * block WITHOUT following any JSR target.
-     * 
-     * @param JSR a JSR block that jumps to this subroutine. If this JSR is not
-     *        null it is added to the successor of the RET blocks found in the
-     *        subroutine.
-     * @param id the id of this subroutine.
-     * @param nbSubroutines the total number of subroutines in the method.
-     */
-    void visitSubroutine(final Label JSR, final long id, final int nbSubroutines)
-    {
-        // user managed stack of labels, to avoid using a recursive method
-        // (recursivity can lead to stack overflow with very large methods)
-        Label stack = this;
-        while (stack != null) {
-            // removes a label l from the stack
-            Label l = stack;
-            stack = l.next;
-            l.next = null;
-            
-            if (JSR != null) {
-                if ((l.status & VISITED2) != 0) {
-                    continue;
-                }
-                l.status |= VISITED2;
-                // adds JSR to the successors of l, if it is a RET block
-                if ((l.status & RET) != 0) {
-                    if (!l.inSameSubroutine(JSR)) {
-                        Edge e = new Edge();
-                        e.info = l.inputStackTop;
-                        e.successor = JSR.successors.successor;
-                        e.next = l.successors;
-                        l.successors = e;
-                    }
-                }
-            } else {
-                // if the l block already belongs to subroutine 'id', continue
-                if (l.inSubroutine(id)) {
-                    continue;
-                }
-                // marks the l block as belonging to subroutine 'id'
-                l.addToSubroutine(id, nbSubroutines);            
-            }
-            // pushes each successor of l on the stack, except JSR targets
-            Edge e = l.successors;
-            while (e != null) {
-                // if the l block is a JSR block, then 'l.successors.next' leads
-                // to the JSR target (see {@link #visitJumpInsn}) and must 
-                // therefore not be followed
-                if ((l.status & Label.JSR) == 0 || e != l.successors.next) {
-                    // pushes e.successor on the stack if it not already added
-                    if (e.successor.next == null) {
-                        e.successor.next = stack;
-                        stack = e.successor;
-                    }
-                }
-                e = e.next;
-            }
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Overriden Object methods
-    // ------------------------------------------------------------------------
-
-    /**
-     * Returns a string representation of this label.
-     * 
-     * @return a string representation of this label.
-     */
-    public String toString() {
-        return "L" + System.identityHashCode(this);
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/MethodAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/MethodAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/MethodAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/MethodAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,195 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * An empty {@link MethodVisitor} that delegates to another
- * {@link MethodVisitor}. This class can be used as a super class to quickly
- * implement usefull method adapter classes, just by overriding the necessary
- * methods.
- * 
- * @author Eric Bruneton
- */
-public class MethodAdapter implements MethodVisitor {
-
-    /**
-     * The {@link MethodVisitor} to which this adapter delegates calls.
-     */
-    protected MethodVisitor mv;
-
-    /**
-     * Constructs a new {@link MethodAdapter} object.
-     * 
-     * @param mv the code visitor to which this adapter must delegate calls.
-     */
-    public MethodAdapter(final MethodVisitor mv) {
-        this.mv = mv;
-    }
-
-    public AnnotationVisitor visitAnnotationDefault() {
-        return mv.visitAnnotationDefault();
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        return mv.visitAnnotation(desc, visible);
-    }
-
-    public AnnotationVisitor visitParameterAnnotation(
-        final int parameter,
-        final String desc,
-        final boolean visible)
-    {
-        return mv.visitParameterAnnotation(parameter, desc, visible);
-    }
-
-    public void visitAttribute(final Attribute attr) {
-        mv.visitAttribute(attr);
-    }
-
-    public void visitCode() {
-        mv.visitCode();
-    }
-
-    public void visitFrame(
-        final int type,
-        final int nLocal,
-        final Object[] local,
-        final int nStack,
-        final Object[] stack)
-    {
-        mv.visitFrame(type, nLocal, local, nStack, stack);
-    }
-
-    public void visitInsn(final int opcode) {
-        mv.visitInsn(opcode);
-    }
-
-    public void visitIntInsn(final int opcode, final int operand) {
-        mv.visitIntInsn(opcode, operand);
-    }
-
-    public void visitVarInsn(final int opcode, final int var) {
-        mv.visitVarInsn(opcode, var);
-    }
-
-    public void visitTypeInsn(final int opcode, final String type) {
-        mv.visitTypeInsn(opcode, type);
-    }
-
-    public void visitFieldInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        mv.visitFieldInsn(opcode, owner, name, desc);
-    }
-
-    public void visitMethodInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        mv.visitMethodInsn(opcode, owner, name, desc);
-    }
-
-    public void visitJumpInsn(final int opcode, final Label label) {
-        mv.visitJumpInsn(opcode, label);
-    }
-
-    public void visitLabel(final Label label) {
-        mv.visitLabel(label);
-    }
-
-    public void visitLdcInsn(final Object cst) {
-        mv.visitLdcInsn(cst);
-    }
-
-    public void visitIincInsn(final int var, final int increment) {
-        mv.visitIincInsn(var, increment);
-    }
-
-    public void visitTableSwitchInsn(
-        final int min,
-        final int max,
-        final Label dflt,
-        final Label[] labels)
-    {
-        mv.visitTableSwitchInsn(min, max, dflt, labels);
-    }
-
-    public void visitLookupSwitchInsn(
-        final Label dflt,
-        final int[] keys,
-        final Label[] labels)
-    {
-        mv.visitLookupSwitchInsn(dflt, keys, labels);
-    }
-
-    public void visitMultiANewArrayInsn(final String desc, final int dims) {
-        mv.visitMultiANewArrayInsn(desc, dims);
-    }
-
-    public void visitTryCatchBlock(
-        final Label start,
-        final Label end,
-        final Label handler,
-        final String type)
-    {
-        mv.visitTryCatchBlock(start, end, handler, type);
-    }
-
-    public void visitLocalVariable(
-        final String name,
-        final String desc,
-        final String signature,
-        final Label start,
-        final Label end,
-        final int index)
-    {
-        mv.visitLocalVariable(name, desc, signature, start, end, index);
-    }
-
-    public void visitLineNumber(final int line, final Label start) {
-        mv.visitLineNumber(line, start);
-    }
-
-    public void visitMaxs(final int maxStack, final int maxLocals) {
-        mv.visitMaxs(maxStack, maxLocals);
-    }
-
-    public void visitEnd() {
-        mv.visitEnd();
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/MethodVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/MethodVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/MethodVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/MethodVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,399 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * A visitor to visit a Java method. The methods of this interface must be
- * called in the following order: [ <tt>visitAnnotationDefault</tt> ] (
- * <tt>visitAnnotation</tt> | <tt>visitParameterAnnotation</tt> |
- * <tt>visitAttribute</tt> )* [ <tt>visitCode</tt> ( <tt>visitFrame</tt> |
- * <tt>visit</tt><i>X</i>Insn</tt> | <tt>visitLabel</tt> | <tt>visitTryCatchBlock</tt> |
- * <tt>visitLocalVariable</tt> | <tt>visitLineNumber</tt>)* <tt>visitMaxs</tt> ]
- * <tt>visitEnd</tt>. In addition, the <tt>visit</tt><i>X</i>Insn</tt>
- * and <tt>visitLabel</tt> methods must be called in the sequential order of
- * the bytecode instructions of the visited code, <tt>visitTryCatchBlock</tt>
- * must be called <i>before</i> the labels passed as arguments have been
- * visited, and the <tt>visitLocalVariable</tt> and <tt>visitLineNumber</tt>
- * methods must be called <i>after</i> the labels passed as arguments have been
- * visited.
- * 
- * @author Eric Bruneton
- */
-public interface MethodVisitor {
-
-    // -------------------------------------------------------------------------
-    // Annotations and non standard attributes
-    // -------------------------------------------------------------------------
-
-    /**
-     * Visits the default value of this annotation interface method.
-     * 
-     * @return a visitor to the visit the actual default value of this
-     *         annotation interface method, or <tt>null</tt> if this visitor
-     *         is not interested in visiting this default value. The 'name'
-     *         parameters passed to the methods of this annotation visitor are
-     *         ignored. Moreover, exacly one visit method must be called on this
-     *         annotation visitor, followed by visitEnd.
-     */
-    AnnotationVisitor visitAnnotationDefault();
-
-    /**
-     * Visits an annotation of this method.
-     * 
-     * @param desc the class descriptor of the annotation class.
-     * @param visible <tt>true</tt> if the annotation is visible at runtime.
-     * @return a visitor to visit the annotation values, or <tt>null</tt> if
-     *         this visitor is not interested in visiting this annotation.
-     */
-    AnnotationVisitor visitAnnotation(String desc, boolean visible);
-
-    /**
-     * Visits an annotation of a parameter this method.
-     * 
-     * @param parameter the parameter index.
-     * @param desc the class descriptor of the annotation class.
-     * @param visible <tt>true</tt> if the annotation is visible at runtime.
-     * @return a visitor to visit the annotation values, or <tt>null</tt> if
-     *         this visitor is not interested in visiting this annotation.
-     */
-    AnnotationVisitor visitParameterAnnotation(
-        int parameter,
-        String desc,
-        boolean visible);
-
-    /**
-     * Visits a non standard attribute of this method.
-     * 
-     * @param attr an attribute.
-     */
-    void visitAttribute(Attribute attr);
-
-    /**
-     * Starts the visit of the method's code, if any (i.e. non abstract method).
-     */
-    void visitCode();
-
-    /**
-     * Visits the current state of the local variables and operand stack
-     * elements. This method must(*) be called <i>just before</i> any
-     * instruction <b>i</b> that follows an unconditional branch instruction
-     * such as GOTO or THROW, that is the target of a jump instruction, or that
-     * starts an exception handler block. The visited types must describe the
-     * values of the local variables and of the operand stack elements <i>just
-     * before</i> <b>i</b> is executed. <br> <br> (*) this is mandatory only
-     * for classes whose version is greater than or equal to
-     * {@link Opcodes#V1_6 V1_6}. <br> <br> Packed frames are basically
-     * "deltas" from the state of the previous frame (very first frame is
-     * implicitly defined by the method's parameters and access flags): <ul>
-     * <li>{@link Opcodes#F_SAME} representing frame with exactly the same
-     * locals as the previous frame and with the empty stack.</li> <li>{@link Opcodes#F_SAME1}
-     * representing frame with exactly the same locals as the previous frame and
-     * with single value on the stack (<code>nStack</code> is 1 and
-     * <code>stack[0]</code> contains value for the type of the stack item).</li>
-     * <li>{@link Opcodes#F_APPEND} representing frame with current locals are
-     * the same as the locals in the previous frame, except that additional
-     * locals are defined (<code>nLocal</code> is 1, 2 or 3 and
-     * <code>local</code> elements contains values representing added types).</li>
-     * <li>{@link Opcodes#F_CHOP} representing frame with current locals are
-     * the same as the locals in the previous frame, except that the last 1-3
-     * locals are absent and with the empty stack (<code>nLocals</code> is 1,
-     * 2 or 3). </li> <li>{@link Opcodes#F_FULL} representing complete frame
-     * data.</li> </li> </ul>
-     * 
-     * @param type the type of this stack map frame. Must be
-     *        {@link Opcodes#F_NEW} for expanded frames, or
-     *        {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND},
-     *        {@link Opcodes#F_CHOP}, {@link Opcodes#F_SAME} or
-     *        {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for compressed
-     *        frames.
-     * @param nLocal the number of local variables in the visited frame.
-     * @param local the local variable types in this frame. This array must not
-     *        be modified. Primitive types are represented by
-     *        {@link Opcodes#TOP}, {@link Opcodes#INTEGER},
-     *        {@link Opcodes#FLOAT}, {@link Opcodes#LONG},
-     *        {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or
-     *        {@link Opcodes#UNINITIALIZED_THIS} (long and double are
-     *        represented by a single element). Reference types are represented
-     *        by String objects (representing internal names), and uninitialized 
-     *        types by Label objects (this label designates the NEW instruction 
-     *        that created this uninitialized value).
-     * @param nStack the number of operand stack elements in the visited frame.
-     * @param stack the operand stack types in this frame. This array must not
-     *        be modified. Its content has the same format as the "local" array.
-     * @throw IllegalStateException if a frame is visited just after another
-     *        one, without any instruction between the two (unless this frame
-     *        is a Opcodes#F_SAME frame, in which case it is silently ignored).
-     */
-    void visitFrame(
-        int type,
-        int nLocal,
-        Object[] local,
-        int nStack,
-        Object[] stack);
-
-    // -------------------------------------------------------------------------
-    // Normal instructions
-    // -------------------------------------------------------------------------
-
-    /**
-     * Visits a zero operand instruction.
-     * 
-     * @param opcode the opcode of the instruction to be visited. This opcode is
-     *        either NOP, ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2,
-     *        ICONST_3, ICONST_4, ICONST_5, LCONST_0, LCONST_1, FCONST_0,
-     *        FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD, LALOAD, FALOAD,
-     *        DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE, FASTORE,
-     *        DASTORE, AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2, DUP,
-     *        DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2, SWAP, IADD, LADD, FADD,
-     *        DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV,
-     *        FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL,
-     *        LSHL, ISHR, LSHR, IUSHR, LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR,
-     *        I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I, D2L, D2F, I2B,
-     *        I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN,
-     *        FRETURN, DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW,
-     *        MONITORENTER, or MONITOREXIT.
-     */
-    void visitInsn(int opcode);
-
-    /**
-     * Visits an instruction with a single int operand.
-     * 
-     * @param opcode the opcode of the instruction to be visited. This opcode is
-     *        either BIPUSH, SIPUSH or NEWARRAY.
-     * @param operand the operand of the instruction to be visited.<br> When
-     *        opcode is BIPUSH, operand value should be between Byte.MIN_VALUE
-     *        and Byte.MAX_VALUE.<br> When opcode is SIPUSH, operand value
-     *        should be between Short.MIN_VALUE and Short.MAX_VALUE.<br> When
-     *        opcode is NEWARRAY, operand value should be one of
-     *        {@link Opcodes#T_BOOLEAN}, {@link Opcodes#T_CHAR},
-     *        {@link Opcodes#T_FLOAT}, {@link Opcodes#T_DOUBLE},
-     *        {@link Opcodes#T_BYTE}, {@link Opcodes#T_SHORT},
-     *        {@link Opcodes#T_INT} or {@link Opcodes#T_LONG}.
-     */
-    void visitIntInsn(int opcode, int operand);
-
-    /**
-     * Visits a local variable instruction. A local variable instruction is an
-     * instruction that loads or stores the value of a local variable.
-     * 
-     * @param opcode the opcode of the local variable instruction to be visited.
-     *        This opcode is either ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE,
-     *        LSTORE, FSTORE, DSTORE, ASTORE or RET.
-     * @param var the operand of the instruction to be visited. This operand is
-     *        the index of a local variable.
-     */
-    void visitVarInsn(int opcode, int var);
-
-    /**
-     * Visits a type instruction. A type instruction is an instruction that
-     * takes the internal name of a class as parameter.
-     * 
-     * @param opcode the opcode of the type instruction to be visited. This
-     *        opcode is either NEW, ANEWARRAY, CHECKCAST or INSTANCEOF.
-     * @param type the operand of the instruction to be visited. This operand
-     *        must be the internal name of an object or array class (see {@link 
-     *        Type#getInternalName() getInternalName}).
-     */
-    void visitTypeInsn(int opcode, String type);
-
-    /**
-     * Visits a field instruction. A field instruction is an instruction that
-     * loads or stores the value of a field of an object.
-     * 
-     * @param opcode the opcode of the type instruction to be visited. This
-     *        opcode is either GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.
-     * @param owner the internal name of the field's owner class (see {@link
-     *        Type#getInternalName() getInternalName}).
-     * @param name the field's name.
-     * @param desc the field's descriptor (see {@link Type Type}).
-     */
-    void visitFieldInsn(int opcode, String owner, String name, String desc);
-
-    /**
-     * Visits a method instruction. A method instruction is an instruction that
-     * invokes a method.
-     * 
-     * @param opcode the opcode of the type instruction to be visited. This
-     *        opcode is either INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC,
-     *        INVOKEINTERFACE or INVOKEDYNAMIC.
-     * @param owner the internal name of the method's owner class (see {@link
-     *        Type#getInternalName() getInternalName})
-     *        or {@link org.eclipse.persistence.internal.libraries.asm.Opcodes#INVOKEDYNAMIC_OWNER}.
-     * @param name the method's name.
-     * @param desc the method's descriptor (see {@link Type Type}).
-     */
-    void visitMethodInsn(int opcode, String owner, String name, String desc);
-
-    /**
-     * Visits a jump instruction. A jump instruction is an instruction that may
-     * jump to another instruction.
-     * 
-     * @param opcode the opcode of the type instruction to be visited. This
-     *        opcode is either IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ,
-     *        IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ,
-     *        IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.
-     * @param label the operand of the instruction to be visited. This operand
-     *        is a label that designates the instruction to which the jump
-     *        instruction may jump.
-     */
-    void visitJumpInsn(int opcode, Label label);
-
-    /**
-     * Visits a label. A label designates the instruction that will be visited
-     * just after it.
-     * 
-     * @param label a {@link Label Label} object.
-     */
-    void visitLabel(Label label);
-
-    // -------------------------------------------------------------------------
-    // Special instructions
-    // -------------------------------------------------------------------------
-
-    /**
-     * Visits a LDC instruction.
-     * 
-     * @param cst the constant to be loaded on the stack. This parameter must be
-     *        a non null {@link Integer}, a {@link Float}, a {@link Long}, a
-     *        {@link Double} a {@link String} (or a {@link Type} for
-     *        <tt>.class</tt> constants, for classes whose version is 49.0 or
-     *        more).
-     */
-    void visitLdcInsn(Object cst);
-
-    /**
-     * Visits an IINC instruction.
-     * 
-     * @param var index of the local variable to be incremented.
-     * @param increment amount to increment the local variable by.
-     */
-    void visitIincInsn(int var, int increment);
-
-    /**
-     * Visits a TABLESWITCH instruction.
-     * 
-     * @param min the minimum key value.
-     * @param max the maximum key value.
-     * @param dflt beginning of the default handler block.
-     * @param labels beginnings of the handler blocks. <tt>labels[i]</tt> is
-     *        the beginning of the handler block for the <tt>min + i</tt> key.
-     */
-    void visitTableSwitchInsn(int min, int max, Label dflt, Label[] labels);
-
-    /**
-     * Visits a LOOKUPSWITCH instruction.
-     * 
-     * @param dflt beginning of the default handler block.
-     * @param keys the values of the keys.
-     * @param labels beginnings of the handler blocks. <tt>labels[i]</tt> is
-     *        the beginning of the handler block for the <tt>keys[i]</tt> key.
-     */
-    void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels);
-
-    /**
-     * Visits a MULTIANEWARRAY instruction.
-     * 
-     * @param desc an array type descriptor (see {@link Type Type}).
-     * @param dims number of dimensions of the array to allocate.
-     */
-    void visitMultiANewArrayInsn(String desc, int dims);
-
-    // -------------------------------------------------------------------------
-    // Exceptions table entries, debug information, max stack and max locals
-    // -------------------------------------------------------------------------
-
-    /**
-     * Visits a try catch block.
-     * 
-     * @param start beginning of the exception handler's scope (inclusive).
-     * @param end end of the exception handler's scope (exclusive).
-     * @param handler beginning of the exception handler's code.
-     * @param type internal name of the type of exceptions handled by the
-     *        handler, or <tt>null</tt> to catch any exceptions (for "finally"
-     *        blocks).
-     * @throws IllegalArgumentException if one of the labels has already been
-     *         visited by this visitor (by the {@link #visitLabel visitLabel}
-     *         method).
-     */
-    void visitTryCatchBlock(Label start, Label end, Label handler, String type);
-
-    /**
-     * Visits a local variable declaration.
-     * 
-     * @param name the name of a local variable.
-     * @param desc the type descriptor of this local variable.
-     * @param signature the type signature of this local variable. May be
-     *        <tt>null</tt> if the local variable type does not use generic
-     *        types.
-     * @param start the first instruction corresponding to the scope of this
-     *        local variable (inclusive).
-     * @param end the last instruction corresponding to the scope of this local
-     *        variable (exclusive).
-     * @param index the local variable's index.
-     * @throws IllegalArgumentException if one of the labels has not already
-     *         been visited by this visitor (by the
-     *         {@link #visitLabel visitLabel} method).
-     */
-    void visitLocalVariable(
-        String name,
-        String desc,
-        String signature,
-        Label start,
-        Label end,
-        int index);
-
-    /**
-     * Visits a line number declaration.
-     * 
-     * @param line a line number. This number refers to the source file from
-     *        which the class was compiled.
-     * @param start the first instruction corresponding to this line number.
-     * @throws IllegalArgumentException if <tt>start</tt> has not already been
-     *         visited by this visitor (by the {@link #visitLabel visitLabel}
-     *         method).
-     */
-    void visitLineNumber(int line, Label start);
-
-    /**
-     * Visits the maximum stack size and the maximum number of local variables
-     * of the method.
-     * 
-     * @param maxStack maximum stack size of the method.
-     * @param maxLocals maximum number of local variables for the method.
-     */
-    void visitMaxs(int maxStack, int maxLocals);
-
-    /**
-     * Visits the end of the method. This method, which is the last one to be
-     * called, is used to inform the visitor that all the annotations and
-     * attributes of the method have been visited.
-     */
-    void visitEnd();
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/MethodWriter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/MethodWriter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/MethodWriter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/MethodWriter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,2580 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * A {@link MethodVisitor} that generates methods in bytecode form. Each visit
- * method of this class appends the bytecode corresponding to the visited
- * instruction to a byte vector, in the order these methods are called.
- * 
- * @author Eric Bruneton
- * @author Eugene Kuleshov
- */
-class MethodWriter implements MethodVisitor {
-
-    /**
-     * Pseudo access flag used to denote constructors.
-     */
-    static final int ACC_CONSTRUCTOR = 262144;
-
-    /**
-     * Frame has exactly the same locals as the previous stack map frame and
-     * number of stack items is zero.
-     */
-    static final int SAME_FRAME = 0; // to 63 (0-3f)
-
-    /**
-     * Frame has exactly the same locals as the previous stack map frame and
-     * number of stack items is 1
-     */
-    static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64; // to 127 (40-7f)
-
-    /**
-     * Reserved for future use
-     */
-    static final int RESERVED = 128;
-
-    /**
-     * Frame has exactly the same locals as the previous stack map frame and
-     * number of stack items is 1. Offset is bigger then 63;
-     */
-    static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247; // f7
-
-    /**
-     * Frame where current locals are the same as the locals in the previous
-     * frame, except that the k last locals are absent. The value of k is given
-     * by the formula 251-frame_type.
-     */
-    static final int CHOP_FRAME = 248; // to 250 (f8-fA)
-
-    /**
-     * Frame has exactly the same locals as the previous stack map frame and
-     * number of stack items is zero. Offset is bigger then 63;
-     */
-    static final int SAME_FRAME_EXTENDED = 251; // fb
-
-    /**
-     * Frame where current locals are the same as the locals in the previous
-     * frame, except that k additional locals are defined. The value of k is
-     * given by the formula frame_type-251.
-     */
-    static final int APPEND_FRAME = 252; // to 254 // fc-fe
-
-    /**
-     * Full frame
-     */
-    static final int FULL_FRAME = 255; // ff
-
-    /**
-     * Indicates that the stack map frames must be recomputed from scratch. In
-     * this case the maximum stack size and number of local variables is also
-     * recomputed from scratch.
-     * 
-     * @see #compute
-     */
-    private static final int FRAMES = 0;
-
-    /**
-     * Indicates that the maximum stack size and number of local variables must
-     * be automatically computed.
-     * 
-     * @see #compute
-     */
-    private static final int MAXS = 1;
-
-    /**
-     * Indicates that nothing must be automatically computed.
-     * 
-     * @see #compute
-     */
-    private static final int NOTHING = 2;
-
-    /**
-     * Next method writer (see {@link ClassWriter#firstMethod firstMethod}).
-     */
-    MethodWriter next;
-
-    /**
-     * The class writer to which this method must be added.
-     */
-    final ClassWriter cw;
-
-    /**
-     * Access flags of this method.
-     */
-    private int access;
-
-    /**
-     * The index of the constant pool item that contains the name of this
-     * method.
-     */
-    private final int name;
-
-    /**
-     * The index of the constant pool item that contains the descriptor of this
-     * method.
-     */
-    private final int desc;
-
-    /**
-     * The descriptor of this method.
-     */
-    private final String descriptor;
-
-    /**
-     * The signature of this method.
-     */
-    String signature;
-
-    /**
-     * If not zero, indicates that the code of this method must be copied from
-     * the ClassReader associated to this writer in <code>cw.cr</code>. More
-     * precisely, this field gives the index of the first byte to copied from
-     * <code>cw.cr.b</code>.
-     */
-    int classReaderOffset;
-
-    /**
-     * If not zero, indicates that the code of this method must be copied from
-     * the ClassReader associated to this writer in <code>cw.cr</code>. More
-     * precisely, this field gives the number of bytes to copied from
-     * <code>cw.cr.b</code>.
-     */
-    int classReaderLength;
-
-    /**
-     * Number of exceptions that can be thrown by this method.
-     */
-    int exceptionCount;
-
-    /**
-     * The exceptions that can be thrown by this method. More precisely, this
-     * array contains the indexes of the constant pool items that contain the
-     * internal names of these exception classes.
-     */
-    int[] exceptions;
-
-    /**
-     * The annotation default attribute of this method. May be <tt>null</tt>.
-     */
-    private ByteVector annd;
-
-    /**
-     * The runtime visible annotations of this method. May be <tt>null</tt>.
-     */
-    private AnnotationWriter anns;
-
-    /**
-     * The runtime invisible annotations of this method. May be <tt>null</tt>.
-     */
-    private AnnotationWriter ianns;
-
-    /**
-     * The runtime visible parameter annotations of this method. May be
-     * <tt>null</tt>.
-     */
-    private AnnotationWriter[] panns;
-
-    /**
-     * The runtime invisible parameter annotations of this method. May be
-     * <tt>null</tt>.
-     */
-    private AnnotationWriter[] ipanns;
-
-    /**
-     * The number of synthetic parameters of this method.
-     */
-    private int synthetics;
-
-    /**
-     * The non standard attributes of the method.
-     */
-    private Attribute attrs;
-
-    /**
-     * The bytecode of this method.
-     */
-    private ByteVector code = new ByteVector();
-
-    /**
-     * Maximum stack size of this method.
-     */
-    private int maxStack;
-
-    /**
-     * Maximum number of local variables for this method.
-     */
-    private int maxLocals;
-
-    /**
-     * Number of stack map frames in the StackMapTable attribute.
-     */
-    private int frameCount;
-
-    /**
-     * The StackMapTable attribute.
-     */
-    private ByteVector stackMap;
-
-    /**
-     * The offset of the last frame that was written in the StackMapTable
-     * attribute.
-     */
-    private int previousFrameOffset;
-
-    /**
-     * The last frame that was written in the StackMapTable attribute.
-     * 
-     * @see #frame
-     */
-    private int[] previousFrame;
-
-    /**
-     * Index of the next element to be added in {@link #frame}.
-     */
-    private int frameIndex;
-
-    /**
-     * The current stack map frame. The first element contains the offset of the
-     * instruction to which the frame corresponds, the second element is the
-     * number of locals and the third one is the number of stack elements. The
-     * local variables start at index 3 and are followed by the operand stack
-     * values. In summary frame[0] = offset, frame[1] = nLocal, frame[2] =
-     * nStack, frame[3] = nLocal. All types are encoded as integers, with the
-     * same format as the one used in {@link Label}, but limited to BASE types.
-     */
-    private int[] frame;
-
-    /**
-     * Number of elements in the exception handler list.
-     */
-    private int handlerCount;
-
-    /**
-     * The first element in the exception handler list.
-     */
-    private Handler firstHandler;
-
-    /**
-     * The last element in the exception handler list.
-     */
-    private Handler lastHandler;
-
-    /**
-     * Number of entries in the LocalVariableTable attribute.
-     */
-    private int localVarCount;
-
-    /**
-     * The LocalVariableTable attribute.
-     */
-    private ByteVector localVar;
-
-    /**
-     * Number of entries in the LocalVariableTypeTable attribute.
-     */
-    private int localVarTypeCount;
-
-    /**
-     * The LocalVariableTypeTable attribute.
-     */
-    private ByteVector localVarType;
-
-    /**
-     * Number of entries in the LineNumberTable attribute.
-     */
-    private int lineNumberCount;
-
-    /**
-     * The LineNumberTable attribute.
-     */
-    private ByteVector lineNumber;
-
-    /**
-     * The non standard attributes of the method's code.
-     */
-    private Attribute cattrs;
-
-    /**
-     * Indicates if some jump instructions are too small and need to be resized.
-     */
-    private boolean resize;
-
-    /**
-     * The number of subroutines in this method.
-     */
-    private int subroutines;
-
-    // ------------------------------------------------------------------------
-
-    /*
-     * Fields for the control flow graph analysis algorithm (used to compute the
-     * maximum stack size). A control flow graph contains one node per "basic
-     * block", and one edge per "jump" from one basic block to another. Each
-     * node (i.e., each basic block) is represented by the Label object that
-     * corresponds to the first instruction of this basic block. Each node also
-     * stores the list of its successors in the graph, as a linked list of Edge
-     * objects.
-     */
-
-    /**
-     * Indicates what must be automatically computed.
-     * 
-     * @see #FRAMES
-     * @see #MAXS
-     * @see #NOTHING
-     */
-    private final int compute;
-
-    /**
-     * A list of labels. This list is the list of basic blocks in the method,
-     * i.e. a list of Label objects linked to each other by their
-     * {@link Label#successor} field, in the order they are visited by
-     * {@link MethodVisitor#visitLabel}, and starting with the first basic block.
-     */
-    private Label labels;
-
-    /**
-     * The previous basic block.
-     */
-    private Label previousBlock;
-
-    /**
-     * The current basic block.
-     */
-    private Label currentBlock;
-
-    /**
-     * The (relative) stack size after the last visited instruction. This size
-     * is relative to the beginning of the current basic block, i.e., the true
-     * stack size after the last visited instruction is equal to the
-     * {@link Label#inputStackTop beginStackSize} of the current basic block
-     * plus <tt>stackSize</tt>.
-     */
-    private int stackSize;
-
-    /**
-     * The (relative) maximum stack size after the last visited instruction.
-     * This size is relative to the beginning of the current basic block, i.e.,
-     * the true maximum stack size after the last visited instruction is equal
-     * to the {@link Label#inputStackTop beginStackSize} of the current basic
-     * block plus <tt>stackSize</tt>.
-     */
-    private int maxStackSize;
-
-    // ------------------------------------------------------------------------
-    // Constructor
-    // ------------------------------------------------------------------------
-
-    /**
-     * Constructs a new {@link MethodWriter}.
-     * 
-     * @param cw the class writer in which the method must be added.
-     * @param access the method's access flags (see {@link Opcodes}).
-     * @param name the method's name.
-     * @param desc the method's descriptor (see {@link Type}).
-     * @param signature the method's signature. May be <tt>null</tt>.
-     * @param exceptions the internal names of the method's exceptions. May be
-     *        <tt>null</tt>.
-     * @param computeMaxs <tt>true</tt> if the maximum stack size and number
-     *        of local variables must be automatically computed.
-     * @param computeFrames <tt>true</tt> if the stack map tables must be
-     *        recomputed from scratch.
-     */
-    MethodWriter(
-        final ClassWriter cw,
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final String[] exceptions,
-        final boolean computeMaxs,
-        final boolean computeFrames)
-    {
-        if (cw.firstMethod == null) {
-            cw.firstMethod = this;
-        } else {
-            cw.lastMethod.next = this;
-        }
-        cw.lastMethod = this;
-        this.cw = cw;
-        this.access = access;
-        this.name = cw.newUTF8(name);
-        this.desc = cw.newUTF8(desc);
-        this.descriptor = desc;
-        if (ClassReader.SIGNATURES) {
-            this.signature = signature;
-        }
-        if (exceptions != null && exceptions.length > 0) {
-            exceptionCount = exceptions.length;
-            this.exceptions = new int[exceptionCount];
-            for (int i = 0; i < exceptionCount; ++i) {
-                this.exceptions[i] = cw.newClass(exceptions[i]);
-            }
-        }
-        this.compute = computeFrames ? FRAMES : (computeMaxs ? MAXS : NOTHING);
-        if (computeMaxs || computeFrames) {
-            if (computeFrames && "<init>".equals(name)) {
-                this.access |= ACC_CONSTRUCTOR;
-            }
-            // updates maxLocals
-            int size = Type.getArgumentsAndReturnSizes(descriptor) >> 2;
-            if ((access & Opcodes.ACC_STATIC) != 0) {
-                --size;
-            }
-            maxLocals = size;
-            // creates and visits the label for the first basic block
-            labels = new Label();
-            labels.status |= Label.PUSHED;
-            visitLabel(labels);
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Implementation of the MethodVisitor interface
-    // ------------------------------------------------------------------------
-
-    public AnnotationVisitor visitAnnotationDefault() {
-        if (!ClassReader.ANNOTATIONS) {
-            return null;
-        }
-        annd = new ByteVector();
-        return new AnnotationWriter(cw, false, annd, null, 0);
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        if (!ClassReader.ANNOTATIONS) {
-            return null;
-        }
-        ByteVector bv = new ByteVector();
-        // write type, and reserve space for values count
-        bv.putShort(cw.newUTF8(desc)).putShort(0);
-        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);
-        if (visible) {
-            aw.next = anns;
-            anns = aw;
-        } else {
-            aw.next = ianns;
-            ianns = aw;
-        }
-        return aw;
-    }
-
-    public AnnotationVisitor visitParameterAnnotation(
-        final int parameter,
-        final String desc,
-        final boolean visible)
-    {
-        if (!ClassReader.ANNOTATIONS) {
-            return null;
-        }
-        ByteVector bv = new ByteVector();
-        if ("Ljava/lang/Synthetic;".equals(desc)) {
-            // workaround for a bug in javac with synthetic parameters
-            // see ClassReader.readParameterAnnotations
-            synthetics = Math.max(synthetics, parameter + 1);
-            return new AnnotationWriter(cw, false, bv, null, 0);
-        }
-        // write type, and reserve space for values count
-        bv.putShort(cw.newUTF8(desc)).putShort(0);
-        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);
-        if (visible) {
-            if (panns == null) {
-                panns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];
-            }
-            aw.next = panns[parameter];
-            panns[parameter] = aw;
-        } else {
-            if (ipanns == null) {
-                ipanns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];
-            }
-            aw.next = ipanns[parameter];
-            ipanns[parameter] = aw;
-        }
-        return aw;
-    }
-
-    public void visitAttribute(final Attribute attr) {
-        if (attr.isCodeAttribute()) {
-            attr.next = cattrs;
-            cattrs = attr;
-        } else {
-            attr.next = attrs;
-            attrs = attr;
-        }
-    }
-
-    public void visitCode() {
-    }
-
-    public void visitFrame(
-        final int type,
-        final int nLocal,
-        final Object[] local,
-        final int nStack,
-        final Object[] stack)
-    {
-        if (!ClassReader.FRAMES || compute == FRAMES) {
-            return;
-        }
-
-        if (type == Opcodes.F_NEW) {
-            startFrame(code.length, nLocal, nStack);
-            for (int i = 0; i < nLocal; ++i) {
-                if (local[i] instanceof String) {
-                    frame[frameIndex++] = Frame.OBJECT
-                            | cw.addType((String) local[i]);
-                } else if (local[i] instanceof Integer) {
-                    frame[frameIndex++] = ((Integer) local[i]).intValue();
-                } else {
-                    frame[frameIndex++] = Frame.UNINITIALIZED
-                            | cw.addUninitializedType("",
-                                    ((Label) local[i]).position);
-                }
-            }
-            for (int i = 0; i < nStack; ++i) {
-                if (stack[i] instanceof String) {
-                    frame[frameIndex++] = Frame.OBJECT
-                            | cw.addType((String) stack[i]);
-                } else if (stack[i] instanceof Integer) {
-                    frame[frameIndex++] = ((Integer) stack[i]).intValue();
-                } else {
-                    frame[frameIndex++] = Frame.UNINITIALIZED
-                            | cw.addUninitializedType("",
-                                    ((Label) stack[i]).position);
-                }
-            }
-            endFrame();
-        } else {
-            int delta;
-            if (stackMap == null) {
-                stackMap = new ByteVector();
-                delta = code.length;
-            } else {
-                delta = code.length - previousFrameOffset - 1;
-                if (delta < 0) {
-                    if (type == Opcodes.F_SAME) {
-                        return;
-                    } else {
-                        throw new IllegalStateException();
-                    }
-                }
-            }
-
-            switch (type) {
-                case Opcodes.F_FULL:
-                    stackMap.putByte(FULL_FRAME)
-                            .putShort(delta)
-                            .putShort(nLocal);
-                    for (int i = 0; i < nLocal; ++i) {
-                        writeFrameType(local[i]);
-                    }
-                    stackMap.putShort(nStack);
-                    for (int i = 0; i < nStack; ++i) {
-                        writeFrameType(stack[i]);
-                    }
-                    break;
-                case Opcodes.F_APPEND:
-                    stackMap.putByte(SAME_FRAME_EXTENDED + nLocal)
-                            .putShort(delta);
-                    for (int i = 0; i < nLocal; ++i) {
-                        writeFrameType(local[i]);
-                    }
-                    break;
-                case Opcodes.F_CHOP:
-                    stackMap.putByte(SAME_FRAME_EXTENDED - nLocal)
-                            .putShort(delta);
-                    break;
-                case Opcodes.F_SAME:
-                    if (delta < 64) {
-                        stackMap.putByte(delta);
-                    } else {
-                        stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);
-                    }
-                    break;
-                case Opcodes.F_SAME1:
-                    if (delta < 64) {
-                        stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);
-                    } else {
-                        stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)
-                                .putShort(delta);
-                    }
-                    writeFrameType(stack[0]);
-                    break;
-            }
-
-            previousFrameOffset = code.length;
-            ++frameCount;
-        }
-    }
-
-    public void visitInsn(final int opcode) {
-        // adds the instruction to the bytecode of the method
-        code.putByte(opcode);
-        // update currentBlock
-        // Label currentBlock = this.currentBlock;
-        if (currentBlock != null) {
-            if (compute == FRAMES) {
-                currentBlock.frame.execute(opcode, 0, null, null);
-            } else {
-                // updates current and max stack sizes
-                int size = stackSize + Frame.SIZE[opcode];
-                if (size > maxStackSize) {
-                    maxStackSize = size;
-                }
-                stackSize = size;
-            }
-            // if opcode == ATHROW or xRETURN, ends current block (no successor)
-            if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN)
-                    || opcode == Opcodes.ATHROW)
-            {
-                noSuccessor();
-            }
-        }
-    }
-
-    public void visitIntInsn(final int opcode, final int operand) {
-        // Label currentBlock = this.currentBlock;
-        if (currentBlock != null) {
-            if (compute == FRAMES) {
-                currentBlock.frame.execute(opcode, operand, null, null);
-            } else if (opcode != Opcodes.NEWARRAY) {
-                // updates current and max stack sizes only for NEWARRAY
-                // (stack size variation = 0 for BIPUSH or SIPUSH)
-                int size = stackSize + 1;
-                if (size > maxStackSize) {
-                    maxStackSize = size;
-                }
-                stackSize = size;
-            }
-        }
-        // adds the instruction to the bytecode of the method
-        if (opcode == Opcodes.SIPUSH) {
-            code.put12(opcode, operand);
-        } else { // BIPUSH or NEWARRAY
-            code.put11(opcode, operand);
-        }
-    }
-
-    public void visitVarInsn(final int opcode, final int var) {
-        // Label currentBlock = this.currentBlock;
-        if (currentBlock != null) {
-            if (compute == FRAMES) {
-                currentBlock.frame.execute(opcode, var, null, null);
-            } else {
-                // updates current and max stack sizes
-                if (opcode == Opcodes.RET) {
-                    // no stack change, but end of current block (no successor)
-                    currentBlock.status |= Label.RET;
-                    // save 'stackSize' here for future use
-                    // (see {@link #findSubroutineSuccessors})
-                    currentBlock.inputStackTop = stackSize;
-                    noSuccessor();
-                } else { // xLOAD or xSTORE
-                    int size = stackSize + Frame.SIZE[opcode];
-                    if (size > maxStackSize) {
-                        maxStackSize = size;
-                    }
-                    stackSize = size;
-                }
-            }
-        }
-        if (compute != NOTHING) {
-            // updates max locals
-            int n;
-            if (opcode == Opcodes.LLOAD || opcode == Opcodes.DLOAD
-                    || opcode == Opcodes.LSTORE || opcode == Opcodes.DSTORE)
-            {
-                n = var + 2;
-            } else {
-                n = var + 1;
-            }
-            if (n > maxLocals) {
-                maxLocals = n;
-            }
-        }
-        // adds the instruction to the bytecode of the method
-        if (var < 4 && opcode != Opcodes.RET) {
-            int opt;
-            if (opcode < Opcodes.ISTORE) {
-                /* ILOAD_0 */
-                opt = 26 + ((opcode - Opcodes.ILOAD) << 2) + var;
-            } else {
-                /* ISTORE_0 */
-                opt = 59 + ((opcode - Opcodes.ISTORE) << 2) + var;
-            }
-            code.putByte(opt);
-        } else if (var >= 256) {
-            code.putByte(196 /* WIDE */).put12(opcode, var);
-        } else {
-            code.put11(opcode, var);
-        }
-        if (opcode >= Opcodes.ISTORE && compute == FRAMES && handlerCount > 0) {
-            visitLabel(new Label());
-        }
-    }
-
-    public void visitTypeInsn(final int opcode, final String type) {
-        Item i = cw.newClassItem(type);
-        // Label currentBlock = this.currentBlock;
-        if (currentBlock != null) {
-            if (compute == FRAMES) {
-                currentBlock.frame.execute(opcode, code.length, cw, i);
-            } else if (opcode == Opcodes.NEW) {
-                // updates current and max stack sizes only if opcode == NEW
-                // (no stack change for ANEWARRAY, CHECKCAST, INSTANCEOF)
-                int size = stackSize + 1;
-                if (size > maxStackSize) {
-                    maxStackSize = size;
-                }
-                stackSize = size;
-            }
-        }
-        // adds the instruction to the bytecode of the method
-        code.put12(opcode, i.index);
-    }
-
-    public void visitFieldInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        Item i = cw.newFieldItem(owner, name, desc);
-        // Label currentBlock = this.currentBlock;
-        if (currentBlock != null) {
-            if (compute == FRAMES) {
-                currentBlock.frame.execute(opcode, 0, cw, i);
-            } else {
-                int size;
-                // computes the stack size variation
-                char c = desc.charAt(0);
-                switch (opcode) {
-                    case Opcodes.GETSTATIC:
-                        size = stackSize + (c == 'D' || c == 'J' ? 2 : 1);
-                        break;
-                    case Opcodes.PUTSTATIC:
-                        size = stackSize + (c == 'D' || c == 'J' ? -2 : -1);
-                        break;
-                    case Opcodes.GETFIELD:
-                        size = stackSize + (c == 'D' || c == 'J' ? 1 : 0);
-                        break;
-                    // case Constants.PUTFIELD:
-                    default:
-                        size = stackSize + (c == 'D' || c == 'J' ? -3 : -2);
-                        break;
-                }
-                // updates current and max stack sizes
-                if (size > maxStackSize) {
-                    maxStackSize = size;
-                }
-                stackSize = size;
-            }
-        }
-        // adds the instruction to the bytecode of the method
-        code.put12(opcode, i.index);
-    }
-
-    public void visitMethodInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        boolean itf = opcode == Opcodes.INVOKEINTERFACE;
-        Item i = (opcode == Opcodes.INVOKEDYNAMIC) ?
-                cw.newNameTypeItem(name, desc):
-                cw.newMethodItem(owner, name, desc, itf);
-        int argSize = i.intVal;
-        // Label currentBlock = this.currentBlock;
-        if (currentBlock != null) {
-            if (compute == FRAMES) {
-                currentBlock.frame.execute(opcode, 0, cw, i);
-            } else {
-                /*
-                 * computes the stack size variation. In order not to recompute
-                 * several times this variation for the same Item, we use the
-                 * intVal field of this item to store this variation, once it
-                 * has been computed. More precisely this intVal field stores
-                 * the sizes of the arguments and of the return value
-                 * corresponding to desc.
-                 */
-                if (argSize == 0) {
-                    // the above sizes have not been computed yet,
-                    // so we compute them...
-                    argSize = Type.getArgumentsAndReturnSizes(desc);
-                    // ... and we save them in order
-                    // not to recompute them in the future
-                    i.intVal = argSize;
-                }
-                int size;
-                if (opcode == Opcodes.INVOKESTATIC || opcode == Opcodes.INVOKEDYNAMIC) {
-                    size = stackSize - (argSize >> 2) + (argSize & 0x03) + 1;
-                } else {
-                    size = stackSize - (argSize >> 2) + (argSize & 0x03);
-                }
-                // updates current and max stack sizes
-                if (size > maxStackSize) {
-                    maxStackSize = size;
-                }
-                stackSize = size;
-            }
-        }
-        // adds the instruction to the bytecode of the method
-        if (itf) {
-            if (argSize == 0) {
-                argSize = Type.getArgumentsAndReturnSizes(desc);
-                i.intVal = argSize;
-            }
-            code.put12(Opcodes.INVOKEINTERFACE, i.index).put11(argSize >> 2, 0);
-        } else {
-            code.put12(opcode, i.index);
-            if (opcode==Opcodes.INVOKEDYNAMIC) {
-                code.putShort(0);
-            }
-        }
-    }
-
-    public void visitJumpInsn(final int opcode, final Label label) {
-        Label nextInsn = null;
-        // Label currentBlock = this.currentBlock;
-        if (currentBlock != null) {
-            if (compute == FRAMES) {
-                currentBlock.frame.execute(opcode, 0, null, null);
-                // 'label' is the target of a jump instruction
-                label.getFirst().status |= Label.TARGET;
-                // adds 'label' as a successor of this basic block
-                addSuccessor(Edge.NORMAL, label);
-                if (opcode != Opcodes.GOTO) {
-                    // creates a Label for the next basic block
-                    nextInsn = new Label();
-                }
-            } else {
-                if (opcode == Opcodes.JSR) {
-                    if ((label.status & Label.SUBROUTINE) == 0) {
-                        label.status |= Label.SUBROUTINE;
-                        ++subroutines;
-                    }
-                    currentBlock.status |= Label.JSR;
-                    addSuccessor(stackSize + 1, label);
-                    // creates a Label for the next basic block
-                    nextInsn = new Label();
-                    /*
-                     * note that, by construction in this method, a JSR block
-                     * has at least two successors in the control flow graph:
-                     * the first one leads the next instruction after the JSR,
-                     * while the second one leads to the JSR target.
-                     */
-                } else {
-                    // updates current stack size (max stack size unchanged
-                    // because stack size variation always negative in this
-                    // case)
-                    stackSize += Frame.SIZE[opcode];
-                    addSuccessor(stackSize, label);
-                }
-            }
-        }
-        // adds the instruction to the bytecode of the method
-        if ((label.status & Label.RESOLVED) != 0
-                && label.position - code.length < Short.MIN_VALUE)
-        {
-            /*
-             * case of a backward jump with an offset < -32768. In this case we
-             * automatically replace GOTO with GOTO_W, JSR with JSR_W and IFxxx
-             * <l> with IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx is the
-             * "opposite" opcode of IFxxx (i.e., IFNE for IFEQ) and where <l'>
-             * designates the instruction just after the GOTO_W.
-             */
-            if (opcode == Opcodes.GOTO) {
-                code.putByte(200); // GOTO_W
-            } else if (opcode == Opcodes.JSR) {
-                code.putByte(201); // JSR_W
-            } else {
-                // if the IF instruction is transformed into IFNOT GOTO_W the
-                // next instruction becomes the target of the IFNOT instruction
-                if (nextInsn != null) {
-                    nextInsn.status |= Label.TARGET;
-                }
-                code.putByte(opcode <= 166
-                        ? ((opcode + 1) ^ 1) - 1
-                        : opcode ^ 1);
-                code.putShort(8); // jump offset
-                code.putByte(200); // GOTO_W
-            }
-            label.put(this, code, code.length - 1, true);
-        } else {
-            /*
-             * case of a backward jump with an offset >= -32768, or of a forward
-             * jump with, of course, an unknown offset. In these cases we store
-             * the offset in 2 bytes (which will be increased in
-             * resizeInstructions, if needed).
-             */
-            code.putByte(opcode);
-            label.put(this, code, code.length - 1, false);
-        }
-        if (currentBlock != null) {
-            if (nextInsn != null) {
-                // if the jump instruction is not a GOTO, the next instruction
-                // is also a successor of this instruction. Calling visitLabel
-                // adds the label of this next instruction as a successor of the
-                // current block, and starts a new basic block
-                visitLabel(nextInsn);
-            }
-            if (opcode == Opcodes.GOTO) {
-                noSuccessor();
-            }
-        }
-    }
-
-    public void visitLabel(final Label label) {
-        // resolves previous forward references to label, if any
-        resize |= label.resolve(this, code.length, code.data);
-        // updates currentBlock
-        if ((label.status & Label.DEBUG) != 0) {
-            return;
-        }
-        if (compute == FRAMES) {
-            if (currentBlock != null) {
-                if (label.position == currentBlock.position) {
-                    // successive labels, do not start a new basic block
-                    currentBlock.status |= (label.status & Label.TARGET);
-                    label.frame = currentBlock.frame;
-                    return;
-                }
-                // ends current block (with one new successor)
-                addSuccessor(Edge.NORMAL, label);
-            }
-            // begins a new current block
-            currentBlock = label;
-            if (label.frame == null) {
-                label.frame = new Frame();
-                label.frame.owner = label;
-            }
-            // updates the basic block list
-            if (previousBlock != null) {
-                if (label.position == previousBlock.position) {
-                    previousBlock.status |= (label.status & Label.TARGET);
-                    label.frame = previousBlock.frame;
-                    currentBlock = previousBlock;
-                    return;
-                }
-                previousBlock.successor = label;
-            }
-            previousBlock = label;
-        } else if (compute == MAXS) {
-            if (currentBlock != null) {
-                // ends current block (with one new successor)
-                currentBlock.outputStackMax = maxStackSize;
-                addSuccessor(stackSize, label);
-            }
-            // begins a new current block
-            currentBlock = label;
-            // resets the relative current and max stack sizes
-            stackSize = 0;
-            maxStackSize = 0;
-            // updates the basic block list
-            if (previousBlock != null) {
-                previousBlock.successor = label;
-            }
-            previousBlock = label;
-        }
-    }
-
-    public void visitLdcInsn(final Object cst) {
-        Item i = cw.newConstItem(cst);
-        // Label currentBlock = this.currentBlock;
-        if (currentBlock != null) {
-            if (compute == FRAMES) {
-                currentBlock.frame.execute(Opcodes.LDC, 0, cw, i);
-            } else {
-                int size;
-                // computes the stack size variation
-                if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE)
-                {
-                    size = stackSize + 2;
-                } else {
-                    size = stackSize + 1;
-                }
-                // updates current and max stack sizes
-                if (size > maxStackSize) {
-                    maxStackSize = size;
-                }
-                stackSize = size;
-            }
-        }
-        // adds the instruction to the bytecode of the method
-        int index = i.index;
-        if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {
-            code.put12(20 /* LDC2_W */, index);
-        } else if (index >= 256) {
-            code.put12(19 /* LDC_W */, index);
-        } else {
-            code.put11(Opcodes.LDC, index);
-        }
-    }
-
-    public void visitIincInsn(final int var, final int increment) {
-        if (currentBlock != null) {
-            if (compute == FRAMES) {
-                currentBlock.frame.execute(Opcodes.IINC, var, null, null);
-            }
-        }
-        if (compute != NOTHING) {
-            // updates max locals
-            int n = var + 1;
-            if (n > maxLocals) {
-                maxLocals = n;
-            }
-        }
-        // adds the instruction to the bytecode of the method
-        if ((var > 255) || (increment > 127) || (increment < -128)) {
-            code.putByte(196 /* WIDE */)
-                    .put12(Opcodes.IINC, var)
-                    .putShort(increment);
-        } else {
-            code.putByte(Opcodes.IINC).put11(var, increment);
-        }
-    }
-
-    public void visitTableSwitchInsn(
-        final int min,
-        final int max,
-        final Label dflt,
-        final Label[] labels)
-    {
-        // adds the instruction to the bytecode of the method
-        int source = code.length;
-        code.putByte(Opcodes.TABLESWITCH);
-        code.putByteArray(null, 0, (4 - code.length % 4) % 4);
-        dflt.put(this, code, source, true);
-        code.putInt(min).putInt(max);
-        for (int i = 0; i < labels.length; ++i) {
-            labels[i].put(this, code, source, true);
-        }
-        // updates currentBlock
-        visitSwitchInsn(dflt, labels);
-    }
-
-    public void visitLookupSwitchInsn(
-        final Label dflt,
-        final int[] keys,
-        final Label[] labels)
-    {
-        // adds the instruction to the bytecode of the method
-        int source = code.length;
-        code.putByte(Opcodes.LOOKUPSWITCH);
-        code.putByteArray(null, 0, (4 - code.length % 4) % 4);
-        dflt.put(this, code, source, true);
-        code.putInt(labels.length);
-        for (int i = 0; i < labels.length; ++i) {
-            code.putInt(keys[i]);
-            labels[i].put(this, code, source, true);
-        }
-        // updates currentBlock
-        visitSwitchInsn(dflt, labels);
-    }
-
-    private void visitSwitchInsn(final Label dflt, final Label[] labels) {
-        // Label currentBlock = this.currentBlock;
-        if (currentBlock != null) {
-            if (compute == FRAMES) {
-                currentBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);
-                // adds current block successors
-                addSuccessor(Edge.NORMAL, dflt);
-                dflt.getFirst().status |= Label.TARGET;
-                for (int i = 0; i < labels.length; ++i) {
-                    addSuccessor(Edge.NORMAL, labels[i]);
-                    labels[i].getFirst().status |= Label.TARGET;
-                }
-            } else {
-                // updates current stack size (max stack size unchanged)
-                --stackSize;
-                // adds current block successors
-                addSuccessor(stackSize, dflt);
-                for (int i = 0; i < labels.length; ++i) {
-                    addSuccessor(stackSize, labels[i]);
-                }
-            }
-            // ends current block
-            noSuccessor();
-        }
-    }
-
-    public void visitMultiANewArrayInsn(final String desc, final int dims) {
-        Item i = cw.newClassItem(desc);
-        // Label currentBlock = this.currentBlock;
-        if (currentBlock != null) {
-            if (compute == FRAMES) {
-                currentBlock.frame.execute(Opcodes.MULTIANEWARRAY, dims, cw, i);
-            } else {
-                // updates current stack size (max stack size unchanged because
-                // stack size variation always negative or null)
-                stackSize += 1 - dims;
-            }
-        }
-        // adds the instruction to the bytecode of the method
-        code.put12(Opcodes.MULTIANEWARRAY, i.index).putByte(dims);
-    }
-
-    public void visitTryCatchBlock(
-        final Label start,
-        final Label end,
-        final Label handler,
-        final String type)
-    {
-        ++handlerCount;
-        Handler h = new Handler();
-        h.start = start;
-        h.end = end;
-        h.handler = handler;
-        h.desc = type;
-        h.type = type != null ? cw.newClass(type) : 0;
-        if (lastHandler == null) {
-            firstHandler = h;
-        } else {
-            lastHandler.next = h;
-        }
-        lastHandler = h;
-    }
-
-    public void visitLocalVariable(
-        final String name,
-        final String desc,
-        final String signature,
-        final Label start,
-        final Label end,
-        final int index)
-    {
-        if (signature != null) {
-            if (localVarType == null) {
-                localVarType = new ByteVector();
-            }
-            ++localVarTypeCount;
-            localVarType.putShort(start.position)
-                    .putShort(end.position - start.position)
-                    .putShort(cw.newUTF8(name))
-                    .putShort(cw.newUTF8(signature))
-                    .putShort(index);
-        }
-        if (localVar == null) {
-            localVar = new ByteVector();
-        }
-        ++localVarCount;
-        localVar.putShort(start.position)
-                .putShort(end.position - start.position)
-                .putShort(cw.newUTF8(name))
-                .putShort(cw.newUTF8(desc))
-                .putShort(index);
-        if (compute != NOTHING) {
-            // updates max locals
-            char c = desc.charAt(0);
-            int n = index + (c == 'J' || c == 'D' ? 2 : 1);
-            if (n > maxLocals) {
-                maxLocals = n;
-            }
-        }
-    }
-
-    public void visitLineNumber(final int line, final Label start) {
-        if (lineNumber == null) {
-            lineNumber = new ByteVector();
-        }
-        ++lineNumberCount;
-        lineNumber.putShort(start.position);
-        lineNumber.putShort(line);
-    }
-
-    public void visitMaxs(final int maxStack, final int maxLocals) {
-        if (ClassReader.FRAMES && compute == FRAMES) {
-            // completes the control flow graph with exception handler blocks
-            Handler handler = firstHandler;
-            while (handler != null) {
-                Label l = handler.start.getFirst();
-                Label h = handler.handler.getFirst();
-                Label e = handler.end.getFirst();
-                // computes the kind of the edges to 'h'
-                String t = handler.desc == null
-                        ? "java/lang/Throwable"
-                        : handler.desc;
-                int kind = Frame.OBJECT | cw.addType(t);
-                // h is an exception handler
-                h.status |= Label.TARGET;
-                // adds 'h' as a successor of labels between 'start' and 'end'
-                while (l != e) {
-                    // creates an edge to 'h'
-                    Edge b = new Edge();
-                    b.info = kind;
-                    b.successor = h;
-                    // adds it to the successors of 'l'
-                    b.next = l.successors;
-                    l.successors = b;
-                    // goes to the next label
-                    l = l.successor;
-                }
-                handler = handler.next;
-            }
-
-            // creates and visits the first (implicit) frame
-            Frame f = labels.frame;
-            Type[] args = Type.getArgumentTypes(descriptor);
-            f.initInputFrame(cw, access, args, this.maxLocals);
-            visitFrame(f);
-
-            /*
-             * fix point algorithm: mark the first basic block as 'changed'
-             * (i.e. put it in the 'changed' list) and, while there are changed
-             * basic blocks, choose one, mark it as unchanged, and update its
-             * successors (which can be changed in the process).
-             */
-            int max = 0;
-            Label changed = labels;
-            while (changed != null) {
-                // removes a basic block from the list of changed basic blocks
-                Label l = changed;
-                changed = changed.next;
-                l.next = null;
-                f = l.frame;
-                // a reachable jump target must be stored in the stack map
-                if ((l.status & Label.TARGET) != 0) {
-                    l.status |= Label.STORE;
-                }
-                // all visited labels are reachable, by definition
-                l.status |= Label.REACHABLE;
-                // updates the (absolute) maximum stack size
-                int blockMax = f.inputStack.length + l.outputStackMax;
-                if (blockMax > max) {
-                    max = blockMax;
-                }
-                // updates the successors of the current basic block
-                Edge e = l.successors;
-                while (e != null) {
-                    Label n = e.successor.getFirst();
-                    boolean change = f.merge(cw, n.frame, e.info);
-                    if (change && n.next == null) {
-                        // if n has changed and is not already in the 'changed'
-                        // list, adds it to this list
-                        n.next = changed;
-                        changed = n;
-                    }
-                    e = e.next;
-                }
-            }
-
-            // visits all the frames that must be stored in the stack map
-            Label l = labels;
-            while (l != null) {
-                f = l.frame;
-                if ((l.status & Label.STORE) != 0) {
-                    visitFrame(f);
-                }
-                if ((l.status & Label.REACHABLE) == 0) {
-                    // finds start and end of dead basic block
-                    Label k = l.successor;
-                    int start = l.position;
-                    int end = (k == null ? code.length : k.position) - 1;
-                    // if non empty basic block
-                    if (end >= start) {
-                        max = Math.max(max, 1);
-                        // replaces instructions with NOP ... NOP ATHROW
-                        for (int i = start; i < end; ++i) {
-                            code.data[i] = Opcodes.NOP;
-                        }
-                        code.data[end] = (byte) Opcodes.ATHROW;
-                        // emits a frame for this unreachable block
-                        startFrame(start, 0, 1);
-                        frame[frameIndex++] = Frame.OBJECT
-                                | cw.addType("java/lang/Throwable");
-                        endFrame();
-                    }
-                }
-                l = l.successor;
-            }
-            
-            this.maxStack = max;
-        } else if (compute == MAXS) {
-            // completes the control flow graph with exception handler blocks
-            Handler handler = firstHandler;
-            while (handler != null) {
-                Label l = handler.start;
-                Label h = handler.handler;
-                Label e = handler.end;
-                // adds 'h' as a successor of labels between 'start' and 'end'
-                while (l != e) {
-                    // creates an edge to 'h'
-                    Edge b = new Edge();
-                    b.info = Edge.EXCEPTION;
-                    b.successor = h;
-                    // adds it to the successors of 'l'
-                    if ((l.status & Label.JSR) == 0) {
-                        b.next = l.successors;
-                        l.successors = b;
-                    } else {
-                        // if l is a JSR block, adds b after the first two edges
-                        // to preserve the hypothesis about JSR block successors
-                        // order (see {@link #visitJumpInsn})
-                        b.next = l.successors.next.next;
-                        l.successors.next.next = b;
-                    }
-                    // goes to the next label
-                    l = l.successor;
-                }
-                handler = handler.next;
-            }
-
-            if (subroutines > 0) {
-                // completes the control flow graph with the RET successors
-                /*
-                 * first step: finds the subroutines. This step determines, for
-                 * each basic block, to which subroutine(s) it belongs.
-                 */
-                // finds the basic blocks that belong to the "main" subroutine
-                int id = 0;
-                labels.visitSubroutine(null, 1, subroutines);
-                // finds the basic blocks that belong to the real subroutines
-                Label l = labels;
-                while (l != null) {
-                    if ((l.status & Label.JSR) != 0) {
-                        // the subroutine is defined by l's TARGET, not by l
-                        Label subroutine = l.successors.next.successor;
-                        // if this subroutine has not been visited yet...
-                        if ((subroutine.status & Label.VISITED) == 0) {
-                            // ...assigns it a new id and finds its basic blocks
-                            id += 1;
-                            subroutine.visitSubroutine(null, (id / 32L) << 32
-                                    | (1L << (id % 32)), subroutines);
-                        }
-                    }
-                    l = l.successor;
-                }
-                // second step: finds the successors of RET blocks
-                l = labels;
-                while (l != null) {
-                    if ((l.status & Label.JSR) != 0) {
-                        Label L = labels;
-                        while (L != null) {
-                            L.status &= ~Label.VISITED2;
-                            L = L.successor;
-                        }
-                        // the subroutine is defined by l's TARGET, not by l
-                        Label subroutine = l.successors.next.successor;
-                        subroutine.visitSubroutine(l, 0, subroutines);
-                    }
-                    l = l.successor;
-                }
-            }
-
-            /*
-             * control flow analysis algorithm: while the block stack is not
-             * empty, pop a block from this stack, update the max stack size,
-             * compute the true (non relative) begin stack size of the
-             * successors of this block, and push these successors onto the
-             * stack (unless they have already been pushed onto the stack).
-             * Note: by hypothesis, the {@link Label#inputStackTop} of the
-             * blocks in the block stack are the true (non relative) beginning
-             * stack sizes of these blocks.
-             */
-            int max = 0;
-            Label stack = labels;
-            while (stack != null) {
-                // pops a block from the stack
-                Label l = stack;
-                stack = stack.next;
-                // computes the true (non relative) max stack size of this block
-                int start = l.inputStackTop;
-                int blockMax = start + l.outputStackMax;
-                // updates the global max stack size
-                if (blockMax > max) {
-                    max = blockMax;
-                }
-                // analyzes the successors of the block
-                Edge b = l.successors;
-                if ((l.status & Label.JSR) != 0) {
-                    // ignores the first edge of JSR blocks (virtual successor)
-                    b = b.next;
-                }
-                while (b != null) {
-                    l = b.successor;
-                    // if this successor has not already been pushed...
-                    if ((l.status & Label.PUSHED) == 0) {
-                        // computes its true beginning stack size...
-                        l.inputStackTop = b.info == Edge.EXCEPTION ? 1 : start
-                                + b.info;
-                        // ...and pushes it onto the stack
-                        l.status |= Label.PUSHED;
-                        l.next = stack;
-                        stack = l;
-                    }
-                    b = b.next;
-                }
-            }
-            this.maxStack = max;
-        } else {
-            this.maxStack = maxStack;
-            this.maxLocals = maxLocals;
-        }
-    }
-
-    public void visitEnd() {
-    }
-
-    // ------------------------------------------------------------------------
-    // Utility methods: control flow analysis algorithm
-    // ------------------------------------------------------------------------
-
-    /**
-     * Adds a successor to the {@link #currentBlock currentBlock} block.
-     * 
-     * @param info information about the control flow edge to be added.
-     * @param successor the successor block to be added to the current block.
-     */
-    private void addSuccessor(final int info, final Label successor) {
-        // creates and initializes an Edge object...
-        Edge b = new Edge();
-        b.info = info;
-        b.successor = successor;
-        // ...and adds it to the successor list of the currentBlock block
-        b.next = currentBlock.successors;
-        currentBlock.successors = b;
-    }
-
-    /**
-     * Ends the current basic block. This method must be used in the case where
-     * the current basic block does not have any successor.
-     */
-    private void noSuccessor() {
-        if (compute == FRAMES) {
-            Label l = new Label();
-            l.frame = new Frame();
-            l.frame.owner = l;
-            l.resolve(this, code.length, code.data);
-            previousBlock.successor = l;
-            previousBlock = l;
-        } else {
-            currentBlock.outputStackMax = maxStackSize;
-        }
-        currentBlock = null;
-    }
-
-    // ------------------------------------------------------------------------
-    // Utility methods: stack map frames
-    // ------------------------------------------------------------------------
-
-    /**
-     * Visits a frame that has been computed from scratch.
-     * 
-     * @param f the frame that must be visited.
-     */
-    private void visitFrame(final Frame f) {
-        int i, t;
-        int nTop = 0;
-        int nLocal = 0;
-        int nStack = 0;
-        int[] locals = f.inputLocals;
-        int[] stacks = f.inputStack;
-        // computes the number of locals (ignores TOP types that are just after
-        // a LONG or a DOUBLE, and all trailing TOP types)
-        for (i = 0; i < locals.length; ++i) {
-            t = locals[i];
-            if (t == Frame.TOP) {
-                ++nTop;
-            } else {
-                nLocal += nTop + 1;
-                nTop = 0;
-            }
-            if (t == Frame.LONG || t == Frame.DOUBLE) {
-                ++i;
-            }
-        }
-        // computes the stack size (ignores TOP types that are just after
-        // a LONG or a DOUBLE)
-        for (i = 0; i < stacks.length; ++i) {
-            t = stacks[i];
-            ++nStack;
-            if (t == Frame.LONG || t == Frame.DOUBLE) {
-                ++i;
-            }
-        }
-        // visits the frame and its content
-        startFrame(f.owner.position, nLocal, nStack);
-        for (i = 0; nLocal > 0; ++i, --nLocal) {
-            t = locals[i];
-            frame[frameIndex++] = t;
-            if (t == Frame.LONG || t == Frame.DOUBLE) {
-                ++i;
-            }
-        }
-        for (i = 0; i < stacks.length; ++i) {
-            t = stacks[i];
-            frame[frameIndex++] = t;
-            if (t == Frame.LONG || t == Frame.DOUBLE) {
-                ++i;
-            }
-        }
-        endFrame();
-    }
-
-    /**
-     * Starts the visit of a stack map frame.
-     * 
-     * @param offset the offset of the instruction to which the frame
-     *        corresponds.
-     * @param nLocal the number of local variables in the frame.
-     * @param nStack the number of stack elements in the frame.
-     */
-    private void startFrame(final int offset, final int nLocal, final int nStack)
-    {
-        int n = 3 + nLocal + nStack;
-        if (frame == null || frame.length < n) {
-            frame = new int[n];
-        }
-        frame[0] = offset;
-        frame[1] = nLocal;
-        frame[2] = nStack;
-        frameIndex = 3;
-    }
-
-    /**
-     * Checks if the visit of the current frame {@link #frame} is finished, and
-     * if yes, write it in the StackMapTable attribute.
-     */
-    private void endFrame() {
-        if (previousFrame != null) { // do not write the first frame
-            if (stackMap == null) {
-                stackMap = new ByteVector();
-            }
-            writeFrame();
-            ++frameCount;
-        }
-        previousFrame = frame;
-        frame = null;
-    }
-
-    /**
-     * Compress and writes the current frame {@link #frame} in the StackMapTable
-     * attribute.
-     */
-    private void writeFrame() {
-        int clocalsSize = frame[1];
-        int cstackSize = frame[2];
-        if ((cw.version & 0xFFFF) < Opcodes.V1_6) {
-            stackMap.putShort(frame[0]).putShort(clocalsSize);
-            writeFrameTypes(3, 3 + clocalsSize);
-            stackMap.putShort(cstackSize);
-            writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);
-            return;
-        }
-        int localsSize = previousFrame[1];
-        int type = FULL_FRAME;
-        int k = 0;
-        int delta;
-        if (frameCount == 0) {
-            delta = frame[0];
-        } else {
-            delta = frame[0] - previousFrame[0] - 1;
-        }
-        if (cstackSize == 0) {
-            k = clocalsSize - localsSize;
-            switch (k) {
-                case -3:
-                case -2:
-                case -1:
-                    type = CHOP_FRAME;
-                    localsSize = clocalsSize;
-                    break;
-                case 0:
-                    type = delta < 64 ? SAME_FRAME : SAME_FRAME_EXTENDED;
-                    break;
-                case 1:
-                case 2:
-                case 3:
-                    type = APPEND_FRAME;
-                    break;
-            }
-        } else if (clocalsSize == localsSize && cstackSize == 1) {
-            type = delta < 63
-                    ? SAME_LOCALS_1_STACK_ITEM_FRAME
-                    : SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;
-        }
-        if (type != FULL_FRAME) {
-            // verify if locals are the same
-            int l = 3;
-            for (int j = 0; j < localsSize; j++) {
-                if (frame[l] != previousFrame[l]) {
-                    type = FULL_FRAME;
-                    break;
-                }
-                l++;
-            }
-        }
-        switch (type) {
-            case SAME_FRAME:
-                stackMap.putByte(delta);
-                break;
-            case SAME_LOCALS_1_STACK_ITEM_FRAME:
-                stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);
-                writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);
-                break;
-            case SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:
-                stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)
-                        .putShort(delta);
-                writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);
-                break;
-            case SAME_FRAME_EXTENDED:
-                stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);
-                break;
-            case CHOP_FRAME:
-                stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);
-                break;
-            case APPEND_FRAME:
-                stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);
-                writeFrameTypes(3 + localsSize, 3 + clocalsSize);
-                break;
-            // case FULL_FRAME:
-            default:
-                stackMap.putByte(FULL_FRAME)
-                        .putShort(delta)
-                        .putShort(clocalsSize);
-                writeFrameTypes(3, 3 + clocalsSize);
-                stackMap.putShort(cstackSize);
-                writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);
-        }
-    }
-
-    /**
-     * Writes some types of the current frame {@link #frame} into the
-     * StackMapTableAttribute. This method converts types from the format used
-     * in {@link Label} to the format used in StackMapTable attributes. In
-     * particular, it converts type table indexes to constant pool indexes.
-     * 
-     * @param start index of the first type in {@link #frame} to write.
-     * @param end index of last type in {@link #frame} to write (exclusive).
-     */
-    private void writeFrameTypes(final int start, final int end) {
-        for (int i = start; i < end; ++i) {
-            int t = frame[i];
-            int d = t & Frame.DIM;
-            if (d == 0) {
-                int v = t & Frame.BASE_VALUE;
-                switch (t & Frame.BASE_KIND) {
-                    case Frame.OBJECT:
-                        stackMap.putByte(7)
-                                .putShort(cw.newClass(cw.typeTable[v].strVal1));
-                        break;
-                    case Frame.UNINITIALIZED:
-                        stackMap.putByte(8).putShort(cw.typeTable[v].intVal);
-                        break;
-                    default:
-                        stackMap.putByte(v);
-                }
-            } else {
-                StringBuffer buf = new StringBuffer();
-                d >>= 28;
-                while (d-- > 0) {
-                    buf.append('[');
-                }
-                if ((t & Frame.BASE_KIND) == Frame.OBJECT) {
-                    buf.append('L');
-                    buf.append(cw.typeTable[t & Frame.BASE_VALUE].strVal1);
-                    buf.append(';');
-                } else {
-                    switch (t & 0xF) {
-                        case 1:
-                            buf.append('I');
-                            break;
-                        case 2:
-                            buf.append('F');
-                            break;
-                        case 3:
-                            buf.append('D');
-                            break;
-                        case 9:
-                            buf.append('Z');
-                            break;
-                        case 10:
-                            buf.append('B');
-                            break;
-                        case 11:
-                            buf.append('C');
-                            break;
-                        case 12:
-                            buf.append('S');
-                            break;
-                        default:
-                            buf.append('J');
-                    }
-                }
-                stackMap.putByte(7).putShort(cw.newClass(buf.toString()));
-            }
-        }
-    }
-
-    private void writeFrameType(final Object type) {
-        if (type instanceof String) {
-            stackMap.putByte(7).putShort(cw.newClass((String) type));
-        } else if (type instanceof Integer) {
-            stackMap.putByte(((Integer) type).intValue());
-        } else {
-            stackMap.putByte(8).putShort(((Label) type).position);
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Utility methods: dump bytecode array
-    // ------------------------------------------------------------------------
-
-    /**
-     * Returns the size of the bytecode of this method.
-     * 
-     * @return the size of the bytecode of this method.
-     */
-    final int getSize() {
-        if (classReaderOffset != 0) {
-            return 6 + classReaderLength;
-        }
-        if (resize) {
-            // replaces the temporary jump opcodes introduced by Label.resolve.
-            if (ClassReader.RESIZE) {
-                resizeInstructions();
-            } else {
-                throw new RuntimeException("Method code too large!");
-            }
-        }
-        int size = 8;
-        if (code.length > 0) {
-            cw.newUTF8("Code");
-            size += 18 + code.length + 8 * handlerCount;
-            if (localVar != null) {
-                cw.newUTF8("LocalVariableTable");
-                size += 8 + localVar.length;
-            }
-            if (localVarType != null) {
-                cw.newUTF8("LocalVariableTypeTable");
-                size += 8 + localVarType.length;
-            }
-            if (lineNumber != null) {
-                cw.newUTF8("LineNumberTable");
-                size += 8 + lineNumber.length;
-            }
-            if (stackMap != null) {
-                boolean zip = (cw.version & 0xFFFF) >= Opcodes.V1_6;
-                cw.newUTF8(zip ? "StackMapTable" : "StackMap");
-                size += 8 + stackMap.length;
-            }
-            if (cattrs != null) {
-                size += cattrs.getSize(cw,
-                        code.data,
-                        code.length,
-                        maxStack,
-                        maxLocals);
-            }
-        }
-        if (exceptionCount > 0) {
-            cw.newUTF8("Exceptions");
-            size += 8 + 2 * exceptionCount;
-        }
-        if ((access & Opcodes.ACC_SYNTHETIC) != 0
-                && ((cw.version & 0xFFFF) < Opcodes.V1_5 || (access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) != 0))
-        {
-            cw.newUTF8("Synthetic");
-            size += 6;
-        }
-        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
-            cw.newUTF8("Deprecated");
-            size += 6;
-        }
-        if (ClassReader.SIGNATURES && signature != null) {
-            cw.newUTF8("Signature");
-            cw.newUTF8(signature);
-            size += 8;
-        }
-        if (ClassReader.ANNOTATIONS && annd != null) {
-            cw.newUTF8("AnnotationDefault");
-            size += 6 + annd.length;
-        }
-        if (ClassReader.ANNOTATIONS && anns != null) {
-            cw.newUTF8("RuntimeVisibleAnnotations");
-            size += 8 + anns.getSize();
-        }
-        if (ClassReader.ANNOTATIONS && ianns != null) {
-            cw.newUTF8("RuntimeInvisibleAnnotations");
-            size += 8 + ianns.getSize();
-        }
-        if (ClassReader.ANNOTATIONS && panns != null) {
-            cw.newUTF8("RuntimeVisibleParameterAnnotations");
-            size += 7 + 2 * (panns.length - synthetics);
-            for (int i = panns.length - 1; i >= synthetics; --i) {
-                size += panns[i] == null ? 0 : panns[i].getSize();
-            }
-        }
-        if (ClassReader.ANNOTATIONS && ipanns != null) {
-            cw.newUTF8("RuntimeInvisibleParameterAnnotations");
-            size += 7 + 2 * (ipanns.length - synthetics);
-            for (int i = ipanns.length - 1; i >= synthetics; --i) {
-                size += ipanns[i] == null ? 0 : ipanns[i].getSize();
-            }
-        }
-        if (attrs != null) {
-            size += attrs.getSize(cw, null, 0, -1, -1);
-        }
-        return size;
-    }
-
-    /**
-     * Puts the bytecode of this method in the given byte vector.
-     * 
-     * @param out the byte vector into which the bytecode of this method must be
-     *        copied.
-     */
-    final void put(final ByteVector out) {
-        int mask = Opcodes.ACC_DEPRECATED
-                | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE
-                | ((access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) / (ClassWriter.ACC_SYNTHETIC_ATTRIBUTE / Opcodes.ACC_SYNTHETIC));
-        out.putShort(access & ~mask).putShort(name).putShort(desc);
-        if (classReaderOffset != 0) {
-            out.putByteArray(cw.cr.b, classReaderOffset, classReaderLength);
-            return;
-        }
-        int attributeCount = 0;
-        if (code.length > 0) {
-            ++attributeCount;
-        }
-        if (exceptionCount > 0) {
-            ++attributeCount;
-        }
-        if ((access & Opcodes.ACC_SYNTHETIC) != 0
-                && ((cw.version & 0xFFFF) < Opcodes.V1_5 || (access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) != 0))
-        {
-            ++attributeCount;
-        }
-        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
-            ++attributeCount;
-        }
-        if (ClassReader.SIGNATURES && signature != null) {
-            ++attributeCount;
-        }
-        if (ClassReader.ANNOTATIONS && annd != null) {
-            ++attributeCount;
-        }
-        if (ClassReader.ANNOTATIONS && anns != null) {
-            ++attributeCount;
-        }
-        if (ClassReader.ANNOTATIONS && ianns != null) {
-            ++attributeCount;
-        }
-        if (ClassReader.ANNOTATIONS && panns != null) {
-            ++attributeCount;
-        }
-        if (ClassReader.ANNOTATIONS && ipanns != null) {
-            ++attributeCount;
-        }
-        if (attrs != null) {
-            attributeCount += attrs.getCount();
-        }
-        out.putShort(attributeCount);
-        if (code.length > 0) {
-            int size = 12 + code.length + 8 * handlerCount;
-            if (localVar != null) {
-                size += 8 + localVar.length;
-            }
-            if (localVarType != null) {
-                size += 8 + localVarType.length;
-            }
-            if (lineNumber != null) {
-                size += 8 + lineNumber.length;
-            }
-            if (stackMap != null) {
-                size += 8 + stackMap.length;
-            }
-            if (cattrs != null) {
-                size += cattrs.getSize(cw,
-                        code.data,
-                        code.length,
-                        maxStack,
-                        maxLocals);
-            }
-            out.putShort(cw.newUTF8("Code")).putInt(size);
-            out.putShort(maxStack).putShort(maxLocals);
-            out.putInt(code.length).putByteArray(code.data, 0, code.length);
-            out.putShort(handlerCount);
-            if (handlerCount > 0) {
-                Handler h = firstHandler;
-                while (h != null) {
-                    out.putShort(h.start.position)
-                            .putShort(h.end.position)
-                            .putShort(h.handler.position)
-                            .putShort(h.type);
-                    h = h.next;
-                }
-            }
-            attributeCount = 0;
-            if (localVar != null) {
-                ++attributeCount;
-            }
-            if (localVarType != null) {
-                ++attributeCount;
-            }
-            if (lineNumber != null) {
-                ++attributeCount;
-            }
-            if (stackMap != null) {
-                ++attributeCount;
-            }
-            if (cattrs != null) {
-                attributeCount += cattrs.getCount();
-            }
-            out.putShort(attributeCount);
-            if (localVar != null) {
-                out.putShort(cw.newUTF8("LocalVariableTable"));
-                out.putInt(localVar.length + 2).putShort(localVarCount);
-                out.putByteArray(localVar.data, 0, localVar.length);
-            }
-            if (localVarType != null) {
-                out.putShort(cw.newUTF8("LocalVariableTypeTable"));
-                out.putInt(localVarType.length + 2).putShort(localVarTypeCount);
-                out.putByteArray(localVarType.data, 0, localVarType.length);
-            }
-            if (lineNumber != null) {
-                out.putShort(cw.newUTF8("LineNumberTable"));
-                out.putInt(lineNumber.length + 2).putShort(lineNumberCount);
-                out.putByteArray(lineNumber.data, 0, lineNumber.length);
-            }
-            if (stackMap != null) {
-                boolean zip = (cw.version & 0xFFFF) >= Opcodes.V1_6;
-                out.putShort(cw.newUTF8(zip ? "StackMapTable" : "StackMap"));
-                out.putInt(stackMap.length + 2).putShort(frameCount);
-                out.putByteArray(stackMap.data, 0, stackMap.length);
-            }
-            if (cattrs != null) {
-                cattrs.put(cw, code.data, code.length, maxLocals, maxStack, out);
-            }
-        }
-        if (exceptionCount > 0) {
-            out.putShort(cw.newUTF8("Exceptions"))
-                    .putInt(2 * exceptionCount + 2);
-            out.putShort(exceptionCount);
-            for (int i = 0; i < exceptionCount; ++i) {
-                out.putShort(exceptions[i]);
-            }
-        }
-        if ((access & Opcodes.ACC_SYNTHETIC) != 0
-                && ((cw.version & 0xFFFF) < Opcodes.V1_5 || (access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) != 0))
-        {
-            out.putShort(cw.newUTF8("Synthetic")).putInt(0);
-        }
-        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
-            out.putShort(cw.newUTF8("Deprecated")).putInt(0);
-        }
-        if (ClassReader.SIGNATURES && signature != null) {
-            out.putShort(cw.newUTF8("Signature"))
-                    .putInt(2)
-                    .putShort(cw.newUTF8(signature));
-        }
-        if (ClassReader.ANNOTATIONS && annd != null) {
-            out.putShort(cw.newUTF8("AnnotationDefault"));
-            out.putInt(annd.length);
-            out.putByteArray(annd.data, 0, annd.length);
-        }
-        if (ClassReader.ANNOTATIONS && anns != null) {
-            out.putShort(cw.newUTF8("RuntimeVisibleAnnotations"));
-            anns.put(out);
-        }
-        if (ClassReader.ANNOTATIONS && ianns != null) {
-            out.putShort(cw.newUTF8("RuntimeInvisibleAnnotations"));
-            ianns.put(out);
-        }
-        if (ClassReader.ANNOTATIONS && panns != null) {
-            out.putShort(cw.newUTF8("RuntimeVisibleParameterAnnotations"));
-            AnnotationWriter.put(panns, synthetics, out);
-        }
-        if (ClassReader.ANNOTATIONS && ipanns != null) {
-            out.putShort(cw.newUTF8("RuntimeInvisibleParameterAnnotations"));
-            AnnotationWriter.put(ipanns, synthetics, out);
-        }
-        if (attrs != null) {
-            attrs.put(cw, null, 0, -1, -1, out);
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Utility methods: instruction resizing (used to handle GOTO_W and JSR_W)
-    // ------------------------------------------------------------------------
-
-    /**
-     * Resizes and replaces the temporary instructions inserted by
-     * {@link Label#resolve} for wide forward jumps, while keeping jump offsets
-     * and instruction addresses consistent. This may require to resize other
-     * existing instructions, or even to introduce new instructions: for
-     * example, increasing the size of an instruction by 2 at the middle of a
-     * method can increases the offset of an IFEQ instruction from 32766 to
-     * 32768, in which case IFEQ 32766 must be replaced with IFNEQ 8 GOTO_W
-     * 32765. This, in turn, may require to increase the size of another jump
-     * instruction, and so on... All these operations are handled automatically
-     * by this method. <p> <i>This method must be called after all the method
-     * that is being built has been visited</i>. In particular, the
-     * {@link Label Label} objects used to construct the method are no longer
-     * valid after this method has been called.
-     */
-    private void resizeInstructions() {
-        byte[] b = code.data; // bytecode of the method
-        int u, v, label; // indexes in b
-        int i, j; // loop indexes
-        /*
-         * 1st step: As explained above, resizing an instruction may require to
-         * resize another one, which may require to resize yet another one, and
-         * so on. The first step of the algorithm consists in finding all the
-         * instructions that need to be resized, without modifying the code.
-         * This is done by the following "fix point" algorithm:
-         * 
-         * Parse the code to find the jump instructions whose offset will need
-         * more than 2 bytes to be stored (the future offset is computed from
-         * the current offset and from the number of bytes that will be inserted
-         * or removed between the source and target instructions). For each such
-         * instruction, adds an entry in (a copy of) the indexes and sizes
-         * arrays (if this has not already been done in a previous iteration!).
-         * 
-         * If at least one entry has been added during the previous step, go
-         * back to the beginning, otherwise stop.
-         * 
-         * In fact the real algorithm is complicated by the fact that the size
-         * of TABLESWITCH and LOOKUPSWITCH instructions depends on their
-         * position in the bytecode (because of padding). In order to ensure the
-         * convergence of the algorithm, the number of bytes to be added or
-         * removed from these instructions is over estimated during the previous
-         * loop, and computed exactly only after the loop is finished (this
-         * requires another pass to parse the bytecode of the method).
-         */
-        int[] allIndexes = new int[0]; // copy of indexes
-        int[] allSizes = new int[0]; // copy of sizes
-        boolean[] resize; // instructions to be resized
-        int newOffset; // future offset of a jump instruction
-
-        resize = new boolean[code.length];
-
-        // 3 = loop again, 2 = loop ended, 1 = last pass, 0 = done
-        int state = 3;
-        do {
-            if (state == 3) {
-                state = 2;
-            }
-            u = 0;
-            while (u < b.length) {
-                int opcode = b[u] & 0xFF; // opcode of current instruction
-                int insert = 0; // bytes to be added after this instruction
-
-                switch (ClassWriter.TYPE[opcode]) {
-                    case ClassWriter.NOARG_INSN:
-                    case ClassWriter.IMPLVAR_INSN:
-                        u += 1;
-                        break;
-                    case ClassWriter.LABEL_INSN:
-                        if (opcode > 201) {
-                            // converts temporary opcodes 202 to 217, 218 and
-                            // 219 to IFEQ ... JSR (inclusive), IFNULL and
-                            // IFNONNULL
-                            opcode = opcode < 218 ? opcode - 49 : opcode - 20;
-                            label = u + readUnsignedShort(b, u + 1);
-                        } else {
-                            label = u + readShort(b, u + 1);
-                        }
-                        newOffset = getNewOffset(allIndexes, allSizes, u, label);
-                        if (newOffset < Short.MIN_VALUE
-                                || newOffset > Short.MAX_VALUE)
-                        {
-                            if (!resize[u]) {
-                                if (opcode == Opcodes.GOTO
-                                        || opcode == Opcodes.JSR)
-                                {
-                                    // two additional bytes will be required to
-                                    // replace this GOTO or JSR instruction with
-                                    // a GOTO_W or a JSR_W
-                                    insert = 2;
-                                } else {
-                                    // five additional bytes will be required to
-                                    // replace this IFxxx <l> instruction with
-                                    // IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx
-                                    // is the "opposite" opcode of IFxxx (i.e.,
-                                    // IFNE for IFEQ) and where <l'> designates
-                                    // the instruction just after the GOTO_W.
-                                    insert = 5;
-                                }
-                                resize[u] = true;
-                            }
-                        }
-                        u += 3;
-                        break;
-                    case ClassWriter.LABELW_INSN:
-                        u += 5;
-                        break;
-                    case ClassWriter.TABL_INSN:
-                        if (state == 1) {
-                            // true number of bytes to be added (or removed)
-                            // from this instruction = (future number of padding
-                            // bytes - current number of padding byte) -
-                            // previously over estimated variation =
-                            // = ((3 - newOffset%4) - (3 - u%4)) - u%4
-                            // = (-newOffset%4 + u%4) - u%4
-                            // = -(newOffset & 3)
-                            newOffset = getNewOffset(allIndexes, allSizes, 0, u);
-                            insert = -(newOffset & 3);
-                        } else if (!resize[u]) {
-                            // over estimation of the number of bytes to be
-                            // added to this instruction = 3 - current number
-                            // of padding bytes = 3 - (3 - u%4) = u%4 = u & 3
-                            insert = u & 3;
-                            resize[u] = true;
-                        }
-                        // skips instruction
-                        u = u + 4 - (u & 3);
-                        u += 4 * (readInt(b, u + 8) - readInt(b, u + 4) + 1) + 12;
-                        break;
-                    case ClassWriter.LOOK_INSN:
-                        if (state == 1) {
-                            // like TABL_INSN
-                            newOffset = getNewOffset(allIndexes, allSizes, 0, u);
-                            insert = -(newOffset & 3);
-                        } else if (!resize[u]) {
-                            // like TABL_INSN
-                            insert = u & 3;
-                            resize[u] = true;
-                        }
-                        // skips instruction
-                        u = u + 4 - (u & 3);
-                        u += 8 * readInt(b, u + 4) + 8;
-                        break;
-                    case ClassWriter.WIDE_INSN:
-                        opcode = b[u + 1] & 0xFF;
-                        if (opcode == Opcodes.IINC) {
-                            u += 6;
-                        } else {
-                            u += 4;
-                        }
-                        break;
-                    case ClassWriter.VAR_INSN:
-                    case ClassWriter.SBYTE_INSN:
-                    case ClassWriter.LDC_INSN:
-                        u += 2;
-                        break;
-                    case ClassWriter.SHORT_INSN:
-                    case ClassWriter.LDCW_INSN:
-                    case ClassWriter.FIELDORMETH_INSN:
-                    case ClassWriter.TYPE_INSN:
-                    case ClassWriter.IINC_INSN:
-                        u += 3;
-                        break;
-                    case ClassWriter.ITFDYNMETH_INSN:
-                        u += 5;
-                        break;
-                    // case ClassWriter.MANA_INSN:
-                    default:
-                        u += 4;
-                        break;
-                }
-                if (insert != 0) {
-                    // adds a new (u, insert) entry in the allIndexes and
-                    // allSizes arrays
-                    int[] newIndexes = new int[allIndexes.length + 1];
-                    int[] newSizes = new int[allSizes.length + 1];
-                    System.arraycopy(allIndexes,
-                            0,
-                            newIndexes,
-                            0,
-                            allIndexes.length);
-                    System.arraycopy(allSizes, 0, newSizes, 0, allSizes.length);
-                    newIndexes[allIndexes.length] = u;
-                    newSizes[allSizes.length] = insert;
-                    allIndexes = newIndexes;
-                    allSizes = newSizes;
-                    if (insert > 0) {
-                        state = 3;
-                    }
-                }
-            }
-            if (state < 3) {
-                --state;
-            }
-        } while (state != 0);
-
-        // 2nd step:
-        // copies the bytecode of the method into a new bytevector, updates the
-        // offsets, and inserts (or removes) bytes as requested.
-
-        ByteVector newCode = new ByteVector(code.length);
-
-        u = 0;
-        while (u < code.length) {
-            int opcode = b[u] & 0xFF;
-            switch (ClassWriter.TYPE[opcode]) {
-                case ClassWriter.NOARG_INSN:
-                case ClassWriter.IMPLVAR_INSN:
-                    newCode.putByte(opcode);
-                    u += 1;
-                    break;
-                case ClassWriter.LABEL_INSN:
-                    if (opcode > 201) {
-                        // changes temporary opcodes 202 to 217 (inclusive), 218
-                        // and 219 to IFEQ ... JSR (inclusive), IFNULL and
-                        // IFNONNULL
-                        opcode = opcode < 218 ? opcode - 49 : opcode - 20;
-                        label = u + readUnsignedShort(b, u + 1);
-                    } else {
-                        label = u + readShort(b, u + 1);
-                    }
-                    newOffset = getNewOffset(allIndexes, allSizes, u, label);
-                    if (resize[u]) {
-                        // replaces GOTO with GOTO_W, JSR with JSR_W and IFxxx
-                        // <l> with IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx is
-                        // the "opposite" opcode of IFxxx (i.e., IFNE for IFEQ)
-                        // and where <l'> designates the instruction just after
-                        // the GOTO_W.
-                        if (opcode == Opcodes.GOTO) {
-                            newCode.putByte(200); // GOTO_W
-                        } else if (opcode == Opcodes.JSR) {
-                            newCode.putByte(201); // JSR_W
-                        } else {
-                            newCode.putByte(opcode <= 166
-                                    ? ((opcode + 1) ^ 1) - 1
-                                    : opcode ^ 1);
-                            newCode.putShort(8); // jump offset
-                            newCode.putByte(200); // GOTO_W
-                            // newOffset now computed from start of GOTO_W
-                            newOffset -= 3;
-                        }
-                        newCode.putInt(newOffset);
-                    } else {
-                        newCode.putByte(opcode);
-                        newCode.putShort(newOffset);
-                    }
-                    u += 3;
-                    break;
-                case ClassWriter.LABELW_INSN:
-                    label = u + readInt(b, u + 1);
-                    newOffset = getNewOffset(allIndexes, allSizes, u, label);
-                    newCode.putByte(opcode);
-                    newCode.putInt(newOffset);
-                    u += 5;
-                    break;
-                case ClassWriter.TABL_INSN:
-                    // skips 0 to 3 padding bytes
-                    v = u;
-                    u = u + 4 - (v & 3);
-                    // reads and copies instruction
-                    newCode.putByte(Opcodes.TABLESWITCH);
-                    newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);
-                    label = v + readInt(b, u);
-                    u += 4;
-                    newOffset = getNewOffset(allIndexes, allSizes, v, label);
-                    newCode.putInt(newOffset);
-                    j = readInt(b, u);
-                    u += 4;
-                    newCode.putInt(j);
-                    j = readInt(b, u) - j + 1;
-                    u += 4;
-                    newCode.putInt(readInt(b, u - 4));
-                    for (; j > 0; --j) {
-                        label = v + readInt(b, u);
-                        u += 4;
-                        newOffset = getNewOffset(allIndexes, allSizes, v, label);
-                        newCode.putInt(newOffset);
-                    }
-                    break;
-                case ClassWriter.LOOK_INSN:
-                    // skips 0 to 3 padding bytes
-                    v = u;
-                    u = u + 4 - (v & 3);
-                    // reads and copies instruction
-                    newCode.putByte(Opcodes.LOOKUPSWITCH);
-                    newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);
-                    label = v + readInt(b, u);
-                    u += 4;
-                    newOffset = getNewOffset(allIndexes, allSizes, v, label);
-                    newCode.putInt(newOffset);
-                    j = readInt(b, u);
-                    u += 4;
-                    newCode.putInt(j);
-                    for (; j > 0; --j) {
-                        newCode.putInt(readInt(b, u));
-                        u += 4;
-                        label = v + readInt(b, u);
-                        u += 4;
-                        newOffset = getNewOffset(allIndexes, allSizes, v, label);
-                        newCode.putInt(newOffset);
-                    }
-                    break;
-                case ClassWriter.WIDE_INSN:
-                    opcode = b[u + 1] & 0xFF;
-                    if (opcode == Opcodes.IINC) {
-                        newCode.putByteArray(b, u, 6);
-                        u += 6;
-                    } else {
-                        newCode.putByteArray(b, u, 4);
-                        u += 4;
-                    }
-                    break;
-                case ClassWriter.VAR_INSN:
-                case ClassWriter.SBYTE_INSN:
-                case ClassWriter.LDC_INSN:
-                    newCode.putByteArray(b, u, 2);
-                    u += 2;
-                    break;
-                case ClassWriter.SHORT_INSN:
-                case ClassWriter.LDCW_INSN:
-                case ClassWriter.FIELDORMETH_INSN:
-                case ClassWriter.TYPE_INSN:
-                case ClassWriter.IINC_INSN:
-                    newCode.putByteArray(b, u, 3);
-                    u += 3;
-                    break;
-                case ClassWriter.ITFDYNMETH_INSN:
-                    newCode.putByteArray(b, u, 5);
-                    u += 5;
-                    break;
-                // case MANA_INSN:
-                default:
-                    newCode.putByteArray(b, u, 4);
-                    u += 4;
-                    break;
-            }
-        }
-
-        // recomputes the stack map frames
-        if (frameCount > 0) {
-            if (compute == FRAMES) {
-                frameCount = 0;
-                stackMap = null;
-                previousFrame = null;
-                frame = null;
-                Frame f = new Frame();
-                f.owner = labels;
-                Type[] args = Type.getArgumentTypes(descriptor);
-                f.initInputFrame(cw, access, args, maxLocals);
-                visitFrame(f);
-                Label l = labels;
-                while (l != null) {
-                    /*
-                     * here we need the original label position. getNewOffset
-                     * must therefore never have been called for this label.
-                     */
-                    u = l.position - 3;
-                    if ((l.status & Label.STORE) != 0 || (u >= 0 && resize[u]))
-                    {
-                        getNewOffset(allIndexes, allSizes, l);
-                        // TODO update offsets in UNINITIALIZED values
-                        visitFrame(l.frame);
-                    }
-                    l = l.successor;
-                }
-            } else {
-                /*
-                 * Resizing an existing stack map frame table is really hard.
-                 * Not only the table must be parsed to update the offets, but
-                 * new frames may be needed for jump instructions that were
-                 * inserted by this method. And updating the offsets or
-                 * inserting frames can change the format of the following
-                 * frames, in case of packed frames. In practice the whole table
-                 * must be recomputed. For this the frames are marked as
-                 * potentially invalid. This will cause the whole class to be
-                 * reread and rewritten with the COMPUTE_FRAMES option (see the
-                 * ClassWriter.toByteArray method). This is not very efficient
-                 * but is much easier and requires much less code than any other
-                 * method I can think of.
-                 */
-                cw.invalidFrames = true;
-            }
-        }
-        // updates the exception handler block labels
-        Handler h = firstHandler;
-        while (h != null) {
-            getNewOffset(allIndexes, allSizes, h.start);
-            getNewOffset(allIndexes, allSizes, h.end);
-            getNewOffset(allIndexes, allSizes, h.handler);
-            h = h.next;
-        }
-        // updates the instructions addresses in the
-        // local var and line number tables
-        for (i = 0; i < 2; ++i) {
-            ByteVector bv = i == 0 ? localVar : localVarType;
-            if (bv != null) {
-                b = bv.data;
-                u = 0;
-                while (u < bv.length) {
-                    label = readUnsignedShort(b, u);
-                    newOffset = getNewOffset(allIndexes, allSizes, 0, label);
-                    writeShort(b, u, newOffset);
-                    label += readUnsignedShort(b, u + 2);
-                    newOffset = getNewOffset(allIndexes, allSizes, 0, label)
-                            - newOffset;
-                    writeShort(b, u + 2, newOffset);
-                    u += 10;
-                }
-            }
-        }
-        if (lineNumber != null) {
-            b = lineNumber.data;
-            u = 0;
-            while (u < lineNumber.length) {
-                writeShort(b, u, getNewOffset(allIndexes,
-                        allSizes,
-                        0,
-                        readUnsignedShort(b, u)));
-                u += 4;
-            }
-        }
-        // updates the labels of the other attributes
-        Attribute attr = cattrs;
-        while (attr != null) {
-            Label[] labels = attr.getLabels();
-            if (labels != null) {
-                for (i = labels.length - 1; i >= 0; --i) {
-                    getNewOffset(allIndexes, allSizes, labels[i]);
-                }
-            }
-            attr = attr.next;
-        }
-
-        // replaces old bytecodes with new ones
-        code = newCode;
-    }
-
-    /**
-     * Reads an unsigned short value in the given byte array.
-     * 
-     * @param b a byte array.
-     * @param index the start index of the value to be read.
-     * @return the read value.
-     */
-    static int readUnsignedShort(final byte[] b, final int index) {
-        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);
-    }
-
-    /**
-     * Reads a signed short value in the given byte array.
-     * 
-     * @param b a byte array.
-     * @param index the start index of the value to be read.
-     * @return the read value.
-     */
-    static short readShort(final byte[] b, final int index) {
-        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));
-    }
-
-    /**
-     * Reads a signed int value in the given byte array.
-     * 
-     * @param b a byte array.
-     * @param index the start index of the value to be read.
-     * @return the read value.
-     */
-    static int readInt(final byte[] b, final int index) {
-        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16)
-                | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);
-    }
-
-    /**
-     * Writes a short value in the given byte array.
-     * 
-     * @param b a byte array.
-     * @param index where the first byte of the short value must be written.
-     * @param s the value to be written in the given byte array.
-     */
-    static void writeShort(final byte[] b, final int index, final int s) {
-        b[index] = (byte) (s >>> 8);
-        b[index + 1] = (byte) s;
-    }
-
-    /**
-     * Computes the future value of a bytecode offset. <p> Note: it is possible
-     * to have several entries for the same instruction in the <tt>indexes</tt>
-     * and <tt>sizes</tt>: two entries (index=a,size=b) and (index=a,size=b')
-     * are equivalent to a single entry (index=a,size=b+b').
-     * 
-     * @param indexes current positions of the instructions to be resized. Each
-     *        instruction must be designated by the index of its <i>last</i>
-     *        byte, plus one (or, in other words, by the index of the <i>first</i>
-     *        byte of the <i>next</i> instruction).
-     * @param sizes the number of bytes to be <i>added</i> to the above
-     *        instructions. More precisely, for each i < <tt>len</tt>,
-     *        <tt>sizes</tt>[i] bytes will be added at the end of the
-     *        instruction designated by <tt>indexes</tt>[i] or, if
-     *        <tt>sizes</tt>[i] is negative, the <i>last</i> |<tt>sizes[i]</tt>|
-     *        bytes of the instruction will be removed (the instruction size
-     *        <i>must not</i> become negative or null).
-     * @param begin index of the first byte of the source instruction.
-     * @param end index of the first byte of the target instruction.
-     * @return the future value of the given bytecode offset.
-     */
-    static int getNewOffset(
-        final int[] indexes,
-        final int[] sizes,
-        final int begin,
-        final int end)
-    {
-        int offset = end - begin;
-        for (int i = 0; i < indexes.length; ++i) {
-            if (begin < indexes[i] && indexes[i] <= end) {
-                // forward jump
-                offset += sizes[i];
-            } else if (end < indexes[i] && indexes[i] <= begin) {
-                // backward jump
-                offset -= sizes[i];
-            }
-        }
-        return offset;
-    }
-
-    /**
-     * Updates the offset of the given label.
-     * 
-     * @param indexes current positions of the instructions to be resized. Each
-     *        instruction must be designated by the index of its <i>last</i>
-     *        byte, plus one (or, in other words, by the index of the <i>first</i>
-     *        byte of the <i>next</i> instruction).
-     * @param sizes the number of bytes to be <i>added</i> to the above
-     *        instructions. More precisely, for each i < <tt>len</tt>,
-     *        <tt>sizes</tt>[i] bytes will be added at the end of the
-     *        instruction designated by <tt>indexes</tt>[i] or, if
-     *        <tt>sizes</tt>[i] is negative, the <i>last</i> |<tt>sizes[i]</tt>|
-     *        bytes of the instruction will be removed (the instruction size
-     *        <i>must not</i> become negative or null).
-     * @param label the label whose offset must be updated.
-     */
-    static void getNewOffset(
-        final int[] indexes,
-        final int[] sizes,
-        final Label label)
-    {
-        if ((label.status & Label.RESIZED) == 0) {
-            label.position = getNewOffset(indexes, sizes, 0, label.position);
-            label.status |= Label.RESIZED;
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/Opcodes.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/Opcodes.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/Opcodes.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/Opcodes.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,347 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-/**
- * Defines the JVM opcodes, access flags and array type codes. This interface
- * does not define all the JVM opcodes because some opcodes are automatically
- * handled. For example, the xLOAD and xSTORE opcodes are automatically replaced
- * by xLOAD_n and xSTORE_n opcodes when possible. The xLOAD_n and xSTORE_n
- * opcodes are therefore not defined in this interface. Likewise for LDC,
- * automatically replaced by LDC_W or LDC2_W when necessary, WIDE, GOTO_W and
- * JSR_W.
- * 
- * @author Eric Bruneton
- * @author Eugene Kuleshov
- */
-public interface Opcodes {
-
-    // versions
-
-    int V1_1 = 3 << 16 | 45;
-    int V1_2 = 0 << 16 | 46;
-    int V1_3 = 0 << 16 | 47;
-    int V1_4 = 0 << 16 | 48;
-    int V1_5 = 0 << 16 | 49;
-    int V1_6 = 0 << 16 | 50;
-    int V1_7 = 0 << 16 | 51;
-
-    // access flags
-
-    int ACC_PUBLIC = 0x0001; // class, field, method
-    int ACC_PRIVATE = 0x0002; // class, field, method
-    int ACC_PROTECTED = 0x0004; // class, field, method
-    int ACC_STATIC = 0x0008; // field, method
-    int ACC_FINAL = 0x0010; // class, field, method
-    int ACC_SUPER = 0x0020; // class
-    int ACC_SYNCHRONIZED = 0x0020; // method
-    int ACC_VOLATILE = 0x0040; // field
-    int ACC_BRIDGE = 0x0040; // method
-    int ACC_VARARGS = 0x0080; // method
-    int ACC_TRANSIENT = 0x0080; // field
-    int ACC_NATIVE = 0x0100; // method
-    int ACC_INTERFACE = 0x0200; // class
-    int ACC_ABSTRACT = 0x0400; // class, method
-    int ACC_STRICT = 0x0800; // method
-    int ACC_SYNTHETIC = 0x1000; // class, field, method
-    int ACC_ANNOTATION = 0x2000; // class
-    int ACC_ENUM = 0x4000; // class(?) field inner
-
-    // ASM specific pseudo access flags
-
-    int ACC_DEPRECATED = 0x20000; // class, field, method
-
-    // types for NEWARRAY
-
-    int T_BOOLEAN = 4;
-    int T_CHAR = 5;
-    int T_FLOAT = 6;
-    int T_DOUBLE = 7;
-    int T_BYTE = 8;
-    int T_SHORT = 9;
-    int T_INT = 10;
-    int T_LONG = 11;
-
-    // stack map frame types
-
-    /**
-     * Represents an expanded frame. See {@link ClassReader#EXPAND_FRAMES}.
-     */
-    int F_NEW = -1;
-
-    /**
-     * Represents a compressed frame with complete frame data.
-     */
-    int F_FULL = 0;
-
-    /**
-     * Represents a compressed frame where locals are the same as the locals in
-     * the previous frame, except that additional 1-3 locals are defined, and
-     * with an empty stack.
-     */
-    int F_APPEND = 1;
-
-    /**
-     * Represents a compressed frame where locals are the same as the locals in
-     * the previous frame, except that the last 1-3 locals are absent and with
-     * an empty stack.
-     */
-    int F_CHOP = 2;
-
-    /**
-     * Represents a compressed frame with exactly the same locals as the
-     * previous frame and with an empty stack.
-     */
-    int F_SAME = 3;
-
-    /**
-     * Represents a compressed frame with exactly the same locals as the
-     * previous frame and with a single value on the stack.
-     */
-    int F_SAME1 = 4;
-
-    Integer TOP = new Integer(0);
-    Integer INTEGER = new Integer(1);
-    Integer FLOAT = new Integer(2);
-    Integer DOUBLE = new Integer(3);
-    Integer LONG = new Integer(4);
-    Integer NULL = new Integer(5);
-    Integer UNINITIALIZED_THIS = new Integer(6);
-
-    /** 
-     * Represents a owner of an invokedynamic call.
-     */
-    String INVOKEDYNAMIC_OWNER = "java/lang/dyn/Dynamic";
-    
-    // opcodes // visit method (- = idem)
-
-    int NOP = 0; // visitInsn
-    int ACONST_NULL = 1; // -
-    int ICONST_M1 = 2; // -
-    int ICONST_0 = 3; // -
-    int ICONST_1 = 4; // -
-    int ICONST_2 = 5; // -
-    int ICONST_3 = 6; // -
-    int ICONST_4 = 7; // -
-    int ICONST_5 = 8; // -
-    int LCONST_0 = 9; // -
-    int LCONST_1 = 10; // -
-    int FCONST_0 = 11; // -
-    int FCONST_1 = 12; // -
-    int FCONST_2 = 13; // -
-    int DCONST_0 = 14; // -
-    int DCONST_1 = 15; // -
-    int BIPUSH = 16; // visitIntInsn
-    int SIPUSH = 17; // -
-    int LDC = 18; // visitLdcInsn
-    // int LDC_W = 19; // -
-    // int LDC2_W = 20; // -
-    int ILOAD = 21; // visitVarInsn
-    int LLOAD = 22; // -
-    int FLOAD = 23; // -
-    int DLOAD = 24; // -
-    int ALOAD = 25; // -
-    // int ILOAD_0 = 26; // -
-    // int ILOAD_1 = 27; // -
-    // int ILOAD_2 = 28; // -
-    // int ILOAD_3 = 29; // -
-    // int LLOAD_0 = 30; // -
-    // int LLOAD_1 = 31; // -
-    // int LLOAD_2 = 32; // -
-    // int LLOAD_3 = 33; // -
-    // int FLOAD_0 = 34; // -
-    // int FLOAD_1 = 35; // -
-    // int FLOAD_2 = 36; // -
-    // int FLOAD_3 = 37; // -
-    // int DLOAD_0 = 38; // -
-    // int DLOAD_1 = 39; // -
-    // int DLOAD_2 = 40; // -
-    // int DLOAD_3 = 41; // -
-    // int ALOAD_0 = 42; // -
-    // int ALOAD_1 = 43; // -
-    // int ALOAD_2 = 44; // -
-    // int ALOAD_3 = 45; // -
-    int IALOAD = 46; // visitInsn
-    int LALOAD = 47; // -
-    int FALOAD = 48; // -
-    int DALOAD = 49; // -
-    int AALOAD = 50; // -
-    int BALOAD = 51; // -
-    int CALOAD = 52; // -
-    int SALOAD = 53; // -
-    int ISTORE = 54; // visitVarInsn
-    int LSTORE = 55; // -
-    int FSTORE = 56; // -
-    int DSTORE = 57; // -
-    int ASTORE = 58; // -
-    // int ISTORE_0 = 59; // -
-    // int ISTORE_1 = 60; // -
-    // int ISTORE_2 = 61; // -
-    // int ISTORE_3 = 62; // -
-    // int LSTORE_0 = 63; // -
-    // int LSTORE_1 = 64; // -
-    // int LSTORE_2 = 65; // -
-    // int LSTORE_3 = 66; // -
-    // int FSTORE_0 = 67; // -
-    // int FSTORE_1 = 68; // -
-    // int FSTORE_2 = 69; // -
-    // int FSTORE_3 = 70; // -
-    // int DSTORE_0 = 71; // -
-    // int DSTORE_1 = 72; // -
-    // int DSTORE_2 = 73; // -
-    // int DSTORE_3 = 74; // -
-    // int ASTORE_0 = 75; // -
-    // int ASTORE_1 = 76; // -
-    // int ASTORE_2 = 77; // -
-    // int ASTORE_3 = 78; // -
-    int IASTORE = 79; // visitInsn
-    int LASTORE = 80; // -
-    int FASTORE = 81; // -
-    int DASTORE = 82; // -
-    int AASTORE = 83; // -
-    int BASTORE = 84; // -
-    int CASTORE = 85; // -
-    int SASTORE = 86; // -
-    int POP = 87; // -
-    int POP2 = 88; // -
-    int DUP = 89; // -
-    int DUP_X1 = 90; // -
-    int DUP_X2 = 91; // -
-    int DUP2 = 92; // -
-    int DUP2_X1 = 93; // -
-    int DUP2_X2 = 94; // -
-    int SWAP = 95; // -
-    int IADD = 96; // -
-    int LADD = 97; // -
-    int FADD = 98; // -
-    int DADD = 99; // -
-    int ISUB = 100; // -
-    int LSUB = 101; // -
-    int FSUB = 102; // -
-    int DSUB = 103; // -
-    int IMUL = 104; // -
-    int LMUL = 105; // -
-    int FMUL = 106; // -
-    int DMUL = 107; // -
-    int IDIV = 108; // -
-    int LDIV = 109; // -
-    int FDIV = 110; // -
-    int DDIV = 111; // -
-    int IREM = 112; // -
-    int LREM = 113; // -
-    int FREM = 114; // -
-    int DREM = 115; // -
-    int INEG = 116; // -
-    int LNEG = 117; // -
-    int FNEG = 118; // -
-    int DNEG = 119; // -
-    int ISHL = 120; // -
-    int LSHL = 121; // -
-    int ISHR = 122; // -
-    int LSHR = 123; // -
-    int IUSHR = 124; // -
-    int LUSHR = 125; // -
-    int IAND = 126; // -
-    int LAND = 127; // -
-    int IOR = 128; // -
-    int LOR = 129; // -
-    int IXOR = 130; // -
-    int LXOR = 131; // -
-    int IINC = 132; // visitIincInsn
-    int I2L = 133; // visitInsn
-    int I2F = 134; // -
-    int I2D = 135; // -
-    int L2I = 136; // -
-    int L2F = 137; // -
-    int L2D = 138; // -
-    int F2I = 139; // -
-    int F2L = 140; // -
-    int F2D = 141; // -
-    int D2I = 142; // -
-    int D2L = 143; // -
-    int D2F = 144; // -
-    int I2B = 145; // -
-    int I2C = 146; // -
-    int I2S = 147; // -
-    int LCMP = 148; // -
-    int FCMPL = 149; // -
-    int FCMPG = 150; // -
-    int DCMPL = 151; // -
-    int DCMPG = 152; // -
-    int IFEQ = 153; // visitJumpInsn
-    int IFNE = 154; // -
-    int IFLT = 155; // -
-    int IFGE = 156; // -
-    int IFGT = 157; // -
-    int IFLE = 158; // -
-    int IF_ICMPEQ = 159; // -
-    int IF_ICMPNE = 160; // -
-    int IF_ICMPLT = 161; // -
-    int IF_ICMPGE = 162; // -
-    int IF_ICMPGT = 163; // -
-    int IF_ICMPLE = 164; // -
-    int IF_ACMPEQ = 165; // -
-    int IF_ACMPNE = 166; // -
-    int GOTO = 167; // -
-    int JSR = 168; // -
-    int RET = 169; // visitVarInsn
-    int TABLESWITCH = 170; // visiTableSwitchInsn
-    int LOOKUPSWITCH = 171; // visitLookupSwitch
-    int IRETURN = 172; // visitInsn
-    int LRETURN = 173; // -
-    int FRETURN = 174; // -
-    int DRETURN = 175; // -
-    int ARETURN = 176; // -
-    int RETURN = 177; // -
-    int GETSTATIC = 178; // visitFieldInsn
-    int PUTSTATIC = 179; // -
-    int GETFIELD = 180; // -
-    int PUTFIELD = 181; // -
-    int INVOKEVIRTUAL = 182; // visitMethodInsn
-    int INVOKESPECIAL = 183; // -
-    int INVOKESTATIC = 184; // -
-    int INVOKEINTERFACE = 185; // -
-    int INVOKEDYNAMIC = 186; // -
-    int NEW = 187; // visitTypeInsn
-    int NEWARRAY = 188; // visitIntInsn
-    int ANEWARRAY = 189; // visitTypeInsn
-    int ARRAYLENGTH = 190; // visitInsn
-    int ATHROW = 191; // -
-    int CHECKCAST = 192; // visitTypeInsn
-    int INSTANCEOF = 193; // -
-    int MONITORENTER = 194; // visitInsn
-    int MONITOREXIT = 195; // -
-    // int WIDE = 196; // NOT VISITED
-    int MULTIANEWARRAY = 197; // visitMultiANewArrayInsn
-    int IFNULL = 198; // visitJumpInsn
-    int IFNONNULL = 199; // -
-    // int GOTO_W = 200; // -
-    // int JSR_W = 201; // -
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/package.html eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/package.html
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/package.html	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/package.html	1970-01-01 01:00:00.000000000 +0100
@@ -1,87 +0,0 @@
-<html>
-<!--
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2005 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
--->
-<body>
-Provides a small and fast bytecode manipulation framework.
-
-<p>
-The <a href="http://www.objectweb.org/asm">ASM</a> framework is organized
-around the {@link org.objectweb.asm.ClassVisitor ClassVisitor}, 
-{@link org.objectweb.asm.FieldVisitor FieldVisitor} and 
-{@link org.objectweb.asm.MethodVisitor MethodVisitor} interfaces, which allow
-one to visit the fields and methods of a class, including the bytecode 
-instructions of each method.
-
-<p>
-In addition to these main interfaces, ASM provides a {@link
-org.objectweb.asm.ClassReader ClassReader} class, that can parse an
-existing class and make a given visitor visit it. ASM also provides
-a {@link org.objectweb.asm.ClassWriter ClassWriter} class, which is
-a visitor that generates Java class files.
-
-<p>
-In order to generate a class from scratch, only the {@link
-org.objectweb.asm.ClassWriter ClassWriter} class is necessary. Indeed,
-in order to generate a class, one must just call its visit<i>XXX</i>
-methods with the appropriate arguments to generate the desired fields
-and methods. See the "helloworld" example in the ASM distribution for
-more details about class generation.
-
-<p>
-In order to modify existing classes, one must use a {@link
-org.objectweb.asm.ClassReader ClassReader} class to analyze
-the original class, a class modifier, and a {@link org.objectweb.asm.ClassWriter
-ClassWriter} to construct the modified class. The class modifier
-is just a {@link org.objectweb.asm.ClassVisitor ClassVisitor}
-that delegates most of the work to another {@link org.objectweb.asm.ClassVisitor
-ClassVisitor}, but that sometimes changes some parameter values,
-or call additional methods, in order to implement the desired
-modification process. In order to make it easier to implement such
-class modifiers, ASM provides the {@link org.objectweb.asm.ClassAdapter
-ClassAdapter} and {@link org.objectweb.asm.MethodAdapter MethodAdapter}
-classes, which implement the {@link org.objectweb.asm.ClassVisitor ClassVisitor} 
-and {@link org.objectweb.asm.MethodVisitor MethodVisitor} interfaces by 
-delegating all work to other visitors. See the "adapt" example in the ASM 
-distribution for more details about class modification.
-
-<p>
-The size of the core ASM library, <tt>asm.jar</tt>, is only 42KB, which is much
-smaller than the size of the 
-<a href="http://jakarta.apache.org/bcel">BCEL</a> library (504KB), and than the 
-size of the
-<a href="http://serp.sourceforge.net">SERP</a> library (150KB). ASM is also
-much faster than these tools. Indeed the overhead of a load time class
-transformation process is of the order of 60% with ASM, 700% or more with BCEL,
-and 1100% or more with SERP (see the <tt>test/perf</tt> directory in the ASM
-distribution)!
-
-@since ASM 1.3
-</body>
-</html>
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/signature/package.html eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/signature/package.html
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/signature/package.html	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/signature/package.html	1970-01-01 01:00:00.000000000 +0100
@@ -1,36 +0,0 @@
-<html>
-<!--
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2005 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
--->
-<body>
-Provides support for type signatures.
-
-@since ASM 2.0
-</body>
-</html>
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/signature/SignatureReader.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/signature/SignatureReader.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/signature/SignatureReader.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/signature/SignatureReader.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,229 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.signature;
-
-/**
- * A type signature parser to make a signature visitor visit an existing
- * signature.
- * 
- * @author Thomas Hallgren
- * @author Eric Bruneton
- */
-public class SignatureReader {
-
-    /**
-     * The signature to be read.
-     */
-    private final String signature;
-
-    /**
-     * Constructs a {@link SignatureReader} for the given signature.
-     * 
-     * @param signature A <i>ClassSignature</i>, <i>MethodTypeSignature</i>,
-     *        or <i>FieldTypeSignature</i>.
-     */
-    public SignatureReader(final String signature) {
-        this.signature = signature;
-    }
-
-    /**
-     * Makes the given visitor visit the signature of this
-     * {@link SignatureReader}. This signature is the one specified in the
-     * constructor (see {@link #SignatureReader(String) SignatureReader}). This
-     * method is intended to be called on a {@link SignatureReader} that was
-     * created using a <i>ClassSignature</i> (such as the
-     * <code>signature</code> parameter of the
-     * {@link org.eclipse.persistence.internal.libraries.asm.ClassVisitor#visit ClassVisitor.visit} method)
-     * or a <i>MethodTypeSignature</i> (such as the <code>signature</code>
-     * parameter of the
-     * {@link org.eclipse.persistence.internal.libraries.asm.ClassVisitor#visitMethod ClassVisitor.visitMethod}
-     * method).
-     * 
-     * @param v the visitor that must visit this signature.
-     */
-    public void accept(final SignatureVisitor v) {
-        String signature = this.signature;
-        int len = signature.length();
-        int pos;
-        char c;
-
-        if (signature.charAt(0) == '<') {
-            pos = 2;
-            do {
-                int end = signature.indexOf(':', pos);
-                v.visitFormalTypeParameter(signature.substring(pos - 1, end));
-                pos = end + 1;
-
-                c = signature.charAt(pos);
-                if (c == 'L' || c == '[' || c == 'T') {
-                    pos = parseType(signature, pos, v.visitClassBound());
-                }
-
-                while ((c = signature.charAt(pos++)) == ':') {
-                    pos = parseType(signature, pos, v.visitInterfaceBound());
-                }
-            } while (c != '>');
-        } else {
-            pos = 0;
-        }
-
-        if (signature.charAt(pos) == '(') {
-            pos++;
-            while (signature.charAt(pos) != ')') {
-                pos = parseType(signature, pos, v.visitParameterType());
-            }
-            pos = parseType(signature, pos + 1, v.visitReturnType());
-            while (pos < len) {
-                pos = parseType(signature, pos + 1, v.visitExceptionType());
-            }
-        } else {
-            pos = parseType(signature, pos, v.visitSuperclass());
-            while (pos < len) {
-                pos = parseType(signature, pos, v.visitInterface());
-            }
-        }
-    }
-
-    /**
-     * Makes the given visitor visit the signature of this
-     * {@link SignatureReader}. This signature is the one specified in the
-     * constructor (see {@link #SignatureReader(String) SignatureReader}). This
-     * method is intended to be called on a {@link SignatureReader} that was
-     * created using a <i>FieldTypeSignature</i>, such as the
-     * <code>signature</code> parameter of the
-     * {@link org.eclipse.persistence.internal.libraries.asm.ClassVisitor#visitField 
-     * ClassVisitor.visitField} or {@link 
-     * org.eclipse.persistence.internal.libraries.asm.MethodVisitor#visitLocalVariable
-     * MethodVisitor.visitLocalVariable} methods.
-     * 
-     * @param v the visitor that must visit this signature.
-     */
-    public void acceptType(final SignatureVisitor v) {
-        parseType(this.signature, 0, v);
-    }
-
-    /**
-     * Parses a field type signature and makes the given visitor visit it.
-     * 
-     * @param signature a string containing the signature that must be parsed.
-     * @param pos index of the first character of the signature to parsed.
-     * @param v the visitor that must visit this signature.
-     * @return the index of the first character after the parsed signature.
-     */
-    private static int parseType(
-        final String signature,
-        int pos,
-        final SignatureVisitor v)
-    {
-        char c;
-        int start, end;
-        boolean visited, inner;
-        String name;
-
-        switch (c = signature.charAt(pos++)) {
-            case 'Z':
-            case 'C':
-            case 'B':
-            case 'S':
-            case 'I':
-            case 'F':
-            case 'J':
-            case 'D':
-            case 'V':
-                v.visitBaseType(c);
-                return pos;
-
-            case '[':
-                return parseType(signature, pos, v.visitArrayType());
-
-            case 'T':
-                end = signature.indexOf(';', pos);
-                v.visitTypeVariable(signature.substring(pos, end));
-                return end + 1;
-
-            default: // case 'L':
-                start = pos;
-                visited = false;
-                inner = false;
-                for (;;) {
-                    switch (c = signature.charAt(pos++)) {
-                        case '.':
-                        case ';':
-                            if (!visited) {
-                                name = signature.substring(start, pos - 1);
-                                if (inner) {
-                                    v.visitInnerClassType(name);
-                                } else {
-                                    v.visitClassType(name);
-                                }
-                            }
-                            if (c == ';') {
-                                v.visitEnd();
-                                return pos;
-                            }
-                            start = pos;
-                            visited = false;
-                            inner = true;
-                            break;
-
-                        case '<':
-                            name = signature.substring(start, pos - 1);
-                            if (inner) {
-                                v.visitInnerClassType(name);
-                            } else {
-                                v.visitClassType(name);
-                            }
-                            visited = true;
-                            top: for (;;) {
-                                switch (c = signature.charAt(pos)) {
-                                    case '>':
-                                        break top;
-                                    case '*':
-                                        ++pos;
-                                        v.visitTypeArgument();
-                                        break;
-                                    case '+':
-                                    case '-':
-                                        pos = parseType(signature,
-                                                pos + 1,
-                                                v.visitTypeArgument(c));
-                                        break;
-                                    default:
-                                        pos = parseType(signature,
-                                                pos,
-                                                v.visitTypeArgument('='));
-                                        break;
-                                }
-                            }
-                    }
-                }
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/signature/SignatureVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/signature/SignatureVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/signature/SignatureVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/signature/SignatureVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,185 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.signature;
-
-/**
- * A visitor to visit a generic signature. The methods of this interface must be
- * called in one of the three following orders (the last one is the only valid
- * order for a {@link SignatureVisitor} that is returned by a method of this
- * interface): <ul> <li><i>ClassSignature</i> = (
- * <tt>visitFormalTypeParameter</tt> 
- *   <tt>visitClassBound</tt>?
- * <tt>visitInterfaceBound</tt>* )* ( <tt>visitSuperClass</tt> 
- *   <tt>visitInterface</tt>* )</li>
- * <li><i>MethodSignature</i> = ( <tt>visitFormalTypeParameter</tt> 
- *   <tt>visitClassBound</tt>?
- * <tt>visitInterfaceBound</tt>* )* ( <tt>visitParameterType</tt>*
- * <tt>visitReturnType</tt> 
- *   <tt>visitExceptionType</tt>* )</li> <li><i>TypeSignature</i> =
- * <tt>visitBaseType</tt> | <tt>visitTypeVariable</tt> |
- * <tt>visitArrayType</tt> | (
- * <tt>visitClassType</tt> <tt>visitTypeArgument</tt>* (
- * <tt>visitInnerClassType</tt> <tt>visitTypeArgument</tt>* )*
- * <tt>visitEnd</tt> ) )</li> </ul>
- * 
- * @author Thomas Hallgren
- * @author Eric Bruneton
- */
-public interface SignatureVisitor {
-
-    /**
-     * Wildcard for an "extends" type argument.
-     */
-    char EXTENDS = '+';
-
-    /**
-     * Wildcard for a "super" type argument.
-     */
-    char SUPER = '-';
-
-    /**
-     * Wildcard for a normal type argument.
-     */
-    char INSTANCEOF = '=';
-
-    /**
-     * Visits a formal type parameter.
-     * 
-     * @param name the name of the formal parameter.
-     */
-    void visitFormalTypeParameter(String name);
-
-    /**
-     * Visits the class bound of the last visited formal type parameter.
-     * 
-     * @return a non null visitor to visit the signature of the class bound.
-     */
-    SignatureVisitor visitClassBound();
-
-    /**
-     * Visits an interface bound of the last visited formal type parameter.
-     * 
-     * @return a non null visitor to visit the signature of the interface bound.
-     */
-    SignatureVisitor visitInterfaceBound();
-
-    /**
-     * Visits the type of the super class.
-     * 
-     * @return a non null visitor to visit the signature of the super class
-     *         type.
-     */
-    SignatureVisitor visitSuperclass();
-
-    /**
-     * Visits the type of an interface implemented by the class.
-     * 
-     * @return a non null visitor to visit the signature of the interface type.
-     */
-    SignatureVisitor visitInterface();
-
-    /**
-     * Visits the type of a method parameter.
-     * 
-     * @return a non null visitor to visit the signature of the parameter type.
-     */
-    SignatureVisitor visitParameterType();
-
-    /**
-     * Visits the return type of the method.
-     * 
-     * @return a non null visitor to visit the signature of the return type.
-     */
-    SignatureVisitor visitReturnType();
-
-    /**
-     * Visits the type of a method exception.
-     * 
-     * @return a non null visitor to visit the signature of the exception type.
-     */
-    SignatureVisitor visitExceptionType();
-
-    /**
-     * Visits a signature corresponding to a primitive type.
-     * 
-     * @param descriptor the descriptor of the primitive type, or 'V' for
-     *        <tt>void</tt>.
-     */
-    void visitBaseType(char descriptor);
-
-    /**
-     * Visits a signature corresponding to a type variable.
-     * 
-     * @param name the name of the type variable.
-     */
-    void visitTypeVariable(String name);
-
-    /**
-     * Visits a signature corresponding to an array type.
-     * 
-     * @return a non null visitor to visit the signature of the array element
-     *         type.
-     */
-    SignatureVisitor visitArrayType();
-
-    /**
-     * Starts the visit of a signature corresponding to a class or interface
-     * type.
-     * 
-     * @param name the internal name of the class or interface.
-     */
-    void visitClassType(String name);
-
-    /**
-     * Visits an inner class.
-     * 
-     * @param name the local name of the inner class in its enclosing class.
-     */
-    void visitInnerClassType(String name);
-
-    /**
-     * Visits an unbounded type argument of the last visited class or inner
-     * class type.
-     */
-    void visitTypeArgument();
-
-    /**
-     * Visits a type argument of the last visited class or inner class type.
-     * 
-     * @param wildcard '+', '-' or '='.
-     * @return a non null visitor to visit the signature of the type argument.
-     */
-    SignatureVisitor visitTypeArgument(char wildcard);
-
-    /**
-     * Ends the visit of a signature corresponding to a class or interface type.
-     */
-    void visitEnd();
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/signature/SignatureWriter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/signature/SignatureWriter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/signature/SignatureWriter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/signature/SignatureWriter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,207 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.signature;
-
-/**
- * A signature visitor that generates signatures in string format.
- * 
- * @author Thomas Hallgren
- * @author Eric Bruneton
- */
-public class SignatureWriter implements SignatureVisitor {
-
-    /**
-     * Buffer used to construct the signature.
-     */
-    private final StringBuffer buf = new StringBuffer();
-
-    /**
-     * Indicates if the signature contains formal type parameters.
-     */
-    private boolean hasFormals;
-
-    /**
-     * Indicates if the signature contains method parameter types.
-     */
-    private boolean hasParameters;
-
-    /**
-     * Stack used to keep track of class types that have arguments. Each element
-     * of this stack is a boolean encoded in one bit. The top of the stack is
-     * the lowest order bit. Pushing false = *2, pushing true = *2+1, popping =
-     * /2.
-     */
-    private int argumentStack;
-
-    /**
-     * Constructs a new {@link SignatureWriter} object.
-     */
-    public SignatureWriter() {
-    }
-
-    // ------------------------------------------------------------------------
-    // Implementation of the SignatureVisitor interface
-    // ------------------------------------------------------------------------
-
-    public void visitFormalTypeParameter(final String name) {
-        if (!hasFormals) {
-            hasFormals = true;
-            buf.append('<');
-        }
-        buf.append(name);
-        buf.append(':');
-    }
-
-    public SignatureVisitor visitClassBound() {
-        return this;
-    }
-
-    public SignatureVisitor visitInterfaceBound() {
-        buf.append(':');
-        return this;
-    }
-
-    public SignatureVisitor visitSuperclass() {
-        endFormals();
-        return this;
-    }
-
-    public SignatureVisitor visitInterface() {
-        return this;
-    }
-
-    public SignatureVisitor visitParameterType() {
-        endFormals();
-        if (!hasParameters) {
-            hasParameters = true;
-            buf.append('(');
-        }
-        return this;
-    }
-
-    public SignatureVisitor visitReturnType() {
-        endFormals();
-        if (!hasParameters) {
-            buf.append('(');
-        }
-        buf.append(')');
-        return this;
-    }
-
-    public SignatureVisitor visitExceptionType() {
-        buf.append('^');
-        return this;
-    }
-
-    public void visitBaseType(final char descriptor) {
-        buf.append(descriptor);
-    }
-
-    public void visitTypeVariable(final String name) {
-        buf.append('T');
-        buf.append(name);
-        buf.append(';');
-    }
-
-    public SignatureVisitor visitArrayType() {
-        buf.append('[');
-        return this;
-    }
-
-    public void visitClassType(final String name) {
-        buf.append('L');
-        buf.append(name);
-        argumentStack *= 2;
-    }
-
-    public void visitInnerClassType(final String name) {
-        endArguments();
-        buf.append('.');
-        buf.append(name);
-        argumentStack *= 2;
-    }
-
-    public void visitTypeArgument() {
-        if (argumentStack % 2 == 0) {
-            ++argumentStack;
-            buf.append('<');
-        }
-        buf.append('*');
-    }
-
-    public SignatureVisitor visitTypeArgument(final char wildcard) {
-        if (argumentStack % 2 == 0) {
-            ++argumentStack;
-            buf.append('<');
-        }
-        if (wildcard != '=') {
-            buf.append(wildcard);
-        }
-        return this;
-    }
-
-    public void visitEnd() {
-        endArguments();
-        buf.append(';');
-    }
-
-    /**
-     * Returns the signature that was built by this signature writer.
-     * 
-     * @return the signature that was built by this signature writer.
-     */
-    public String toString() {
-        return buf.toString();
-    }
-
-    // ------------------------------------------------------------------------
-    // Utility methods
-    // ------------------------------------------------------------------------
-
-    /**
-     * Ends the formal type parameters section of the signature.
-     */
-    private void endFormals() {
-        if (hasFormals) {
-            hasFormals = false;
-            buf.append('>');
-        }
-    }
-
-    /**
-     * Ends the type arguments of a class or inner class type.
-     */
-    private void endArguments() {
-        if (argumentStack % 2 != 0) {
-            buf.append('>');
-        }
-        argumentStack /= 2;
-    }
-}
\ Manca newline alla fine del file
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/AbstractInsnNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/AbstractInsnNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/AbstractInsnNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/AbstractInsnNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,233 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.List;
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-/**
- * A node that represents a bytecode instruction. <i>An instruction can appear
- * at most once in at most one {@link InsnList} at a time</i>.
- * 
- * @author Eric Bruneton
- */
-public abstract class AbstractInsnNode {
-
-    /**
-     * The type of {@link InsnNode} instructions.
-     */
-    public static final int INSN = 0;
-
-    /**
-     * The type of {@link IntInsnNode} instructions.
-     */
-    public static final int INT_INSN = 1;
-
-    /**
-     * The type of {@link VarInsnNode} instructions.
-     */
-    public static final int VAR_INSN = 2;
-
-    /**
-     * The type of {@link TypeInsnNode} instructions.
-     */
-    public static final int TYPE_INSN = 3;
-
-    /**
-     * The type of {@link FieldInsnNode} instructions.
-     */
-    public static final int FIELD_INSN = 4;
-
-    /**
-     * The type of {@link MethodInsnNode} instructions.
-     */
-    public static final int METHOD_INSN = 5;
-
-    /**
-     * The type of {@link JumpInsnNode} instructions.
-     */
-    public static final int JUMP_INSN = 6;
-
-    /**
-     * The type of {@link LabelNode} "instructions".
-     */
-    public static final int LABEL = 7;
-
-    /**
-     * The type of {@link LdcInsnNode} instructions.
-     */
-    public static final int LDC_INSN = 8;
-
-    /**
-     * The type of {@link IincInsnNode} instructions.
-     */
-    public static final int IINC_INSN = 9;
-
-    /**
-     * The type of {@link TableSwitchInsnNode} instructions.
-     */
-    public static final int TABLESWITCH_INSN = 10;
-
-    /**
-     * The type of {@link LookupSwitchInsnNode} instructions.
-     */
-    public static final int LOOKUPSWITCH_INSN = 11;
-
-    /**
-     * The type of {@link MultiANewArrayInsnNode} instructions.
-     */
-    public static final int MULTIANEWARRAY_INSN = 12;
-
-    /**
-     * The type of {@link FrameNode} "instructions".
-     */
-    public static final int FRAME = 13;
-
-    /**
-     * The type of {@link LineNumberNode} "instructions".
-     */
-    public static final int LINE = 14;
-
-    /**
-     * The opcode of this instruction.
-     */
-    protected int opcode;
-
-    /**
-     * Previous instruction in the list to which this instruction belongs.
-     */
-    AbstractInsnNode prev;
-
-    /**
-     * Next instruction in the list to which this instruction belongs.
-     */
-    AbstractInsnNode next;
-
-    /**
-     * Index of this instruction in the list to which it belongs. The value of
-     * this field is correct only when {@link InsnList#cache} is not null. A
-     * value of -1 indicates that this instruction does not belong to any
-     * {@link InsnList}.
-     */
-    int index;
-
-    /**
-     * Constructs a new {@link AbstractInsnNode}.
-     * 
-     * @param opcode the opcode of the instruction to be constructed.
-     */
-    protected AbstractInsnNode(final int opcode) {
-        this.opcode = opcode;
-        this.index = -1;
-    }
-
-    /**
-     * Returns the opcode of this instruction.
-     * 
-     * @return the opcode of this instruction.
-     */
-    public int getOpcode() {
-        return opcode;
-    }
-
-    /**
-     * Returns the type of this instruction.
-     * 
-     * @return the type of this instruction, i.e. one the constants defined in
-     *         this class.
-     */
-    public abstract int getType();
-
-    /**
-     * Returns the previous instruction in the list to which this instruction
-     * belongs, if any.
-     * 
-     * @return the previous instruction in the list to which this instruction
-     *         belongs, if any. May be <tt>null</tt>.
-     */
-    public AbstractInsnNode getPrevious() {
-        return prev;
-    }
-
-    /**
-     * Returns the next instruction in the list to which this instruction
-     * belongs, if any.
-     * 
-     * @return the next instruction in the list to which this instruction
-     *         belongs, if any. May be <tt>null</tt>.
-     */
-    public AbstractInsnNode getNext() {
-        return next;
-    }
-
-    /**
-     * Makes the given code visitor visit this instruction.
-     * 
-     * @param cv a code visitor.
-     */
-    public abstract void accept(final MethodVisitor cv);
-
-    /**
-     * Returns a copy of this instruction.
-     * 
-     * @param labels a map from LabelNodes to cloned LabelNodes.
-     * @return a copy of this instruction. The returned instruction does not
-     *         belong to any {@link InsnList}.
-     */
-    public abstract AbstractInsnNode clone(final Map labels);
-
-    /**
-     * Returns the clone of the given label.
-     * 
-     * @param label a label.
-     * @param map a map from LabelNodes to cloned LabelNodes.
-     * @return the clone of the given label.
-     */
-    static LabelNode clone(final LabelNode label, final Map map) {
-        return (LabelNode) map.get(label);
-    }
-
-    /**
-     * Returns the clones of the given labels.
-     * 
-     * @param labels a list of labels.
-     * @param map a map from LabelNodes to cloned LabelNodes.
-     * @return the clones of the given labels.
-     */
-    static LabelNode[] clone(final List labels, final Map map) {
-        LabelNode[] clones = new LabelNode[labels.size()];
-        for (int i = 0; i < clones.length; ++i) {
-            clones[i] = (LabelNode) map.get(labels.get(i));
-        }
-        return clones;
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/AnalyzerException.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/AnalyzerException.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/AnalyzerException.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/AnalyzerException.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,64 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree.analysis;
-
-import org.eclipse.persistence.internal.libraries.asm.tree.AbstractInsnNode;
-
-/**
- * Thrown if a problem occurs during the analysis of a method.
- * 
- * @author Bing Ran
- * @author Eric Bruneton
- */
-public class AnalyzerException extends Exception {
-
-    public final AbstractInsnNode node;
-    
-    public AnalyzerException(final AbstractInsnNode node, final String msg) {
-        super(msg);
-        this.node = node;
-    }
-
-    public AnalyzerException(final AbstractInsnNode node, final String msg, final Throwable exception) {
-        super(msg, exception);
-        this.node = node;
-    }
-
-    public AnalyzerException(
-        final AbstractInsnNode node, 
-        final String msg,
-        final Object expected,
-        final Value encountered)
-    {
-        super((msg == null ? "Expected " : msg + ": expected ") + expected
-                + ", but found " + encountered);
-        this.node = node;
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Analyzer.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Analyzer.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Analyzer.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Analyzer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,523 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree.analysis;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-import org.eclipse.persistence.internal.libraries.asm.tree.AbstractInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.IincInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.InsnList;
-import org.eclipse.persistence.internal.libraries.asm.tree.JumpInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.LabelNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.LookupSwitchInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.MethodNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.TableSwitchInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.TryCatchBlockNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.VarInsnNode;
-
-/**
- * A semantic bytecode analyzer. <i>This class does not fully check that JSR and
- * RET instructions are valid.</i>
- * 
- * @author Eric Bruneton
- */
-public class Analyzer implements Opcodes {
-
-    private final Interpreter interpreter;
-
-    private int n;
-
-    private InsnList insns;
-
-    private List[] handlers;
-
-    private Frame[] frames;
-
-    private Subroutine[] subroutines;
-
-    private boolean[] queued;
-
-    private int[] queue;
-
-    private int top;
-
-    /**
-     * Constructs a new {@link Analyzer}.
-     * 
-     * @param interpreter the interpreter to be used to symbolically interpret
-     *        the bytecode instructions.
-     */
-    public Analyzer(final Interpreter interpreter) {
-        this.interpreter = interpreter;
-    }
-
-    /**
-     * Analyzes the given method.
-     * 
-     * @param owner the internal name of the class to which the method belongs.
-     * @param m the method to be analyzed.
-     * @return the symbolic state of the execution stack frame at each bytecode
-     *         instruction of the method. The size of the returned array is
-     *         equal to the number of instructions (and labels) of the method. A
-     *         given frame is <tt>null</tt> if and only if the corresponding
-     *         instruction cannot be reached (dead code).
-     * @throws AnalyzerException if a problem occurs during the analysis.
-     */
-    public Frame[] analyze(final String owner, final MethodNode m)
-            throws AnalyzerException
-    {
-        if ((m.access & (ACC_ABSTRACT | ACC_NATIVE)) != 0) {
-            frames = new Frame[0];
-            return frames;
-        }
-        n = m.instructions.size();
-        insns = m.instructions;
-        handlers = new List[n];
-        frames = new Frame[n];
-        subroutines = new Subroutine[n];
-        queued = new boolean[n];
-        queue = new int[n];
-        top = 0;
-
-        // computes exception handlers for each instruction
-        for (int i = 0; i < m.tryCatchBlocks.size(); ++i) {
-            TryCatchBlockNode tcb = (TryCatchBlockNode) m.tryCatchBlocks.get(i);
-            int begin = insns.indexOf(tcb.start);
-            int end = insns.indexOf(tcb.end);
-            for (int j = begin; j < end; ++j) {
-                List insnHandlers = handlers[j];
-                if (insnHandlers == null) {
-                    insnHandlers = new ArrayList();
-                    handlers[j] = insnHandlers;
-                }
-                insnHandlers.add(tcb);
-            }
-        }
-
-        // computes the subroutine for each instruction:
-        Subroutine main = new Subroutine(null, m.maxLocals, null);
-        List subroutineCalls = new ArrayList();
-        Map subroutineHeads = new HashMap();
-        findSubroutine(0, main, subroutineCalls);
-        while (!subroutineCalls.isEmpty()) {
-            JumpInsnNode jsr = (JumpInsnNode) subroutineCalls.remove(0);
-            Subroutine sub = (Subroutine) subroutineHeads.get(jsr.label);
-            if (sub == null) {
-                sub = new Subroutine(jsr.label, m.maxLocals, jsr);
-                subroutineHeads.put(jsr.label, sub);
-                findSubroutine(insns.indexOf(jsr.label), sub, subroutineCalls);
-            } else {
-                sub.callers.add(jsr);
-            }
-        }
-        for (int i = 0; i < n; ++i) {
-            if (subroutines[i] != null && subroutines[i].start == null) {
-                subroutines[i] = null;
-            }
-        }
-
-        // initializes the data structures for the control flow analysis
-        Frame current = newFrame(m.maxLocals, m.maxStack);
-        Frame handler = newFrame(m.maxLocals, m.maxStack);
-        current.setReturn(interpreter.newValue(Type.getReturnType(m.desc)));
-        Type[] args = Type.getArgumentTypes(m.desc);
-        int local = 0;
-        if ((m.access & ACC_STATIC) == 0) {
-            Type ctype = Type.getObjectType(owner);
-            current.setLocal(local++, interpreter.newValue(ctype));
-        }
-        for (int i = 0; i < args.length; ++i) {
-            current.setLocal(local++, interpreter.newValue(args[i]));
-            if (args[i].getSize() == 2) {
-                current.setLocal(local++, interpreter.newValue(null));
-            }
-        }
-        while (local < m.maxLocals) {
-            current.setLocal(local++, interpreter.newValue(null));
-        }
-        merge(0, current, null);
-        
-        init(owner, m);
-
-        // control flow analysis
-        while (top > 0) {
-            int insn = queue[--top];
-            Frame f = frames[insn];
-            Subroutine subroutine = subroutines[insn];
-            queued[insn] = false;
-
-            AbstractInsnNode insnNode = null;
-            try {
-                insnNode = m.instructions.get(insn);
-                int insnOpcode = insnNode.getOpcode();
-                int insnType = insnNode.getType();
-
-                if (insnType == AbstractInsnNode.LABEL
-                        || insnType == AbstractInsnNode.LINE
-                        || insnType == AbstractInsnNode.FRAME)
-                {
-                    merge(insn + 1, f, subroutine);
-                    newControlFlowEdge(insn, insn + 1);
-                } else {
-                    current.init(f).execute(insnNode, interpreter);
-                    subroutine = subroutine == null ? null : subroutine.copy();
-
-                    if (insnNode instanceof JumpInsnNode) {
-                        JumpInsnNode j = (JumpInsnNode) insnNode;
-                        if (insnOpcode != GOTO && insnOpcode != JSR) {
-                            merge(insn + 1, current, subroutine);
-                            newControlFlowEdge(insn, insn + 1);
-                        }
-                        int jump = insns.indexOf(j.label);
-                        if (insnOpcode == JSR) {
-                            merge(jump, current, new Subroutine(j.label,
-                                    m.maxLocals,
-                                    j));
-                        } else {
-                            merge(jump, current, subroutine);
-                        }
-                        newControlFlowEdge(insn, jump);
-                    } else if (insnNode instanceof LookupSwitchInsnNode) {
-                        LookupSwitchInsnNode lsi = (LookupSwitchInsnNode) insnNode;
-                        int jump = insns.indexOf(lsi.dflt);
-                        merge(jump, current, subroutine);
-                        newControlFlowEdge(insn, jump);
-                        for (int j = 0; j < lsi.labels.size(); ++j) {
-                            LabelNode label = (LabelNode) lsi.labels.get(j);
-                            jump = insns.indexOf(label);
-                            merge(jump, current, subroutine);
-                            newControlFlowEdge(insn, jump);
-                        }
-                    } else if (insnNode instanceof TableSwitchInsnNode) {
-                        TableSwitchInsnNode tsi = (TableSwitchInsnNode) insnNode;
-                        int jump = insns.indexOf(tsi.dflt);
-                        merge(jump, current, subroutine);
-                        newControlFlowEdge(insn, jump);
-                        for (int j = 0; j < tsi.labels.size(); ++j) {
-                            LabelNode label = (LabelNode) tsi.labels.get(j);
-                            jump = insns.indexOf(label);
-                            merge(jump, current, subroutine);
-                            newControlFlowEdge(insn, jump);
-                        }
-                    } else if (insnOpcode == RET) {
-                        if (subroutine == null) {
-                            throw new AnalyzerException(insnNode, "RET instruction outside of a sub routine");
-                        }
-                        for (int i = 0; i < subroutine.callers.size(); ++i) {
-                            Object caller = subroutine.callers.get(i);
-                            int call = insns.indexOf((AbstractInsnNode) caller);
-                            if (frames[call] != null) {
-                                merge(call + 1,
-                                        frames[call],
-                                        current,
-                                        subroutines[call],
-                                        subroutine.access);
-                                newControlFlowEdge(insn, call + 1);
-                            }
-                        }
-                    } else if (insnOpcode != ATHROW
-                            && (insnOpcode < IRETURN || insnOpcode > RETURN))
-                    {
-                        if (subroutine != null) {
-                            if (insnNode instanceof VarInsnNode) {
-                                int var = ((VarInsnNode) insnNode).var;
-                                subroutine.access[var] = true;
-                                if (insnOpcode == LLOAD || insnOpcode == DLOAD
-                                        || insnOpcode == LSTORE
-                                        || insnOpcode == DSTORE)
-                                {
-                                    subroutine.access[var + 1] = true;
-                                }
-                            } else if (insnNode instanceof IincInsnNode) {
-                                int var = ((IincInsnNode) insnNode).var;
-                                subroutine.access[var] = true;
-                            }
-                        }
-                        merge(insn + 1, current, subroutine);
-                        newControlFlowEdge(insn, insn + 1);
-                    }
-                }
-
-                List insnHandlers = handlers[insn];
-                if (insnHandlers != null) {
-                    for (int i = 0; i < insnHandlers.size(); ++i) {
-                        TryCatchBlockNode tcb = (TryCatchBlockNode) insnHandlers.get(i);
-                        Type type;
-                        if (tcb.type == null) {
-                            type = Type.getObjectType("java/lang/Throwable");
-                        } else {
-                            type = Type.getObjectType(tcb.type);
-                        }
-                        int jump = insns.indexOf(tcb.handler);
-                        if (newControlFlowExceptionEdge(insn, jump)) {
-                            handler.init(f);
-                            handler.clearStack();
-                            handler.push(interpreter.newValue(type));
-                            merge(jump, handler, subroutine);
-                        }
-                    }
-                }
-            } catch (AnalyzerException e) {
-                throw new AnalyzerException(e.node, "Error at instruction " + insn
-                        + ": " + e.getMessage(), e);
-            } catch (Exception e) {
-                throw new AnalyzerException(insnNode, "Error at instruction " + insn
-                        + ": " + e.getMessage(), e);
-            }
-        }
-
-        return frames;
-    }
-
-    private void findSubroutine(int insn, final Subroutine sub, final List calls)
-            throws AnalyzerException
-    {
-        while (true) {
-            if (insn < 0 || insn >= n) {
-                throw new AnalyzerException(null, "Execution can fall off end of the code");
-            }
-            if (subroutines[insn] != null) {
-                return;
-            }
-            subroutines[insn] = sub.copy();
-            AbstractInsnNode node = insns.get(insn);
-
-            // calls findSubroutine recursively on normal successors
-            if (node instanceof JumpInsnNode) {
-                if (node.getOpcode() == JSR) {
-                    // do not follow a JSR, it leads to another subroutine!
-                    calls.add(node);
-                } else {
-                    JumpInsnNode jnode = (JumpInsnNode) node;
-                    findSubroutine(insns.indexOf(jnode.label), sub, calls);
-                }
-            } else if (node instanceof TableSwitchInsnNode) {
-                TableSwitchInsnNode tsnode = (TableSwitchInsnNode) node;
-                findSubroutine(insns.indexOf(tsnode.dflt), sub, calls);
-                for (int i = tsnode.labels.size() - 1; i >= 0; --i) {
-                    LabelNode l = (LabelNode) tsnode.labels.get(i);
-                    findSubroutine(insns.indexOf(l), sub, calls);
-                }
-            } else if (node instanceof LookupSwitchInsnNode) {
-                LookupSwitchInsnNode lsnode = (LookupSwitchInsnNode) node;
-                findSubroutine(insns.indexOf(lsnode.dflt), sub, calls);
-                for (int i = lsnode.labels.size() - 1; i >= 0; --i) {
-                    LabelNode l = (LabelNode) lsnode.labels.get(i);
-                    findSubroutine(insns.indexOf(l), sub, calls);
-                }
-            }
-
-            // calls findSubroutine recursively on exception handler successors
-            List insnHandlers = handlers[insn];
-            if (insnHandlers != null) {
-                for (int i = 0; i < insnHandlers.size(); ++i) {
-                    TryCatchBlockNode tcb = (TryCatchBlockNode) insnHandlers.get(i);
-                    findSubroutine(insns.indexOf(tcb.handler), sub, calls);
-                }
-            }
-
-            // if insn does not falls through to the next instruction, return.
-            switch (node.getOpcode()) {
-                case GOTO:
-                case RET:
-                case TABLESWITCH:
-                case LOOKUPSWITCH:
-                case IRETURN:
-                case LRETURN:
-                case FRETURN:
-                case DRETURN:
-                case ARETURN:
-                case RETURN:
-                case ATHROW:
-                    return;
-            }
-            insn++;
-        }
-    }
-
-    /**
-     * Returns the symbolic stack frame for each instruction of the last
-     * recently analyzed method.
-     * 
-     * @return the symbolic state of the execution stack frame at each bytecode
-     *         instruction of the method. The size of the returned array is
-     *         equal to the number of instructions (and labels) of the method. A
-     *         given frame is <tt>null</tt> if the corresponding instruction
-     *         cannot be reached, or if an error occured during the analysis of
-     *         the method.
-     */
-    public Frame[] getFrames() {
-        return frames;
-    }
-
-    /**
-     * Returns the exception handlers for the given instruction.
-     * 
-     * @param insn the index of an instruction of the last recently analyzed
-     *        method.
-     * @return a list of {@link TryCatchBlockNode} objects.
-     */
-    public List getHandlers(final int insn) {
-        return handlers[insn];
-    }
-
-    /**
-     * Initializes this analyzer. This method is called just before the
-     * execution of control flow analysis loop in #analyze. The default
-     * implementation of this method does nothing.
-     * 
-     * @param owner the internal name of the class to which the method belongs.
-     * @param m the method to be analyzed.
-     * @throws AnalyzerException if a problem occurs.
-     */
-    protected void init(String owner, MethodNode m) throws AnalyzerException {    
-    }
-    
-    /**
-     * Constructs a new frame with the given size.
-     * 
-     * @param nLocals the maximum number of local variables of the frame.
-     * @param nStack the maximum stack size of the frame.
-     * @return the created frame.
-     */
-    protected Frame newFrame(final int nLocals, final int nStack) {
-        return new Frame(nLocals, nStack);
-    }
-
-    /**
-     * Constructs a new frame that is identical to the given frame.
-     * 
-     * @param src a frame.
-     * @return the created frame.
-     */
-    protected Frame newFrame(final Frame src) {
-        return new Frame(src);
-    }
-
-    /**
-     * Creates a control flow graph edge. The default implementation of this
-     * method does nothing. It can be overriden in order to construct the
-     * control flow graph of a method (this method is called by the
-     * {@link #analyze analyze} method during its visit of the method's code).
-     * 
-     * @param insn an instruction index.
-     * @param successor index of a successor instruction.
-     */
-    protected void newControlFlowEdge(final int insn, final int successor) {
-    }
-
-    /**
-     * Creates a control flow graph edge corresponding to an exception handler.
-     * The default implementation of this method does nothing. It can be
-     * overriden in order to construct the control flow graph of a method (this
-     * method is called by the {@link #analyze analyze} method during its visit
-     * of the method's code).
-     * 
-     * @param insn an instruction index.
-     * @param successor index of a successor instruction.
-     * @return true if this edge must be considered in the data flow analysis
-     *         performed by this analyzer, or false otherwise. The default
-     *         implementation of this method always returns true.
-     */
-    protected boolean newControlFlowExceptionEdge(
-        final int insn,
-        final int successor)
-    {
-        return true;
-    }
-
-    // -------------------------------------------------------------------------
-    
-    private void merge(
-        final int insn,
-        final Frame frame,
-        final Subroutine subroutine) throws AnalyzerException
-    {
-        Frame oldFrame = frames[insn];
-        Subroutine oldSubroutine = subroutines[insn];
-        boolean changes;
-
-        if (oldFrame == null) {
-            frames[insn] = newFrame(frame);
-            changes = true;
-        } else {
-            changes = oldFrame.merge(frame, interpreter);
-        }
-
-        if (oldSubroutine == null) {
-            if (subroutine != null) {
-                subroutines[insn] = subroutine.copy();
-                changes = true;
-            }
-        } else {
-            if (subroutine != null) {
-                changes |= oldSubroutine.merge(subroutine);
-            }
-        }
-        if (changes && !queued[insn]) {
-            queued[insn] = true;
-            queue[top++] = insn;
-        }
-    }
-
-    private void merge(
-        final int insn,
-        final Frame beforeJSR,
-        final Frame afterRET,
-        final Subroutine subroutineBeforeJSR,
-        final boolean[] access) throws AnalyzerException
-    {
-        Frame oldFrame = frames[insn];
-        Subroutine oldSubroutine = subroutines[insn];
-        boolean changes;
-
-        afterRET.merge(beforeJSR, access);
-
-        if (oldFrame == null) {
-            frames[insn] = newFrame(afterRET);
-            changes = true;
-        } else {
-            changes = oldFrame.merge(afterRET, access);
-        }
-
-        if (oldSubroutine != null && subroutineBeforeJSR != null) {
-            changes |= oldSubroutine.merge(subroutineBeforeJSR);
-        }
-        if (changes && !queued[insn]) {
-            queued[insn] = true;
-            queue[top++] = insn;
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/BasicInterpreter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/BasicInterpreter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/BasicInterpreter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/BasicInterpreter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,330 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree.analysis;
-
-import java.util.List;
-
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-import org.eclipse.persistence.internal.libraries.asm.tree.AbstractInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.FieldInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.IntInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.LdcInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.MethodInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.MultiANewArrayInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.TypeInsnNode;
-
-/**
- * An {@link Interpreter} for {@link BasicValue} values.
- * 
- * @author Eric Bruneton
- * @author Bing Ran
- */
-public class BasicInterpreter implements Opcodes, Interpreter {
-
-    public Value newValue(final Type type) {
-        if (type == null) {
-            return BasicValue.UNINITIALIZED_VALUE;
-        }
-        switch (type.getSort()) {
-            case Type.VOID:
-                return null;
-            case Type.BOOLEAN:
-            case Type.CHAR:
-            case Type.BYTE:
-            case Type.SHORT:
-            case Type.INT:
-                return BasicValue.INT_VALUE;
-            case Type.FLOAT:
-                return BasicValue.FLOAT_VALUE;
-            case Type.LONG:
-                return BasicValue.LONG_VALUE;
-            case Type.DOUBLE:
-                return BasicValue.DOUBLE_VALUE;
-            case Type.ARRAY:
-            case Type.OBJECT:
-                return BasicValue.REFERENCE_VALUE;
-            default:
-                throw new Error("Internal error");
-        }
-    }
-
-    public Value newOperation(final AbstractInsnNode insn)
-            throws AnalyzerException
-    {
-        switch (insn.getOpcode()) {
-            case ACONST_NULL:
-                return newValue(Type.getObjectType("null"));
-            case ICONST_M1:
-            case ICONST_0:
-            case ICONST_1:
-            case ICONST_2:
-            case ICONST_3:
-            case ICONST_4:
-            case ICONST_5:
-                return BasicValue.INT_VALUE;
-            case LCONST_0:
-            case LCONST_1:
-                return BasicValue.LONG_VALUE;
-            case FCONST_0:
-            case FCONST_1:
-            case FCONST_2:
-                return BasicValue.FLOAT_VALUE;
-            case DCONST_0:
-            case DCONST_1:
-                return BasicValue.DOUBLE_VALUE;
-            case BIPUSH:
-            case SIPUSH:
-                return BasicValue.INT_VALUE;
-            case LDC:
-                Object cst = ((LdcInsnNode) insn).cst;
-                if (cst instanceof Integer) {
-                    return BasicValue.INT_VALUE;
-                } else if (cst instanceof Float) {
-                    return BasicValue.FLOAT_VALUE;
-                } else if (cst instanceof Long) {
-                    return BasicValue.LONG_VALUE;
-                } else if (cst instanceof Double) {
-                    return BasicValue.DOUBLE_VALUE;
-                } else if (cst instanceof Type) {
-                    return newValue(Type.getObjectType("java/lang/Class"));
-                } else {
-                    return newValue(Type.getType(cst.getClass()));
-                }
-            case JSR:
-                return BasicValue.RETURNADDRESS_VALUE;
-            case GETSTATIC:
-                return newValue(Type.getType(((FieldInsnNode) insn).desc));
-            case NEW:
-                return newValue(Type.getObjectType(((TypeInsnNode) insn).desc));
-            default:
-                throw new Error("Internal error.");
-        }
-    }
-
-    public Value copyOperation(final AbstractInsnNode insn, final Value value)
-            throws AnalyzerException
-    {
-        return value;
-    }
-
-    public Value unaryOperation(final AbstractInsnNode insn, final Value value)
-            throws AnalyzerException
-    {
-        switch (insn.getOpcode()) {
-            case INEG:
-            case IINC:
-            case L2I:
-            case F2I:
-            case D2I:
-            case I2B:
-            case I2C:
-            case I2S:
-                return BasicValue.INT_VALUE;
-            case FNEG:
-            case I2F:
-            case L2F:
-            case D2F:
-                return BasicValue.FLOAT_VALUE;
-            case LNEG:
-            case I2L:
-            case F2L:
-            case D2L:
-                return BasicValue.LONG_VALUE;
-            case DNEG:
-            case I2D:
-            case L2D:
-            case F2D:
-                return BasicValue.DOUBLE_VALUE;
-            case IFEQ:
-            case IFNE:
-            case IFLT:
-            case IFGE:
-            case IFGT:
-            case IFLE:
-            case TABLESWITCH:
-            case LOOKUPSWITCH:
-            case IRETURN:
-            case LRETURN:
-            case FRETURN:
-            case DRETURN:
-            case ARETURN:
-            case PUTSTATIC:
-                return null;
-            case GETFIELD:
-                return newValue(Type.getType(((FieldInsnNode) insn).desc));
-            case NEWARRAY:
-                switch (((IntInsnNode) insn).operand) {
-                    case T_BOOLEAN:
-                        return newValue(Type.getType("[Z"));
-                    case T_CHAR:
-                        return newValue(Type.getType("[C"));
-                    case T_BYTE:
-                        return newValue(Type.getType("[B"));
-                    case T_SHORT:
-                        return newValue(Type.getType("[S"));
-                    case T_INT:
-                        return newValue(Type.getType("[I"));
-                    case T_FLOAT:
-                        return newValue(Type.getType("[F"));
-                    case T_DOUBLE:
-                        return newValue(Type.getType("[D"));
-                    case T_LONG:
-                        return newValue(Type.getType("[J"));
-                    default:
-                        throw new AnalyzerException(insn, "Invalid array type");
-                }
-            case ANEWARRAY:
-                String desc = ((TypeInsnNode) insn).desc;
-                return newValue(Type.getType("[" + Type.getObjectType(desc)));
-            case ARRAYLENGTH:
-                return BasicValue.INT_VALUE;
-            case ATHROW:
-                return null;
-            case CHECKCAST:
-                desc = ((TypeInsnNode) insn).desc;
-                return newValue(Type.getObjectType(desc));
-            case INSTANCEOF:
-                return BasicValue.INT_VALUE;
-            case MONITORENTER:
-            case MONITOREXIT:
-            case IFNULL:
-            case IFNONNULL:
-                return null;
-            default:
-                throw new Error("Internal error.");
-        }
-    }
-
-    public Value binaryOperation(
-        final AbstractInsnNode insn,
-        final Value value1,
-        final Value value2) throws AnalyzerException
-    {
-        switch (insn.getOpcode()) {
-            case IALOAD:
-            case BALOAD:
-            case CALOAD:
-            case SALOAD:
-            case IADD:
-            case ISUB:
-            case IMUL:
-            case IDIV:
-            case IREM:
-            case ISHL:
-            case ISHR:
-            case IUSHR:
-            case IAND:
-            case IOR:
-            case IXOR:
-                return BasicValue.INT_VALUE;
-            case FALOAD:
-            case FADD:
-            case FSUB:
-            case FMUL:
-            case FDIV:
-            case FREM:
-                return BasicValue.FLOAT_VALUE;
-            case LALOAD:
-            case LADD:
-            case LSUB:
-            case LMUL:
-            case LDIV:
-            case LREM:
-            case LSHL:
-            case LSHR:
-            case LUSHR:
-            case LAND:
-            case LOR:
-            case LXOR:
-                return BasicValue.LONG_VALUE;
-            case DALOAD:
-            case DADD:
-            case DSUB:
-            case DMUL:
-            case DDIV:
-            case DREM:
-                return BasicValue.DOUBLE_VALUE;
-            case AALOAD:
-                return BasicValue.REFERENCE_VALUE;
-            case LCMP:
-            case FCMPL:
-            case FCMPG:
-            case DCMPL:
-            case DCMPG:
-                return BasicValue.INT_VALUE;
-            case IF_ICMPEQ:
-            case IF_ICMPNE:
-            case IF_ICMPLT:
-            case IF_ICMPGE:
-            case IF_ICMPGT:
-            case IF_ICMPLE:
-            case IF_ACMPEQ:
-            case IF_ACMPNE:
-            case PUTFIELD:
-                return null;
-            default:
-                throw new Error("Internal error.");
-        }
-    }
-
-    public Value ternaryOperation(
-        final AbstractInsnNode insn,
-        final Value value1,
-        final Value value2,
-        final Value value3) throws AnalyzerException
-    {
-        return null;
-    }
-
-    public Value naryOperation(final AbstractInsnNode insn, final List values)
-            throws AnalyzerException
-    {
-        if (insn.getOpcode() == MULTIANEWARRAY) {
-            return newValue(Type.getType(((MultiANewArrayInsnNode) insn).desc));
-        } else {
-            return newValue(Type.getReturnType(((MethodInsnNode) insn).desc));
-        }
-    }
-
-    public void returnOperation(
-        final AbstractInsnNode insn,
-        final Value value,
-        final Value expected) throws AnalyzerException
-    {
-    }
-    
-    public Value merge(final Value v, final Value w) {
-        if (!v.equals(w)) {
-            return BasicValue.UNINITIALIZED_VALUE;
-        }
-        return v;
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/BasicValue.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/BasicValue.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/BasicValue.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/BasicValue.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,105 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree.analysis;
-
-import org.eclipse.persistence.internal.libraries.asm.Type;
-
-/**
- * A {@link Value} that is represented by its type in a seven types type system.
- * This type system distinguishes the UNINITIALZED, INT, FLOAT, LONG, DOUBLE,
- * REFERENCE and RETURNADDRESS types.
- * 
- * @author Eric Bruneton
- */
-public class BasicValue implements Value {
-
-    public static final Value UNINITIALIZED_VALUE = new BasicValue(null);
-
-    public static final Value INT_VALUE = new BasicValue(Type.INT_TYPE);
-
-    public static final Value FLOAT_VALUE = new BasicValue(Type.FLOAT_TYPE);
-
-    public static final Value LONG_VALUE = new BasicValue(Type.LONG_TYPE);
-
-    public static final Value DOUBLE_VALUE = new BasicValue(Type.DOUBLE_TYPE);
-
-    public static final Value REFERENCE_VALUE = new BasicValue(Type.getObjectType("java/lang/Object"));
-
-    public static final Value RETURNADDRESS_VALUE = new BasicValue(Type.VOID_TYPE);
-
-    private final Type type;
-
-    public BasicValue(final Type type) {
-        this.type = type;
-    }
-
-    public Type getType() {
-        return type;
-    }
-
-    public int getSize() {
-        return type == Type.LONG_TYPE || type == Type.DOUBLE_TYPE ? 2 : 1;
-    }
-
-    public boolean isReference() {
-        return type != null
-                && (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY);
-    }
-
-    public boolean equals(final Object value) {
-        if (value == this) {
-            return true;
-        } else if (value instanceof BasicValue) {
-            if (type == null) {
-                return ((BasicValue) value).type == null;
-            } else {
-                return type.equals(((BasicValue) value).type);
-            }
-        } else {
-            return false;
-        }
-    }
-
-    public int hashCode() {
-        return type == null ? 0 : type.hashCode();
-    }
-
-    public String toString() {
-        if (this == UNINITIALIZED_VALUE) {
-            return ".";
-        } else if (this == RETURNADDRESS_VALUE) {
-            return "A";
-        } else if (this == REFERENCE_VALUE) {
-            return "R";
-        } else {
-            return type.getDescriptor();
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/BasicVerifier.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/BasicVerifier.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/BasicVerifier.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/BasicVerifier.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,441 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree.analysis;
-
-import java.util.List;
-
-import org.eclipse.persistence.internal.libraries.asm.Type;
-import org.eclipse.persistence.internal.libraries.asm.tree.AbstractInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.FieldInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.MethodInsnNode;
-
-/**
- * An extended {@link BasicInterpreter} that checks that bytecode instructions
- * are correctly used.
- * 
- * @author Eric Bruneton
- * @author Bing Ran
- */
-public class BasicVerifier extends BasicInterpreter {
-
-    public Value copyOperation(final AbstractInsnNode insn, final Value value)
-            throws AnalyzerException
-    {
-        Value expected;
-        switch (insn.getOpcode()) {
-            case ILOAD:
-            case ISTORE:
-                expected = BasicValue.INT_VALUE;
-                break;
-            case FLOAD:
-            case FSTORE:
-                expected = BasicValue.FLOAT_VALUE;
-                break;
-            case LLOAD:
-            case LSTORE:
-                expected = BasicValue.LONG_VALUE;
-                break;
-            case DLOAD:
-            case DSTORE:
-                expected = BasicValue.DOUBLE_VALUE;
-                break;
-            case ALOAD:
-                if (!((BasicValue) value).isReference()) {
-                    throw new AnalyzerException(insn,
-                            null,
-                            "an object reference",
-                            value);
-                }
-                return value;
-            case ASTORE:
-                if (!((BasicValue) value).isReference()
-                        && !BasicValue.RETURNADDRESS_VALUE.equals(value))
-                {
-                    throw new AnalyzerException(insn,
-                            null,
-                            "an object reference or a return address",
-                            value);
-                }
-                return value;
-            default:
-                return value;
-        }
-        if (!expected.equals(value)) {
-            throw new AnalyzerException(insn, null, expected, value);
-        }
-        return value;
-    }
-
-    public Value unaryOperation(final AbstractInsnNode insn, final Value value)
-            throws AnalyzerException
-    {
-        Value expected;
-        switch (insn.getOpcode()) {
-            case INEG:
-            case IINC:
-            case I2F:
-            case I2L:
-            case I2D:
-            case I2B:
-            case I2C:
-            case I2S:
-            case IFEQ:
-            case IFNE:
-            case IFLT:
-            case IFGE:
-            case IFGT:
-            case IFLE:
-            case TABLESWITCH:
-            case LOOKUPSWITCH:
-            case IRETURN:
-            case NEWARRAY:
-            case ANEWARRAY:
-                expected = BasicValue.INT_VALUE;
-                break;
-            case FNEG:
-            case F2I:
-            case F2L:
-            case F2D:
-            case FRETURN:
-                expected = BasicValue.FLOAT_VALUE;
-                break;
-            case LNEG:
-            case L2I:
-            case L2F:
-            case L2D:
-            case LRETURN:
-                expected = BasicValue.LONG_VALUE;
-                break;
-            case DNEG:
-            case D2I:
-            case D2F:
-            case D2L:
-            case DRETURN:
-                expected = BasicValue.DOUBLE_VALUE;
-                break;
-            case GETFIELD:
-                expected = newValue(Type.getObjectType(((FieldInsnNode) insn).owner));
-                break;
-            case CHECKCAST:
-                if (!((BasicValue) value).isReference()) {
-                    throw new AnalyzerException(insn,
-                            null,
-                            "an object reference",
-                            value);
-                }
-                return super.unaryOperation(insn, value);
-            case ARRAYLENGTH:
-                if (!isArrayValue(value)) {
-                    throw new AnalyzerException(insn,
-                            null,
-                            "an array reference",
-                            value);
-                }
-                return super.unaryOperation(insn, value);
-            case ARETURN:
-            case ATHROW:
-            case INSTANCEOF:
-            case MONITORENTER:
-            case MONITOREXIT:
-            case IFNULL:
-            case IFNONNULL:
-                if (!((BasicValue) value).isReference()) {
-                    throw new AnalyzerException(insn,
-                            null,
-                            "an object reference",
-                            value);
-                }
-                return super.unaryOperation(insn, value);
-            case PUTSTATIC:
-                expected = newValue(Type.getType(((FieldInsnNode) insn).desc));
-                break;
-            default:
-                throw new Error("Internal error.");
-        }
-        if (!isSubTypeOf(value, expected)) {
-            throw new AnalyzerException(insn, null, expected, value);
-        }
-        return super.unaryOperation(insn, value);
-    }
-
-    public Value binaryOperation(
-        final AbstractInsnNode insn,
-        final Value value1,
-        final Value value2) throws AnalyzerException
-    {
-        Value expected1;
-        Value expected2;
-        switch (insn.getOpcode()) {
-            case IALOAD:
-                expected1 = newValue(Type.getType("[I"));
-                expected2 = BasicValue.INT_VALUE;
-                break;
-            case BALOAD:
-                if (isSubTypeOf(value1, newValue(Type.getType("[Z")))) {
-                    expected1 = newValue(Type.getType("[Z"));
-                } else {
-                    expected1 = newValue(Type.getType("[B"));
-                }
-                expected2 = BasicValue.INT_VALUE;
-                break;
-            case CALOAD:
-                expected1 = newValue(Type.getType("[C"));
-                expected2 = BasicValue.INT_VALUE;
-                break;
-            case SALOAD:
-                expected1 = newValue(Type.getType("[S"));
-                expected2 = BasicValue.INT_VALUE;
-                break;
-            case LALOAD:
-                expected1 = newValue(Type.getType("[J"));
-                expected2 = BasicValue.INT_VALUE;
-                break;
-            case FALOAD:
-                expected1 = newValue(Type.getType("[F"));
-                expected2 = BasicValue.INT_VALUE;
-                break;
-            case DALOAD:
-                expected1 = newValue(Type.getType("[D"));
-                expected2 = BasicValue.INT_VALUE;
-                break;
-            case AALOAD:
-                expected1 = newValue(Type.getType("[Ljava/lang/Object;"));
-                expected2 = BasicValue.INT_VALUE;
-                break;
-            case IADD:
-            case ISUB:
-            case IMUL:
-            case IDIV:
-            case IREM:
-            case ISHL:
-            case ISHR:
-            case IUSHR:
-            case IAND:
-            case IOR:
-            case IXOR:
-            case IF_ICMPEQ:
-            case IF_ICMPNE:
-            case IF_ICMPLT:
-            case IF_ICMPGE:
-            case IF_ICMPGT:
-            case IF_ICMPLE:
-                expected1 = BasicValue.INT_VALUE;
-                expected2 = BasicValue.INT_VALUE;
-                break;
-            case FADD:
-            case FSUB:
-            case FMUL:
-            case FDIV:
-            case FREM:
-            case FCMPL:
-            case FCMPG:
-                expected1 = BasicValue.FLOAT_VALUE;
-                expected2 = BasicValue.FLOAT_VALUE;
-                break;
-            case LADD:
-            case LSUB:
-            case LMUL:
-            case LDIV:
-            case LREM:
-            case LAND:
-            case LOR:
-            case LXOR:
-            case LCMP:
-                expected1 = BasicValue.LONG_VALUE;
-                expected2 = BasicValue.LONG_VALUE;
-                break;
-            case LSHL:
-            case LSHR:
-            case LUSHR:
-                expected1 = BasicValue.LONG_VALUE;
-                expected2 = BasicValue.INT_VALUE;
-                break;
-            case DADD:
-            case DSUB:
-            case DMUL:
-            case DDIV:
-            case DREM:
-            case DCMPL:
-            case DCMPG:
-                expected1 = BasicValue.DOUBLE_VALUE;
-                expected2 = BasicValue.DOUBLE_VALUE;
-                break;
-            case IF_ACMPEQ:
-            case IF_ACMPNE:
-                expected1 = BasicValue.REFERENCE_VALUE;
-                expected2 = BasicValue.REFERENCE_VALUE;
-                break;
-            case PUTFIELD:
-                FieldInsnNode fin = (FieldInsnNode) insn;
-                expected1 = newValue(Type.getObjectType(fin.owner));
-                expected2 = newValue(Type.getType(fin.desc));
-                break;
-            default:
-                throw new Error("Internal error.");
-        }
-        if (!isSubTypeOf(value1, expected1)) {
-            throw new AnalyzerException(insn, "First argument", expected1, value1);
-        } else if (!isSubTypeOf(value2, expected2)) {
-            throw new AnalyzerException(insn, "Second argument", expected2, value2);
-        }
-        if (insn.getOpcode() == AALOAD) {
-            return getElementValue(value1);
-        } else {
-            return super.binaryOperation(insn, value1, value2);
-        }
-    }
-
-    public Value ternaryOperation(
-        final AbstractInsnNode insn,
-        final Value value1,
-        final Value value2,
-        final Value value3) throws AnalyzerException
-    {
-        Value expected1;
-        Value expected3;
-        switch (insn.getOpcode()) {
-            case IASTORE:
-                expected1 = newValue(Type.getType("[I"));
-                expected3 = BasicValue.INT_VALUE;
-                break;
-            case BASTORE:
-                if (isSubTypeOf(value1, newValue(Type.getType("[Z")))) {
-                    expected1 = newValue(Type.getType("[Z"));
-                } else {
-                    expected1 = newValue(Type.getType("[B"));
-                }
-                expected3 = BasicValue.INT_VALUE;
-                break;
-            case CASTORE:
-                expected1 = newValue(Type.getType("[C"));
-                expected3 = BasicValue.INT_VALUE;
-                break;
-            case SASTORE:
-                expected1 = newValue(Type.getType("[S"));
-                expected3 = BasicValue.INT_VALUE;
-                break;
-            case LASTORE:
-                expected1 = newValue(Type.getType("[J"));
-                expected3 = BasicValue.LONG_VALUE;
-                break;
-            case FASTORE:
-                expected1 = newValue(Type.getType("[F"));
-                expected3 = BasicValue.FLOAT_VALUE;
-                break;
-            case DASTORE:
-                expected1 = newValue(Type.getType("[D"));
-                expected3 = BasicValue.DOUBLE_VALUE;
-                break;
-            case AASTORE:
-                expected1 = value1;
-                expected3 = BasicValue.REFERENCE_VALUE;
-                break;
-            default:
-                throw new Error("Internal error.");
-        }
-        if (!isSubTypeOf(value1, expected1)) {
-            throw new AnalyzerException(insn, "First argument", "a " + expected1
-                    + " array reference", value1);
-        } else if (!BasicValue.INT_VALUE.equals(value2)) {
-            throw new AnalyzerException(insn, "Second argument",
-                    BasicValue.INT_VALUE,
-                    value2);
-        } else if (!isSubTypeOf(value3, expected3)) {
-            throw new AnalyzerException(insn, "Third argument", expected3, value3);
-        }
-        return null;
-    }
-
-    public Value naryOperation(final AbstractInsnNode insn, final List values)
-            throws AnalyzerException
-    {
-        int opcode = insn.getOpcode();
-        if (opcode == MULTIANEWARRAY) {
-            for (int i = 0; i < values.size(); ++i) {
-                if (!BasicValue.INT_VALUE.equals(values.get(i))) {
-                    throw new AnalyzerException(insn,
-                            null,
-                            BasicValue.INT_VALUE,
-                            (Value) values.get(i));
-                }
-            }
-        } else {
-            int i = 0;
-            int j = 0;
-            if (opcode != INVOKESTATIC && opcode != INVOKEDYNAMIC) {
-                Type owner = Type.getObjectType(((MethodInsnNode) insn).owner);
-                if (!isSubTypeOf((Value) values.get(i++), newValue(owner))) {
-                    throw new AnalyzerException(insn, "Method owner",
-                            newValue(owner),
-                            (Value) values.get(0));
-                }
-            }
-            Type[] args = Type.getArgumentTypes(((MethodInsnNode) insn).desc);
-            while (i < values.size()) {
-                Value expected = newValue(args[j++]);
-                Value encountered = (Value) values.get(i++);
-                if (!isSubTypeOf(encountered, expected)) {
-                    throw new AnalyzerException(insn,
-                            "Argument " + j,
-                            expected,
-                            encountered);
-                }
-            }
-        }
-        return super.naryOperation(insn, values);
-    }
-
-    public void returnOperation(
-        final AbstractInsnNode insn,
-        final Value value,
-        final Value expected) throws AnalyzerException
-    {
-        if (!isSubTypeOf(value, expected)) {
-            throw new AnalyzerException(insn,
-                    "Incompatible return type",
-                    expected,
-                    value);
-        }
-    }
-
-    protected boolean isArrayValue(final Value value) {
-        return ((BasicValue) value).isReference();
-    }
-
-    protected Value getElementValue(final Value objectArrayValue)
-            throws AnalyzerException
-    {
-        return BasicValue.REFERENCE_VALUE;
-    }
-
-    protected boolean isSubTypeOf(final Value value, final Value expected) {
-        return value.equals(expected);
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Frame.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Frame.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Frame.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Frame.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,693 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree.analysis;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-import org.eclipse.persistence.internal.libraries.asm.tree.AbstractInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.IincInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.MethodInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.MultiANewArrayInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.VarInsnNode;
-
-/**
- * A symbolic execution stack frame. A stack frame contains a set of local
- * variable slots, and an operand stack. Warning: long and double values are
- * represented by <i>two</i> slots in local variables, and by <i>one</i> slot
- * in the operand stack.
- * 
- * @author Eric Bruneton
- */
-public class Frame {
-
-    /**
-     * The expected return type of the analyzed method, or <tt>null</tt> if the
-     * method returns void.
-     */
-    private Value returnValue;
-
-    /**
-     * The local variables and operand stack of this frame.
-     */
-    private Value[] values;
-
-    /**
-     * The number of local variables of this frame.
-     */
-    private int locals;
-
-    /**
-     * The number of elements in the operand stack.
-     */
-    private int top;
-
-    /**
-     * Constructs a new frame with the given size.
-     * 
-     * @param nLocals the maximum number of local variables of the frame.
-     * @param nStack the maximum stack size of the frame.
-     */
-    public Frame(final int nLocals, final int nStack) {
-        this.values = new Value[nLocals + nStack];
-        this.locals = nLocals;
-    }
-
-    /**
-     * Constructs a new frame that is identical to the given frame.
-     * 
-     * @param src a frame.
-     */
-    public Frame(final Frame src) {
-        this(src.locals, src.values.length - src.locals);
-        init(src);
-    }
-
-    /**
-     * Copies the state of the given frame into this frame.
-     * 
-     * @param src a frame.
-     * @return this frame.
-     */
-    public Frame init(final Frame src) {
-        returnValue = src.returnValue;
-        System.arraycopy(src.values, 0, values, 0, values.length);
-        top = src.top;
-        return this;
-    }
-
-    /**
-     * Sets the expected return type of the analyzed method.
-     * 
-     * @param v the expected return type of the analyzed method, or
-     *        <tt>null</tt> if the method returns void.
-     */
-    public void setReturn(final Value v) {
-        returnValue = v;
-    }
-    
-    /**
-     * Returns the maximum number of local variables of this frame.
-     * 
-     * @return the maximum number of local variables of this frame.
-     */
-    public int getLocals() {
-        return locals;
-    }
-
-    /**
-     * Returns the value of the given local variable.
-     * 
-     * @param i a local variable index.
-     * @return the value of the given local variable.
-     * @throws IndexOutOfBoundsException if the variable does not exist.
-     */
-    public Value getLocal(final int i) throws IndexOutOfBoundsException {
-        if (i >= locals) {
-            throw new IndexOutOfBoundsException("Trying to access an inexistant local variable");
-        }
-        return values[i];
-    }
-
-    /**
-     * Sets the value of the given local variable.
-     * 
-     * @param i a local variable index.
-     * @param value the new value of this local variable.
-     * @throws IndexOutOfBoundsException if the variable does not exist.
-     */
-    public void setLocal(final int i, final Value value)
-            throws IndexOutOfBoundsException
-    {
-        if (i >= locals) {
-            throw new IndexOutOfBoundsException("Trying to access an inexistant local variable "+i);
-        }
-        values[i] = value;
-    }
-
-    /**
-     * Returns the number of values in the operand stack of this frame. Long and
-     * double values are treated as single values.
-     * 
-     * @return the number of values in the operand stack of this frame.
-     */
-    public int getStackSize() {
-        return top;
-    }
-
-    /**
-     * Returns the value of the given operand stack slot.
-     * 
-     * @param i the index of an operand stack slot.
-     * @return the value of the given operand stack slot.
-     * @throws IndexOutOfBoundsException if the operand stack slot does not
-     *         exist.
-     */
-    public Value getStack(final int i) throws IndexOutOfBoundsException {
-        return values[i + locals];
-    }
-
-    /**
-     * Clears the operand stack of this frame.
-     */
-    public void clearStack() {
-        top = 0;
-    }
-
-    /**
-     * Pops a value from the operand stack of this frame.
-     * 
-     * @return the value that has been popped from the stack.
-     * @throws IndexOutOfBoundsException if the operand stack is empty.
-     */
-    public Value pop() throws IndexOutOfBoundsException {
-        if (top == 0) {
-            throw new IndexOutOfBoundsException("Cannot pop operand off an empty stack.");
-        }
-        return values[--top + locals];
-    }
-
-    /**
-     * Pushes a value into the operand stack of this frame.
-     * 
-     * @param value the value that must be pushed into the stack.
-     * @throws IndexOutOfBoundsException if the operand stack is full.
-     */
-    public void push(final Value value) throws IndexOutOfBoundsException {
-        if (top + locals >= values.length) {
-            throw new IndexOutOfBoundsException("Insufficient maximum stack size.");
-        }
-        values[top++ + locals] = value;
-    }
-
-    public void execute(
-        final AbstractInsnNode insn,
-        final Interpreter interpreter) throws AnalyzerException
-    {
-        Value value1, value2, value3, value4;
-        List values;
-        int var;
-
-        switch (insn.getOpcode()) {
-            case Opcodes.NOP:
-                break;
-            case Opcodes.ACONST_NULL:
-            case Opcodes.ICONST_M1:
-            case Opcodes.ICONST_0:
-            case Opcodes.ICONST_1:
-            case Opcodes.ICONST_2:
-            case Opcodes.ICONST_3:
-            case Opcodes.ICONST_4:
-            case Opcodes.ICONST_5:
-            case Opcodes.LCONST_0:
-            case Opcodes.LCONST_1:
-            case Opcodes.FCONST_0:
-            case Opcodes.FCONST_1:
-            case Opcodes.FCONST_2:
-            case Opcodes.DCONST_0:
-            case Opcodes.DCONST_1:
-            case Opcodes.BIPUSH:
-            case Opcodes.SIPUSH:
-            case Opcodes.LDC:
-                push(interpreter.newOperation(insn));
-                break;
-            case Opcodes.ILOAD:
-            case Opcodes.LLOAD:
-            case Opcodes.FLOAD:
-            case Opcodes.DLOAD:
-            case Opcodes.ALOAD:
-                push(interpreter.copyOperation(insn,
-                        getLocal(((VarInsnNode) insn).var)));
-                break;
-            case Opcodes.IALOAD:
-            case Opcodes.LALOAD:
-            case Opcodes.FALOAD:
-            case Opcodes.DALOAD:
-            case Opcodes.AALOAD:
-            case Opcodes.BALOAD:
-            case Opcodes.CALOAD:
-            case Opcodes.SALOAD:
-                value2 = pop();
-                value1 = pop();
-                push(interpreter.binaryOperation(insn, value1, value2));
-                break;
-            case Opcodes.ISTORE:
-            case Opcodes.LSTORE:
-            case Opcodes.FSTORE:
-            case Opcodes.DSTORE:
-            case Opcodes.ASTORE:
-                value1 = interpreter.copyOperation(insn, pop());
-                var = ((VarInsnNode) insn).var;
-                setLocal(var, value1);
-                if (value1.getSize() == 2) {
-                    setLocal(var + 1, interpreter.newValue(null));
-                }
-                if (var > 0) {
-                    Value local = getLocal(var - 1);
-                    if (local != null && local.getSize() == 2) {
-                        setLocal(var - 1, interpreter.newValue(null));
-                    }
-                }
-                break;
-            case Opcodes.IASTORE:
-            case Opcodes.LASTORE:
-            case Opcodes.FASTORE:
-            case Opcodes.DASTORE:
-            case Opcodes.AASTORE:
-            case Opcodes.BASTORE:
-            case Opcodes.CASTORE:
-            case Opcodes.SASTORE:
-                value3 = pop();
-                value2 = pop();
-                value1 = pop();
-                interpreter.ternaryOperation(insn, value1, value2, value3);
-                break;
-            case Opcodes.POP:
-                if (pop().getSize() == 2) {
-                    throw new AnalyzerException(insn, "Illegal use of POP");
-                }
-                break;
-            case Opcodes.POP2:
-                if (pop().getSize() == 1) {
-                    if (pop().getSize() != 1) {
-                        throw new AnalyzerException(insn, "Illegal use of POP2");
-                    }
-                }
-                break;
-            case Opcodes.DUP:
-                value1 = pop();
-                if (value1.getSize() != 1) {
-                    throw new AnalyzerException(insn, "Illegal use of DUP");
-                }
-                push(value1);
-                push(interpreter.copyOperation(insn, value1));
-                break;
-            case Opcodes.DUP_X1:
-                value1 = pop();
-                value2 = pop();
-                if (value1.getSize() != 1 || value2.getSize() != 1) {
-                    throw new AnalyzerException(insn, "Illegal use of DUP_X1");
-                }
-                push(interpreter.copyOperation(insn, value1));
-                push(value2);
-                push(value1);
-                break;
-            case Opcodes.DUP_X2:
-                value1 = pop();
-                if (value1.getSize() == 1) {
-                    value2 = pop();
-                    if (value2.getSize() == 1) {
-                        value3 = pop();
-                        if (value3.getSize() == 1) {
-                            push(interpreter.copyOperation(insn, value1));
-                            push(value3);
-                            push(value2);
-                            push(value1);
-                            break;
-                        }
-                    } else {
-                        push(interpreter.copyOperation(insn, value1));
-                        push(value2);
-                        push(value1);
-                        break;
-                    }
-                }
-                throw new AnalyzerException(insn, "Illegal use of DUP_X2");
-            case Opcodes.DUP2:
-                value1 = pop();
-                if (value1.getSize() == 1) {
-                    value2 = pop();
-                    if (value2.getSize() == 1) {
-                        push(value2);
-                        push(value1);
-                        push(interpreter.copyOperation(insn, value2));
-                        push(interpreter.copyOperation(insn, value1));
-                        break;
-                    }
-                } else {
-                    push(value1);
-                    push(interpreter.copyOperation(insn, value1));
-                    break;
-                }
-                throw new AnalyzerException(insn, "Illegal use of DUP2");
-            case Opcodes.DUP2_X1:
-                value1 = pop();
-                if (value1.getSize() == 1) {
-                    value2 = pop();
-                    if (value2.getSize() == 1) {
-                        value3 = pop();
-                        if (value3.getSize() == 1) {
-                            push(interpreter.copyOperation(insn, value2));
-                            push(interpreter.copyOperation(insn, value1));
-                            push(value3);
-                            push(value2);
-                            push(value1);
-                            break;
-                        }
-                    }
-                } else {
-                    value2 = pop();
-                    if (value2.getSize() == 1) {
-                        push(interpreter.copyOperation(insn, value1));
-                        push(value2);
-                        push(value1);
-                        break;
-                    }
-                }
-                throw new AnalyzerException(insn, "Illegal use of DUP2_X1");
-            case Opcodes.DUP2_X2:
-                value1 = pop();
-                if (value1.getSize() == 1) {
-                    value2 = pop();
-                    if (value2.getSize() == 1) {
-                        value3 = pop();
-                        if (value3.getSize() == 1) {
-                            value4 = pop();
-                            if (value4.getSize() == 1) {
-                                push(interpreter.copyOperation(insn, value2));
-                                push(interpreter.copyOperation(insn, value1));
-                                push(value4);
-                                push(value3);
-                                push(value2);
-                                push(value1);
-                                break;
-                            }
-                        } else {
-                            push(interpreter.copyOperation(insn, value2));
-                            push(interpreter.copyOperation(insn, value1));
-                            push(value3);
-                            push(value2);
-                            push(value1);
-                            break;
-                        }
-                    }
-                } else {
-                    value2 = pop();
-                    if (value2.getSize() == 1) {
-                        value3 = pop();
-                        if (value3.getSize() == 1) {
-                            push(interpreter.copyOperation(insn, value1));
-                            push(value3);
-                            push(value2);
-                            push(value1);
-                            break;
-                        }
-                    } else {
-                        push(interpreter.copyOperation(insn, value1));
-                        push(value2);
-                        push(value1);
-                        break;
-                    }
-                }
-                throw new AnalyzerException(insn, "Illegal use of DUP2_X2");
-            case Opcodes.SWAP:
-                value2 = pop();
-                value1 = pop();
-                if (value1.getSize() != 1 || value2.getSize() != 1) {
-                    throw new AnalyzerException(insn, "Illegal use of SWAP");
-                }
-                push(interpreter.copyOperation(insn, value2));
-                push(interpreter.copyOperation(insn, value1));
-                break;
-            case Opcodes.IADD:
-            case Opcodes.LADD:
-            case Opcodes.FADD:
-            case Opcodes.DADD:
-            case Opcodes.ISUB:
-            case Opcodes.LSUB:
-            case Opcodes.FSUB:
-            case Opcodes.DSUB:
-            case Opcodes.IMUL:
-            case Opcodes.LMUL:
-            case Opcodes.FMUL:
-            case Opcodes.DMUL:
-            case Opcodes.IDIV:
-            case Opcodes.LDIV:
-            case Opcodes.FDIV:
-            case Opcodes.DDIV:
-            case Opcodes.IREM:
-            case Opcodes.LREM:
-            case Opcodes.FREM:
-            case Opcodes.DREM:
-                value2 = pop();
-                value1 = pop();
-                push(interpreter.binaryOperation(insn, value1, value2));
-                break;
-            case Opcodes.INEG:
-            case Opcodes.LNEG:
-            case Opcodes.FNEG:
-            case Opcodes.DNEG:
-                push(interpreter.unaryOperation(insn, pop()));
-                break;
-            case Opcodes.ISHL:
-            case Opcodes.LSHL:
-            case Opcodes.ISHR:
-            case Opcodes.LSHR:
-            case Opcodes.IUSHR:
-            case Opcodes.LUSHR:
-            case Opcodes.IAND:
-            case Opcodes.LAND:
-            case Opcodes.IOR:
-            case Opcodes.LOR:
-            case Opcodes.IXOR:
-            case Opcodes.LXOR:
-                value2 = pop();
-                value1 = pop();
-                push(interpreter.binaryOperation(insn, value1, value2));
-                break;
-            case Opcodes.IINC:
-                var = ((IincInsnNode) insn).var;
-                setLocal(var, interpreter.unaryOperation(insn, getLocal(var)));
-                break;
-            case Opcodes.I2L:
-            case Opcodes.I2F:
-            case Opcodes.I2D:
-            case Opcodes.L2I:
-            case Opcodes.L2F:
-            case Opcodes.L2D:
-            case Opcodes.F2I:
-            case Opcodes.F2L:
-            case Opcodes.F2D:
-            case Opcodes.D2I:
-            case Opcodes.D2L:
-            case Opcodes.D2F:
-            case Opcodes.I2B:
-            case Opcodes.I2C:
-            case Opcodes.I2S:
-                push(interpreter.unaryOperation(insn, pop()));
-                break;
-            case Opcodes.LCMP:
-            case Opcodes.FCMPL:
-            case Opcodes.FCMPG:
-            case Opcodes.DCMPL:
-            case Opcodes.DCMPG:
-                value2 = pop();
-                value1 = pop();
-                push(interpreter.binaryOperation(insn, value1, value2));
-                break;
-            case Opcodes.IFEQ:
-            case Opcodes.IFNE:
-            case Opcodes.IFLT:
-            case Opcodes.IFGE:
-            case Opcodes.IFGT:
-            case Opcodes.IFLE:
-                interpreter.unaryOperation(insn, pop());
-                break;
-            case Opcodes.IF_ICMPEQ:
-            case Opcodes.IF_ICMPNE:
-            case Opcodes.IF_ICMPLT:
-            case Opcodes.IF_ICMPGE:
-            case Opcodes.IF_ICMPGT:
-            case Opcodes.IF_ICMPLE:
-            case Opcodes.IF_ACMPEQ:
-            case Opcodes.IF_ACMPNE:
-                value2 = pop();
-                value1 = pop();
-                interpreter.binaryOperation(insn, value1, value2);
-                break;
-            case Opcodes.GOTO:
-                break;
-            case Opcodes.JSR:
-                push(interpreter.newOperation(insn));
-                break;
-            case Opcodes.RET:
-                break;
-            case Opcodes.TABLESWITCH:
-            case Opcodes.LOOKUPSWITCH:
-                interpreter.unaryOperation(insn, pop());
-                break;
-            case Opcodes.IRETURN:
-            case Opcodes.LRETURN:
-            case Opcodes.FRETURN:
-            case Opcodes.DRETURN:
-            case Opcodes.ARETURN:
-                value1 = pop();
-                interpreter.unaryOperation(insn, value1);
-                interpreter.returnOperation(insn, value1, returnValue);
-                break;
-            case Opcodes.RETURN:
-                if (returnValue != null) {
-                    throw new AnalyzerException(insn, "Incompatible return type");
-                }
-                break;
-            case Opcodes.GETSTATIC:
-                push(interpreter.newOperation(insn));
-                break;
-            case Opcodes.PUTSTATIC:
-                interpreter.unaryOperation(insn, pop());
-                break;
-            case Opcodes.GETFIELD:
-                push(interpreter.unaryOperation(insn, pop()));
-                break;
-            case Opcodes.PUTFIELD:
-                value2 = pop();
-                value1 = pop();
-                interpreter.binaryOperation(insn, value1, value2);
-                break;
-            case Opcodes.INVOKEVIRTUAL:
-            case Opcodes.INVOKESPECIAL:
-            case Opcodes.INVOKESTATIC:
-            case Opcodes.INVOKEINTERFACE:
-            case Opcodes.INVOKEDYNAMIC:
-                values = new ArrayList();
-                String desc = ((MethodInsnNode) insn).desc;
-                for (int i = Type.getArgumentTypes(desc).length; i > 0; --i) {
-                    values.add(0, pop());
-                }
-                if (insn.getOpcode() != Opcodes.INVOKESTATIC &&
-                    insn.getOpcode() != Opcodes.INVOKEDYNAMIC) {
-                    values.add(0, pop());
-                }
-                if (Type.getReturnType(desc) == Type.VOID_TYPE) {
-                    interpreter.naryOperation(insn, values);
-                } else {
-                    push(interpreter.naryOperation(insn, values));
-                }
-                break;
-            case Opcodes.NEW:
-                push(interpreter.newOperation(insn));
-                break;
-            case Opcodes.NEWARRAY:
-            case Opcodes.ANEWARRAY:
-            case Opcodes.ARRAYLENGTH:
-                push(interpreter.unaryOperation(insn, pop()));
-                break;
-            case Opcodes.ATHROW:
-                interpreter.unaryOperation(insn, pop());
-                break;
-            case Opcodes.CHECKCAST:
-            case Opcodes.INSTANCEOF:
-                push(interpreter.unaryOperation(insn, pop()));
-                break;
-            case Opcodes.MONITORENTER:
-            case Opcodes.MONITOREXIT:
-                interpreter.unaryOperation(insn, pop());
-                break;
-            case Opcodes.MULTIANEWARRAY:
-                values = new ArrayList();
-                for (int i = ((MultiANewArrayInsnNode) insn).dims; i > 0; --i) {
-                    values.add(0, pop());
-                }
-                push(interpreter.naryOperation(insn, values));
-                break;
-            case Opcodes.IFNULL:
-            case Opcodes.IFNONNULL:
-                interpreter.unaryOperation(insn, pop());
-                break;
-            default:
-                throw new RuntimeException("Illegal opcode "+insn.getOpcode());
-        }
-    }
-
-    /**
-     * Merges this frame with the given frame.
-     * 
-     * @param frame a frame.
-     * @param interpreter the interpreter used to merge values.
-     * @return <tt>true</tt> if this frame has been changed as a result of the
-     *         merge operation, or <tt>false</tt> otherwise.
-     * @throws AnalyzerException if the frames have incompatible sizes.
-     */
-    public boolean merge(final Frame frame, final Interpreter interpreter)
-            throws AnalyzerException
-    {
-        if (top != frame.top) {
-            throw new AnalyzerException(null, "Incompatible stack heights");
-        }
-        boolean changes = false;
-        for (int i = 0; i < locals + top; ++i) {
-            Value v = interpreter.merge(values[i], frame.values[i]);
-            if (v != values[i]) {
-                values[i] = v;
-                changes |= true;
-            }
-        }
-        return changes;
-    }
-
-    /**
-     * Merges this frame with the given frame (case of a RET instruction).
-     * 
-     * @param frame a frame
-     * @param access the local variables that have been accessed by the
-     *        subroutine to which the RET instruction corresponds.
-     * @return <tt>true</tt> if this frame has been changed as a result of the
-     *         merge operation, or <tt>false</tt> otherwise.
-     */
-    public boolean merge(final Frame frame, final boolean[] access) {
-        boolean changes = false;
-        for (int i = 0; i < locals; ++i) {
-            if (!access[i] && !values[i].equals(frame.values[i])) {
-                values[i] = frame.values[i];
-                changes = true;
-            }
-        }
-        return changes;
-    }
-
-    /**
-     * Returns a string representation of this frame.
-     * 
-     * @return a string representation of this frame.
-     */
-    public String toString() {
-        StringBuffer b = new StringBuffer();
-        for (int i = 0; i < getLocals(); ++i) {
-            b.append(getLocal(i));
-        }
-        b.append(' ');
-        for (int i = 0; i < getStackSize(); ++i) {
-            b.append(getStack(i).toString());
-        }
-        return b.toString();
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Interpreter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Interpreter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Interpreter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Interpreter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,192 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree.analysis;
-
-import java.util.List;
-
-import org.eclipse.persistence.internal.libraries.asm.Type;
-import org.eclipse.persistence.internal.libraries.asm.tree.AbstractInsnNode;
-
-/**
- * A semantic bytecode interpreter. More precisely, this interpreter only
- * manages the computation of values from other values: it does not manage the
- * transfer of values to or from the stack, and to or from the local variables.
- * This separation allows a generic bytecode {@link Analyzer} to work with
- * various semantic interpreters, without needing to duplicate the code to
- * simulate the transfer of values.
- * 
- * @author Eric Bruneton
- */
-public interface Interpreter {
-
-    /**
-     * Creates a new value that represents the given type.
-     * 
-     * Called for method parameters (including <code>this</code>),
-     * exception handler variable and with <code>null</code> type 
-     * for variables reserved by long and double types.
-     * 
-     * @param type a primitive or reference type, or <tt>null</tt> to
-     *        represent an uninitialized value.
-     * @return a value that represents the given type. The size of the returned
-     *         value must be equal to the size of the given type.
-     */
-    Value newValue(Type type);
-
-    /**
-     * Interprets a bytecode instruction without arguments. This method is
-     * called for the following opcodes:
-     * 
-     * ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4,
-     * ICONST_5, LCONST_0, LCONST_1, FCONST_0, FCONST_1, FCONST_2, DCONST_0,
-     * DCONST_1, BIPUSH, SIPUSH, LDC, JSR, GETSTATIC, NEW
-     * 
-     * @param insn the bytecode instruction to be interpreted.
-     * @return the result of the interpretation of the given instruction.
-     * @throws AnalyzerException if an error occured during the interpretation.
-     */
-    Value newOperation(AbstractInsnNode insn) throws AnalyzerException;
-
-    /**
-     * Interprets a bytecode instruction that moves a value on the stack or to
-     * or from local variables. This method is called for the following opcodes:
-     * 
-     * ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE,
-     * ASTORE, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2, SWAP
-     * 
-     * @param insn the bytecode instruction to be interpreted.
-     * @param value the value that must be moved by the instruction.
-     * @return the result of the interpretation of the given instruction. The
-     *         returned value must be <tt>equal</tt> to the given value.
-     * @throws AnalyzerException if an error occured during the interpretation.
-     */
-    Value copyOperation(AbstractInsnNode insn, Value value)
-            throws AnalyzerException;
-
-    /**
-     * Interprets a bytecode instruction with a single argument. This method is
-     * called for the following opcodes:
-     * 
-     * INEG, LNEG, FNEG, DNEG, IINC, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L,
-     * F2D, D2I, D2L, D2F, I2B, I2C, I2S, IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE,
-     * TABLESWITCH, LOOKUPSWITCH, IRETURN, LRETURN, FRETURN, DRETURN, ARETURN,
-     * PUTSTATIC, GETFIELD, NEWARRAY, ANEWARRAY, ARRAYLENGTH, ATHROW, CHECKCAST,
-     * INSTANCEOF, MONITORENTER, MONITOREXIT, IFNULL, IFNONNULL
-     * 
-     * @param insn the bytecode instruction to be interpreted.
-     * @param value the argument of the instruction to be interpreted.
-     * @return the result of the interpretation of the given instruction.
-     * @throws AnalyzerException if an error occured during the interpretation.
-     */
-    Value unaryOperation(AbstractInsnNode insn, Value value)
-            throws AnalyzerException;
-
-    /**
-     * Interprets a bytecode instruction with two arguments. This method is
-     * called for the following opcodes:
-     * 
-     * IALOAD, LALOAD, FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IADD,
-     * LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV,
-     * LDIV, FDIV, DDIV, IREM, LREM, FREM, DREM, ISHL, LSHL, ISHR, LSHR, IUSHR,
-     * LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, LCMP, FCMPL, FCMPG, DCMPL,
-     * DCMPG, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE,
-     * IF_ACMPEQ, IF_ACMPNE, PUTFIELD
-     * 
-     * @param insn the bytecode instruction to be interpreted.
-     * @param value1 the first argument of the instruction to be interpreted.
-     * @param value2 the second argument of the instruction to be interpreted.
-     * @return the result of the interpretation of the given instruction.
-     * @throws AnalyzerException if an error occured during the interpretation.
-     */
-    Value binaryOperation(AbstractInsnNode insn, Value value1, Value value2)
-            throws AnalyzerException;
-
-    /**
-     * Interprets a bytecode instruction with three arguments. This method is
-     * called for the following opcodes:
-     * 
-     * IASTORE, LASTORE, FASTORE, DASTORE, AASTORE, BASTORE, CASTORE, SASTORE
-     * 
-     * @param insn the bytecode instruction to be interpreted.
-     * @param value1 the first argument of the instruction to be interpreted.
-     * @param value2 the second argument of the instruction to be interpreted.
-     * @param value3 the third argument of the instruction to be interpreted.
-     * @return the result of the interpretation of the given instruction.
-     * @throws AnalyzerException if an error occured during the interpretation.
-     */
-    Value ternaryOperation(
-        AbstractInsnNode insn,
-        Value value1,
-        Value value2,
-        Value value3) throws AnalyzerException;
-
-    /**
-     * Interprets a bytecode instruction with a variable number of arguments.
-     * This method is called for the following opcodes:
-     * 
-     * INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC, INVOKEINTERFACE,
-     * MULTIANEWARRAY
-     * 
-     * @param insn the bytecode instruction to be interpreted.
-     * @param values the arguments of the instruction to be interpreted.
-     * @return the result of the interpretation of the given instruction.
-     * @throws AnalyzerException if an error occured during the interpretation.
-     */
-    Value naryOperation(AbstractInsnNode insn, List values)
-            throws AnalyzerException;
-
-    /**
-     * Interprets a bytecode return instruction. This method is called for the 
-     * following opcodes:
-     * 
-     * IRETURN, LRETURN, FRETURN, DRETURN, ARETURN
-     * 
-     * @param insn the bytecode instruction to be interpreted.
-     * @param value the argument of the instruction to be interpreted.
-     * @param expected the expected return type of the analyzed method.
-     * @throws AnalyzerException if an error occured during the interpretation.
-     */
-    void returnOperation(AbstractInsnNode insn, Value value, Value expected)
-            throws AnalyzerException;
-    
-    /**
-     * Merges two values. The merge operation must return a value that
-     * represents both values (for instance, if the two values are two types,
-     * the merged value must be a common super type of the two types. If the two
-     * values are integer intervals, the merged value must be an interval that
-     * contains the previous ones. Likewise for other types of values).
-     * 
-     * @param v a value.
-     * @param w another value.
-     * @return the merged value. If the merged value is equal to <tt>v</tt>,
-     *         this method <i>must</i> return <tt>v</tt>.
-     */
-    Value merge(Value v, Value w);
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/package.html eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/package.html
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/package.html	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/package.html	1970-01-01 01:00:00.000000000 +0100
@@ -1,67 +0,0 @@
-<html>
-<!--
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2005 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
--->
-<body>
-
-<p>
-Provides a framework for static code analysis based on the asm.tree package.
-</p>
-
-<p>
-Basic usage:
-</p>
-
-<pre>
-ClassReader cr = new ClassReader(bytecode);
-ClassNode cn = new ClassNode();
-cr.accept(cn, ClassReader.SKIP_DEBUG);
-
-List methods = cn.methods;
-for (int i = 0; i < methods.size(); ++i) {
-    MethodNode method = (MethodNode) methods.get(i);
-    if (method.instructions.size() > 0) {
-        Analyzer a = new Analyzer(new BasicInterpreter());
-        a.analyze(cn.name, method);
-        Frame[] frames = a.getFrames();
-        // Elements of the frames arrray now contains info for each instruction 
-        // from the analyzed method. BasicInterpreter creates BasicValue, that
-        // is using simplified type system that distinguishes the UNINITIALZED, 
-        // INT, FLOAT, LONG, DOUBLE, REFERENCE and RETURNADDRESS types.
-        ...
-    }
-}   
-</pre>
-
-<p>
-@since ASM 1.4.3
-</p>
-
-</body>
-</html>
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/SimpleVerifier.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/SimpleVerifier.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/SimpleVerifier.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/SimpleVerifier.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,309 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree.analysis;
-
-import java.util.List;
-
-import org.eclipse.persistence.internal.libraries.asm.Type;
-
-/**
- * An extended {@link BasicVerifier} that performs more precise verifications.
- * This verifier computes exact class types, instead of using a single "object
- * reference" type (as done in the {@link BasicVerifier}).
- * 
- * @author Eric Bruneton
- * @author Bing Ran
- */
-public class SimpleVerifier extends BasicVerifier {
-
-    /**
-     * The class that is verified.
-     */
-    private final Type currentClass;
-
-    /**
-     * The super class of the class that is verified.
-     */
-    private final Type currentSuperClass;
-
-    /**
-     * The interfaces implemented by the class that is verified.
-     */
-    private final List currentClassInterfaces;
-
-    /**
-     * If the class that is verified is an interface.
-     */
-    private final boolean isInterface;
-
-    /**
-     * The loader to use for referenced classes.
-     */
-    private ClassLoader loader = getClass().getClassLoader();
-
-    /**
-     * Constructs a new {@link SimpleVerifier}.
-     */
-    public SimpleVerifier() {
-        this(null, null, false);
-    }
-
-    /**
-     * Constructs a new {@link SimpleVerifier} to verify a specific class. This
-     * class will not be loaded into the JVM since it may be incorrect.
-     * 
-     * @param currentClass the class that is verified.
-     * @param currentSuperClass the super class of the class that is verified.
-     * @param isInterface if the class that is verified is an interface.
-     */
-    public SimpleVerifier(
-        final Type currentClass,
-        final Type currentSuperClass,
-        final boolean isInterface)
-    {
-        this(currentClass, currentSuperClass, null, isInterface);
-    }
-
-    /**
-     * Constructs a new {@link SimpleVerifier} to verify a specific class. This
-     * class will not be loaded into the JVM since it may be incorrect.
-     * 
-     * @param currentClass the class that is verified.
-     * @param currentSuperClass the super class of the class that is verified.
-     * @param currentClassInterfaces the interfaces implemented by the class
-     *        that is verified.
-     * @param isInterface if the class that is verified is an interface.
-     */
-    public SimpleVerifier(
-        final Type currentClass,
-        final Type currentSuperClass,
-        final List currentClassInterfaces,
-        final boolean isInterface)
-    {
-        this.currentClass = currentClass;
-        this.currentSuperClass = currentSuperClass;
-        this.currentClassInterfaces = currentClassInterfaces;
-        this.isInterface = isInterface;
-    }
-
-    /**
-     * Set the <code>ClassLoader</code> which will be used to load referenced
-     * classes. This is useful if you are verifying multiple interdependent
-     * classes.
-     * 
-     * @param loader a <code>ClassLoader</code> to use
-     */
-    public void setClassLoader(final ClassLoader loader) {
-        this.loader = loader;
-    }
-
-    public Value newValue(final Type type) {
-        if (type == null) {
-            return BasicValue.UNINITIALIZED_VALUE;
-        }
-
-        boolean isArray = type.getSort() == Type.ARRAY;
-        if (isArray) {
-            switch (type.getElementType().getSort()) {
-                case Type.BOOLEAN:
-                case Type.CHAR:
-                case Type.BYTE:
-                case Type.SHORT:
-                    return new BasicValue(type);
-            }
-        }
-
-        Value v = super.newValue(type);
-        if (BasicValue.REFERENCE_VALUE.equals(v)) {
-            if (isArray) {
-                v = newValue(type.getElementType());
-                String desc = ((BasicValue) v).getType().getDescriptor();
-                for (int i = 0; i < type.getDimensions(); ++i) {
-                    desc = '[' + desc;
-                }
-                v = new BasicValue(Type.getType(desc));
-            } else {
-                v = new BasicValue(type);
-            }
-        }
-        return v;
-    }
-
-    protected boolean isArrayValue(final Value value) {
-        Type t = ((BasicValue) value).getType();
-        return t != null
-                && ("Lnull;".equals(t.getDescriptor()) || t.getSort() == Type.ARRAY);
-    }
-
-    protected Value getElementValue(final Value objectArrayValue)
-            throws AnalyzerException
-    {
-        Type arrayType = ((BasicValue) objectArrayValue).getType();
-        if (arrayType != null) {
-            if (arrayType.getSort() == Type.ARRAY) {
-                return newValue(Type.getType(arrayType.getDescriptor()
-                        .substring(1)));
-            } else if ("Lnull;".equals(arrayType.getDescriptor())) {
-                return objectArrayValue;
-            }
-        }
-        throw new Error("Internal error");
-    }
-
-    protected boolean isSubTypeOf(final Value value, final Value expected) {
-        Type expectedType = ((BasicValue) expected).getType();
-        Type type = ((BasicValue) value).getType();
-        switch (expectedType.getSort()) {
-            case Type.INT:
-            case Type.FLOAT:
-            case Type.LONG:
-            case Type.DOUBLE:
-                return type.equals(expectedType);
-            case Type.ARRAY:
-            case Type.OBJECT:
-                if ("Lnull;".equals(type.getDescriptor())) {
-                    return true;
-                } else if (type.getSort() == Type.OBJECT
-                        || type.getSort() == Type.ARRAY)
-                {
-                    return isAssignableFrom(expectedType, type);
-                } else {
-                    return false;
-                }
-            default:
-                throw new Error("Internal error");
-        }
-    }
-
-    public Value merge(final Value v, final Value w) {
-        if (!v.equals(w)) {
-            Type t = ((BasicValue) v).getType();
-            Type u = ((BasicValue) w).getType();
-            if (t != null
-                    && (t.getSort() == Type.OBJECT || t.getSort() == Type.ARRAY))
-            {
-                if (u != null
-                        && (u.getSort() == Type.OBJECT || u.getSort() == Type.ARRAY))
-                {
-                    if ("Lnull;".equals(t.getDescriptor())) {
-                        return w;
-                    }
-                    if ("Lnull;".equals(u.getDescriptor())) {
-                        return v;
-                    }
-                    if (isAssignableFrom(t, u)) {
-                        return v;
-                    }
-                    if (isAssignableFrom(u, t)) {
-                        return w;
-                    }
-                    // TODO case of array classes of the same dimension
-                    // TODO should we look also for a common super interface?
-                    // problem: there may be several possible common super
-                    // interfaces
-                    do {
-                        if (t == null || isInterface(t)) {
-                            return BasicValue.REFERENCE_VALUE;
-                        }
-                        t = getSuperClass(t);
-                        if (isAssignableFrom(t, u)) {
-                            return newValue(t);
-                        }
-                    } while (true);
-                }
-            }
-            return BasicValue.UNINITIALIZED_VALUE;
-        }
-        return v;
-    }
-
-    protected boolean isInterface(final Type t) {
-        if (currentClass != null && t.equals(currentClass)) {
-            return isInterface;
-        }
-        return getClass(t).isInterface();
-    }
-
-    protected Type getSuperClass(final Type t) {
-        if (currentClass != null && t.equals(currentClass)) {
-            return currentSuperClass;
-        }
-        Class c = getClass(t).getSuperclass();
-        return c == null ? null : Type.getType(c);
-    }
-
-    protected boolean isAssignableFrom(final Type t, final Type u) {
-        if (t.equals(u)) {
-            return true;
-        }
-        if (currentClass != null && t.equals(currentClass)) {
-            if (getSuperClass(u) == null) {
-                return false;
-            } else {
-                if (isInterface) {
-                    return u.getSort() == Type.OBJECT || u.getSort() == Type.ARRAY;
-                }
-                return isAssignableFrom(t, getSuperClass(u));
-            }
-        }
-        if (currentClass != null && u.equals(currentClass)) {
-            if (isAssignableFrom(t, currentSuperClass)) {
-                return true;
-            }
-            if (currentClassInterfaces != null) {
-                for (int i = 0; i < currentClassInterfaces.size(); ++i) {
-                    Type v = (Type) currentClassInterfaces.get(i);
-                    if (isAssignableFrom(t, v)) {
-                        return true;
-                    }
-                }
-            }
-            return false;
-        }
-        Class tc = getClass(t);
-        if (tc.isInterface()) {
-            tc = Object.class;
-        }
-        return tc.isAssignableFrom(getClass(u));
-    }
-
-    protected Class getClass(final Type t) {
-        try {
-            if (t.getSort() == Type.ARRAY) {
-                return Class.forName(t.getDescriptor().replace('/', '.'),
-                        false,
-                        loader);
-            }
-            return Class.forName(t.getClassName(), false, loader);
-        } catch (ClassNotFoundException e) {
-            throw new RuntimeException(e.toString());
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/SmallSet.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/SmallSet.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/SmallSet.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/SmallSet.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,126 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree.analysis;
-
-import java.util.AbstractSet;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Set;
-
-/**
- * A set of at most two elements.
- * 
- * @author Eric Bruneton
- */
-class SmallSet extends AbstractSet implements Iterator {
-
-    // if e1 is null, e2 must be null; otherwise e2 must be different from e1
-
-    Object e1, e2;
-
-    static final Set EMPTY_SET = new SmallSet(null, null);
-
-    SmallSet(final Object e1, final Object e2) {
-        this.e1 = e1;
-        this.e2 = e2;
-    }
-
-    // -------------------------------------------------------------------------
-    // Implementation of inherited abstract methods
-    // -------------------------------------------------------------------------
-
-    public Iterator iterator() {
-        return new SmallSet(e1, e2);
-    }
-
-    public int size() {
-        return e1 == null ? 0 : (e2 == null ? 1 : 2);
-    }
-
-    // -------------------------------------------------------------------------
-    // Implementation of the Iterator interface
-    // -------------------------------------------------------------------------
-
-    public boolean hasNext() {
-        return e1 != null;
-    }
-
-    public Object next() {
-        Object e = e1;
-        e1 = e2;
-        e2 = null;
-        return e;
-    }
-
-    public void remove() {
-    }
-
-    // -------------------------------------------------------------------------
-    // Utility methods
-    // -------------------------------------------------------------------------
-
-    Set union(final SmallSet s) {
-        if ((s.e1 == e1 && s.e2 == e2) || (s.e1 == e2 && s.e2 == e1)) {
-            return this; // if the two sets are equal, return this
-        }
-        if (s.e1 == null) {
-            return this; // if s is empty, return this
-        }
-        if (e1 == null) {
-            return s; // if this is empty, return s
-        }
-        if (s.e2 == null) { // s contains exactly one element
-            if (e2 == null) {
-                return new SmallSet(e1, s.e1); // necessarily e1 != s.e1
-            } else if (s.e1 == e1 || s.e1 == e2) { // s is included in this
-                return this;
-            }
-        }
-        if (e2 == null) { // this contains exactly one element
-            // if (s.e2 == null) { // cannot happen
-            // return new SmallSet(e1, s.e1); // necessarily e1 != s.e1
-            // } else
-            if (e1 == s.e1 || e1 == s.e2) { // this in included in s
-                return s;
-            }
-        }
-        // here we know that there are at least 3 distinct elements
-        HashSet r = new HashSet(4);
-        r.add(e1);
-        if (e2 != null) {
-            r.add(e2);
-        }
-        r.add(s.e1);
-        if (s.e2 != null) {
-            r.add(s.e2);
-        }
-        return r;
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/SourceInterpreter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/SourceInterpreter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/SourceInterpreter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/SourceInterpreter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,184 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree.analysis;
-
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-import org.eclipse.persistence.internal.libraries.asm.tree.AbstractInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.FieldInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.LdcInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.MethodInsnNode;
-
-/**
- * An {@link Interpreter} for {@link SourceValue} values.
- * 
- * @author Eric Bruneton
- */
-public class SourceInterpreter implements Opcodes, Interpreter {
-
-    public Value newValue(final Type type) {
-        if (type == Type.VOID_TYPE) {
-            return null;
-        }
-        return new SourceValue(type == null ? 1 : type.getSize());
-    }
-
-    public Value newOperation(final AbstractInsnNode insn) {
-        int size;
-        switch (insn.getOpcode()) {
-            case LCONST_0:
-            case LCONST_1:
-            case DCONST_0:
-            case DCONST_1:
-                size = 2;
-                break;
-            case LDC:
-                Object cst = ((LdcInsnNode) insn).cst;
-                size = cst instanceof Long || cst instanceof Double ? 2 : 1;
-                break;
-            case GETSTATIC:
-                size = Type.getType(((FieldInsnNode) insn).desc).getSize();
-                break;
-            default:
-                size = 1;
-        }
-        return new SourceValue(size, insn);
-    }
-
-    public Value copyOperation(final AbstractInsnNode insn, final Value value) {
-        return new SourceValue(value.getSize(), insn);
-    }
-
-    public Value unaryOperation(final AbstractInsnNode insn, final Value value)
-    {
-        int size;
-        switch (insn.getOpcode()) {
-            case LNEG:
-            case DNEG:
-            case I2L:
-            case I2D:
-            case L2D:
-            case F2L:
-            case F2D:
-            case D2L:
-                size = 2;
-                break;
-            case GETFIELD:
-                size = Type.getType(((FieldInsnNode) insn).desc).getSize();
-                break;
-            default:
-                size = 1;
-        }
-        return new SourceValue(size, insn);
-    }
-
-    public Value binaryOperation(
-        final AbstractInsnNode insn,
-        final Value value1,
-        final Value value2)
-    {
-        int size;
-        switch (insn.getOpcode()) {
-            case LALOAD:
-            case DALOAD:
-            case LADD:
-            case DADD:
-            case LSUB:
-            case DSUB:
-            case LMUL:
-            case DMUL:
-            case LDIV:
-            case DDIV:
-            case LREM:
-            case DREM:
-            case LSHL:
-            case LSHR:
-            case LUSHR:
-            case LAND:
-            case LOR:
-            case LXOR:
-                size = 2;
-                break;
-            default:
-                size = 1;
-        }
-        return new SourceValue(size, insn);
-    }
-
-    public Value ternaryOperation(
-        final AbstractInsnNode insn,
-        final Value value1,
-        final Value value2,
-        final Value value3)
-    {
-        return new SourceValue(1, insn);
-    }
-
-    public Value naryOperation(final AbstractInsnNode insn, final List values) {
-        int size;
-        if (insn.getOpcode() == MULTIANEWARRAY) {
-            size = 1;
-        } else {
-            size = Type.getReturnType(((MethodInsnNode) insn).desc).getSize();
-        }
-        return new SourceValue(size, insn);
-    }
-
-    public void returnOperation(
-        final AbstractInsnNode insn,
-        final Value value,
-        final Value expected)
-    {
-    }
-
-    public Value merge(final Value v, final Value w) {
-        SourceValue dv = (SourceValue) v;
-        SourceValue dw = (SourceValue) w;
-        if (dv.insns instanceof SmallSet && dw.insns instanceof SmallSet) {
-            Set s = ((SmallSet) dv.insns).union((SmallSet) dw.insns);
-            if (s == dv.insns && dv.size == dw.size) {
-                return v;
-            } else {
-                return new SourceValue(Math.min(dv.size, dw.size), s);
-            }
-        }
-        if (dv.size != dw.size || !dv.insns.containsAll(dw.insns)) {
-            Set s = new HashSet();
-            s.addAll(dv.insns);
-            s.addAll(dw.insns);
-            return new SourceValue(Math.min(dv.size, dw.size), s);
-        }
-        return v;
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/SourceValue.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/SourceValue.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/SourceValue.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/SourceValue.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,95 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree.analysis;
-
-import java.util.Set;
-
-import org.eclipse.persistence.internal.libraries.asm.tree.AbstractInsnNode;
-
-/**
- * A {@link Value} that is represented by its type in a two types type system.
- * This type system distinguishes the ONEWORD and TWOWORDS types.
- * 
- * @author Eric Bruneton
- */
-public class SourceValue implements Value {
-
-    /**
-     * The size of this value.
-     */
-    public final int size;
-
-    /**
-     * The instructions that can produce this value. For example, for the Java
-     * code below, the instructions that can produce the value of <tt>i</tt>
-     * at line 5 are the txo ISTORE instructions at line 1 and 3:
-     * 
-     * <pre>
-     * 1: i = 0;
-     * 2: if (...) {
-     * 3:   i = 1;
-     * 4: }
-     * 5: return i;
-     * </pre>
-     * 
-     * This field is a set of {@link AbstractInsnNode} objects.
-     */
-    public final Set insns;
-
-    public SourceValue(final int size) {
-        this(size, SmallSet.EMPTY_SET);
-    }
-
-    public SourceValue(final int size, final AbstractInsnNode insn) {
-        this.size = size;
-        this.insns = new SmallSet(insn, null);
-    }
-
-    public SourceValue(final int size, final Set insns) {
-        this.size = size;
-        this.insns = insns;
-    }
-
-    public int getSize() {
-        return size;
-    }
-
-    public boolean equals(final Object value) {
-        if (!(value instanceof SourceValue)) {
-        	return false;
-        }
-        SourceValue v = (SourceValue) value;
-        return size == v.size && insns.equals(v.insns);
-    }
-
-    public int hashCode() {
-        return insns.hashCode();
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Subroutine.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Subroutine.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Subroutine.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Subroutine.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,93 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree.analysis;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.eclipse.persistence.internal.libraries.asm.tree.JumpInsnNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.LabelNode;
-
-/**
- * A method subroutine (corresponds to a JSR instruction).
- * 
- * @author Eric Bruneton
- */
-class Subroutine {
-
-    LabelNode start;
-
-    boolean[] access;
-
-    List callers;
-
-    private Subroutine() {
-    }
-
-    Subroutine(
-        final LabelNode start,
-        final int maxLocals,
-        final JumpInsnNode caller)
-    {
-        this.start = start;
-        this.access = new boolean[maxLocals];
-        this.callers = new ArrayList();
-        callers.add(caller);
-    }
-
-    public Subroutine copy() {
-        Subroutine result = new Subroutine();
-        result.start = start;
-        result.access = new boolean[access.length];
-        System.arraycopy(access, 0, result.access, 0, access.length);
-        result.callers = new ArrayList(callers);
-        return result;
-    }
-
-    public boolean merge(final Subroutine subroutine) throws AnalyzerException {
-        boolean changes = false;
-        for (int i = 0; i < access.length; ++i) {
-            if (subroutine.access[i] && !access[i]) {
-                access[i] = true;
-                changes = true;
-            }
-        }
-        if (subroutine.start == start) {
-            for (int i = 0; i < subroutine.callers.size(); ++i) {
-                Object caller = subroutine.callers.get(i);
-                if (!callers.contains(caller)) {
-                    callers.add(caller);
-                    changes = true;
-                }
-            }
-        }
-        return changes;
-    }
-}
\ Manca newline alla fine del file
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Value.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Value.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Value.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/analysis/Value.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree.analysis;
-
-/**
- * An immutable symbolic value for semantic interpretation of bytecode.
- * 
- * @author Eric Bruneton
- */
-public interface Value {
-
-    /**
-     * Returns the size of this value in words.
-     * 
-     * @return either 1 or 2.
-     */
-    int getSize();
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/AnnotationNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/AnnotationNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/AnnotationNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/AnnotationNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,191 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-
-/**
- * A node that represents an annotationn.
- * 
- * @author Eric Bruneton
- */
-public class AnnotationNode implements AnnotationVisitor {
-
-    /**
-     * The class descriptor of the annotation class.
-     */
-    public String desc;
-
-    /**
-     * The name value pairs of this annotation. Each name value pair is stored
-     * as two consecutive elements in the list. The name is a {@link String},
-     * and the value may be a {@link Byte}, {@link Boolean}, {@link Character},
-     * {@link Short}, {@link Integer}, {@link Long}, {@link Float},
-     * {@link Double}, {@link String} or {@link org.eclipse.persistence.internal.libraries.asm.Type}, or an
-     * two elements String array (for enumeration values), a
-     * {@link AnnotationNode}, or a {@link List} of values of one of the
-     * preceding types. The list may be <tt>null</tt> if there is no name
-     * value pair.
-     */
-    public List values;
-
-    /**
-     * Constructs a new {@link AnnotationNode}.
-     * 
-     * @param desc the class descriptor of the annotation class.
-     */
-    public AnnotationNode(final String desc) {
-        this.desc = desc;
-    }
-
-    /**
-     * Constructs a new {@link AnnotationNode} to visit an array value.
-     * 
-     * @param values where the visited values must be stored.
-     */
-    AnnotationNode(final List values) {
-        this.values = values;
-    }
-
-    // ------------------------------------------------------------------------
-    // Implementation of the AnnotationVisitor interface
-    // ------------------------------------------------------------------------
-
-    public void visit(final String name, final Object value) {
-        if (values == null) {
-            values = new ArrayList(this.desc != null ? 2 : 1);
-        }
-        if (this.desc != null) {
-            values.add(name);
-        }
-        values.add(value);
-    }
-
-    public void visitEnum(
-        final String name,
-        final String desc,
-        final String value)
-    {
-        if (values == null) {
-            values = new ArrayList(this.desc != null ? 2 : 1);
-        }
-        if (this.desc != null) {
-            values.add(name);
-        }
-        values.add(new String[] { desc, value });
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String name,
-        final String desc)
-    {
-        if (values == null) {
-            values = new ArrayList(this.desc != null ? 2 : 1);
-        }
-        if (this.desc != null) {
-            values.add(name);
-        }
-        AnnotationNode annotation = new AnnotationNode(desc);
-        values.add(annotation);
-        return annotation;
-    }
-
-    public AnnotationVisitor visitArray(final String name) {
-        if (values == null) {
-            values = new ArrayList(this.desc != null ? 2 : 1);
-        }
-        if (this.desc != null) {
-            values.add(name);
-        }
-        List array = new ArrayList();
-        values.add(array);
-        return new AnnotationNode(array);
-    }
-
-    public void visitEnd() {
-    }
-
-    // ------------------------------------------------------------------------
-    // Accept methods
-    // ------------------------------------------------------------------------
-
-    /**
-     * Makes the given visitor visit this annotation.
-     * 
-     * @param av an annotation visitor. Maybe <tt>null</tt>.
-     */
-    public void accept(final AnnotationVisitor av) {
-        if (av != null) {
-            if (values != null) {
-                for (int i = 0; i < values.size(); i += 2) {
-                    String name = (String) values.get(i);
-                    Object value = values.get(i + 1);
-                    accept(av, name, value);
-                }
-            }
-            av.visitEnd();
-        }
-    }
-
-    /**
-     * Makes the given visitor visit a given annotation value.
-     * 
-     * @param av an annotation visitor. Maybe <tt>null</tt>.
-     * @param name the value name.
-     * @param value the actual value.
-     */
-    static void accept(
-        final AnnotationVisitor av,
-        final String name,
-        final Object value)
-    {
-        if (av != null) {
-            if (value instanceof String[]) {
-                String[] typeconst = (String[]) value;
-                av.visitEnum(name, typeconst[0], typeconst[1]);
-            } else if (value instanceof AnnotationNode) {
-                AnnotationNode an = (AnnotationNode) value;
-                an.accept(av.visitAnnotation(name, an.desc));
-            } else if (value instanceof List) {
-                AnnotationVisitor v = av.visitArray(name);
-                List array = (List) value;
-                for (int j = 0; j < array.size(); ++j) {
-                    accept(v, null, array.get(j));
-                }
-                v.visitEnd();
-            } else {
-                av.visit(name, value);
-            }
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/ClassNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/ClassNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/ClassNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/ClassNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,280 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-import org.eclipse.persistence.internal.libraries.asm.ClassVisitor;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-import java.util.List;
-import java.util.ArrayList;
-import java.util.Arrays;
-
-/**
- * A node that represents a class.
- * 
- * @author Eric Bruneton
- */
-public class ClassNode extends MemberNode implements ClassVisitor {
-
-    /**
-     * The class version.
-     */
-    public int version;
-
-    /**
-     * The class's access flags (see {@link org.eclipse.persistence.internal.libraries.asm.Opcodes}). This
-     * field also indicates if the class is deprecated.
-     */
-    public int access;
-
-    /**
-     * The internal name of the class (see
-     * {@link org.eclipse.persistence.internal.libraries.asm.Type#getInternalName() getInternalName}).
-     */
-    public String name;
-
-    /**
-     * The signature of the class. Mayt be <tt>null</tt>.
-     */
-    public String signature;
-
-    /**
-     * The internal of name of the super class (see
-     * {@link org.eclipse.persistence.internal.libraries.asm.Type#getInternalName() getInternalName}). For
-     * interfaces, the super class is {@link Object}. May be <tt>null</tt>,
-     * but only for the {@link Object} class.
-     */
-    public String superName;
-
-    /**
-     * The internal names of the class's interfaces (see
-     * {@link org.eclipse.persistence.internal.libraries.asm.Type#getInternalName() getInternalName}). This
-     * list is a list of {@link String} objects.
-     */
-    public List interfaces;
-
-    /**
-     * The name of the source file from which this class was compiled. May be
-     * <tt>null</tt>.
-     */
-    public String sourceFile;
-
-    /**
-     * Debug information to compute the correspondance between source and
-     * compiled elements of the class. May be <tt>null</tt>.
-     */
-    public String sourceDebug;
-
-    /**
-     * The internal name of the enclosing class of the class. May be
-     * <tt>null</tt>.
-     */
-    public String outerClass;
-
-    /**
-     * The name of the method that contains the class, or <tt>null</tt> if the
-     * class is not enclosed in a method.
-     */
-    public String outerMethod;
-
-    /**
-     * The descriptor of the method that contains the class, or <tt>null</tt>
-     * if the class is not enclosed in a method.
-     */
-    public String outerMethodDesc;
-
-    /**
-     * Informations about the inner classes of this class. This list is a list
-     * of {@link InnerClassNode} objects.
-     * 
-     * @associates org.objectweb.asm.tree.InnerClassNode
-     */
-    public List innerClasses;
-
-    /**
-     * The fields of this class. This list is a list of {@link FieldNode}
-     * objects.
-     * 
-     * @associates org.objectweb.asm.tree.FieldNode
-     */
-    public List fields;
-
-    /**
-     * The methods of this class. This list is a list of {@link MethodNode}
-     * objects.
-     * 
-     * @associates org.objectweb.asm.tree.MethodNode
-     */
-    public List methods;
-
-    /**
-     * Constructs a new {@link ClassNode}.
-     */
-    public ClassNode() {
-        this.interfaces = new ArrayList();
-        this.innerClasses = new ArrayList();
-        this.fields = new ArrayList();
-        this.methods = new ArrayList();
-    }
-
-    // ------------------------------------------------------------------------
-    // Implementation of the ClassVisitor interface
-    // ------------------------------------------------------------------------
-
-    public void visit(
-        final int version,
-        final int access,
-        final String name,
-        final String signature,
-        final String superName,
-        final String[] interfaces)
-    {
-        this.version = version;
-        this.access = access;
-        this.name = name;
-        this.signature = signature;
-        this.superName = superName;
-        if (interfaces != null) {
-            this.interfaces.addAll(Arrays.asList(interfaces));
-        }
-    }
-
-    public void visitSource(final String file, final String debug) {
-        sourceFile = file;
-        sourceDebug = debug;
-    }
-
-    public void visitOuterClass(
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        outerClass = owner;
-        outerMethod = name;
-        outerMethodDesc = desc;
-    }
-
-    public void visitInnerClass(
-        final String name,
-        final String outerName,
-        final String innerName,
-        final int access)
-    {
-        InnerClassNode icn = new InnerClassNode(name,
-                outerName,
-                innerName,
-                access);
-        innerClasses.add(icn);
-    }
-
-    public FieldVisitor visitField(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final Object value)
-    {
-        FieldNode fn = new FieldNode(access, name, desc, signature, value);
-        fields.add(fn);
-        return fn;
-    }
-
-    public MethodVisitor visitMethod(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final String[] exceptions)
-    {
-        MethodNode mn = new MethodNode(access,
-                name,
-                desc,
-                signature,
-                exceptions);
-        methods.add(mn);
-        return mn;
-    }
-
-    // ------------------------------------------------------------------------
-    // Accept method
-    // ------------------------------------------------------------------------
-
-    /**
-     * Makes the given class visitor visit this class.
-     * 
-     * @param cv a class visitor.
-     */
-    public void accept(final ClassVisitor cv) {
-        // visits header
-        String[] interfaces = new String[this.interfaces.size()];
-        this.interfaces.toArray(interfaces);
-        cv.visit(version, access, name, signature, superName, interfaces);
-        // visits source
-        if (sourceFile != null || sourceDebug != null) {
-            cv.visitSource(sourceFile, sourceDebug);
-        }
-        // visits outer class
-        if (outerClass != null) {
-            cv.visitOuterClass(outerClass, outerMethod, outerMethodDesc);
-        }
-        // visits attributes
-        int i, n;
-        n = visibleAnnotations == null ? 0 : visibleAnnotations.size();
-        for (i = 0; i < n; ++i) {
-            AnnotationNode an = (AnnotationNode) visibleAnnotations.get(i);
-            an.accept(cv.visitAnnotation(an.desc, true));
-        }
-        n = invisibleAnnotations == null ? 0 : invisibleAnnotations.size();
-        for (i = 0; i < n; ++i) {
-            AnnotationNode an = (AnnotationNode) invisibleAnnotations.get(i);
-            an.accept(cv.visitAnnotation(an.desc, false));
-        }
-        n = attrs == null ? 0 : attrs.size();
-        for (i = 0; i < n; ++i) {
-            cv.visitAttribute((Attribute) attrs.get(i));
-        }
-        // visits inner classes
-        for (i = 0; i < innerClasses.size(); ++i) {
-            ((InnerClassNode) innerClasses.get(i)).accept(cv);
-        }
-        // visits fields
-        for (i = 0; i < fields.size(); ++i) {
-            ((FieldNode) fields.get(i)).accept(cv);
-        }
-        // visits methods
-        for (i = 0; i < methods.size(); ++i) {
-            ((MethodNode) methods.get(i)).accept(cv);
-        }
-        // visits end
-        cv.visitEnd();
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/FieldInsnNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/FieldInsnNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/FieldInsnNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/FieldInsnNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,103 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-/**
- * A node that represents a field instruction. A field instruction is an
- * instruction that loads or stores the value of a field of an object.
- * 
- * @author Eric Bruneton
- */
-public class FieldInsnNode extends AbstractInsnNode {
-
-    /**
-     * The internal name of the field's owner class (see
-     * {@link org.eclipse.persistence.internal.libraries.asm.Type#getInternalName() getInternalName}).
-     */
-    public String owner;
-
-    /**
-     * The field's name.
-     */
-    public String name;
-
-    /**
-     * The field's descriptor (see {@link org.eclipse.persistence.internal.libraries.asm.Type}).
-     */
-    public String desc;
-
-    /**
-     * Constructs a new {@link FieldInsnNode}.
-     * 
-     * @param opcode the opcode of the type instruction to be constructed. This
-     *        opcode must be GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.
-     * @param owner the internal name of the field's owner class (see
-     *        {@link org.eclipse.persistence.internal.libraries.asm.Type#getInternalName() getInternalName}).
-     * @param name the field's name.
-     * @param desc the field's descriptor (see {@link org.eclipse.persistence.internal.libraries.asm.Type}).
-     */
-    public FieldInsnNode(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        super(opcode);
-        this.owner = owner;
-        this.name = name;
-        this.desc = desc;
-    }
-
-    /**
-     * Sets the opcode of this instruction.
-     * 
-     * @param opcode the new instruction opcode. This opcode must be GETSTATIC,
-     *        PUTSTATIC, GETFIELD or PUTFIELD.
-     */
-    public void setOpcode(final int opcode) {
-        this.opcode = opcode;
-    }
-
-    public int getType() {
-        return FIELD_INSN;
-    }
-
-    public void accept(final MethodVisitor cv) {
-        cv.visitFieldInsn(opcode, owner, name, desc);
-    }
-
-    public AbstractInsnNode clone(final Map labels) {
-        return new FieldInsnNode(opcode, owner, name, desc);
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/FieldNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/FieldNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/FieldNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/FieldNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,127 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-import org.eclipse.persistence.internal.libraries.asm.ClassVisitor;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-
-/**
- * A node that represents a field.
- * 
- * @author Eric Bruneton
- */
-public class FieldNode extends MemberNode implements FieldVisitor {
-
-    /**
-     * The field's access flags (see {@link org.eclipse.persistence.internal.libraries.asm.Opcodes}). This
-     * field also indicates if the field is synthetic and/or deprecated.
-     */
-    public int access;
-
-    /**
-     * The field's name.
-     */
-    public String name;
-
-    /**
-     * The field's descriptor (see {@link org.eclipse.persistence.internal.libraries.asm.Type}).
-     */
-    public String desc;
-
-    /**
-     * The field's signature. May be <tt>null</tt>.
-     */
-    public String signature;
-
-    /**
-     * The field's initial value. This field, which may be <tt>null</tt> if
-     * the field does not have an initial value, must be an {@link Integer}, a
-     * {@link Float}, a {@link Long}, a {@link Double} or a {@link String}.
-     */
-    public Object value;
-
-    /**
-     * Constructs a new {@link FieldNode}.
-     * 
-     * @param access the field's access flags (see
-     *        {@link org.eclipse.persistence.internal.libraries.asm.Opcodes}). This parameter also indicates
-     *        if the field is synthetic and/or deprecated.
-     * @param name the field's name.
-     * @param desc the field's descriptor (see
-     *        {@link org.eclipse.persistence.internal.libraries.asm.Type Type}).
-     * @param signature the field's signature.
-     * @param value the field's initial value. This parameter, which may be
-     *        <tt>null</tt> if the field does not have an initial value, must
-     *        be an {@link Integer}, a {@link Float}, a {@link Long}, a
-     *        {@link Double} or a {@link String}.
-     */
-    public FieldNode(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final Object value)
-    {
-        this.access = access;
-        this.name = name;
-        this.desc = desc;
-        this.signature = signature;
-        this.value = value;
-    }
-
-    /**
-     * Makes the given class visitor visit this field.
-     * 
-     * @param cv a class visitor.
-     */
-    public void accept(final ClassVisitor cv) {
-        FieldVisitor fv = cv.visitField(access, name, desc, signature, value);
-        if (fv == null) {
-            return;
-        }
-        int i, n;
-        n = visibleAnnotations == null ? 0 : visibleAnnotations.size();
-        for (i = 0; i < n; ++i) {
-            AnnotationNode an = (AnnotationNode) visibleAnnotations.get(i);
-            an.accept(fv.visitAnnotation(an.desc, true));
-        }
-        n = invisibleAnnotations == null ? 0 : invisibleAnnotations.size();
-        for (i = 0; i < n; ++i) {
-            AnnotationNode an = (AnnotationNode) invisibleAnnotations.get(i);
-            an.accept(fv.visitAnnotation(an.desc, false));
-        }
-        n = attrs == null ? 0 : attrs.size();
-        for (i = 0; i < n; ++i) {
-            fv.visitAttribute((Attribute) attrs.get(i));
-        }
-        fv.visitEnd();
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/FrameNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/FrameNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/FrameNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/FrameNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,208 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-
-/**
- * A node that represents a stack map frame. These nodes are pseudo instruction
- * nodes in order to be inserted in an instruction list. In fact these nodes
- * must(*) be inserted <i>just before</i> any instruction node <b>i</b> that
- * follows an unconditionnal branch instruction such as GOTO or THROW, that is
- * the target of a jump instruction, or that starts an exception handler block.
- * The stack map frame types must describe the values of the local variables and
- * of the operand stack elements <i>just before</i> <b>i</b> is executed. <br>
- * <br> (*) this is mandatory only for classes whose version is greater than or
- * equal to {@link Opcodes#V1_6 V1_6}.
- * 
- * @author Eric Bruneton
- */
-public class FrameNode extends AbstractInsnNode {
-
-    /**
-     * The type of this frame. Must be {@link Opcodes#F_NEW} for expanded
-     * frames, or {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND},
-     * {@link Opcodes#F_CHOP}, {@link Opcodes#F_SAME} or
-     * {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for compressed frames.
-     */
-    public int type;
-
-    /**
-     * The types of the local variables of this stack map frame. Elements of
-     * this list can be Integer, String or LabelNode objects (for primitive,
-     * reference and uninitialized types respectively - see
-     * {@link MethodVisitor}).
-     */
-    public List local;
-
-    /**
-     * The types of the operand stack elements of this stack map frame. Elements
-     * of this list can be Integer, String or LabelNode objects (for primitive,
-     * reference and uninitialized types respectively - see
-     * {@link MethodVisitor}).
-     */
-    public List stack;
-
-    private FrameNode() {
-        super(-1);
-    }
-
-    /**
-     * Constructs a new {@link FrameNode}.
-     * 
-     * @param type the type of this frame. Must be {@link Opcodes#F_NEW} for
-     *        expanded frames, or {@link Opcodes#F_FULL},
-     *        {@link Opcodes#F_APPEND}, {@link Opcodes#F_CHOP},
-     *        {@link Opcodes#F_SAME} or {@link Opcodes#F_APPEND},
-     *        {@link Opcodes#F_SAME1} for compressed frames.
-     * @param nLocal number of local variables of this stack map frame.
-     * @param local the types of the local variables of this stack map frame.
-     *        Elements of this list can be Integer, String or LabelNode objects
-     *        (for primitive, reference and uninitialized types respectively -
-     *        see {@link MethodVisitor}).
-     * @param nStack number of operand stack elements of this stack map frame.
-     * @param stack the types of the operand stack elements of this stack map
-     *        frame. Elements of this list can be Integer, String or LabelNode
-     *        objects (for primitive, reference and uninitialized types
-     *        respectively - see {@link MethodVisitor}).
-     */
-    public FrameNode(
-        final int type,
-        final int nLocal,
-        final Object[] local,
-        final int nStack,
-        final Object[] stack)
-    {
-        super(-1);
-        this.type = type;
-        switch (type) {
-            case Opcodes.F_NEW:
-            case Opcodes.F_FULL:
-                this.local = asList(nLocal, local);
-                this.stack = asList(nStack, stack);
-                break;
-            case Opcodes.F_APPEND:
-                this.local = asList(nLocal, local);
-                break;
-            case Opcodes.F_CHOP:
-                this.local = Arrays.asList(new Object[nLocal]);
-                break;
-            case Opcodes.F_SAME:
-                break;
-            case Opcodes.F_SAME1:
-                this.stack = asList(1, stack);
-                break;
-        }
-    }
-
-    public int getType() {
-        return FRAME;
-    }
-
-    /**
-     * Makes the given visitor visit this stack map frame.
-     * 
-     * @param mv a method visitor.
-     */
-    public void accept(final MethodVisitor mv) {
-        switch (type) {
-            case Opcodes.F_NEW:
-            case Opcodes.F_FULL:
-                mv.visitFrame(type,
-                        local.size(),
-                        asArray(local),
-                        stack.size(),
-                        asArray(stack));
-                break;
-            case Opcodes.F_APPEND:
-                mv.visitFrame(type, local.size(), asArray(local), 0, null);
-                break;
-            case Opcodes.F_CHOP:
-                mv.visitFrame(type, local.size(), null, 0, null);
-                break;
-            case Opcodes.F_SAME:
-                mv.visitFrame(type, 0, null, 0, null);
-                break;
-            case Opcodes.F_SAME1:
-                mv.visitFrame(type, 0, null, 1, asArray(stack));
-                break;
-        }
-    }
-
-    public AbstractInsnNode clone(final Map labels) {
-        FrameNode clone = new FrameNode();
-        clone.type = type;
-        if (local != null) {
-            clone.local = new ArrayList();
-            for (int i = 0; i < local.size(); ++i) {
-                Object l = local.get(i);
-                if (l instanceof LabelNode) {
-                    l = labels.get(l);
-                }
-                clone.local.add(l);
-            }
-        }
-        if (stack != null) {
-            clone.stack = new ArrayList();
-            for (int i = 0; i < stack.size(); ++i) {
-                Object s = stack.get(i);
-                if (s instanceof LabelNode) {
-                    s = labels.get(s);
-                }
-                clone.stack.add(s);
-            }
-        }
-        return clone;
-    }
-
-    // ------------------------------------------------------------------------
-
-    private static List asList(final int n, final Object[] o) {
-        return Arrays.asList(o).subList(0, n);
-    }
-
-    private static Object[] asArray(final List l) {
-        Object[] objs = new Object[l.size()];
-        for (int i = 0; i < objs.length; ++i) {
-            Object o = l.get(i);
-            if (o instanceof LabelNode) {
-                o = ((LabelNode) o).getLabel();
-            }
-            objs[i] = o;
-        }
-        return objs;
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/IincInsnNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/IincInsnNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/IincInsnNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/IincInsnNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-
-/**
- * A node that represents an IINC instruction.
- * 
- * @author Eric Bruneton
- */
-public class IincInsnNode extends AbstractInsnNode {
-
-    /**
-     * Index of the local variable to be incremented.
-     */
-    public int var;
-
-    /**
-     * Amount to increment the local variable by.
-     */
-    public int incr;
-
-    /**
-     * Constructs a new {@link IincInsnNode}.
-     * 
-     * @param var index of the local variable to be incremented.
-     * @param incr increment amount to increment the local variable by.
-     */
-    public IincInsnNode(final int var, final int incr) {
-        super(Opcodes.IINC);
-        this.var = var;
-        this.incr = incr;
-    }
-
-    public int getType() {
-        return IINC_INSN;
-    }
-
-    public void accept(final MethodVisitor mv) {
-        mv.visitIincInsn(var, incr);
-    }
-
-    public AbstractInsnNode clone(final Map labels) {
-        return new IincInsnNode(var, incr);
-    }
-}
\ Manca newline alla fine del file
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/InnerClassNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/InnerClassNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/InnerClassNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/InnerClassNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,101 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import org.eclipse.persistence.internal.libraries.asm.ClassVisitor;
-
-/**
- * A node that represents an inner class.
- * 
- * @author Eric Bruneton
- */
-public class InnerClassNode {
-
-    /**
-     * The internal name of an inner class (see
-     * {@link org.eclipse.persistence.internal.libraries.asm.Type#getInternalName() getInternalName}).
-     */
-    public String name;
-
-    /**
-     * The internal name of the class to which the inner class belongs (see
-     * {@link org.eclipse.persistence.internal.libraries.asm.Type#getInternalName() getInternalName}). May
-     * be <tt>null</tt>.
-     */
-    public String outerName;
-
-    /**
-     * The (simple) name of the inner class inside its enclosing class. May be
-     * <tt>null</tt> for anonymous inner classes.
-     */
-    public String innerName;
-
-    /**
-     * The access flags of the inner class as originally declared in the
-     * enclosing class.
-     */
-    public int access;
-
-    /**
-     * Constructs a new {@link InnerClassNode}.
-     * 
-     * @param name the internal name of an inner class (see
-     *        {@link org.eclipse.persistence.internal.libraries.asm.Type#getInternalName() getInternalName}).
-     * @param outerName the internal name of the class to which the inner class
-     *        belongs (see
-     *        {@link org.eclipse.persistence.internal.libraries.asm.Type#getInternalName() getInternalName}).
-     *        May be <tt>null</tt>.
-     * @param innerName the (simple) name of the inner class inside its
-     *        enclosing class. May be <tt>null</tt> for anonymous inner
-     *        classes.
-     * @param access the access flags of the inner class as originally declared
-     *        in the enclosing class.
-     */
-    public InnerClassNode(
-        final String name,
-        final String outerName,
-        final String innerName,
-        final int access)
-    {
-        this.name = name;
-        this.outerName = outerName;
-        this.innerName = innerName;
-        this.access = access;
-    }
-
-    /**
-     * Makes the given class visitor visit this inner class.
-     * 
-     * @param cv a class visitor.
-     */
-    public void accept(final ClassVisitor cv) {
-        cv.visitInnerClass(name, outerName, innerName, access);
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/InsnList.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/InsnList.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/InsnList.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/InsnList.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,640 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.ListIterator;
-import java.util.NoSuchElementException;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-/**
- * A doubly linked list of {@link AbstractInsnNode} objects. <i>This
- * implementation is not thread safe</i>.
- */
-public class InsnList {
-
-    /**
-     * Indicates if preconditions of methods of this class must be checked.
-     * <i>Checking preconditions causes the {@link #indexOf indexOf},
-     * {@link #set set}, {@link #insert(AbstractInsnNode, AbstractInsnNode)},
-     * {@link #insert(AbstractInsnNode, InsnList)}, {@link #remove remove} and
-     * {@link #clear} methods to execute in O(n) time instead of O(1)</i>.
-     */
-    public static boolean check;
-
-    /**
-     * The number of instructions in this list.
-     */
-    private int size;
-
-    /**
-     * The first instruction in this list. May be <tt>null</tt>.
-     */
-    private AbstractInsnNode first;
-
-    /**
-     * The last instruction in this list. May be <tt>null</tt>.
-     */
-    private AbstractInsnNode last;
-
-    /**
-     * A cache of the instructions of this list. This cache is used to improve
-     * the performance of the {@link #get} method.
-     */
-    AbstractInsnNode[] cache;
-
-    /**
-     * Returns the number of instructions in this list.
-     * 
-     * @return the number of instructions in this list.
-     */
-    public int size() {
-        return size;
-    }
-
-    /**
-     * Returns the first instruction in this list.
-     * 
-     * @return the first instruction in this list, or <tt>null</tt> if the
-     *         list is empty.
-     */
-    public AbstractInsnNode getFirst() {
-        return first;
-    }
-
-    /**
-     * Returns the last instruction in this list.
-     * 
-     * @return the last instruction in this list, or <tt>null</tt> if the list
-     *         is empty.
-     */
-    public AbstractInsnNode getLast() {
-        return last;
-    }
-
-    /**
-     * Returns the instruction whose index is given. This method builds a cache
-     * of the instructions in this list to avoid scanning the whole list each
-     * time it is called. Once the cache is built, this method run in constant
-     * time. This cache is invalidated by all the methods that modify the list.
-     * 
-     * @param index the index of the instruction that must be returned.
-     * @return the instruction whose index is given.
-     * @throws IndexOutOfBoundsException if (index < 0 || index >= size()).
-     */
-    public AbstractInsnNode get(final int index) {
-        if (index < 0 || index >= size) {
-            throw new IndexOutOfBoundsException();
-        }
-        if (cache == null) {
-            cache = toArray();
-        }
-        return cache[index];
-    }
-
-    /**
-     * Returns <tt>true</tt> if the given instruction belongs to this list.
-     * This method always scans the instructions of this list until it finds the
-     * given instruction or reaches the end of the list.
-     * 
-     * @param insn an instruction.
-     * @return <tt>true</tt> if the given instruction belongs to this list.
-     */
-    public boolean contains(final AbstractInsnNode insn) {
-        AbstractInsnNode i = first;
-        while (i != null && i != insn) {
-            i = i.next;
-        }
-        return i != null;
-    }
-
-    /**
-     * Returns the index of the given instruction in this list. This method
-     * builds a cache of the instruction indexes to avoid scanning the whole
-     * list each time it is called. Once the cache is built, this method run in
-     * constant time. The cache is invalidated by all the methods that modify
-     * the list.
-     * 
-     * @param insn an instruction <i>of this list</i>.
-     * @return the index of the given instruction in this list. <i>The result of
-     *         this method is undefined if the given instruction does not belong
-     *         to this list</i>. Use {@link #contains contains} to test if an
-     *         instruction belongs to an instruction list or not.
-     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt> and
-     *         if insn does not belong to this list.
-     */
-    public int indexOf(final AbstractInsnNode insn) {
-        if (check && !contains(insn)) {
-            throw new IllegalArgumentException();
-        }
-        if (cache == null) {
-            cache = toArray();
-        }
-        return insn.index;
-    }
-
-    /**
-     * Makes the given visitor visit all of the instructions in this list.
-     * 
-     * @param mv the method visitor that must visit the instructions.
-     */
-    public void accept(final MethodVisitor mv) {
-        AbstractInsnNode insn = first;
-        while (insn != null) {
-            insn.accept(mv);
-            insn = insn.next;
-        }
-    }
-
-    /**
-     * Returns an iterator over the instructions in this list.
-     * 
-     * @return an iterator over the instructions in this list.
-     */
-    public ListIterator iterator() {
-        return iterator(0);
-    }
-
-    /**
-     * Returns an iterator over the instructions in this list.
-     * 
-     * @return an iterator over the instructions in this list.
-     */
-    public ListIterator iterator(int index) {
-        return new InsnListIterator(index);
-    }
-    
-    /**
-     * Returns an array containing all of the instructions in this list.
-     * 
-     * @return an array containing all of the instructions in this list.
-     */
-    public AbstractInsnNode[] toArray() {
-        int i = 0;
-        AbstractInsnNode elem = first;
-        AbstractInsnNode[] insns = new AbstractInsnNode[size];
-        while (elem != null) {
-            insns[i] = elem;
-            elem.index = i++;
-            elem = elem.next;
-        }
-        return insns;
-    }
-
-    /**
-     * Replaces an instruction of this list with another instruction.
-     * 
-     * @param location an instruction <i>of this list</i>.
-     * @param insn another instruction, <i>which must not belong to any
-     *        {@link InsnList}</i>.
-     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,
-     *         and if i does not belong to this list or if insn belongs to an
-     *         instruction list.
-     */
-    public void set(final AbstractInsnNode location, final AbstractInsnNode insn) {
-        if (check && !(contains(location) && insn.index == -1)) {
-            throw new IllegalArgumentException();
-        }
-        AbstractInsnNode next = location.next;
-        insn.next = next;
-        if (next != null) {
-            next.prev = insn;
-        } else {
-            last = insn;
-        }
-        AbstractInsnNode prev = location.prev;
-        insn.prev = prev;
-        if (prev != null) {
-            prev.next = insn;
-        } else {
-            first = insn;
-        }
-        if (cache != null) {
-            int index = location.index;
-            cache[index] = insn;
-            insn.index = index;
-        } else {
-            insn.index = 0; // insn now belongs to an InsnList
-        }
-        location.index = -1; // i no longer belongs to an InsnList
-        location.prev = null;
-        location.next = null;
-    }
-
-    /**
-     * Adds the given instruction to the end of this list.
-     * 
-     * @param insn an instruction, <i>which must not belong to any
-     *        {@link InsnList}</i>.
-     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,
-     *         and if insn belongs to an instruction list.
-     */
-    public void add(final AbstractInsnNode insn) {
-        if (check && insn.index != -1) {
-            throw new IllegalArgumentException();
-        }
-        ++size;
-        if (last == null) {
-            first = insn;
-            last = insn;
-        } else {
-            last.next = insn;
-            insn.prev = last;
-        }
-        last = insn;
-        cache = null;
-        insn.index = 0; // insn now belongs to an InsnList
-    }
-
-    /**
-     * Adds the given instructions to the end of this list.
-     * 
-     * @param insns an instruction list, which is cleared during the process.
-     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,
-     *         and if insn == this.
-     */
-    public void add(final InsnList insns) {
-        if (check && insns == this) {
-            throw new IllegalArgumentException();
-        }
-        if (insns.size == 0) {
-            return;
-        }
-        size += insns.size;
-        if (last == null) {
-            first = insns.first;
-            last = insns.last;
-        } else {
-            AbstractInsnNode elem = insns.first;
-            last.next = elem;
-            elem.prev = last;
-            last = insns.last;
-        }
-        cache = null;
-        insns.removeAll(false);
-    }
-
-    /**
-     * Inserts the given instruction at the begining of this list.
-     * 
-     * @param insn an instruction, <i>which must not belong to any
-     *        {@link InsnList}</i>.
-     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,
-     *         and if insn belongs to an instruction list.
-     */
-    public void insert(final AbstractInsnNode insn) {
-        if (check && insn.index != -1) {
-            throw new IllegalArgumentException();
-        }
-        ++size;
-        if (first == null) {
-            first = insn;
-            last = insn;
-        } else {
-            first.prev = insn;
-            insn.next = first;
-        }
-        first = insn;
-        cache = null;
-        insn.index = 0; // insn now belongs to an InsnList
-    }
-
-    /**
-     * Inserts the given instructions at the begining of this list.
-     * 
-     * @param insns an instruction list, which is cleared during the process.
-     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,
-     *         and if insn == this.
-     */
-    public void insert(final InsnList insns) {
-        if (check && insns == this) {
-            throw new IllegalArgumentException();
-        }
-        if (insns.size == 0) {
-            return;
-        }
-        size += insns.size;
-        if (first == null) {
-            first = insns.first;
-            last = insns.last;
-        } else {
-            AbstractInsnNode elem = insns.last;
-            first.prev = elem;
-            elem.next = first;
-            first = insns.first;
-        }
-        cache = null;
-        insns.removeAll(false);
-    }
-
-    /**
-     * Inserts the given instruction after the specified instruction.
-     * 
-     * @param location an instruction <i>of this list</i> after which insn must be
-     *        inserted.
-     * @param insn the instruction to be inserted, <i>which must not belong to
-     *        any {@link InsnList}</i>.
-     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,
-     *         and if i does not belong to this list or if insn belongs to an
-     *         instruction list.
-     */
-    public void insert(final AbstractInsnNode location, final AbstractInsnNode insn) {
-        if (check && !(contains(location) && insn.index == -1)) {
-            throw new IllegalArgumentException();
-        }
-        ++size;
-        AbstractInsnNode next = location.next;
-        if (next == null) {
-            last = insn;
-        } else {
-            next.prev = insn;
-        }
-        location.next = insn;
-        insn.next = next;
-        insn.prev = location;
-        cache = null;
-        insn.index = 0; // insn now belongs to an InsnList
-    }
-
-    /**
-     * Inserts the given instructions after the specified instruction.
-     * 
-     * @param location an instruction <i>of this list</i> after which the instructions
-     *        must be inserted.
-     * @param insns the instruction list to be inserted, which is cleared during
-     *        the process.
-     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,
-     *         and if i does not belong to this list or if insns == this.
-     */
-    public void insert(final AbstractInsnNode location, final InsnList insns) {
-        if (check && !(contains(location) && insns != this)) {
-            throw new IllegalArgumentException();
-        }
-        if (insns.size == 0) {
-            return;
-        }
-        size += insns.size;
-        AbstractInsnNode ifirst = insns.first;
-        AbstractInsnNode ilast = insns.last;
-        AbstractInsnNode next = location.next;
-        if (next == null) {
-            last = ilast;
-        } else {
-            next.prev = ilast;
-        }
-        location.next = ifirst;
-        ilast.next = next;
-        ifirst.prev = location;
-        cache = null;
-        insns.removeAll(false);
-    }
-    
-    /**
-     * Inserts the given instruction before the specified instruction.
-     * 
-     * @param location an instruction <i>of this list</i> before which insn must be
-     *        inserted.
-     * @param insn the instruction to be inserted, <i>which must not belong to
-     *        any {@link InsnList}</i>.
-     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,
-     *         and if i does not belong to this list or if insn belongs to an
-     *         instruction list.
-     */
-    public void insertBefore(final AbstractInsnNode location, final AbstractInsnNode insn) {
-        if (check && !(contains(location) && insn.index == -1)) {
-            throw new IllegalArgumentException();
-        }
-        ++size;
-        AbstractInsnNode prev = location.prev;
-        if (prev == null) {
-            first = insn;
-        } else {
-            prev.next = insn;
-        }
-        location.prev = insn;
-        insn.next = location;
-        insn.prev = prev;
-        cache = null;
-        insn.index = 0; // insn now belongs to an InsnList
-    }
-    
-    /**
-     * Inserts the given instructions before the specified instruction.
-     * 
-     * @param location  an instruction <i>of this list</i> before which the instructions
-     *        must be inserted.
-     * @param insns the instruction list to be inserted, which is cleared during
-     *        the process.
-     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,
-     *         and if i does not belong to this list or if insns == this.
-     */
-    public void insertBefore(final AbstractInsnNode location, final InsnList insns) {
-        if (check && !(contains(location ) && insns != this)) {
-            throw new IllegalArgumentException();
-        }
-        if (insns.size == 0) {
-            return;
-        }
-        size += insns.size;
-        AbstractInsnNode ifirst = insns.first;
-        AbstractInsnNode ilast = insns.last;
-        AbstractInsnNode prev = location .prev;
-        if (prev == null) {
-            first = ifirst;
-        } else {
-            prev.next = ifirst;
-        }
-        location .prev = ilast;
-        ilast.next = location ;
-        ifirst.prev = prev;
-        cache = null;
-        insns.removeAll(false);
-    }
-    
-    
-
-    /**
-     * Removes the given instruction from this list.
-     * 
-     * @param insn the instruction <i>of this list</i> that must be removed.
-     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,
-     *         and if insn does not belong to this list.
-     */
-    public void remove(final AbstractInsnNode insn) {
-        if (check && !contains(insn)) {
-            throw new IllegalArgumentException();
-        }
-        --size;
-        AbstractInsnNode next = insn.next;
-        AbstractInsnNode prev = insn.prev;
-        if (next == null) {
-            if (prev == null) {
-                first = null;
-                last = null;
-            } else {
-                prev.next = null;
-                last = prev;
-            }
-        } else {
-            if (prev == null) {
-                first = next;
-                next.prev = null;
-            } else {
-                prev.next = next;
-                next.prev = prev;
-            }
-        }
-        cache = null;
-        insn.index = -1; // insn no longer belongs to an InsnList
-        insn.prev = null;
-        insn.next = null;
-    }
-
-    /**
-     * Removes all of the instructions of this list.
-     * 
-     * @param mark if the instructions must be marked as no longer belonging to
-     *        any {@link InsnList}.
-     */
-    private void removeAll(final boolean mark) {
-        if (mark) {
-            AbstractInsnNode insn = first;
-            while (insn != null) {
-                AbstractInsnNode next = insn.next;
-                insn.index = -1; // insn no longer belongs to an InsnList
-                insn.prev = null;
-                insn.next = null;
-                insn = next;
-            }
-        }
-        size = 0;
-        first = null;
-        last = null;
-        cache = null;
-    }
-
-    /**
-     * Removes all of the instructions of this list.
-     */
-    public void clear() {
-        removeAll(check);
-    }
-
-    /**
-     * Reset all labels in the instruction list. This method should be called
-     * before reusing same instructions list between several
-     * <code>ClassWriter</code>s.
-     */
-    public void resetLabels() {
-        AbstractInsnNode insn = first;
-        while (insn != null) {
-            if (insn instanceof LabelNode) {
-                ((LabelNode) insn).resetLabel();
-            }
-            insn = insn.next;
-        }
-    }
-    
-    private final class InsnListIterator implements ListIterator {
-        AbstractInsnNode next;
-        AbstractInsnNode prev;
-
-        InsnListIterator(int index) {
-            if(index==size()) {
-                next = null;
-                prev = getLast();
-            } else {
-                next = get(index);
-                prev = next.prev;
-            }
-        }
-
-        public boolean hasNext() {
-            return next != null;
-        }
-
-        public Object next() {
-            if (next == null) {
-                throw new NoSuchElementException();
-            }
-            AbstractInsnNode result = next;
-            prev = result;
-            next = result.next;
-            return result;
-        }
-
-        public void remove() {
-            InsnList.this.remove(prev);
-            prev = prev.prev;
-        }
-
-        public boolean hasPrevious() {
-            return prev != null;
-        }
-
-        public Object previous() {
-            AbstractInsnNode result = prev;
-            next = result;
-            prev = result.prev;
-            return result;
-        }
-
-        public int nextIndex() {
-            if (next == null) {
-                return size();
-            }
-            if (cache == null) {
-                cache = toArray();
-            }
-            return next.index;
-        }
-
-        public int previousIndex() {
-            if (prev == null) {
-                return -1;
-            }
-            if (cache == null) {
-                cache = toArray();
-            }
-            return prev.index;
-        }
-
-        public void add(Object o) {
-            InsnList.this.insertBefore(next, (AbstractInsnNode) o);
-            prev = (AbstractInsnNode) o;
-        }
-
-        public void set(Object o) {
-            InsnList.this.set(next.prev, (AbstractInsnNode) o);
-            prev = (AbstractInsnNode) o;
-        }
-    }
-
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/InsnNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/InsnNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/InsnNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/InsnNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,81 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-/**
- * A node that represents a zero operand instruction.
- * 
- * @author Eric Bruneton
- */
-public class InsnNode extends AbstractInsnNode {
-
-    /**
-     * Constructs a new {@link InsnNode}.
-     * 
-     * @param opcode the opcode of the instruction to be constructed. This
-     *        opcode must be NOP, ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1,
-     *        ICONST_2, ICONST_3, ICONST_4, ICONST_5, LCONST_0, LCONST_1,
-     *        FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD, LALOAD,
-     *        FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE,
-     *        FASTORE, DASTORE, AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2,
-     *        DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2, SWAP, IADD, LADD,
-     *        FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV,
-     *        LDIV, FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG,
-     *        ISHL, LSHL, ISHR, LSHR, IUSHR, LUSHR, IAND, LAND, IOR, LOR, IXOR,
-     *        LXOR, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I, D2L, D2F,
-     *        I2B, I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN,
-     *        FRETURN, DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW,
-     *        MONITORENTER, or MONITOREXIT.
-     */
-    public InsnNode(final int opcode) {
-        super(opcode);
-    }
-
-    public int getType() {
-        return INSN;
-    }
-
-    /**
-     * Makes the given visitor visit this instruction.
-     * 
-     * @param mv a method visitor.
-     */
-    public void accept(final MethodVisitor mv) {
-        mv.visitInsn(opcode);
-    }
-
-    public AbstractInsnNode clone(final Map labels) {
-        return new InsnNode(opcode);
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/IntInsnNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/IntInsnNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/IntInsnNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/IntInsnNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,81 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-/**
- * A node that represents an instruction with a single int operand.
- * 
- * @author Eric Bruneton
- */
-public class IntInsnNode extends AbstractInsnNode {
-
-    /**
-     * The operand of this instruction.
-     */
-    public int operand;
-
-    /**
-     * Constructs a new {@link IntInsnNode}.
-     * 
-     * @param opcode the opcode of the instruction to be constructed. This
-     *        opcode must be BIPUSH, SIPUSH or NEWARRAY.
-     * @param operand the operand of the instruction to be constructed.
-     */
-    public IntInsnNode(final int opcode, final int operand) {
-        super(opcode);
-        this.operand = operand;
-    }
-
-    /**
-     * Sets the opcode of this instruction.
-     * 
-     * @param opcode the new instruction opcode. This opcode must be BIPUSH,
-     *        SIPUSH or NEWARRAY.
-     */
-    public void setOpcode(final int opcode) {
-        this.opcode = opcode;
-    }
-
-    public int getType() {
-        return INT_INSN;
-    }
-
-    public void accept(final MethodVisitor mv) {
-        mv.visitIntInsn(opcode, operand);
-    }
-
-    public AbstractInsnNode clone(final Map labels) {
-        return new IntInsnNode(opcode, operand);
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/JumpInsnNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/JumpInsnNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/JumpInsnNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/JumpInsnNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,89 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-/**
- * A node that represents a jump instruction. A jump instruction is an
- * instruction that may jump to another instruction.
- * 
- * @author Eric Bruneton
- */
-public class JumpInsnNode extends AbstractInsnNode {
-
-    /**
-     * The operand of this instruction. This operand is a label that designates
-     * the instruction to which this instruction may jump.
-     */
-    public LabelNode label;
-
-    /**
-     * Constructs a new {@link JumpInsnNode}.
-     * 
-     * @param opcode the opcode of the type instruction to be constructed. This
-     *        opcode must be IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ,
-     *        IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ,
-     *        IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.
-     * @param label the operand of the instruction to be constructed. This
-     *        operand is a label that designates the instruction to which the
-     *        jump instruction may jump.
-     */
-    public JumpInsnNode(final int opcode, final LabelNode label) {
-        super(opcode);
-        this.label = label;
-    }
-
-    /**
-     * Sets the opcode of this instruction.
-     * 
-     * @param opcode the new instruction opcode. This opcode must be IFEQ, IFNE,
-     *        IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT,
-     *        IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR,
-     *        IFNULL or IFNONNULL.
-     */
-    public void setOpcode(final int opcode) {
-        this.opcode = opcode;
-    }
-
-    public int getType() {
-        return JUMP_INSN;
-    }
-
-    public void accept(final MethodVisitor mv) {
-        mv.visitJumpInsn(opcode, label.getLabel());
-    }
-
-    public AbstractInsnNode clone(final Map labels) {
-        return new JumpInsnNode(opcode, clone(label, labels));
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/LabelNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/LabelNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/LabelNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/LabelNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-/**
- * An {@link AbstractInsnNode} that encapsulates a {@link Label}.
- */
-public class LabelNode extends AbstractInsnNode {
-
-    private Label label;
-
-    public LabelNode() {
-        super(-1);
-    }
-
-    public LabelNode(final Label label) {
-        super(-1);
-        this.label = label;
-    }
-
-    public int getType() {
-        return LABEL;
-    }
-
-    public Label getLabel() {
-        if (label == null) {
-            label = new Label();
-        }
-        return label;
-    }
-
-    public void accept(final MethodVisitor cv) {
-        cv.visitLabel(getLabel());
-    }
-
-    public AbstractInsnNode clone(final Map labels) {
-        return (LabelNode) labels.get(this);
-    }
-
-    public void resetLabel() {
-        label = null;
-    }
-}
\ Manca newline alla fine del file
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/LdcInsnNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/LdcInsnNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/LdcInsnNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/LdcInsnNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,74 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-
-/**
- * A node that represents an LDC instruction.
- * 
- * @author Eric Bruneton
- */
-public class LdcInsnNode extends AbstractInsnNode {
-
-    /**
-     * The constant to be loaded on the stack. This parameter must be a non null
-     * {@link Integer}, a {@link Float}, a {@link Long}, a {@link Double}, a
-     * {@link String} or a {@link org.eclipse.persistence.internal.libraries.asm.Type}.
-     */
-    public Object cst;
-
-    /**
-     * Constructs a new {@link LdcInsnNode}.
-     * 
-     * @param cst the constant to be loaded on the stack. This parameter must be
-     *        a non null {@link Integer}, a {@link Float}, a {@link Long}, a
-     *        {@link Double} or a {@link String}.
-     */
-    public LdcInsnNode(final Object cst) {
-        super(Opcodes.LDC);
-        this.cst = cst;
-    }
-
-    public int getType() {
-        return LDC_INSN;
-    }
-
-    public void accept(final MethodVisitor mv) {
-        mv.visitLdcInsn(cst);
-    }
-
-    public AbstractInsnNode clone(final Map labels) {
-        return new LdcInsnNode(cst);
-    }
-}
\ Manca newline alla fine del file
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/LineNumberNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/LineNumberNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/LineNumberNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/LineNumberNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,79 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-/**
- * A node that represents a line number declaration. These nodes are pseudo
- * instruction nodes in order to be inserted in an instruction list.
- * 
- * @author Eric Bruneton
- */
-public class LineNumberNode extends AbstractInsnNode {
-
-    /**
-     * A line number. This number refers to the source file from which the class
-     * was compiled.
-     */
-    public int line;
-
-    /**
-     * The first instruction corresponding to this line number.
-     */
-    public LabelNode start;
-
-    /**
-     * Constructs a new {@link LineNumberNode}.
-     * 
-     * @param line a line number. This number refers to the source file from
-     *        which the class was compiled.
-     * @param start the first instruction corresponding to this line number.
-     */
-    public LineNumberNode(final int line, final LabelNode start) {
-        super(-1);
-        this.line = line;
-        this.start = start;
-    }
-
-    public int getType() {
-        return LINE;
-    }
-
-    public void accept(final MethodVisitor mv) {
-        mv.visitLineNumber(line, start.getLabel());
-    }
-
-    public AbstractInsnNode clone(final Map labels) {
-        return new LineNumberNode(line, clone(start, labels));
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/LocalVariableNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/LocalVariableNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/LocalVariableNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/LocalVariableNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,115 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-/**
- * A node that represents a local variable declaration.
- * 
- * @author Eric Bruneton
- */
-public class LocalVariableNode {
-
-    /**
-     * The name of a local variable.
-     */
-    public String name;
-
-    /**
-     * The type descriptor of this local variable.
-     */
-    public String desc;
-
-    /**
-     * The signature of this local variable. May be <tt>null</tt>.
-     */
-    public String signature;
-
-    /**
-     * The first instruction corresponding to the scope of this local variable
-     * (inclusive).
-     */
-    public LabelNode start;
-
-    /**
-     * The last instruction corresponding to the scope of this local variable
-     * (exclusive).
-     */
-    public LabelNode end;
-
-    /**
-     * The local variable's index.
-     */
-    public int index;
-
-    /**
-     * Constructs a new {@link LocalVariableNode}.
-     * 
-     * @param name the name of a local variable.
-     * @param desc the type descriptor of this local variable.
-     * @param signature the signature of this local variable. May be
-     *        <tt>null</tt>.
-     * @param start the first instruction corresponding to the scope of this
-     *        local variable (inclusive).
-     * @param end the last instruction corresponding to the scope of this local
-     *        variable (exclusive).
-     * @param index the local variable's index.
-     */
-    public LocalVariableNode(
-        final String name,
-        final String desc,
-        final String signature,
-        final LabelNode start,
-        final LabelNode end,
-        final int index)
-    {
-        this.name = name;
-        this.desc = desc;
-        this.signature = signature;
-        this.start = start;
-        this.end = end;
-        this.index = index;
-    }
-
-    /**
-     * Makes the given visitor visit this local variable declaration.
-     * 
-     * @param mv a method visitor.
-     */
-    public void accept(final MethodVisitor mv) {
-        mv.visitLocalVariable(name,
-                desc,
-                signature,
-                start.getLabel(),
-                end.getLabel(),
-                index);
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/LookupSwitchInsnNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/LookupSwitchInsnNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/LookupSwitchInsnNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/LookupSwitchInsnNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,113 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-
-import java.util.List;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Map;
-
-/**
- * A node that represents a LOOKUPSWITCH instruction.
- * 
- * @author Eric Bruneton
- */
-public class LookupSwitchInsnNode extends AbstractInsnNode {
-
-    /**
-     * Beginning of the default handler block.
-     */
-    public LabelNode dflt;
-
-    /**
-     * The values of the keys. This list is a list of {@link Integer} objects.
-     */
-    public List keys;
-
-    /**
-     * Beginnings of the handler blocks. This list is a list of
-     * {@link LabelNode} objects.
-     */
-    public List labels;
-
-    /**
-     * Constructs a new {@link LookupSwitchInsnNode}.
-     * 
-     * @param dflt beginning of the default handler block.
-     * @param keys the values of the keys.
-     * @param labels beginnings of the handler blocks. <tt>labels[i]</tt> is
-     *        the beginning of the handler block for the <tt>keys[i]</tt> key.
-     */
-    public LookupSwitchInsnNode(
-        final LabelNode dflt,
-        final int[] keys,
-        final LabelNode[] labels)
-    {
-        super(Opcodes.LOOKUPSWITCH);
-        this.dflt = dflt;
-        this.keys = new ArrayList(keys == null ? 0 : keys.length);
-        this.labels = new ArrayList(labels == null ? 0 : labels.length);
-        if (keys != null) {
-            for (int i = 0; i < keys.length; ++i) {
-                this.keys.add(new Integer(keys[i]));
-            }
-        }
-        if (labels != null) {
-            this.labels.addAll(Arrays.asList(labels));
-        }
-    }
-
-    public int getType() {
-        return LOOKUPSWITCH_INSN;
-    }
-
-    public void accept(final MethodVisitor mv) {
-        int[] keys = new int[this.keys.size()];
-        for (int i = 0; i < keys.length; ++i) {
-            keys[i] = ((Integer) this.keys.get(i)).intValue();
-        }
-        Label[] labels = new Label[this.labels.size()];
-        for (int i = 0; i < labels.length; ++i) {
-            labels[i] = ((LabelNode) this.labels.get(i)).getLabel();
-        }
-        mv.visitLookupSwitchInsn(dflt.getLabel(), keys, labels);
-    }
-
-    public AbstractInsnNode clone(final Map labels) {
-        LookupSwitchInsnNode clone = new LookupSwitchInsnNode(clone(dflt,
-                labels), null, clone(this.labels, labels));
-        clone.keys.addAll(keys);
-        return clone;
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/MemberNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/MemberNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/MemberNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/MemberNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,120 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-
-/**
- * An abstract class, field or method node.
- * 
- * @author Eric Bruneton
- */
-public abstract class MemberNode {
-
-    /**
-     * The runtime visible annotations of this class, field or method. This list
-     * is a list of {@link AnnotationNode} objects. May be <tt>null</tt>.
-     * 
-     * @associates org.objectweb.asm.tree.AnnotationNode
-     * @label visible
-     */
-    public List visibleAnnotations;
-
-    /**
-     * The runtime invisible annotations of this class, field or method. This
-     * list is a list of {@link AnnotationNode} objects. May be <tt>null</tt>.
-     * 
-     * @associates org.objectweb.asm.tree.AnnotationNode
-     * @label invisible
-     */
-    public List invisibleAnnotations;
-
-    /**
-     * The non standard attributes of this class, field or method. This list is
-     * a list of {@link Attribute} objects. May be <tt>null</tt>.
-     * 
-     * @associates org.objectweb.asm.Attribute
-     */
-    public List attrs;
-
-    /**
-     * Constructs a new {@link MemberNode}.
-     */
-    protected MemberNode() {
-    }
-
-    /**
-     * Visits an annotation of this class, field or method.
-     * 
-     * @param desc the class descriptor of the annotation class.
-     * @param visible <tt>true</tt> if the annotation is visible at runtime.
-     * @return a visitor to visit the annotation values.
-     */
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        AnnotationNode an = new AnnotationNode(desc);
-        if (visible) {
-            if (visibleAnnotations == null) {
-                visibleAnnotations = new ArrayList(1);
-            }
-            visibleAnnotations.add(an);
-        } else {
-            if (invisibleAnnotations == null) {
-                invisibleAnnotations = new ArrayList(1);
-            }
-            invisibleAnnotations.add(an);
-        }
-        return an;
-    }
-
-    /**
-     * Visits a non standard attribute of this class, field or method.
-     * 
-     * @param attr an attribute.
-     */
-    public void visitAttribute(final Attribute attr) {
-        if (attrs == null) {
-            attrs = new ArrayList(1);
-        }
-        attrs.add(attr);
-    }
-
-    /**
-     * Visits the end of this class, field or method.
-     */
-    public void visitEnd() {
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/MethodInsnNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/MethodInsnNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/MethodInsnNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/MethodInsnNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,105 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-/**
- * A node that represents a method instruction. A method instruction is an
- * instruction that invokes a method.
- * 
- * @author Eric Bruneton
- */
-public class MethodInsnNode extends AbstractInsnNode {
-
-    /**
-     * The internal name of the method's owner class (see
-     * {@link org.eclipse.persistence.internal.libraries.asm.Type#getInternalName() getInternalName}).
-     */
-    public String owner;
-
-    /**
-     * The method's name.
-     */
-    public String name;
-
-    /**
-     * The method's descriptor (see {@link org.eclipse.persistence.internal.libraries.asm.Type}).
-     */
-    public String desc;
-
-    /**
-     * Constructs a new {@link MethodInsnNode}.
-     * 
-     * @param opcode the opcode of the type instruction to be constructed. This
-     *        opcode must be INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC,
-     *        INVOKEINTERFACE or INVOKEDYNAMIC.
-     * @param owner the internal name of the method's owner class (see
-     *        {@link org.eclipse.persistence.internal.libraries.asm.Type#getInternalName() getInternalName})
-     *        or {@link org.eclipse.persistence.internal.libraries.asm.Opcodes#INVOKEDYNAMIC_OWNER}.
-     * @param name the method's name.
-     * @param desc the method's descriptor (see {@link org.eclipse.persistence.internal.libraries.asm.Type}).
-     */
-    public MethodInsnNode(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        super(opcode);
-        this.owner = owner;
-        this.name = name;
-        this.desc = desc;
-    }
-
-    /**
-     * Sets the opcode of this instruction.
-     * 
-     * @param opcode the new instruction opcode. This opcode must be
-     *        INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.
-     */
-    public void setOpcode(final int opcode) {
-        this.opcode = opcode;
-    }
-
-    public int getType() {
-        return METHOD_INSN;
-    }
-
-    public void accept(final MethodVisitor mv) {
-        mv.visitMethodInsn(opcode, owner, name, desc);
-    }
-
-    public AbstractInsnNode clone(final Map labels) {
-        return new MethodInsnNode(opcode, owner, name, desc);
-    }
-}
\ Manca newline alla fine del file
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/MethodNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/MethodNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/MethodNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/MethodNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,491 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-import org.eclipse.persistence.internal.libraries.asm.ClassVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-
-import java.util.List;
-import java.util.ArrayList;
-import java.util.Arrays;
-
-/**
- * A node that represents a method.
- * 
- * @author Eric Bruneton
- */
-public class MethodNode extends MemberNode implements MethodVisitor {
-
-    /**
-     * The method's access flags (see {@link Opcodes}). This field also
-     * indicates if the method is synthetic and/or deprecated.
-     */
-    public int access;
-
-    /**
-     * The method's name.
-     */
-    public String name;
-
-    /**
-     * The method's descriptor (see {@link Type}).
-     */
-    public String desc;
-
-    /**
-     * The method's signature. May be <tt>null</tt>.
-     */
-    public String signature;
-
-    /**
-     * The internal names of the method's exception classes (see
-     * {@link Type#getInternalName() getInternalName}). This list is a list of
-     * {@link String} objects.
-     */
-    public List exceptions;
-
-    /**
-     * The default value of this annotation interface method. This field must be
-     * a {@link Byte}, {@link Boolean}, {@link Character}, {@link Short},
-     * {@link Integer}, {@link Long}, {@link Float}, {@link Double},
-     * {@link String} or {@link Type}, or an two elements String array (for
-     * enumeration values), a {@link AnnotationNode}, or a {@link List} of
-     * values of one of the preceding types. May be <tt>null</tt>.
-     */
-    public Object annotationDefault;
-
-    /**
-     * The runtime visible parameter annotations of this method. These lists are
-     * lists of {@link AnnotationNode} objects. May be <tt>null</tt>.
-     * 
-     * @associates org.objectweb.asm.tree.AnnotationNode
-     * @label invisible parameters
-     */
-    public List[] visibleParameterAnnotations;
-
-    /**
-     * The runtime invisible parameter annotations of this method. These lists
-     * are lists of {@link AnnotationNode} objects. May be <tt>null</tt>.
-     * 
-     * @associates org.objectweb.asm.tree.AnnotationNode
-     * @label visible parameters
-     */
-    public List[] invisibleParameterAnnotations;
-
-    /**
-     * The instructions of this method. This list is a list of
-     * {@link AbstractInsnNode} objects.
-     * 
-     * @associates org.objectweb.asm.tree.AbstractInsnNode
-     * @label instructions
-     */
-    public InsnList instructions;
-
-    /**
-     * The try catch blocks of this method. This list is a list of
-     * {@link TryCatchBlockNode} objects.
-     * 
-     * @associates org.objectweb.asm.tree.TryCatchBlockNode
-     */
-    public List tryCatchBlocks;
-
-    /**
-     * The maximum stack size of this method.
-     */
-    public int maxStack;
-
-    /**
-     * The maximum number of local variables of this method.
-     */
-    public int maxLocals;
-
-    /**
-     * The local variables of this method. This list is a list of
-     * {@link LocalVariableNode} objects. May be <tt>null</tt>
-     * 
-     * @associates org.objectweb.asm.tree.LocalVariableNode
-     */
-    public List localVariables;
-
-    /**
-     * Constructs an unitialized {@link MethodNode}.
-     */
-    public MethodNode() {
-        this.instructions = new InsnList();
-    }
-    
-    /**
-     * Constructs a new {@link MethodNode}.
-     * 
-     * @param access the method's access flags (see {@link Opcodes}). This
-     *        parameter also indicates if the method is synthetic and/or
-     *        deprecated.
-     * @param name the method's name.
-     * @param desc the method's descriptor (see {@link Type}).
-     * @param signature the method's signature. May be <tt>null</tt>.
-     * @param exceptions the internal names of the method's exception classes
-     *        (see {@link Type#getInternalName() getInternalName}). May be
-     *        <tt>null</tt>.
-     */
-    public MethodNode(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final String[] exceptions)
-    {
-        this();
-        this.access = access;
-        this.name = name;
-        this.desc = desc;
-        this.signature = signature;
-        this.exceptions = new ArrayList(exceptions == null
-                ? 0
-                : exceptions.length);
-        boolean isAbstract = (access & Opcodes.ACC_ABSTRACT) != 0;
-        if (!isAbstract) {
-            this.localVariables = new ArrayList(5);
-        }
-        this.tryCatchBlocks = new ArrayList();
-        if (exceptions != null) {
-            this.exceptions.addAll(Arrays.asList(exceptions));
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Implementation of the MethodVisitor interface
-    // ------------------------------------------------------------------------
-
-    public AnnotationVisitor visitAnnotationDefault() {
-        return new AnnotationNode(new ArrayList(0) {
-            public boolean add(final Object o) {
-                annotationDefault = o;
-                return super.add(o);
-            }
-        });
-    }
-
-    public AnnotationVisitor visitParameterAnnotation(
-        final int parameter,
-        final String desc,
-        final boolean visible)
-    {
-        AnnotationNode an = new AnnotationNode(desc);
-        if (visible) {
-            if (visibleParameterAnnotations == null) {
-                int params = Type.getArgumentTypes(this.desc).length;
-                visibleParameterAnnotations = new List[params];
-            }
-            if (visibleParameterAnnotations[parameter] == null) {
-                visibleParameterAnnotations[parameter] = new ArrayList(1);
-            }
-            visibleParameterAnnotations[parameter].add(an);
-        } else {
-            if (invisibleParameterAnnotations == null) {
-                int params = Type.getArgumentTypes(this.desc).length;
-                invisibleParameterAnnotations = new List[params];
-            }
-            if (invisibleParameterAnnotations[parameter] == null) {
-                invisibleParameterAnnotations[parameter] = new ArrayList(1);
-            }
-            invisibleParameterAnnotations[parameter].add(an);
-        }
-        return an;
-    }
-
-    public void visitCode() {
-    }
-
-    public void visitFrame(
-        final int type,
-        final int nLocal,
-        final Object[] local,
-        final int nStack,
-        final Object[] stack)
-    {
-        instructions.add(new FrameNode(type, nLocal, local == null
-                ? null
-                : getLabelNodes(local), nStack, stack == null
-                ? null
-                : getLabelNodes(stack)));
-    }
-
-    public void visitInsn(final int opcode) {
-        instructions.add(new InsnNode(opcode));
-    }
-
-    public void visitIntInsn(final int opcode, final int operand) {
-        instructions.add(new IntInsnNode(opcode, operand));
-    }
-
-    public void visitVarInsn(final int opcode, final int var) {
-        instructions.add(new VarInsnNode(opcode, var));
-    }
-
-    public void visitTypeInsn(final int opcode, final String type) {
-        instructions.add(new TypeInsnNode(opcode, type));
-    }
-
-    public void visitFieldInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        instructions.add(new FieldInsnNode(opcode, owner, name, desc));
-    }
-
-    public void visitMethodInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        instructions.add(new MethodInsnNode(opcode, owner, name, desc));
-    }
-
-    public void visitJumpInsn(final int opcode, final Label label) {
-        instructions.add(new JumpInsnNode(opcode, getLabelNode(label)));
-    }
-
-    public void visitLabel(final Label label) {
-        instructions.add(getLabelNode(label));
-    }
-
-    public void visitLdcInsn(final Object cst) {
-        instructions.add(new LdcInsnNode(cst));
-    }
-
-    public void visitIincInsn(final int var, final int increment) {
-        instructions.add(new IincInsnNode(var, increment));
-    }
-
-    public void visitTableSwitchInsn(
-        final int min,
-        final int max,
-        final Label dflt,
-        final Label[] labels)
-    {
-        instructions.add(new TableSwitchInsnNode(min,
-                max,
-                getLabelNode(dflt),
-                getLabelNodes(labels)));
-    }
-
-    public void visitLookupSwitchInsn(
-        final Label dflt,
-        final int[] keys,
-        final Label[] labels)
-    {
-        instructions.add(new LookupSwitchInsnNode(getLabelNode(dflt),
-                keys,
-                getLabelNodes(labels)));
-    }
-
-    public void visitMultiANewArrayInsn(final String desc, final int dims) {
-        instructions.add(new MultiANewArrayInsnNode(desc, dims));
-    }
-
-    public void visitTryCatchBlock(
-        final Label start,
-        final Label end,
-        final Label handler,
-        final String type)
-    {
-        tryCatchBlocks.add(new TryCatchBlockNode(getLabelNode(start),
-                getLabelNode(end),
-                getLabelNode(handler),
-                type));
-    }
-
-    public void visitLocalVariable(
-        final String name,
-        final String desc,
-        final String signature,
-        final Label start,
-        final Label end,
-        final int index)
-    {
-        localVariables.add(new LocalVariableNode(name,
-                desc,
-                signature,
-                getLabelNode(start),
-                getLabelNode(end),
-                index));
-    }
-
-    public void visitLineNumber(final int line, final Label start) {
-        instructions.add(new LineNumberNode(line, getLabelNode(start)));
-    }
-
-    public void visitMaxs(final int maxStack, final int maxLocals) {
-        this.maxStack = maxStack;
-        this.maxLocals = maxLocals;
-    }
-
-    /**
-     * Returns the LabelNode corresponding to the given Label. Creates a new 
-     * LabelNode if necessary. The default implementation of this method uses
-     * the {@link Label#info} field to store associations between labels and
-     * label nodes.
-     * 
-     * @param l a Label.
-     * @return the LabelNode corresponding to l.
-     */    
-    protected LabelNode getLabelNode(final Label l) {
-        if (!(l.info instanceof LabelNode)) {
-            l.info = new LabelNode(l);
-        }
-        return (LabelNode) l.info;
-    }
-
-    private LabelNode[] getLabelNodes(final Label[] l) {
-        LabelNode[] nodes = new LabelNode[l.length];
-        for (int i = 0; i < l.length; ++i) {
-            nodes[i] = getLabelNode(l[i]);
-        }
-        return nodes;
-    }
-
-    private Object[] getLabelNodes(final Object[] objs) {
-        Object[] nodes = new Object[objs.length];
-        for (int i = 0; i < objs.length; ++i) {
-            Object o = objs[i];
-            if (o instanceof Label) {
-                o = getLabelNode((Label) o);
-            }
-            nodes[i] = o;
-        }
-        return nodes;
-    }
-
-    // ------------------------------------------------------------------------
-    // Accept method
-    // ------------------------------------------------------------------------
-
-    /**
-     * Makes the given class visitor visit this method.
-     * 
-     * @param cv a class visitor.
-     */
-    public void accept(final ClassVisitor cv) {
-        String[] exceptions = new String[this.exceptions.size()];
-        this.exceptions.toArray(exceptions);
-        MethodVisitor mv = cv.visitMethod(access,
-                name,
-                desc,
-                signature,
-                exceptions);
-        if (mv != null) {
-            accept(mv);
-        }
-    }
-
-    /**
-     * Makes the given method visitor visit this method.
-     * 
-     * @param mv a method visitor.
-     */
-    public void accept(final MethodVisitor mv) {
-        // visits the method attributes
-        int i, j, n;
-        if (annotationDefault != null) {
-            AnnotationVisitor av = mv.visitAnnotationDefault();
-            AnnotationNode.accept(av, null, annotationDefault);
-            if (av != null) {
-                av.visitEnd();
-            }
-        }
-        n = visibleAnnotations == null ? 0 : visibleAnnotations.size();
-        for (i = 0; i < n; ++i) {
-            AnnotationNode an = (AnnotationNode) visibleAnnotations.get(i);
-            an.accept(mv.visitAnnotation(an.desc, true));
-        }
-        n = invisibleAnnotations == null ? 0 : invisibleAnnotations.size();
-        for (i = 0; i < n; ++i) {
-            AnnotationNode an = (AnnotationNode) invisibleAnnotations.get(i);
-            an.accept(mv.visitAnnotation(an.desc, false));
-        }
-        n = visibleParameterAnnotations == null
-                ? 0
-                : visibleParameterAnnotations.length;
-        for (i = 0; i < n; ++i) {
-            List l = visibleParameterAnnotations[i];
-            if (l == null) {
-                continue;
-            }
-            for (j = 0; j < l.size(); ++j) {
-                AnnotationNode an = (AnnotationNode) l.get(j);
-                an.accept(mv.visitParameterAnnotation(i, an.desc, true));
-            }
-        }
-        n = invisibleParameterAnnotations == null
-                ? 0
-                : invisibleParameterAnnotations.length;
-        for (i = 0; i < n; ++i) {
-            List l = invisibleParameterAnnotations[i];
-            if (l == null) {
-                continue;
-            }
-            for (j = 0; j < l.size(); ++j) {
-                AnnotationNode an = (AnnotationNode) l.get(j);
-                an.accept(mv.visitParameterAnnotation(i, an.desc, false));
-            }
-        }
-        n = attrs == null ? 0 : attrs.size();
-        for (i = 0; i < n; ++i) {
-            mv.visitAttribute((Attribute) attrs.get(i));
-        }
-        // visits the method's code
-        if (instructions.size() > 0) {
-            mv.visitCode();
-            // visits try catch blocks
-            n = tryCatchBlocks == null ? 0 : tryCatchBlocks.size();
-            for (i = 0; i < n; ++i) {
-                ((TryCatchBlockNode) tryCatchBlocks.get(i)).accept(mv);
-            }
-            // visits instructions
-            instructions.accept(mv);
-            // visits local variables
-            n = localVariables == null ? 0 : localVariables.size();
-            for (i = 0; i < n; ++i) {
-                ((LocalVariableNode) localVariables.get(i)).accept(mv);
-            }
-            // visits maxs
-            mv.visitMaxs(maxStack, maxLocals);
-        }
-        mv.visitEnd();
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/MultiANewArrayInsnNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/MultiANewArrayInsnNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/MultiANewArrayInsnNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/MultiANewArrayInsnNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,78 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-
-/**
- * A node that represents a MULTIANEWARRAY instruction.
- * 
- * @author Eric Bruneton
- */
-public class MultiANewArrayInsnNode extends AbstractInsnNode {
-
-    /**
-     * An array type descriptor (see {@link org.eclipse.persistence.internal.libraries.asm.Type}).
-     */
-    public String desc;
-
-    /**
-     * Number of dimensions of the array to allocate.
-     */
-    public int dims;
-
-    /**
-     * Constructs a new {@link MultiANewArrayInsnNode}.
-     * 
-     * @param desc an array type descriptor (see {@link org.eclipse.persistence.internal.libraries.asm.Type}).
-     * @param dims number of dimensions of the array to allocate.
-     */
-    public MultiANewArrayInsnNode(final String desc, final int dims) {
-        super(Opcodes.MULTIANEWARRAY);
-        this.desc = desc;
-        this.dims = dims;
-    }
-
-    public int getType() {
-        return MULTIANEWARRAY_INSN;
-    }
-
-    public void accept(final MethodVisitor mv) {
-        mv.visitMultiANewArrayInsn(desc, dims);
-    }
-
-    public AbstractInsnNode clone(final Map labels) {
-        return new MultiANewArrayInsnNode(desc, dims);
-    }
-
-}
\ Manca newline alla fine del file
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/package.html eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/package.html
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/package.html	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/package.html	1970-01-01 01:00:00.000000000 +0100
@@ -1,192 +0,0 @@
-<html>
-<!--
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2005 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
--->
-<body>
-  
-<p>  
-Provides an ASM visitor that constructs a tree representation of the
-classes it visits. This class adapter can be useful to implement "complex"
-class manipulation operations, i.e., operations that would be very hard to
-implement without using a tree representation (such as optimizing the number
-of local variables used by a method).
-</p>
-  
-<p>
-However, this class adapter has a cost: it makes ASM bigger and slower. Indeed
-it requires more than twenty new classes, and multiplies the time needed to
-transform a class by almost two (it is almost two times faster to read, "modify"
-and write a class with a ClassAdapter than with a ClassNode). This is why
-this package is bundled in an optional <tt>asm-tree.jar</tt> library that
-is separated from (but requires) the <tt>asm.jar</tt> library, which contains
-the core ASM framework. This is also why <i><font color="red">it is recommended
-not to use this class adapter when it is possible</font></i>.
-</p>
-
-<p>
-The root class is the ClassNode, that can be created from existing bytecode. For example:
-</p>
-  
-<pre>
-  ClassReader cr = new ClassReader(source);
-  ClassNode cn = new ClassNode();
-  cr.accept(cn, true);
-</pre>
-
-<p>
-Now content of ClassNode can be modified and then
-serialized back into bytecode:
-</p>
-
-<pre>
-  ClassWriter cw = new ClassWriter(true);
-  cn.accept(cw);
-</pre>  
-
-<p>
-Using simple ClassAdapter it is possible to create MethodNode instances per-method.
-In this example MethodNode is acting as a buffer that is flushed out at visitEnd() call:
-</p>
-
-<pre>
-  ClassReader cr = new ClassReader(source);
-  ClassWriter cw = new ClassWriter();
-  ClassAdapter ca = new ClassAdapter(cw) {
-      public MethodVisitor visitMethod(int access, String name, 
-          String desc, String signature, String[] exceptions) {
-        final MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);
-        MethodNode mn = new MethodNode(access, name, desc, signature, exceptions) {
-            public void visitEnd() {
-              // transform or analyze method code using tree API
-              accept(mv);
-            }
-          };
-      }
-    };
-  cr.accept(ca, true);
-</pre>
-
-<p>  
-Several strategies can be used to construct method code from scratch. The first
-option is to create a MethodNode, and then create XXXInsnNode instances and 
-add them to the instructions list:
-</p>
-
-<pre>
-MethodNode m = new MethodNode(...);
-m.instructions.add(new VarInsnNode(ALOAD, 0));
-...
-</pre>
-
-<p>
-Alternatively, you can use the fact that MethodNode is a MethodVisitor, and use
-that to create the XXXInsnNode and add them to the instructions list through
-the standard MethodVisitor interface:
-</p>
-
-<pre>
-MethodNode m = new MethodNode(...);
-m.visitVarInsn(ALOAD, 0);
-...
-</pre>
-
-<p>
-If you cannot generate all the instructions in sequential order, i.e. if you 
-need to save some pointer in the instruction list and then insert instructions
-at that place after other instructions have been generated, you can use InsnList 
-methods insert() and insertBefore() to insert instructions at saved pointer.
-</p>
-
-<pre>
-MethodNode m = new MethodNode(...);
-m.visitVarInsn(ALOAD, 0);
-AbstractInsnNode ptr = m.instructions.getLast();
-m.visitVarInsn(ALOAD, 1);
-// inserts an instruction between ALOAD 0 and ALOAD 1
-m.instructions.insert(ptr, new VarInsnNode(ALOAD, 0));
-...
-</pre>
-
-<p>
-If you need to insert instructions while iterating over an existing instruction 
-list, you can also use several strategies. The first one is to use a 
-ListIterator over the instruction list:
-</p>
-
-<pre>
-ListIterator it = m.instructions.iterator();
-while (it.hasNext()) {
-    AbstractInsnNode n = (AbstractInsnNode) it.next();
-    if (...) {
-        it.add(new VarInsnNode(ALOAD, 0));
-    }
-}
-</pre>
-
-<p>
-It is also possible to convert instruction list into the array and iterate trough
-array elements:
-</p>
-
-<pre>
-AbstractInsnNode[] insns = m.instructions.toArray();
-for(int i = 0; i&lt;insns.length; i++) {
-    AbstractInsnNode n = insns[i];
-    if (...) {
-        m.instructions.insert(n, new VarInsnNode(ALOAD, 0));
-    }
-}
-</pre>
-
-<p>
-If you want to insert these instructions through the MethodVisitor interface,
-you can use another instance of MethodNode as a MethodVisitor and then 
-insert instructions collected by that instance into the instruction list. 
-For example:
-</p>
-
-<pre>
-AbstractInsnNode[] insns = m.instructions.toArray();
-for(int i = 0; i&lt;insns.length; i++) {
-    AbstractInsnNode n = insns[i];
-    if (...) {
-        MethodNode mn = new MethodNode();
-        mn.visitVarInsn(ALOAD, 0);
-        mn.visitVarInsn(ALOAD, 1);
-        m.instructions.insert(n, mn.instructions);
-    }
-}
-</pre>
-
-<p>  
-@since ASM 1.3.3
-</p>
-    
-</body>
-</html>
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/TableSwitchInsnNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/TableSwitchInsnNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/TableSwitchInsnNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/TableSwitchInsnNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,112 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-
-/**
- * A node that represents a TABLESWITCH instruction.
- * 
- * @author Eric Bruneton
- */
-public class TableSwitchInsnNode extends AbstractInsnNode {
-
-    /**
-     * The minimum key value.
-     */
-    public int min;
-
-    /**
-     * The maximum key value.
-     */
-    public int max;
-
-    /**
-     * Beginning of the default handler block.
-     */
-    public LabelNode dflt;
-
-    /**
-     * Beginnings of the handler blocks. This list is a list of
-     * {@link LabelNode} objects.
-     */
-    public List labels;
-
-    /**
-     * Constructs a new {@link TableSwitchInsnNode}.
-     * 
-     * @param min the minimum key value.
-     * @param max the maximum key value.
-     * @param dflt beginning of the default handler block.
-     * @param labels beginnings of the handler blocks. <tt>labels[i]</tt> is
-     *        the beginning of the handler block for the <tt>min + i</tt> key.
-     */
-    public TableSwitchInsnNode(
-        final int min,
-        final int max,
-        final LabelNode dflt,
-        final LabelNode[] labels)
-    {
-        super(Opcodes.TABLESWITCH);
-        this.min = min;
-        this.max = max;
-        this.dflt = dflt;
-        this.labels = new ArrayList();
-        if (labels != null) {
-            this.labels.addAll(Arrays.asList(labels));
-        }
-    }
-
-    public int getType() {
-        return TABLESWITCH_INSN;
-    }
-
-    public void accept(final MethodVisitor mv) {
-        Label[] labels = new Label[this.labels.size()];
-        for (int i = 0; i < labels.length; ++i) {
-            labels[i] = ((LabelNode) this.labels.get(i)).getLabel();
-        }
-        mv.visitTableSwitchInsn(min, max, dflt.getLabel(), labels);
-    }
-
-    public AbstractInsnNode clone(final Map labels) {
-        return new TableSwitchInsnNode(min,
-                max,
-                clone(dflt, labels),
-                clone(this.labels, labels));
-    }
-}
\ Manca newline alla fine del file
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/TryCatchBlockNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/TryCatchBlockNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/TryCatchBlockNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/TryCatchBlockNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,94 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-/**
- * A node that represents a try catch block.
- * 
- * @author Eric Bruneton
- */
-public class TryCatchBlockNode {
-
-    /**
-     * Beginning of the exception handler's scope (inclusive).
-     */
-    public LabelNode start;
-
-    /**
-     * End of the exception handler's scope (exclusive).
-     */
-    public LabelNode end;
-
-    /**
-     * Beginning of the exception handler's code.
-     */
-    public LabelNode handler;
-
-    /**
-     * Internal name of the type of exceptions handled by the handler. May be
-     * <tt>null</tt> to catch any exceptions (for "finally" blocks).
-     */
-    public String type;
-
-    /**
-     * Constructs a new {@link TryCatchBlockNode}.
-     * 
-     * @param start beginning of the exception handler's scope (inclusive).
-     * @param end end of the exception handler's scope (exclusive).
-     * @param handler beginning of the exception handler's code.
-     * @param type internal name of the type of exceptions handled by the
-     *        handler, or <tt>null</tt> to catch any exceptions (for "finally"
-     *        blocks).
-     */
-    public TryCatchBlockNode(
-        final LabelNode start,
-        final LabelNode end,
-        final LabelNode handler,
-        final String type)
-    {
-        this.start = start;
-        this.end = end;
-        this.handler = handler;
-        this.type = type;
-    }
-
-    /**
-     * Makes the given visitor visit this try catch block.
-     * 
-     * @param mv a method visitor.
-     */
-    public void accept(final MethodVisitor mv) {
-        mv.visitTryCatchBlock(start.getLabel(), end.getLabel(), handler == null
-                ? null
-                : handler.getLabel(), type);
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/TypeInsnNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/TypeInsnNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/TypeInsnNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/TypeInsnNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,84 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-/**
- * A node that represents a type instruction. A type instruction is an
- * instruction that takes a type descriptor as parameter.
- * 
- * @author Eric Bruneton
- */
-public class TypeInsnNode extends AbstractInsnNode {
-
-    /**
-     * The operand of this instruction. This operand is an internal name (see
-     * {@link org.eclipse.persistence.internal.libraries.asm.Type}).
-     */
-    public String desc;
-
-    /**
-     * Constructs a new {@link TypeInsnNode}.
-     * 
-     * @param opcode the opcode of the type instruction to be constructed. This
-     *        opcode must be NEW, ANEWARRAY, CHECKCAST or INSTANCEOF.
-     * @param desc the operand of the instruction to be constructed. This
-     *        operand is an internal name (see {@link org.eclipse.persistence.internal.libraries.asm.Type}).
-     */
-    public TypeInsnNode(final int opcode, final String desc) {
-        super(opcode);
-        this.desc = desc;
-    }
-
-    /**
-     * Sets the opcode of this instruction.
-     * 
-     * @param opcode the new instruction opcode. This opcode must be NEW,
-     *        ANEWARRAY, CHECKCAST or INSTANCEOF.
-     */
-    public void setOpcode(final int opcode) {
-        this.opcode = opcode;
-    }
-
-    public int getType() {
-        return TYPE_INSN;
-    }
-
-    public void accept(final MethodVisitor mv) {
-        mv.visitTypeInsn(opcode, desc);
-    }
-
-    public AbstractInsnNode clone(final Map labels) {
-        return new TypeInsnNode(opcode, desc);
-    }
-}
\ Manca newline alla fine del file
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/VarInsnNode.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/VarInsnNode.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/tree/VarInsnNode.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/tree/VarInsnNode.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,87 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.tree;
-
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-
-/**
- * A node that represents a local variable instruction. A local variable
- * instruction is an instruction that loads or stores the value of a local
- * variable.
- * 
- * @author Eric Bruneton
- */
-public class VarInsnNode extends AbstractInsnNode {
-
-    /**
-     * The operand of this instruction. This operand is the index of a local
-     * variable.
-     */
-    public int var;
-
-    /**
-     * Constructs a new {@link VarInsnNode}.
-     * 
-     * @param opcode the opcode of the local variable instruction to be
-     *        constructed. This opcode must be ILOAD, LLOAD, FLOAD, DLOAD,
-     *        ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.
-     * @param var the operand of the instruction to be constructed. This operand
-     *        is the index of a local variable.
-     */
-    public VarInsnNode(final int opcode, final int var) {
-        super(opcode);
-        this.var = var;
-    }
-
-    /**
-     * Sets the opcode of this instruction.
-     * 
-     * @param opcode the new instruction opcode. This opcode must be ILOAD,
-     *        LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE
-     *        or RET.
-     */
-    public void setOpcode(final int opcode) {
-        this.opcode = opcode;
-    }
-
-    public int getType() {
-        return VAR_INSN;
-    }
-
-    public void accept(final MethodVisitor mv) {
-        mv.visitVarInsn(opcode, var);
-    }
-
-    public AbstractInsnNode clone(final Map labels) {
-        return new VarInsnNode(opcode, var);
-    }
-}
\ Manca newline alla fine del file
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/Type.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/Type.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/Type.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/Type.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,772 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
-
-/**
- * A Java type. This class can be used to make it easier to manipulate type and
- * method descriptors.
- * 
- * @author Eric Bruneton
- * @author Chris Nokleberg
- */
-public class Type {
-
-    /**
-     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.
-     */
-    public static final int VOID = 0;
-
-    /**
-     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.
-     */
-    public static final int BOOLEAN = 1;
-
-    /**
-     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.
-     */
-    public static final int CHAR = 2;
-
-    /**
-     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.
-     */
-    public static final int BYTE = 3;
-
-    /**
-     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.
-     */
-    public static final int SHORT = 4;
-
-    /**
-     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.
-     */
-    public static final int INT = 5;
-
-    /**
-     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.
-     */
-    public static final int FLOAT = 6;
-
-    /**
-     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.
-     */
-    public static final int LONG = 7;
-
-    /**
-     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.
-     */
-    public static final int DOUBLE = 8;
-
-    /**
-     * The sort of array reference types. See {@link #getSort getSort}.
-     */
-    public static final int ARRAY = 9;
-
-    /**
-     * The sort of object reference type. See {@link #getSort getSort}.
-     */
-    public static final int OBJECT = 10;
-
-    /**
-     * The <tt>void</tt> type.
-     */
-    public static final Type VOID_TYPE = new Type(VOID, null, ('V' << 24)
-            | (5 << 16) | (0 << 8) | 0, 1);
-
-    /**
-     * The <tt>boolean</tt> type.
-     */
-    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN, null, ('Z' << 24)
-            | (0 << 16) | (5 << 8) | 1, 1);
-
-    /**
-     * The <tt>char</tt> type.
-     */
-    public static final Type CHAR_TYPE = new Type(CHAR, null, ('C' << 24)
-            | (0 << 16) | (6 << 8) | 1, 1);
-
-    /**
-     * The <tt>byte</tt> type.
-     */
-    public static final Type BYTE_TYPE = new Type(BYTE, null, ('B' << 24)
-            | (0 << 16) | (5 << 8) | 1, 1);
-
-    /**
-     * The <tt>short</tt> type.
-     */
-    public static final Type SHORT_TYPE = new Type(SHORT, null, ('S' << 24)
-            | (0 << 16) | (7 << 8) | 1, 1);
-
-    /**
-     * The <tt>int</tt> type.
-     */
-    public static final Type INT_TYPE = new Type(INT, null, ('I' << 24)
-            | (0 << 16) | (0 << 8) | 1, 1);
-
-    /**
-     * The <tt>float</tt> type.
-     */
-    public static final Type FLOAT_TYPE = new Type(FLOAT, null, ('F' << 24)
-            | (2 << 16) | (2 << 8) | 1, 1);
-
-    /**
-     * The <tt>long</tt> type.
-     */
-    public static final Type LONG_TYPE = new Type(LONG, null, ('J' << 24)
-            | (1 << 16) | (1 << 8) | 2, 1);
-
-    /**
-     * The <tt>double</tt> type.
-     */
-    public static final Type DOUBLE_TYPE = new Type(DOUBLE, null, ('D' << 24)
-            | (3 << 16) | (3 << 8) | 2, 1);
-
-    // ------------------------------------------------------------------------
-    // Fields
-    // ------------------------------------------------------------------------
-
-    /**
-     * The sort of this Java type.
-     */
-    private final int sort;
-
-    /**
-     * A buffer containing the internal name of this Java type. This field is
-     * only used for reference types.
-     */
-    private final char[] buf;
-
-    /**
-     * The offset of the internal name of this Java type in {@link #buf buf} or,
-     * for primitive types, the size, descriptor and getOpcode offsets for this
-     * type (byte 0 contains the size, byte 1 the descriptor, byte 2 the offset
-     * for IALOAD or IASTORE, byte 3 the offset for all other instructions).
-     */
-    private final int off;
-
-    /**
-     * The length of the internal name of this Java type.
-     */
-    private final int len;
-
-    // ------------------------------------------------------------------------
-    // Constructors
-    // ------------------------------------------------------------------------
-
-    /**
-     * Constructs a reference type.
-     * 
-     * @param sort the sort of the reference type to be constructed.
-     * @param buf a buffer containing the descriptor of the previous type.
-     * @param off the offset of this descriptor in the previous buffer.
-     * @param len the length of this descriptor.
-     */
-    private Type(final int sort, final char[] buf, final int off, final int len)
-    {
-        this.sort = sort;
-        this.buf = buf;
-        this.off = off;
-        this.len = len;
-    }
-
-    /**
-     * Returns the Java type corresponding to the given type descriptor.
-     * 
-     * @param typeDescriptor a type descriptor.
-     * @return the Java type corresponding to the given type descriptor.
-     */
-    public static Type getType(final String typeDescriptor) {
-        return getType(typeDescriptor.toCharArray(), 0);
-    }
-
-    /**
-     * Returns the Java type corresponding to the given internal name.
-     * 
-     * @param internalName an internal name.
-     * @return the Java type corresponding to the given internal name.
-     */
-    public static Type getObjectType(final String internalName) {
-        char[] buf = internalName.toCharArray();
-        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);
-    }
-
-    /**
-     * Returns the Java type corresponding to the given class.
-     * 
-     * @param c a class.
-     * @return the Java type corresponding to the given class.
-     */
-    public static Type getType(final Class c) {
-        if (c.isPrimitive()) {
-            if (c == Integer.TYPE) {
-                return INT_TYPE;
-            } else if (c == Void.TYPE) {
-                return VOID_TYPE;
-            } else if (c == Boolean.TYPE) {
-                return BOOLEAN_TYPE;
-            } else if (c == Byte.TYPE) {
-                return BYTE_TYPE;
-            } else if (c == Character.TYPE) {
-                return CHAR_TYPE;
-            } else if (c == Short.TYPE) {
-                return SHORT_TYPE;
-            } else if (c == Double.TYPE) {
-                return DOUBLE_TYPE;
-            } else if (c == Float.TYPE) {
-                return FLOAT_TYPE;
-            } else /* if (c == Long.TYPE) */{
-                return LONG_TYPE;
-            }
-        } else {
-            return getType(getDescriptor(c));
-        }
-    }
-
-    /**
-     * Returns the Java types corresponding to the argument types of the given
-     * method descriptor.
-     * 
-     * @param methodDescriptor a method descriptor.
-     * @return the Java types corresponding to the argument types of the given
-     *         method descriptor.
-     */
-    public static Type[] getArgumentTypes(final String methodDescriptor) {
-        char[] buf = methodDescriptor.toCharArray();
-        int off = 1;
-        int size = 0;
-        while (true) {
-            char car = buf[off++];
-            if (car == ')') {
-                break;
-            } else if (car == 'L') {
-                while (buf[off++] != ';') {
-                }
-                ++size;
-            } else if (car != '[') {
-                ++size;
-            }
-        }
-        Type[] args = new Type[size];
-        off = 1;
-        size = 0;
-        while (buf[off] != ')') {
-            args[size] = getType(buf, off);
-            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);
-            size += 1;
-        }
-        return args;
-    }
-
-    /**
-     * Returns the Java types corresponding to the argument types of the given
-     * method.
-     * 
-     * @param method a method.
-     * @return the Java types corresponding to the argument types of the given
-     *         method.
-     */
-    public static Type[] getArgumentTypes(final Method method) {
-        Class[] classes = method.getParameterTypes();
-        Type[] types = new Type[classes.length];
-        for (int i = classes.length - 1; i >= 0; --i) {
-            types[i] = getType(classes[i]);
-        }
-        return types;
-    }
-
-    /**
-     * Returns the Java type corresponding to the return type of the given
-     * method descriptor.
-     * 
-     * @param methodDescriptor a method descriptor.
-     * @return the Java type corresponding to the return type of the given
-     *         method descriptor.
-     */
-    public static Type getReturnType(final String methodDescriptor) {
-        char[] buf = methodDescriptor.toCharArray();
-        return getType(buf, methodDescriptor.indexOf(')') + 1);
-    }
-
-    /**
-     * Returns the Java type corresponding to the return type of the given
-     * method.
-     * 
-     * @param method a method.
-     * @return the Java type corresponding to the return type of the given
-     *         method.
-     */
-    public static Type getReturnType(final Method method) {
-        return getType(method.getReturnType());
-    }
-
-    /**
-     * Computes the size of the arguments and of the return value of a method.
-     * 
-     * @param desc the descriptor of a method.
-     * @return the size of the arguments of the method (plus one for the
-     *         implicit this argument), argSize, and the size of its return
-     *         value, retSize, packed into a single int i =
-     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal
-     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).
-     */
-    public static int getArgumentsAndReturnSizes(final String desc) {
-        int n = 1;
-        int c = 1;
-        while (true) {
-            char car = desc.charAt(c++);
-            if (car == ')') {
-                car = desc.charAt(c);
-                return n << 2
-                        | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));
-            } else if (car == 'L') {
-                while (desc.charAt(c++) != ';') {
-                }
-                n += 1;
-            } else if (car == '[') {
-                while ((car = desc.charAt(c)) == '[') {
-                    ++c;
-                }
-                if (car == 'D' || car == 'J') {
-                    n -= 1;
-                }
-            } else if (car == 'D' || car == 'J') {
-                n += 2;
-            } else {
-                n += 1;
-            }
-        }
-    }
-
-    /**
-     * Returns the Java type corresponding to the given type descriptor.
-     * 
-     * @param buf a buffer containing a type descriptor.
-     * @param off the offset of this descriptor in the previous buffer.
-     * @return the Java type corresponding to the given type descriptor.
-     */
-    private static Type getType(final char[] buf, final int off) {
-        int len;
-        switch (buf[off]) {
-            case 'V':
-                return VOID_TYPE;
-            case 'Z':
-                return BOOLEAN_TYPE;
-            case 'C':
-                return CHAR_TYPE;
-            case 'B':
-                return BYTE_TYPE;
-            case 'S':
-                return SHORT_TYPE;
-            case 'I':
-                return INT_TYPE;
-            case 'F':
-                return FLOAT_TYPE;
-            case 'J':
-                return LONG_TYPE;
-            case 'D':
-                return DOUBLE_TYPE;
-            case '[':
-                len = 1;
-                while (buf[off + len] == '[') {
-                    ++len;
-                }
-                if (buf[off + len] == 'L') {
-                    ++len;
-                    while (buf[off + len] != ';') {
-                        ++len;
-                    }
-                }
-                return new Type(ARRAY, buf, off, len + 1);
-                // case 'L':
-            default:
-                len = 1;
-                while (buf[off + len] != ';') {
-                    ++len;
-                }
-                return new Type(OBJECT, buf, off + 1, len - 1);
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Accessors
-    // ------------------------------------------------------------------------
-
-    /**
-     * Returns the sort of this Java type.
-     * 
-     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},
-     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},
-     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},
-     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or
-     *         {@link #OBJECT OBJECT}.
-     */
-    public int getSort() {
-        return sort;
-    }
-
-    /**
-     * Returns the number of dimensions of this array type. This method should
-     * only be used for an array type.
-     * 
-     * @return the number of dimensions of this array type.
-     */
-    public int getDimensions() {
-        int i = 1;
-        while (buf[off + i] == '[') {
-            ++i;
-        }
-        return i;
-    }
-
-    /**
-     * Returns the type of the elements of this array type. This method should
-     * only be used for an array type.
-     * 
-     * @return Returns the type of the elements of this array type.
-     */
-    public Type getElementType() {
-        return getType(buf, off + getDimensions());
-    }
-
-    /**
-     * Returns the name of the class corresponding to this type.
-     * 
-     * @return the fully qualified name of the class corresponding to this type.
-     */
-    public String getClassName() {
-        switch (sort) {
-            case VOID:
-                return "void";
-            case BOOLEAN:
-                return "boolean";
-            case CHAR:
-                return "char";
-            case BYTE:
-                return "byte";
-            case SHORT:
-                return "short";
-            case INT:
-                return "int";
-            case FLOAT:
-                return "float";
-            case LONG:
-                return "long";
-            case DOUBLE:
-                return "double";
-            case ARRAY:
-                StringBuffer b = new StringBuffer(getElementType().getClassName());
-                for (int i = getDimensions(); i > 0; --i) {
-                    b.append("[]");
-                }
-                return b.toString();
-                // case OBJECT:
-            default:
-                return new String(buf, off, len).replace('/', '.');
-        }
-    }
-
-    /**
-     * Returns the internal name of the class corresponding to this object or
-     * array type. The internal name of a class is its fully qualified name (as
-     * returned by Class.getName(), where '.' are replaced by '/'. This method
-     * should only be used for an object or array type.
-     * 
-     * @return the internal name of the class corresponding to this object type.
-     */
-    public String getInternalName() {
-        return new String(buf, off, len);
-    }
-
-    // ------------------------------------------------------------------------
-    // Conversion to type descriptors
-    // ------------------------------------------------------------------------
-
-    /**
-     * Returns the descriptor corresponding to this Java type.
-     * 
-     * @return the descriptor corresponding to this Java type.
-     */
-    public String getDescriptor() {
-        StringBuffer buf = new StringBuffer();
-        getDescriptor(buf);
-        return buf.toString();
-    }
-
-    /**
-     * Returns the descriptor corresponding to the given argument and return
-     * types.
-     * 
-     * @param returnType the return type of the method.
-     * @param argumentTypes the argument types of the method.
-     * @return the descriptor corresponding to the given argument and return
-     *         types.
-     */
-    public static String getMethodDescriptor(
-        final Type returnType,
-        final Type[] argumentTypes)
-    {
-        StringBuffer buf = new StringBuffer();
-        buf.append('(');
-        for (int i = 0; i < argumentTypes.length; ++i) {
-            argumentTypes[i].getDescriptor(buf);
-        }
-        buf.append(')');
-        returnType.getDescriptor(buf);
-        return buf.toString();
-    }
-
-    /**
-     * Appends the descriptor corresponding to this Java type to the given
-     * string buffer.
-     * 
-     * @param buf the string buffer to which the descriptor must be appended.
-     */
-    private void getDescriptor(final StringBuffer buf) {
-        if (this.buf == null) {
-            // descriptor is in byte 3 of 'off' for primitive types (buf == null)
-            buf.append((char) ((off & 0xFF000000) >>> 24));
-        } else if (sort == ARRAY) {
-            buf.append(this.buf, off, len);
-        } else { // sort == OBJECT
-            buf.append('L');
-            buf.append(this.buf, off, len);
-            buf.append(';');
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Direct conversion from classes to type descriptors,
-    // without intermediate Type objects
-    // ------------------------------------------------------------------------
-
-    /**
-     * Returns the internal name of the given class. The internal name of a
-     * class is its fully qualified name, as returned by Class.getName(), where
-     * '.' are replaced by '/'.
-     * 
-     * @param c an object or array class.
-     * @return the internal name of the given class.
-     */
-    public static String getInternalName(final Class c) {
-        return c.getName().replace('.', '/');
-    }
-
-    /**
-     * Returns the descriptor corresponding to the given Java type.
-     * 
-     * @param c an object class, a primitive class or an array class.
-     * @return the descriptor corresponding to the given class.
-     */
-    public static String getDescriptor(final Class c) {
-        StringBuffer buf = new StringBuffer();
-        getDescriptor(buf, c);
-        return buf.toString();
-    }
-
-    /**
-     * Returns the descriptor corresponding to the given constructor.
-     * 
-     * @param c a {@link Constructor Constructor} object.
-     * @return the descriptor of the given constructor.
-     */
-    public static String getConstructorDescriptor(final Constructor c) {
-        Class[] parameters = c.getParameterTypes();
-        StringBuffer buf = new StringBuffer();
-        buf.append('(');
-        for (int i = 0; i < parameters.length; ++i) {
-            getDescriptor(buf, parameters[i]);
-        }
-        return buf.append(")V").toString();
-    }
-
-    /**
-     * Returns the descriptor corresponding to the given method.
-     * 
-     * @param m a {@link Method Method} object.
-     * @return the descriptor of the given method.
-     */
-    public static String getMethodDescriptor(final Method m) {
-        Class[] parameters = m.getParameterTypes();
-        StringBuffer buf = new StringBuffer();
-        buf.append('(');
-        for (int i = 0; i < parameters.length; ++i) {
-            getDescriptor(buf, parameters[i]);
-        }
-        buf.append(')');
-        getDescriptor(buf, m.getReturnType());
-        return buf.toString();
-    }
-
-    /**
-     * Appends the descriptor of the given class to the given string buffer.
-     * 
-     * @param buf the string buffer to which the descriptor must be appended.
-     * @param c the class whose descriptor must be computed.
-     */
-    private static void getDescriptor(final StringBuffer buf, final Class c) {
-        Class d = c;
-        while (true) {
-            if (d.isPrimitive()) {
-                char car;
-                if (d == Integer.TYPE) {
-                    car = 'I';
-                } else if (d == Void.TYPE) {
-                    car = 'V';
-                } else if (d == Boolean.TYPE) {
-                    car = 'Z';
-                } else if (d == Byte.TYPE) {
-                    car = 'B';
-                } else if (d == Character.TYPE) {
-                    car = 'C';
-                } else if (d == Short.TYPE) {
-                    car = 'S';
-                } else if (d == Double.TYPE) {
-                    car = 'D';
-                } else if (d == Float.TYPE) {
-                    car = 'F';
-                } else /* if (d == Long.TYPE) */{
-                    car = 'J';
-                }
-                buf.append(car);
-                return;
-            } else if (d.isArray()) {
-                buf.append('[');
-                d = d.getComponentType();
-            } else {
-                buf.append('L');
-                String name = d.getName();
-                int len = name.length();
-                for (int i = 0; i < len; ++i) {
-                    char car = name.charAt(i);
-                    buf.append(car == '.' ? '/' : car);
-                }
-                buf.append(';');
-                return;
-            }
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Corresponding size and opcodes
-    // ------------------------------------------------------------------------
-
-    /**
-     * Returns the size of values of this type.
-     * 
-     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and
-     *         <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.
-     */
-    public int getSize() {
-        // the size is in byte 0 of 'off' for primitive types (buf == null)
-        return buf == null ? (off & 0xFF) : 1;
-    }
-
-    /**
-     * Returns a JVM instruction opcode adapted to this Java type.
-     * 
-     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,
-     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,
-     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.
-     * @return an opcode that is similar to the given opcode, but adapted to
-     *         this Java type. For example, if this type is <tt>float</tt> and
-     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.
-     */
-    public int getOpcode(final int opcode) {
-        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {
-            // the offset for IALOAD or IASTORE is in byte 1 of 'off' for
-            // primitive types (buf == null)
-            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);
-        } else {
-            // the offset for other instructions is in byte 2 of 'off' for
-            // primitive types (buf == null)
-            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Equals, hashCode and toString
-    // ------------------------------------------------------------------------
-
-    /**
-     * Tests if the given object is equal to this type.
-     * 
-     * @param o the object to be compared to this type.
-     * @return <tt>true</tt> if the given object is equal to this type.
-     */
-    public boolean equals(final Object o) {
-        if (this == o) {
-            return true;
-        }
-        if (!(o instanceof Type)) {
-            return false;
-        }
-        Type t = (Type) o;
-        if (sort != t.sort) {
-            return false;
-        }
-        if (sort == OBJECT || sort == ARRAY) {
-            if (len != t.len) {
-                return false;
-            }
-            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {
-                if (buf[i] != t.buf[j]) {
-                    return false;
-                }
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Returns a hash code value for this type.
-     * 
-     * @return a hash code value for this type.
-     */
-    public int hashCode() {
-        int hc = 13 * sort;
-        if (sort == OBJECT || sort == ARRAY) {
-            for (int i = off, end = i + len; i < end; i++) {
-                hc = 17 * (hc + buf[i]);
-            }
-        }
-        return hc;
-    }
-
-    /**
-     * Returns a string representation of this type.
-     * 
-     * @return the descriptor of this type.
-     */
-    public String toString() {
-        return getDescriptor();
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/AbstractVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/AbstractVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/AbstractVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/AbstractVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,202 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-
-/**
- * An abstract visitor.
- * 
- * @author Eric Bruneton
- */
-public abstract class AbstractVisitor {
-
-    /**
-     * The names of the Java Virtual Machine opcodes.
-     */
-    public static final String[] OPCODES;
-    /**
-     * Types for <code>operand</code> parameter of the
-     * {@link org.eclipse.persistence.internal.libraries.asm.MethodVisitor#visitIntInsn} method when
-     * <code>opcode</code> is <code>NEWARRAY</code>.
-     */
-    public static final String[] TYPES;
-
-    static {
-        String s = "NOP,ACONST_NULL,ICONST_M1,ICONST_0,ICONST_1,ICONST_2,"
-                + "ICONST_3,ICONST_4,ICONST_5,LCONST_0,LCONST_1,FCONST_0,"
-                + "FCONST_1,FCONST_2,DCONST_0,DCONST_1,BIPUSH,SIPUSH,LDC,,,"
-                + "ILOAD,LLOAD,FLOAD,DLOAD,ALOAD,,,,,,,,,,,,,,,,,,,,,IALOAD,"
-                + "LALOAD,FALOAD,DALOAD,AALOAD,BALOAD,CALOAD,SALOAD,ISTORE,"
-                + "LSTORE,FSTORE,DSTORE,ASTORE,,,,,,,,,,,,,,,,,,,,,IASTORE,"
-                + "LASTORE,FASTORE,DASTORE,AASTORE,BASTORE,CASTORE,SASTORE,POP,"
-                + "POP2,DUP,DUP_X1,DUP_X2,DUP2,DUP2_X1,DUP2_X2,SWAP,IADD,LADD,"
-                + "FADD,DADD,ISUB,LSUB,FSUB,DSUB,IMUL,LMUL,FMUL,DMUL,IDIV,LDIV,"
-                + "FDIV,DDIV,IREM,LREM,FREM,DREM,INEG,LNEG,FNEG,DNEG,ISHL,LSHL,"
-                + "ISHR,LSHR,IUSHR,LUSHR,IAND,LAND,IOR,LOR,IXOR,LXOR,IINC,I2L,"
-                + "I2F,I2D,L2I,L2F,L2D,F2I,F2L,F2D,D2I,D2L,D2F,I2B,I2C,I2S,LCMP,"
-                + "FCMPL,FCMPG,DCMPL,DCMPG,IFEQ,IFNE,IFLT,IFGE,IFGT,IFLE,"
-                + "IF_ICMPEQ,IF_ICMPNE,IF_ICMPLT,IF_ICMPGE,IF_ICMPGT,IF_ICMPLE,"
-                + "IF_ACMPEQ,IF_ACMPNE,GOTO,JSR,RET,TABLESWITCH,LOOKUPSWITCH,"
-                + "IRETURN,LRETURN,FRETURN,DRETURN,ARETURN,RETURN,GETSTATIC,"
-                + "PUTSTATIC,GETFIELD,PUTFIELD,INVOKEVIRTUAL,INVOKESPECIAL,"
-                + "INVOKESTATIC,INVOKEINTERFACE,INVOKEDYNAMIC,NEW,NEWARRAY,"
-                + "ANEWARRAY,ARRAYLENGTH,ATHROW,CHECKCAST,INSTANCEOF,"
-                + "MONITORENTER,MONITOREXIT,,MULTIANEWARRAY,IFNULL,IFNONNULL,";
-        OPCODES = new String[200];
-        int i = 0;
-        int j = 0;
-        int l;
-        while ((l = s.indexOf(',', j)) > 0) {
-            OPCODES[i++] = j + 1 == l ? null : s.substring(j, l);
-            j = l + 1;
-        }
-
-        s = "T_BOOLEAN,T_CHAR,T_FLOAT,T_DOUBLE,T_BYTE,T_SHORT,T_INT,T_LONG,";
-        TYPES = new String[12];
-        j = 0;
-        i = 4;
-        while ((l = s.indexOf(',', j)) > 0) {
-            TYPES[i++] = s.substring(j, l);
-            j = l + 1;
-        }
-    }
-
-    /**
-     * The text to be printed. Since the code of methods is not necessarily
-     * visited in sequential order, one method after the other, but can be
-     * interlaced (some instructions from method one, then some instructions
-     * from method two, then some instructions from method one again...), it is
-     * not possible to print the visited instructions directly to a sequential
-     * stream. A class is therefore printed in a two steps process: a string
-     * tree is constructed during the visit, and printed to a sequential stream
-     * at the end of the visit. This string tree is stored in this field, as a
-     * string list that can contain other string lists, which can themselves
-     * contain other string lists, and so on.
-     */
-    public final List text;
-
-    /**
-     * A buffer that can be used to create strings.
-     */
-    protected final StringBuffer buf;
-
-    /**
-     * Constructs a new {@link AbstractVisitor}.
-     */
-    protected AbstractVisitor() {
-        this.text = new ArrayList();
-        this.buf = new StringBuffer();
-    }
-
-    /**
-     * Returns the text constructed by this visitor.
-     * 
-     * @return the text constructed by this visitor.
-     */
-    public List getText() {
-        return text;
-    }
-
-    /**
-     * Prints the text constructed by this visitor.
-     * 
-     * @param pw the print writer to be used.
-     */
-    public void print(final PrintWriter pw) {
-        printList(pw, text);
-    }
-    
-    /**
-     * Appends a quoted string to a given buffer.
-     * 
-     * @param buf the buffer where the string must be added.
-     * @param s the string to be added.
-     */
-    public static void appendString(final StringBuffer buf, final String s) {
-        buf.append('\"');
-        for (int i = 0; i < s.length(); ++i) {
-            char c = s.charAt(i);
-            if (c == '\n') {
-                buf.append("\\n");
-            } else if (c == '\r') {
-                buf.append("\\r");
-            } else if (c == '\\') {
-                buf.append("\\\\");
-            } else if (c == '"') {
-                buf.append("\\\"");
-            } else if (c < 0x20 || c > 0x7f) {
-                buf.append("\\u");
-                if (c < 0x10) {
-                    buf.append("000");
-                } else if (c < 0x100) {
-                    buf.append("00");
-                } else if (c < 0x1000) {
-                    buf.append('0');
-                }
-                buf.append(Integer.toString(c, 16));
-            } else {
-                buf.append(c);
-            }
-        }
-        buf.append('\"');
-    }
-
-    /**
-     * Prints the given string tree.
-     * 
-     * @param pw the writer to be used to print the tree.
-     * @param l a string tree, i.e., a string list that can contain other string
-     *        lists, and so on recursively.
-     */
-    static void printList(final PrintWriter pw, final List l) {
-        for (int i = 0; i < l.size(); ++i) {
-            Object o = l.get(i);
-            if (o instanceof List) {
-                printList(pw, (List) o);
-            } else {
-                pw.print(o.toString());
-            }
-        }
-    }
-
-    /**
-     * Returns the default {@link ASMifiable} prototypes.
-     * 
-     * @return the default {@link ASMifiable} prototypes.
-     */
-    public static Attribute[] getDefaultAttributes() {
-        return new Attribute[0];
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/ASMifiable.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/ASMifiable.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/ASMifiable.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/ASMifiable.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,53 +0,0 @@
-/**
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import java.util.Map;
-
-/**
- * An attribute that can print the ASM code to create an equivalent attribute.
- * 
- * Implementation should print the ASM code that generates attribute data
- * structures for current attribute state.
- * 
- * @author Eugene Kuleshov
- */
-public interface ASMifiable {
-
-    /**
-     * Prints the ASM code to create an attribute equal to this attribute.
-     * 
-     * @param buf A buffer used for printing Java code.
-     * @param varName name of the variable in a printed code used to store
-     *        attribute instance.
-     * @param labelNames map of label instances to their names.
-     */
-    void asmify(StringBuffer buf, String varName, Map labelNames);
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/ASMifierAbstractVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/ASMifierAbstractVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/ASMifierAbstractVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/ASMifierAbstractVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,222 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-
-import java.util.Map;
-
-/**
- * An abstract ASMifier visitor.
- * 
- * @author Eric Bruneton
- */
-public class ASMifierAbstractVisitor extends AbstractVisitor {
-
-    /**
-     * The name of the variable for this visitor in the produced code.
-     */
-    protected String name;
-
-    /**
-     * The label names. This map associates String values to Label keys. It is
-     * used only in ASMifierMethodVisitor.
-     */
-    Map labelNames;
-
-    /**
-     * Constructs a new {@link ASMifierAbstractVisitor}.
-     * 
-     * @param name the name of the variable for this visitor in the produced
-     *        code.
-     */
-    protected ASMifierAbstractVisitor(final String name) {
-        this.name = name;
-    }
-
-    /**
-     * Prints the ASM code that generates the given annotation.
-     * 
-     * @param desc the class descriptor of the annotation class.
-     * @param visible <tt>true</tt> if the annotation is visible at runtime.
-     * @return a visitor to visit the annotation values.
-     */
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        buf.setLength(0);
-        buf.append("{\n")
-                .append("av0 = ")
-                .append(name)
-                .append(".visitAnnotation(");
-        appendConstant(desc);
-        buf.append(", ").append(visible).append(");\n");
-        text.add(buf.toString());
-        ASMifierAnnotationVisitor av = new ASMifierAnnotationVisitor(0);
-        text.add(av.getText());
-        text.add("}\n");
-        return av;
-    }
-
-    /**
-     * Prints the ASM code that generates the given attribute.
-     * 
-     * @param attr an attribute.
-     */
-    public void visitAttribute(final Attribute attr) {
-        buf.setLength(0);
-        buf.append("// ATTRIBUTE ").append(attr.type).append('\n');
-        if (attr instanceof ASMifiable) {
-            buf.append("{\n");
-            ((ASMifiable) attr).asmify(buf, "attr", labelNames);
-            buf.append(name).append(".visitAttribute(attr);\n");
-            buf.append("}\n");
-        }
-        text.add(buf.toString());
-    }
-
-    /**
-     * Prints the ASM code to end the visit.
-     */
-    public void visitEnd() {
-        buf.setLength(0);
-        buf.append(name).append(".visitEnd();\n");
-        text.add(buf.toString());
-    }
-
-    /**
-     * Appends a string representation of the given constant to the given
-     * buffer.
-     * 
-     * @param cst an {@link Integer}, {@link Float}, {@link Long},
-     *        {@link Double} or {@link String} object. May be <tt>null</tt>.
-     */
-    void appendConstant(final Object cst) {
-        appendConstant(buf, cst);
-    }
-
-    /**
-     * Appends a string representation of the given constant to the given
-     * buffer.
-     * 
-     * @param buf a string buffer.
-     * @param cst an {@link Integer}, {@link Float}, {@link Long},
-     *        {@link Double} or {@link String} object. May be <tt>null</tt>.
-     */
-    static void appendConstant(final StringBuffer buf, final Object cst) {
-        if (cst == null) {
-            buf.append("null");
-        } else if (cst instanceof String) {
-            appendString(buf, (String) cst);
-        } else if (cst instanceof Type) {
-            buf.append("Type.getType(\"");
-            buf.append(((Type) cst).getDescriptor());
-            buf.append("\")");
-        } else if (cst instanceof Byte) {
-            buf.append("new Byte((byte)").append(cst).append(')');
-        } else if (cst instanceof Boolean) {
-            buf.append(((Boolean) cst).booleanValue() ? "Boolean.TRUE" : "Boolean.FALSE");
-        } else if (cst instanceof Short) {
-            buf.append("new Short((short)").append(cst).append(')');
-        } else if (cst instanceof Character) {
-            int c = ((Character) cst).charValue();
-            buf.append("new Character((char)").append(c).append(')');
-        } else if (cst instanceof Integer) {
-            buf.append("new Integer(").append(cst).append(')');
-        } else if (cst instanceof Float) {
-            buf.append("new Float(\"").append(cst).append("\")");
-        } else if (cst instanceof Long) {
-            buf.append("new Long(").append(cst).append("L)");
-        } else if (cst instanceof Double) {
-            buf.append("new Double(\"").append(cst).append("\")");
-        } else if (cst instanceof byte[]) {
-            byte[] v = (byte[]) cst;
-            buf.append("new byte[] {");
-            for (int i = 0; i < v.length; i++) {
-                buf.append(i == 0 ? "" : ",").append(v[i]);
-            }
-            buf.append('}');
-        } else if (cst instanceof boolean[]) {
-            boolean[] v = (boolean[]) cst;
-            buf.append("new boolean[] {");
-            for (int i = 0; i < v.length; i++) {
-                buf.append(i == 0 ? "" : ",").append(v[i]);
-            }
-            buf.append('}');
-        } else if (cst instanceof short[]) {
-            short[] v = (short[]) cst;
-            buf.append("new short[] {");
-            for (int i = 0; i < v.length; i++) {
-                buf.append(i == 0 ? "" : ",").append("(short)").append(v[i]);
-            }
-            buf.append('}');
-        } else if (cst instanceof char[]) {
-            char[] v = (char[]) cst;
-            buf.append("new char[] {");
-            for (int i = 0; i < v.length; i++) {
-                buf.append(i == 0 ? "" : ",")
-                        .append("(char)")
-                        .append((int) v[i]);
-            }
-            buf.append('}');
-        } else if (cst instanceof int[]) {
-            int[] v = (int[]) cst;
-            buf.append("new int[] {");
-            for (int i = 0; i < v.length; i++) {
-                buf.append(i == 0 ? "" : ",").append(v[i]);
-            }
-            buf.append('}');
-        } else if (cst instanceof long[]) {
-            long[] v = (long[]) cst;
-            buf.append("new long[] {");
-            for (int i = 0; i < v.length; i++) {
-                buf.append(i == 0 ? "" : ",").append(v[i]).append('L');
-            }
-            buf.append('}');
-        } else if (cst instanceof float[]) {
-            float[] v = (float[]) cst;
-            buf.append("new float[] {");
-            for (int i = 0; i < v.length; i++) {
-                buf.append(i == 0 ? "" : ",").append(v[i]).append('f');
-            }
-            buf.append('}');
-        } else if (cst instanceof double[]) {
-            double[] v = (double[]) cst;
-            buf.append("new double[] {");
-            for (int i = 0; i < v.length; i++) {
-                buf.append(i == 0 ? "" : ",").append(v[i]).append('d');
-            }
-            buf.append('}');
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/ASMifierAnnotationVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/ASMifierAnnotationVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/ASMifierAnnotationVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/ASMifierAnnotationVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,127 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-
-/**
- * An {@link AnnotationVisitor} that prints the ASM code that generates the
- * annotations it visits.
- * 
- * @author Eric Bruneton
- */
-public class ASMifierAnnotationVisitor extends AbstractVisitor implements
-        AnnotationVisitor
-{
-
-    /**
-     * Identifier of the annotation visitor variable in the produced code.
-     */
-    protected final int id;
-
-    /**
-     * Constructs a new {@link ASMifierAnnotationVisitor}.
-     * 
-     * @param id identifier of the annotation visitor variable in the produced
-     *        code.
-     */
-    public ASMifierAnnotationVisitor(final int id) {
-        this.id = id;
-    }
-
-    // ------------------------------------------------------------------------
-    // Implementation of the AnnotationVisitor interface
-    // ------------------------------------------------------------------------
-
-    public void visit(final String name, final Object value) {
-        buf.setLength(0);
-        buf.append("av").append(id).append(".visit(");
-        ASMifierAbstractVisitor.appendConstant(buf, name);
-        buf.append(", ");
-        ASMifierAbstractVisitor.appendConstant(buf, value);
-        buf.append(");\n");
-        text.add(buf.toString());
-    }
-
-    public void visitEnum(
-        final String name,
-        final String desc,
-        final String value)
-    {
-        buf.setLength(0);
-        buf.append("av").append(id).append(".visitEnum(");
-        ASMifierAbstractVisitor.appendConstant(buf, name);
-        buf.append(", ");
-        ASMifierAbstractVisitor.appendConstant(buf, desc);
-        buf.append(", ");
-        ASMifierAbstractVisitor.appendConstant(buf, value);
-        buf.append(");\n");
-        text.add(buf.toString());
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String name,
-        final String desc)
-    {
-        buf.setLength(0);
-        buf.append("{\n");
-        buf.append("AnnotationVisitor av").append(id + 1).append(" = av");
-        buf.append(id).append(".visitAnnotation(");
-        ASMifierAbstractVisitor.appendConstant(buf, name);
-        buf.append(", ");
-        ASMifierAbstractVisitor.appendConstant(buf, desc);
-        buf.append(");\n");
-        text.add(buf.toString());
-        ASMifierAnnotationVisitor av = new ASMifierAnnotationVisitor(id + 1);
-        text.add(av.getText());
-        text.add("}\n");
-        return av;
-    }
-
-    public AnnotationVisitor visitArray(final String name) {
-        buf.setLength(0);
-        buf.append("{\n");
-        buf.append("AnnotationVisitor av").append(id + 1).append(" = av");
-        buf.append(id).append(".visitArray(");
-        ASMifierAbstractVisitor.appendConstant(buf, name);
-        buf.append(");\n");
-        text.add(buf.toString());
-        ASMifierAnnotationVisitor av = new ASMifierAnnotationVisitor(id + 1);
-        text.add(av.getText());
-        text.add("}\n");
-        return av;
-    }
-
-    public void visitEnd() {
-        buf.setLength(0);
-        buf.append("av").append(id).append(".visitEnd();\n");
-        text.add(buf.toString());
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/ASMifierClassVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/ASMifierClassVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/ASMifierClassVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/ASMifierClassVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,575 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import java.io.FileInputStream;
-import java.io.PrintWriter;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.ClassReader;
-import org.eclipse.persistence.internal.libraries.asm.ClassVisitor;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-
-/**
- * A {@link ClassVisitor} that prints the ASM code that generates the classes it
- * visits. This class visitor can be used to quickly write ASM code to generate
- * some given bytecode: <ul> <li>write the Java source code equivalent to the
- * bytecode you want to generate;</li> <li>compile it with <tt>javac</tt>;</li>
- * <li>make a {@link ASMifierClassVisitor} visit this compiled class (see the
- * {@link #main main} method);</li> <li>edit the generated source code, if
- * necessary.</li> </ul> The source code printed when visiting the
- * <tt>Hello</tt> class is the following: <p> <blockquote>
- * 
- * <pre>
- * import org.objectweb.asm.*;
- *
- * public class HelloDump implements Opcodes {
- *
- *     public static byte[] dump() throws Exception {
- *
- *         ClassWriter cw = new ClassWriter(0);
- *         FieldVisitor fv;
- *         MethodVisitor mv;
- *         AnnotationVisitor av0;
- *
- *         cw.visit(49,
- *                 ACC_PUBLIC + ACC_SUPER,
- *                 &quot;Hello&quot;,
- *                 null,
- *                 &quot;java/lang/Object&quot;,
- *                 null);
- *
- *         cw.visitSource(&quot;Hello.java&quot;, null);
- *
- *         {
- *             mv = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);
- *             mv.visitVarInsn(ALOAD, 0);
- *             mv.visitMethodInsn(INVOKESPECIAL,
- *                     &quot;java/lang/Object&quot;,
- *                     &quot;&lt;init&gt;&quot;,
- *                     &quot;()V&quot;);
- *             mv.visitInsn(RETURN);
- *             mv.visitMaxs(1, 1);
- *             mv.visitEnd();
- *         }
- *         {
- *             mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC,
- *                     &quot;main&quot;,
- *                     &quot;([Ljava/lang/String;)V&quot;,
- *                     null,
- *                     null);
- *             mv.visitFieldInsn(GETSTATIC,
- *                     &quot;java/lang/System&quot;,
- *                     &quot;out&quot;,
- *                     &quot;Ljava/io/PrintStream;&quot;);
- *             mv.visitLdcInsn(&quot;hello&quot;);
- *             mv.visitMethodInsn(INVOKEVIRTUAL,
- *                     &quot;java/io/PrintStream&quot;,
- *                     &quot;println&quot;,
- *                     &quot;(Ljava/lang/String;)V&quot;);
- *             mv.visitInsn(RETURN);
- *             mv.visitMaxs(2, 1);
- *             mv.visitEnd();
- *         }
- *         cw.visitEnd();
- *
- *         return cw.toByteArray();
- *     }
- * }
- *
- * </pre>
- * 
- * </blockquote> where <tt>Hello</tt> is defined by: <p> <blockquote>
- * 
- * <pre>
- * public class Hello {
- *
- *     public static void main(String[] args) {
- *         System.out.println(&quot;hello&quot;);
- *     }
- * }
- * </pre>
- * 
- * </blockquote>
- * 
- * @author Eric Bruneton
- * @author Eugene Kuleshov
- */
-public class ASMifierClassVisitor extends ASMifierAbstractVisitor implements
-        ClassVisitor
-{
-
-    /**
-     * Pseudo access flag used to distinguish class access flags.
-     */
-    private static final int ACCESS_CLASS = 262144;
-
-    /**
-     * Pseudo access flag used to distinguish field access flags.
-     */
-    private static final int ACCESS_FIELD = 524288;
-
-    /**
-     * Pseudo access flag used to distinguish inner class flags.
-     */
-    private static final int ACCESS_INNER = 1048576;
-
-    /**
-     * The print writer to be used to print the class.
-     */
-    protected final PrintWriter pw;
-
-    /**
-     * Prints the ASM source code to generate the given class to the standard
-     * output. <p> Usage: ASMifierClassVisitor [-debug] &lt;fully qualified
-     * class name or class file name&gt;
-     * 
-     * @param args the command line arguments.
-     * 
-     * @throws Exception if the class cannot be found, or if an IO exception
-     *         occurs.
-     */
-    public static void main(final String[] args) throws Exception {
-        int i = 0;
-        int flags = ClassReader.SKIP_DEBUG;
-
-        boolean ok = true;
-        if (args.length < 1 || args.length > 2) {
-            ok = false;
-        }
-        if (ok && "-debug".equals(args[0])) {
-            i = 1;
-            flags = 0;
-            if (args.length != 2) {
-                ok = false;
-            }
-        }
-        if (!ok) {
-            System.err.println("Prints the ASM code to generate the given class.");
-            System.err.println("Usage: ASMifierClassVisitor [-debug] "
-                    + "<fully qualified class name or class file name>");
-            return;
-        }
-        ClassReader cr;
-        if (args[i].endsWith(".class") || args[i].indexOf('\\') > -1
-                || args[i].indexOf('/') > -1)
-        {
-            cr = new ClassReader(new FileInputStream(args[i]));
-        } else {
-            cr = new ClassReader(args[i]);
-        }
-        cr.accept(new ASMifierClassVisitor(new PrintWriter(System.out)),
-                getDefaultAttributes(),
-                flags);
-    }
-
-    /**
-     * Constructs a new {@link ASMifierClassVisitor} object.
-     * 
-     * @param pw the print writer to be used to print the class.
-     */
-    public ASMifierClassVisitor(final PrintWriter pw) {
-        super("cw");
-        this.pw = pw;
-    }
-
-    // ------------------------------------------------------------------------
-    // Implementation of the ClassVisitor interface
-    // ------------------------------------------------------------------------
-
-    public void visit(
-        final int version,
-        final int access,
-        final String name,
-        final String signature,
-        final String superName,
-        final String[] interfaces)
-    {
-        String simpleName;
-        int n = name.lastIndexOf('/');
-        if (n == -1) {
-            simpleName = name;
-        } else {
-            text.add("package asm." + name.substring(0, n).replace('/', '.')
-                    + ";\n");
-            simpleName = name.substring(n + 1);
-        }
-        text.add("import java.util.*;\n");
-        text.add("import org.objectweb.asm.*;\n");
-        text.add("import org.objectweb.asm.attrs.*;\n");
-        text.add("public class " + simpleName + "Dump implements Opcodes {\n\n");
-        text.add("public static byte[] dump () throws Exception {\n\n");
-        text.add("ClassWriter cw = new ClassWriter(0);\n");
-        text.add("FieldVisitor fv;\n");
-        text.add("MethodVisitor mv;\n");
-        text.add("AnnotationVisitor av0;\n\n");
-
-        buf.setLength(0);
-        buf.append("cw.visit(");
-        switch (version) {
-            case Opcodes.V1_1:
-                buf.append("V1_1");
-                break;
-            case Opcodes.V1_2:
-                buf.append("V1_2");
-                break;
-            case Opcodes.V1_3:
-                buf.append("V1_3");
-                break;
-            case Opcodes.V1_4:
-                buf.append("V1_4");
-                break;
-            case Opcodes.V1_5:
-                buf.append("V1_5");
-                break;
-            case Opcodes.V1_6:
-                buf.append("V1_6");
-                break;
-            default:
-                buf.append(version);
-                break;
-        }
-        buf.append(", ");
-        appendAccess(access | ACCESS_CLASS);
-        buf.append(", ");
-        appendConstant(name);
-        buf.append(", ");
-        appendConstant(signature);
-        buf.append(", ");
-        appendConstant(superName);
-        buf.append(", ");
-        if (interfaces != null && interfaces.length > 0) {
-            buf.append("new String[] {");
-            for (int i = 0; i < interfaces.length; ++i) {
-                buf.append(i == 0 ? " " : ", ");
-                appendConstant(interfaces[i]);
-            }
-            buf.append(" }");
-        } else {
-            buf.append("null");
-        }
-        buf.append(");\n\n");
-        text.add(buf.toString());
-    }
-
-    public void visitSource(final String file, final String debug) {
-        buf.setLength(0);
-        buf.append("cw.visitSource(");
-        appendConstant(file);
-        buf.append(", ");
-        appendConstant(debug);
-        buf.append(");\n\n");
-        text.add(buf.toString());
-    }
-
-    public void visitOuterClass(
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        buf.setLength(0);
-        buf.append("cw.visitOuterClass(");
-        appendConstant(owner);
-        buf.append(", ");
-        appendConstant(name);
-        buf.append(", ");
-        appendConstant(desc);
-        buf.append(");\n\n");
-        text.add(buf.toString());
-    }
-
-    public void visitInnerClass(
-        final String name,
-        final String outerName,
-        final String innerName,
-        final int access)
-    {
-        buf.setLength(0);
-        buf.append("cw.visitInnerClass(");
-        appendConstant(name);
-        buf.append(", ");
-        appendConstant(outerName);
-        buf.append(", ");
-        appendConstant(innerName);
-        buf.append(", ");
-        appendAccess(access | ACCESS_INNER);
-        buf.append(");\n\n");
-        text.add(buf.toString());
-    }
-
-    public FieldVisitor visitField(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final Object value)
-    {
-        buf.setLength(0);
-        buf.append("{\n");
-        buf.append("fv = cw.visitField(");
-        appendAccess(access | ACCESS_FIELD);
-        buf.append(", ");
-        appendConstant(name);
-        buf.append(", ");
-        appendConstant(desc);
-        buf.append(", ");
-        appendConstant(signature);
-        buf.append(", ");
-        appendConstant(value);
-        buf.append(");\n");
-        text.add(buf.toString());
-        ASMifierFieldVisitor aav = new ASMifierFieldVisitor();
-        text.add(aav.getText());
-        text.add("}\n");
-        return aav;
-    }
-
-    public MethodVisitor visitMethod(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final String[] exceptions)
-    {
-        buf.setLength(0);
-        buf.append("{\n");
-        buf.append("mv = cw.visitMethod(");
-        appendAccess(access);
-        buf.append(", ");
-        appendConstant(name);
-        buf.append(", ");
-        appendConstant(desc);
-        buf.append(", ");
-        appendConstant(signature);
-        buf.append(", ");
-        if (exceptions != null && exceptions.length > 0) {
-            buf.append("new String[] {");
-            for (int i = 0; i < exceptions.length; ++i) {
-                buf.append(i == 0 ? " " : ", ");
-                appendConstant(exceptions[i]);
-            }
-            buf.append(" }");
-        } else {
-            buf.append("null");
-        }
-        buf.append(");\n");
-        text.add(buf.toString());
-        ASMifierMethodVisitor acv = createASMifierMethodVisitor();
-        text.add(acv.getText());
-        text.add("}\n");
-        return acv;
-    }
-
-    protected ASMifierMethodVisitor createASMifierMethodVisitor() {
-        return new ASMifierMethodVisitor();
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        buf.setLength(0);
-        buf.append("{\n");
-        buf.append("av0 = cw.visitAnnotation(");
-        appendConstant(desc);
-        buf.append(", ");
-        buf.append(visible);
-        buf.append(");\n");
-        text.add(buf.toString());
-        ASMifierAnnotationVisitor av = new ASMifierAnnotationVisitor(0);
-        text.add(av.getText());
-        text.add("}\n");
-        return av;
-    }
-
-    public void visitEnd() {
-        text.add("cw.visitEnd();\n\n");
-        text.add("return cw.toByteArray();\n");
-        text.add("}\n");
-        text.add("}\n");
-        printList(pw, text);
-        pw.flush();
-    }
-
-    // ------------------------------------------------------------------------
-    // Utility methods
-    // ------------------------------------------------------------------------
-
-    /**
-     * Appends a string representation of the given access modifiers to {@link
-     * #buf buf}.
-     * 
-     * @param access some access modifiers.
-     */
-    void appendAccess(final int access) {
-        boolean first = true;
-        if ((access & Opcodes.ACC_PUBLIC) != 0) {
-            buf.append("ACC_PUBLIC");
-            first = false;
-        }
-        if ((access & Opcodes.ACC_PRIVATE) != 0) {
-            buf.append("ACC_PRIVATE");
-            first = false;
-        }
-        if ((access & Opcodes.ACC_PROTECTED) != 0) {
-            buf.append("ACC_PROTECTED");
-            first = false;
-        }
-        if ((access & Opcodes.ACC_FINAL) != 0) {
-            if (!first) {
-                buf.append(" + ");
-            }
-            buf.append("ACC_FINAL");
-            first = false;
-        }
-        if ((access & Opcodes.ACC_STATIC) != 0) {
-            if (!first) {
-                buf.append(" + ");
-            }
-            buf.append("ACC_STATIC");
-            first = false;
-        }
-        if ((access & Opcodes.ACC_SYNCHRONIZED) != 0) {
-            if (!first) {
-                buf.append(" + ");
-            }
-            if ((access & ACCESS_CLASS) == 0) {
-                buf.append("ACC_SYNCHRONIZED");
-            } else {
-                buf.append("ACC_SUPER");
-            }
-            first = false;
-        }
-        if ((access & Opcodes.ACC_VOLATILE) != 0
-                && (access & ACCESS_FIELD) != 0)
-        {
-            if (!first) {
-                buf.append(" + ");
-            }
-            buf.append("ACC_VOLATILE");
-            first = false;
-        }
-        if ((access & Opcodes.ACC_BRIDGE) != 0 && (access & ACCESS_CLASS) == 0
-                && (access & ACCESS_FIELD) == 0)
-        {
-            if (!first) {
-                buf.append(" + ");
-            }
-            buf.append("ACC_BRIDGE");
-            first = false;
-        }
-        if ((access & Opcodes.ACC_VARARGS) != 0 && (access & ACCESS_CLASS) == 0
-                && (access & ACCESS_FIELD) == 0)
-        {
-            if (!first) {
-                buf.append(" + ");
-            }
-            buf.append("ACC_VARARGS");
-            first = false;
-        }
-        if ((access & Opcodes.ACC_TRANSIENT) != 0
-                && (access & ACCESS_FIELD) != 0)
-        {
-            if (!first) {
-                buf.append(" + ");
-            }
-            buf.append("ACC_TRANSIENT");
-            first = false;
-        }
-        if ((access & Opcodes.ACC_NATIVE) != 0 && (access & ACCESS_CLASS) == 0
-                && (access & ACCESS_FIELD) == 0)
-        {
-            if (!first) {
-                buf.append(" + ");
-            }
-            buf.append("ACC_NATIVE");
-            first = false;
-        }
-        if ((access & Opcodes.ACC_ENUM) != 0
-                && ((access & ACCESS_CLASS) != 0
-                        || (access & ACCESS_FIELD) != 0 || (access & ACCESS_INNER) != 0))
-        {
-            if (!first) {
-                buf.append(" + ");
-            }
-            buf.append("ACC_ENUM");
-            first = false;
-        }
-        if ((access & Opcodes.ACC_ANNOTATION) != 0
-                && (access & ACCESS_CLASS) != 0)
-        {
-            if (!first) {
-                buf.append(" + ");
-            }
-            buf.append("ACC_ANNOTATION");
-            first = false;
-        }
-        if ((access & Opcodes.ACC_ABSTRACT) != 0) {
-            if (!first) {
-                buf.append(" + ");
-            }
-            buf.append("ACC_ABSTRACT");
-            first = false;
-        }
-        if ((access & Opcodes.ACC_INTERFACE) != 0) {
-            if (!first) {
-                buf.append(" + ");
-            }
-            buf.append("ACC_INTERFACE");
-            first = false;
-        }
-        if ((access & Opcodes.ACC_STRICT) != 0) {
-            if (!first) {
-                buf.append(" + ");
-            }
-            buf.append("ACC_STRICT");
-            first = false;
-        }
-        if ((access & Opcodes.ACC_SYNTHETIC) != 0) {
-            if (!first) {
-                buf.append(" + ");
-            }
-            buf.append("ACC_SYNTHETIC");
-            first = false;
-        }
-        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
-            if (!first) {
-                buf.append(" + ");
-            }
-            buf.append("ACC_DEPRECATED");
-            first = false;
-        }
-        if (first) {
-            buf.append('0');
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/ASMifierFieldVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/ASMifierFieldVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/ASMifierFieldVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/ASMifierFieldVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,50 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-
-/**
- * A {@link FieldVisitor} that prints the ASM code that generates the fields it
- * visits.
- * 
- * @author Eric Bruneton
- */
-public class ASMifierFieldVisitor extends ASMifierAbstractVisitor implements
-        FieldVisitor
-{
-
-    /**
-     * Constructs a new {@link ASMifierFieldVisitor}.
-     */
-    public ASMifierFieldVisitor() {
-        super("fv");
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/ASMifierMethodVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/ASMifierMethodVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/ASMifierMethodVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/ASMifierMethodVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,443 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-
-import java.util.HashMap;
-
-/**
- * A {@link MethodVisitor} that prints the ASM code that generates the methods
- * it visits.
- * 
- * @author Eric Bruneton
- * @author Eugene Kuleshov
- */
-public class ASMifierMethodVisitor extends ASMifierAbstractVisitor implements
-        MethodVisitor
-{
-
-    /**
-     * Constructs a new {@link ASMifierMethodVisitor} object.
-     */
-    public ASMifierMethodVisitor() {
-        super("mv");
-        this.labelNames = new HashMap();
-    }
-
-    public AnnotationVisitor visitAnnotationDefault() {
-        buf.setLength(0);
-        buf.append("{\n").append("av0 = mv.visitAnnotationDefault();\n");
-        text.add(buf.toString());
-        ASMifierAnnotationVisitor av = new ASMifierAnnotationVisitor(0);
-        text.add(av.getText());
-        text.add("}\n");
-        return av;
-    }
-
-    public AnnotationVisitor visitParameterAnnotation(
-        final int parameter,
-        final String desc,
-        final boolean visible)
-    {
-        buf.setLength(0);
-        buf.append("{\n")
-                .append("av0 = mv.visitParameterAnnotation(")
-                .append(parameter)
-                .append(", ");
-        appendConstant(desc);
-        buf.append(", ").append(visible).append(");\n");
-        text.add(buf.toString());
-        ASMifierAnnotationVisitor av = new ASMifierAnnotationVisitor(0);
-        text.add(av.getText());
-        text.add("}\n");
-        return av;
-    }
-
-    public void visitCode() {
-        text.add("mv.visitCode();\n");
-    }
-
-    public void visitFrame(
-        final int type,
-        final int nLocal,
-        final Object[] local,
-        final int nStack,
-        final Object[] stack)
-    {
-        buf.setLength(0);
-        switch (type) {
-            case Opcodes.F_NEW:
-            case Opcodes.F_FULL:
-                declareFrameTypes(nLocal, local);
-                declareFrameTypes(nStack, stack);
-                if (type == Opcodes.F_NEW) {
-                    buf.append("mv.visitFrame(Opcodes.F_NEW, ");
-                } else {
-                    buf.append("mv.visitFrame(Opcodes.F_FULL, ");
-                }
-                buf.append(nLocal).append(", new Object[] {");
-                appendFrameTypes(nLocal, local);
-                buf.append("}, ").append(nStack).append(", new Object[] {");
-                appendFrameTypes(nStack, stack);
-                buf.append('}');
-                break;
-            case Opcodes.F_APPEND:
-                declareFrameTypes(nLocal, local);
-                buf.append("mv.visitFrame(Opcodes.F_APPEND,")
-                        .append(nLocal)
-                        .append(", new Object[] {");
-                appendFrameTypes(nLocal, local);
-                buf.append("}, 0, null");
-                break;
-            case Opcodes.F_CHOP:
-                buf.append("mv.visitFrame(Opcodes.F_CHOP,")
-                        .append(nLocal)
-                        .append(", null, 0, null");
-                break;
-            case Opcodes.F_SAME:
-                buf.append("mv.visitFrame(Opcodes.F_SAME, 0, null, 0, null");
-                break;
-            case Opcodes.F_SAME1:
-                declareFrameTypes(1, stack);
-                buf.append("mv.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[] {");
-                appendFrameTypes(1, stack);
-                buf.append('}');
-                break;
-        }
-        buf.append(");\n");
-        text.add(buf.toString());
-    }
-
-    public void visitInsn(final int opcode) {
-        buf.setLength(0);
-        buf.append("mv.visitInsn(").append(OPCODES[opcode]).append(");\n");
-        text.add(buf.toString());
-    }
-
-    public void visitIntInsn(final int opcode, final int operand) {
-        buf.setLength(0);
-        buf.append("mv.visitIntInsn(")
-                .append(OPCODES[opcode])
-                .append(", ")
-                .append(opcode == Opcodes.NEWARRAY
-                        ? TYPES[operand]
-                        : Integer.toString(operand))
-                .append(");\n");
-        text.add(buf.toString());
-    }
-
-    public void visitVarInsn(final int opcode, final int var) {
-        buf.setLength(0);
-        buf.append("mv.visitVarInsn(")
-                .append(OPCODES[opcode])
-                .append(", ")
-                .append(var)
-                .append(");\n");
-        text.add(buf.toString());
-    }
-
-    public void visitTypeInsn(final int opcode, final String type) {
-        buf.setLength(0);
-        buf.append("mv.visitTypeInsn(").append(OPCODES[opcode]).append(", ");
-        appendConstant(type);
-        buf.append(");\n");
-        text.add(buf.toString());
-    }
-
-    public void visitFieldInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        buf.setLength(0);
-        buf.append("mv.visitFieldInsn(").append(OPCODES[opcode]).append(", ");
-        appendConstant(owner);
-        buf.append(", ");
-        appendConstant(name);
-        buf.append(", ");
-        appendConstant(desc);
-        buf.append(");\n");
-        text.add(buf.toString());
-    }
-
-    public void visitMethodInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        buf.setLength(0);
-        buf.append("mv.visitMethodInsn(").append(OPCODES[opcode]).append(", ");
-        appendConstant(owner);
-        buf.append(", ");
-        appendConstant(name);
-        buf.append(", ");
-        appendConstant(desc);
-        buf.append(");\n");
-        text.add(buf.toString());
-    }
-
-    public void visitJumpInsn(final int opcode, final Label label) {
-        buf.setLength(0);
-        declareLabel(label);
-        buf.append("mv.visitJumpInsn(").append(OPCODES[opcode]).append(", ");
-        appendLabel(label);
-        buf.append(");\n");
-        text.add(buf.toString());
-    }
-
-    public void visitLabel(final Label label) {
-        buf.setLength(0);
-        declareLabel(label);
-        buf.append("mv.visitLabel(");
-        appendLabel(label);
-        buf.append(");\n");
-        text.add(buf.toString());
-    }
-
-    public void visitLdcInsn(final Object cst) {
-        buf.setLength(0);
-        buf.append("mv.visitLdcInsn(");
-        appendConstant(cst);
-        buf.append(");\n");
-        text.add(buf.toString());
-    }
-
-    public void visitIincInsn(final int var, final int increment) {
-        buf.setLength(0);
-        buf.append("mv.visitIincInsn(")
-                .append(var)
-                .append(", ")
-                .append(increment)
-                .append(");\n");
-        text.add(buf.toString());
-    }
-
-    public void visitTableSwitchInsn(
-        final int min,
-        final int max,
-        final Label dflt,
-        final Label[] labels)
-    {
-        buf.setLength(0);
-        for (int i = 0; i < labels.length; ++i) {
-            declareLabel(labels[i]);
-        }
-        declareLabel(dflt);
-
-        buf.append("mv.visitTableSwitchInsn(")
-                .append(min)
-                .append(", ")
-                .append(max)
-                .append(", ");
-        appendLabel(dflt);
-        buf.append(", new Label[] {");
-        for (int i = 0; i < labels.length; ++i) {
-            buf.append(i == 0 ? " " : ", ");
-            appendLabel(labels[i]);
-        }
-        buf.append(" });\n");
-        text.add(buf.toString());
-    }
-
-    public void visitLookupSwitchInsn(
-        final Label dflt,
-        final int[] keys,
-        final Label[] labels)
-    {
-        buf.setLength(0);
-        for (int i = 0; i < labels.length; ++i) {
-            declareLabel(labels[i]);
-        }
-        declareLabel(dflt);
-
-        buf.append("mv.visitLookupSwitchInsn(");
-        appendLabel(dflt);
-        buf.append(", new int[] {");
-        for (int i = 0; i < keys.length; ++i) {
-            buf.append(i == 0 ? " " : ", ").append(keys[i]);
-        }
-        buf.append(" }, new Label[] {");
-        for (int i = 0; i < labels.length; ++i) {
-            buf.append(i == 0 ? " " : ", ");
-            appendLabel(labels[i]);
-        }
-        buf.append(" });\n");
-        text.add(buf.toString());
-    }
-
-    public void visitMultiANewArrayInsn(final String desc, final int dims) {
-        buf.setLength(0);
-        buf.append("mv.visitMultiANewArrayInsn(");
-        appendConstant(desc);
-        buf.append(", ").append(dims).append(");\n");
-        text.add(buf.toString());
-    }
-
-    public void visitTryCatchBlock(
-        final Label start,
-        final Label end,
-        final Label handler,
-        final String type)
-    {
-        buf.setLength(0);
-        declareLabel(start);
-        declareLabel(end);
-        declareLabel(handler);
-        buf.append("mv.visitTryCatchBlock(");
-        appendLabel(start);
-        buf.append(", ");
-        appendLabel(end);
-        buf.append(", ");
-        appendLabel(handler);
-        buf.append(", ");
-        appendConstant(type);
-        buf.append(");\n");
-        text.add(buf.toString());
-    }
-
-    public void visitLocalVariable(
-        final String name,
-        final String desc,
-        final String signature,
-        final Label start,
-        final Label end,
-        final int index)
-    {
-        buf.setLength(0);
-        buf.append("mv.visitLocalVariable(");
-        appendConstant(name);
-        buf.append(", ");
-        appendConstant(desc);
-        buf.append(", ");
-        appendConstant(signature);
-        buf.append(", ");
-        appendLabel(start);
-        buf.append(", ");
-        appendLabel(end);
-        buf.append(", ").append(index).append(");\n");
-        text.add(buf.toString());
-    }
-
-    public void visitLineNumber(final int line, final Label start) {
-        buf.setLength(0);
-        buf.append("mv.visitLineNumber(").append(line).append(", ");
-        appendLabel(start);
-        buf.append(");\n");
-        text.add(buf.toString());
-    }
-
-    public void visitMaxs(final int maxStack, final int maxLocals) {
-        buf.setLength(0);
-        buf.append("mv.visitMaxs(")
-                .append(maxStack)
-                .append(", ")
-                .append(maxLocals)
-                .append(");\n");
-        text.add(buf.toString());
-    }
-
-    private void declareFrameTypes(final int n, final Object[] o) {
-        for (int i = 0; i < n; ++i) {
-            if (o[i] instanceof Label) {
-                declareLabel((Label) o[i]);
-            }
-        }
-    }
-
-    private void appendFrameTypes(final int n, final Object[] o) {
-        for (int i = 0; i < n; ++i) {
-            if (i > 0) {
-                buf.append(", ");
-            }
-            if (o[i] instanceof String) {
-                appendConstant(o[i]);
-            } else if (o[i] instanceof Integer) {
-                switch (((Integer) o[i]).intValue()) {
-                    case 0:
-                        buf.append("Opcodes.TOP");
-                        break;
-                    case 1:
-                        buf.append("Opcodes.INTEGER");
-                        break;
-                    case 2:
-                        buf.append("Opcodes.FLOAT");
-                        break;
-                    case 3:
-                        buf.append("Opcodes.DOUBLE");
-                        break;
-                    case 4:
-                        buf.append("Opcodes.LONG");
-                        break;
-                    case 5:
-                        buf.append("Opcodes.NULL");
-                        break;
-                    case 6:
-                        buf.append("Opcodes.UNINITIALIZED_THIS");
-                        break;
-                }
-            } else {
-                appendLabel((Label) o[i]);
-            }
-        }
-    }
-
-    /**
-     * Appends a declaration of the given label to {@link #buf buf}. This
-     * declaration is of the form "Label lXXX = new Label();". Does nothing if
-     * the given label has already been declared.
-     * 
-     * @param l a label.
-     */
-    private void declareLabel(final Label l) {
-        String name = (String) labelNames.get(l);
-        if (name == null) {
-            name = "l" + labelNames.size();
-            labelNames.put(l, name);
-            buf.append("Label ").append(name).append(" = new Label();\n");
-        }
-    }
-
-    /**
-     * Appends the name of the given label to {@link #buf buf}. The given label
-     * <i>must</i> already have a name. One way to ensure this is to always
-     * call {@link #declareLabel declared} before calling this method.
-     * 
-     * @param l a label.
-     */
-    private void appendLabel(final Label l) {
-        buf.append((String) labelNames.get(l));
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/CheckAnnotationAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/CheckAnnotationAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/CheckAnnotationAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/CheckAnnotationAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,132 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-
-/**
- * An {@link AnnotationVisitor} that checks that its methods are properly used.
- * 
- * @author Eric Bruneton
- */
-public class CheckAnnotationAdapter implements AnnotationVisitor {
-
-    private final AnnotationVisitor av;
-
-    private final boolean named;
-
-    private boolean end;
-
-    public CheckAnnotationAdapter(final AnnotationVisitor av) {
-        this(av, true);
-    }
-
-    CheckAnnotationAdapter(final AnnotationVisitor av, final boolean named) {
-        this.av = av;
-        this.named = named;
-    }
-
-    public void visit(final String name, final Object value) {
-        checkEnd();
-        checkName(name);
-        if (!(value instanceof Byte || value instanceof Boolean
-                || value instanceof Character || value instanceof Short
-                || value instanceof Integer || value instanceof Long
-                || value instanceof Float || value instanceof Double
-                || value instanceof String || value instanceof Type
-                || value instanceof byte[] || value instanceof boolean[]
-                || value instanceof char[] || value instanceof short[]
-                || value instanceof int[] || value instanceof long[]
-                || value instanceof float[] || value instanceof double[]))
-        {
-            throw new IllegalArgumentException("Invalid annotation value");
-        }
-        if (av != null) {
-            av.visit(name, value);
-        }
-    }
-
-    public void visitEnum(
-        final String name,
-        final String desc,
-        final String value)
-    {
-        checkEnd();
-        checkName(name);
-        CheckMethodAdapter.checkDesc(desc, false);
-        if (value == null) {
-            throw new IllegalArgumentException("Invalid enum value");
-        }
-        if (av != null) {
-            av.visitEnum(name, desc, value);
-        }
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String name,
-        final String desc)
-    {
-        checkEnd();
-        checkName(name);
-        CheckMethodAdapter.checkDesc(desc, false);
-        return new CheckAnnotationAdapter(av == null
-                ? null
-                : av.visitAnnotation(name, desc));
-    }
-
-    public AnnotationVisitor visitArray(final String name) {
-        checkEnd();
-        checkName(name);
-        return new CheckAnnotationAdapter(av == null
-                ? null
-                : av.visitArray(name), false);
-    }
-
-    public void visitEnd() {
-        checkEnd();
-        end = true;
-        if (av != null) {
-            av.visitEnd();
-        }
-    }
-
-    private void checkEnd() {
-        if (end) {
-            throw new IllegalStateException("Cannot call a visit method after visitEnd has been called");
-        }
-    }
-
-    private void checkName(final String name) {
-        if (named && name == null) {
-            throw new IllegalArgumentException("Annotation value name must not be null");
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/CheckClassAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/CheckClassAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/CheckClassAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/CheckClassAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,569 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import java.io.FileInputStream;
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-import org.eclipse.persistence.internal.libraries.asm.ClassAdapter;
-import org.eclipse.persistence.internal.libraries.asm.ClassReader;
-import org.eclipse.persistence.internal.libraries.asm.ClassVisitor;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-import org.eclipse.persistence.internal.libraries.asm.tree.ClassNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.MethodNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.TryCatchBlockNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.analysis.Analyzer;
-import org.eclipse.persistence.internal.libraries.asm.tree.analysis.Frame;
-import org.eclipse.persistence.internal.libraries.asm.tree.analysis.SimpleVerifier;
-
-/**
- * A {@link ClassAdapter} that checks that its methods are properly used. More
- * precisely this class adapter checks each method call individually, based
- * <i>only</i> on its arguments, but does <i>not</i> check the <i>sequence</i>
- * of method calls. For example, the invalid sequence
- * <tt>visitField(ACC_PUBLIC, "i", "I", null)</tt> <tt>visitField(ACC_PUBLIC,
- * "i", "D", null)</tt>
- * will <i>not</i> be detected by this class adapter.
- *
- * <p><code>CheckClassAdapter</code> can be also used to verify bytecode
- * transformations in order to make sure transformed bytecode is sane. For
- * example:
- *
- * <pre>
- *   InputStream is = ...; // get bytes for the source class
- *   ClassReader cr = new ClassReader(is);
- *   ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_MAXS);
- *   ClassVisitor cv = new <b>MyClassAdapter</b>(new CheckClassAdapter(cw));
- *   cr.accept(cv, 0);
- *
- *   StringWriter sw = new StringWriter();
- *   PrintWriter pw = new PrintWriter(sw);
- *   CheckClassAdapter.verify(new ClassReader(cw.toByteArray()), false, pw);
- *   assertTrue(sw.toString(), sw.toString().length()==0);
- * </pre>
- *
- * Above code runs transformed bytecode trough the
- * <code>CheckClassAdapter</code>. It won't be exactly the same verification
- * as JVM does, but it run data flow analysis for the code of each method and
- * checks that expectations are met for each method instruction.
- *
- * <p>If method bytecode has errors, assertion text will show the erroneous
- * instruction number and dump of the failed method with information about
- * locals and stack slot for each instruction. For example (format is -
- * insnNumber locals : stack):
- *
- * <pre>
- * org.objectweb.asm.tree.analysis.AnalyzerException: Error at instruction 71: Expected I, but found .
- *   at org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:289)
- *   at org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:135)
- * ...
- * remove()V
- * 00000 LinkedBlockingQueue$Itr . . . . . . . .  :
- *   ICONST_0
- * 00001 LinkedBlockingQueue$Itr . . . . . . . .  : I
- *   ISTORE 2
- * 00001 LinkedBlockingQueue$Itr <b>.</b> I . . . . . .  :
- * ...
- *
- * 00071 LinkedBlockingQueue$Itr <b>.</b> I . . . . . .  :
- *   ILOAD 1
- * 00072 <b>?</b>
- *   INVOKESPECIAL java/lang/Integer.<init> (I)V
- * ...
- * </pre>
- *
- * In the above output you can see that variable 1 loaded by
- * <code>ILOAD 1</code> instruction at position <code>00071</code> is not
- * initialized. You can also see that at the beginning of the method (code
- * inserted by the transformation) variable 2 is initialized.
- *
- * <p>Note that when used like that, <code>CheckClassAdapter.verify()</code>
- * can trigger additional class loading, because it is using
- * <code>SimpleVerifier</code>.
- *
- * @author Eric Bruneton
- */
-public class CheckClassAdapter extends ClassAdapter {
-
-    /**
-     * The class version number.
-     */
-    private int version;
-    
-    /**
-     * <tt>true</tt> if the visit method has been called.
-     */
-    private boolean start;
-
-    /**
-     * <tt>true</tt> if the visitSource method has been called.
-     */
-    private boolean source;
-
-    /**
-     * <tt>true</tt> if the visitOuterClass method has been called.
-     */
-    private boolean outer;
-
-    /**
-     * <tt>true</tt> if the visitEnd method has been called.
-     */
-    private boolean end;
-
-    /**
-     * The already visited labels. This map associate Integer values to Label
-     * keys.
-     */
-    private Map labels;
-
-    /**
-     * <tt>true</tt> if the method code must be checked with a BasicVerifier.
-     */
-    private boolean checkDataFlow;
-
-    /**
-     * Checks a given class. <p> Usage: CheckClassAdapter &lt;fully qualified
-     * class name or class file name&gt;
-     *
-     * @param args the command line arguments.
-     *
-     * @throws Exception if the class cannot be found, or if an IO exception
-     *         occurs.
-     */
-    public static void main(final String[] args) throws Exception {
-        if (args.length != 1) {
-            System.err.println("Verifies the given class.");
-            System.err.println("Usage: CheckClassAdapter "
-                    + "<fully qualified class name or class file name>");
-            return;
-        }
-        ClassReader cr;
-        if (args[0].endsWith(".class")) {
-            cr = new ClassReader(new FileInputStream(args[0]));
-        } else {
-            cr = new ClassReader(args[0]);
-        }
-
-        verify(cr, false, new PrintWriter(System.err));
-    }
-
-    /**
-     * Checks a given class
-     *
-     * @param cr a <code>ClassReader</code> that contains bytecode for the
-     *        analysis.
-     * @param loader a <code>ClassLoader</code> which will be used to load
-     *        referenced classes. This is useful if you are verifiying multiple
-     *        interdependent classes.
-     * @param dump true if bytecode should be printed out not only when errors
-     *        are found.
-     * @param pw write where results going to be printed
-     */
-    public static void verify(
-        final ClassReader cr,
-        final ClassLoader loader,
-        final boolean dump,
-        final PrintWriter pw)
-    {
-        ClassNode cn = new ClassNode();
-        cr.accept(new CheckClassAdapter(cn, false), ClassReader.SKIP_DEBUG);
-
-        Type syperType = cn.superName == null
-                ? null
-                : Type.getObjectType(cn.superName);
-        List methods = cn.methods;
-
-        List interfaces = new ArrayList();
-        for (Iterator i = cn.interfaces.iterator(); i.hasNext();) {
-            interfaces.add(Type.getObjectType(i.next().toString()));
-        }
-
-        for (int i = 0; i < methods.size(); ++i) {
-            MethodNode method = (MethodNode) methods.get(i);
-            SimpleVerifier verifier = new SimpleVerifier(Type.getObjectType(cn.name),
-                    syperType,
-                    interfaces,
-                    (cn.access | Opcodes.ACC_INTERFACE) != 0);
-            Analyzer a = new Analyzer(verifier);
-            if (loader != null) {
-                verifier.setClassLoader(loader);
-            }
-            try {
-                a.analyze(cn.name, method);
-                if (!dump) {
-                    continue;
-                }
-            } catch (Exception e) {
-                e.printStackTrace(pw);
-            }
-            printAnalyzerResult(method, a, pw);
-        }
-        pw.flush();
-    }
-
-    /**
-     * Checks a given class
-     *
-     * @param cr a <code>ClassReader</code> that contains bytecode for the
-     *        analysis.
-     * @param dump true if bytecode should be printed out not only when errors
-     *        are found.
-     * @param pw write where results going to be printed
-     */
-    public static void verify(
-        final ClassReader cr,
-        final boolean dump,
-        final PrintWriter pw)
-    {
-        verify(cr, null, dump, pw);
-    }
-
-    static void printAnalyzerResult(
-        MethodNode method,
-        Analyzer a,
-        final PrintWriter pw)
-    {
-        Frame[] frames = a.getFrames();
-        TraceMethodVisitor mv = new TraceMethodVisitor();
-
-        pw.println(method.name + method.desc);
-        for (int j = 0; j < method.instructions.size(); ++j) {
-            method.instructions.get(j).accept(mv);
-
-            StringBuffer s = new StringBuffer();
-            Frame f = frames[j];
-            if (f == null) {
-                s.append('?');
-            } else {
-                for (int k = 0; k < f.getLocals(); ++k) {
-                    s.append(getShortName(f.getLocal(k).toString()))
-                            .append(' ');
-                }
-                s.append(" : ");
-                for (int k = 0; k < f.getStackSize(); ++k) {
-                    s.append(getShortName(f.getStack(k).toString()))
-                            .append(' ');
-                }
-            }
-            while (s.length() < method.maxStack + method.maxLocals + 1) {
-                s.append(' ');
-            }
-            pw.print(Integer.toString(j + 100000).substring(1));
-            pw.print(" " + s + " : " + mv.buf); // mv.text.get(j));
-        }
-        for (int j = 0; j < method.tryCatchBlocks.size(); ++j) {
-            ((TryCatchBlockNode) method.tryCatchBlocks.get(j)).accept(mv);
-            pw.print(" " + mv.buf);
-        }
-        pw.println();
-    }
-
-    private static String getShortName(final String name) {
-        int n = name.lastIndexOf('/');
-        int k = name.length();
-        if (name.charAt(k - 1) == ';') {
-            k--;
-        }
-        return n == -1 ? name : name.substring(n + 1, k);
-    }
-
-    /**
-     * Constructs a new {@link CheckClassAdapter}.
-     *
-     * @param cv the class visitor to which this adapter must delegate calls.
-     */
-    public CheckClassAdapter(final ClassVisitor cv) {
-        this(cv, true);
-    }
-
-    /**
-     * Constructs a new {@link CheckClassAdapter}.
-     *
-     * @param cv the class visitor to which this adapter must delegate calls.
-     * @param checkDataFlow <tt>true</tt> to perform basic data flow checks, or
-     *        <tt>false</tt> to not perform any data flow check (see
-     *        {@link CheckMethodAdapter}). This option requires valid maxLocals
-     *        and maxStack values.
-     */
-    public CheckClassAdapter(final ClassVisitor cv, boolean checkDataFlow) {
-        super(cv);
-        this.labels = new HashMap();
-        this.checkDataFlow = checkDataFlow;
-    }
-
-    // ------------------------------------------------------------------------
-    // Implementation of the ClassVisitor interface
-    // ------------------------------------------------------------------------
-
-    public void visit(
-        final int version,
-        final int access,
-        final String name,
-        final String signature,
-        final String superName,
-        final String[] interfaces)
-    {
-        if (start) {
-            throw new IllegalStateException("visit must be called only once");
-        }
-        start = true;
-        checkState();
-        checkAccess(access, Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL
-                + Opcodes.ACC_SUPER + Opcodes.ACC_INTERFACE
-                + Opcodes.ACC_ABSTRACT + Opcodes.ACC_SYNTHETIC
-                + Opcodes.ACC_ANNOTATION + Opcodes.ACC_ENUM
-                + Opcodes.ACC_DEPRECATED
-                + 0x40000); // ClassWriter.ACC_SYNTHETIC_ATTRIBUTE
-        if (name == null || !name.endsWith("package-info")) {
-            CheckMethodAdapter.checkInternalName(name, "class name");
-        }
-        if ("java/lang/Object".equals(name)) {
-            if (superName != null) {
-                throw new IllegalArgumentException("The super class name of the Object class must be 'null'");
-            }
-        } else {
-            CheckMethodAdapter.checkInternalName(superName, "super class name");
-        }
-        if (signature != null) {
-            CheckMethodAdapter.checkClassSignature(signature);
-        }
-        if ((access & Opcodes.ACC_INTERFACE) != 0) {
-            if (!"java/lang/Object".equals(superName)) {
-                throw new IllegalArgumentException("The super class name of interfaces must be 'java/lang/Object'");
-            }
-        }
-        if (interfaces != null) {
-            for (int i = 0; i < interfaces.length; ++i) {
-                CheckMethodAdapter.checkInternalName(interfaces[i],
-                        "interface name at index " + i);
-            }
-        }
-        this.version = version;
-        cv.visit(version, access, name, signature, superName, interfaces);
-    }
-
-    public void visitSource(final String file, final String debug) {
-        checkState();
-        if (source) {
-            throw new IllegalStateException("visitSource can be called only once.");
-        }
-        source = true;
-        cv.visitSource(file, debug);
-    }
-
-    public void visitOuterClass(
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        checkState();
-        if (outer) {
-            throw new IllegalStateException("visitOuterClass can be called only once.");
-        }
-        outer = true;
-        if (owner == null) {
-            throw new IllegalArgumentException("Illegal outer class owner");
-        }
-        if (desc != null) {
-            CheckMethodAdapter.checkMethodDesc(desc);
-        }
-        cv.visitOuterClass(owner, name, desc);
-    }
-
-    public void visitInnerClass(
-        final String name,
-        final String outerName,
-        final String innerName,
-        final int access)
-    {
-        checkState();
-        CheckMethodAdapter.checkInternalName(name, "class name");
-        if (outerName != null) {
-            CheckMethodAdapter.checkInternalName(outerName, "outer class name");
-        }
-        if (innerName != null) {
-            CheckMethodAdapter.checkIdentifier(innerName, "inner class name");
-        }
-        checkAccess(access, Opcodes.ACC_PUBLIC + Opcodes.ACC_PRIVATE
-                + Opcodes.ACC_PROTECTED + Opcodes.ACC_STATIC
-                + Opcodes.ACC_FINAL + Opcodes.ACC_INTERFACE
-                + Opcodes.ACC_ABSTRACT + Opcodes.ACC_SYNTHETIC
-                + Opcodes.ACC_ANNOTATION + Opcodes.ACC_ENUM);
-        cv.visitInnerClass(name, outerName, innerName, access);
-    }
-
-    public FieldVisitor visitField(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final Object value)
-    {
-        checkState();
-        checkAccess(access, Opcodes.ACC_PUBLIC + Opcodes.ACC_PRIVATE
-                + Opcodes.ACC_PROTECTED + Opcodes.ACC_STATIC
-                + Opcodes.ACC_FINAL + Opcodes.ACC_VOLATILE
-                + Opcodes.ACC_TRANSIENT + Opcodes.ACC_SYNTHETIC
-                + Opcodes.ACC_ENUM + Opcodes.ACC_DEPRECATED
-                + 0x40000); // ClassWriter.ACC_SYNTHETIC_ATTRIBUTE
-        CheckMethodAdapter.checkUnqualifiedName(version, name, "field name");
-        CheckMethodAdapter.checkDesc(desc, false);
-        if (signature != null) {
-            CheckMethodAdapter.checkFieldSignature(signature);
-        }
-        if (value != null) {
-            CheckMethodAdapter.checkConstant(value);
-        }
-        FieldVisitor av = cv.visitField(access, name, desc, signature, value);
-        return new CheckFieldAdapter(av);
-    }
-
-    public MethodVisitor visitMethod(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final String[] exceptions)
-    {
-        checkState();
-        checkAccess(access, Opcodes.ACC_PUBLIC + Opcodes.ACC_PRIVATE
-                + Opcodes.ACC_PROTECTED + Opcodes.ACC_STATIC
-                + Opcodes.ACC_FINAL + Opcodes.ACC_SYNCHRONIZED
-                + Opcodes.ACC_BRIDGE + Opcodes.ACC_VARARGS + Opcodes.ACC_NATIVE
-                + Opcodes.ACC_ABSTRACT + Opcodes.ACC_STRICT
-                + Opcodes.ACC_SYNTHETIC + Opcodes.ACC_DEPRECATED
-                + 0x40000); // ClassWriter.ACC_SYNTHETIC_ATTRIBUTE
-        CheckMethodAdapter.checkMethodIdentifier(version, name, "method name");
-        CheckMethodAdapter.checkMethodDesc(desc);
-        if (signature != null) {
-            CheckMethodAdapter.checkMethodSignature(signature);
-        }
-        if (exceptions != null) {
-            for (int i = 0; i < exceptions.length; ++i) {
-                CheckMethodAdapter.checkInternalName(exceptions[i],
-                        "exception name at index " + i);
-            }
-        }
-        CheckMethodAdapter cma;
-        if (checkDataFlow) {
-            cma = new CheckMethodAdapter(access,
-                    name,
-                    desc,
-                    cv.visitMethod(access, name, desc, signature, exceptions),
-                    labels);
-        } else {
-            cma = new CheckMethodAdapter(cv.visitMethod(access,
-                    name,
-                    desc,
-                    signature,
-                    exceptions), labels);
-        }
-        cma.version = version;
-        return cma;
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        checkState();
-        CheckMethodAdapter.checkDesc(desc, false);
-        return new CheckAnnotationAdapter(cv.visitAnnotation(desc, visible));
-    }
-
-    public void visitAttribute(final Attribute attr) {
-        checkState();
-        if (attr == null) {
-            throw new IllegalArgumentException("Invalid attribute (must not be null)");
-        }
-        cv.visitAttribute(attr);
-    }
-
-    public void visitEnd() {
-        checkState();
-        end = true;
-        cv.visitEnd();
-    }
-
-    // ------------------------------------------------------------------------
-    // Utility methods
-    // ------------------------------------------------------------------------
-
-    /**
-     * Checks that the visit method has been called and that visitEnd has not
-     * been called.
-     */
-    private void checkState() {
-        if (!start) {
-            throw new IllegalStateException("Cannot visit member before visit has been called.");
-        }
-        if (end) {
-            throw new IllegalStateException("Cannot visit member after visitEnd has been called.");
-        }
-    }
-
-    /**
-     * Checks that the given access flags do not contain invalid flags. This
-     * method also checks that mutually incompatible flags are not set
-     * simultaneously.
-     *
-     * @param access the access flags to be checked
-     * @param possibleAccess the valid access flags.
-     */
-    static void checkAccess(final int access, final int possibleAccess) {
-        if ((access & ~possibleAccess) != 0) {
-            throw new IllegalArgumentException("Invalid access flags: "
-                    + access);
-        }
-        int pub = (access & Opcodes.ACC_PUBLIC) == 0 ? 0 : 1;
-        int pri = (access & Opcodes.ACC_PRIVATE) == 0 ? 0 : 1;
-        int pro = (access & Opcodes.ACC_PROTECTED) == 0 ? 0 : 1;
-        if (pub + pri + pro > 1) {
-            throw new IllegalArgumentException("public private and protected are mutually exclusive: "
-                    + access);
-        }
-        int fin = (access & Opcodes.ACC_FINAL) == 0 ? 0 : 1;
-        int abs = (access & Opcodes.ACC_ABSTRACT) == 0 ? 0 : 1;
-        if (fin + abs > 1) {
-            throw new IllegalArgumentException("final and abstract are mutually exclusive: "
-                    + access);
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/CheckFieldAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/CheckFieldAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/CheckFieldAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/CheckFieldAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-
-/**
- * A {@link FieldVisitor} that checks that its methods are properly used.
- */
-public class CheckFieldAdapter implements FieldVisitor {
-
-    private final FieldVisitor fv;
-
-    private boolean end;
-
-    public CheckFieldAdapter(final FieldVisitor fv) {
-        this.fv = fv;
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        checkEnd();
-        CheckMethodAdapter.checkDesc(desc, false);
-        return new CheckAnnotationAdapter(fv.visitAnnotation(desc, visible));
-    }
-
-    public void visitAttribute(final Attribute attr) {
-        checkEnd();
-        if (attr == null) {
-            throw new IllegalArgumentException("Invalid attribute (must not be null)");
-        }
-        fv.visitAttribute(attr);
-    }
-
-    public void visitEnd() {
-        checkEnd();
-        end = true;
-        fv.visitEnd();
-    }
-
-    private void checkEnd() {
-        if (end) {
-            throw new IllegalStateException("Cannot call a visit method after visitEnd has been called");
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/CheckMethodAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/CheckMethodAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/CheckMethodAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/CheckMethodAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,1498 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodAdapter;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-import org.eclipse.persistence.internal.libraries.asm.tree.MethodNode;
-import org.eclipse.persistence.internal.libraries.asm.tree.analysis.Analyzer;
-import org.eclipse.persistence.internal.libraries.asm.tree.analysis.BasicVerifier;
-
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.lang.reflect.Field;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * A {@link MethodAdapter} that checks that its methods are properly used. More
- * precisely this method adapter checks each instruction individually, i.e.,
- * each visit method checks some preconditions based <i>only</i> on its
- * arguments - such as the fact that the given opcode is correct for a given
- * visit method. This adapter can also perform some basic data flow checks (more
- * precisely those that can be performed without the full class hierarchy - see
- * {@link org.eclipse.persistence.internal.libraries.asm.tree.analysis.BasicVerifier}). For instance in a
- * method whose signature is <tt>void m ()</tt>, the invalid instruction
- * IRETURN, or the invalid sequence IADD L2I will be detected if the data flow
- * checks are enabled. These checks are enabled by using the {@link 
- * CheckMethodAdapter(int,String,String,MethodVisitor,Map)} constructor. They
- * are not performed if any other constructor is used.
- * 
- * @author Eric Bruneton
- */
-public class CheckMethodAdapter extends MethodAdapter {
-
-    /**
-     * The class version number.
-     */
-    public int version;
-    
-    /**
-     * <tt>true</tt> if the visitCode method has been called.
-     */
-    private boolean startCode;
-
-    /**
-     * <tt>true</tt> if the visitMaxs method has been called.
-     */
-    private boolean endCode;
-
-    /**
-     * <tt>true</tt> if the visitEnd method has been called.
-     */
-    private boolean endMethod;
-
-    /**
-     * The already visited labels. This map associate Integer values to Label
-     * keys.
-     */
-    private final Map labels;
-
-    /**
-     * Code of the visit method to be used for each opcode.
-     */
-    private static final int[] TYPE;
-    
-    /**
-     * The Label.status field.
-     */
-    private static Field labelStatusField;
-
-    static {
-        String s = "BBBBBBBBBBBBBBBBCCIAADDDDDAAAAAAAAAAAAAAAAAAAABBBBBBBBDD"
-                + "DDDAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
-                + "BBBBBBBBBBBBBBBBBBBJBBBBBBBBBBBBBBBBBBBBHHHHHHHHHHHHHHHHD"
-                + "KLBBBBBBFFFFGGGGGECEBBEEBBAMHHAA";
-        TYPE = new int[s.length()];
-        for (int i = 0; i < TYPE.length; ++i) {
-            TYPE[i] = s.charAt(i) - 'A' - 1;
-        }
-    }
-
-    // code to generate the above string
-    // public static void main (String[] args) {
-    // int[] TYPE = new int[] {
-    // 0, //NOP
-    // 0, //ACONST_NULL
-    // 0, //ICONST_M1
-    // 0, //ICONST_0
-    // 0, //ICONST_1
-    // 0, //ICONST_2
-    // 0, //ICONST_3
-    // 0, //ICONST_4
-    // 0, //ICONST_5
-    // 0, //LCONST_0
-    // 0, //LCONST_1
-    // 0, //FCONST_0
-    // 0, //FCONST_1
-    // 0, //FCONST_2
-    // 0, //DCONST_0
-    // 0, //DCONST_1
-    // 1, //BIPUSH
-    // 1, //SIPUSH
-    // 7, //LDC
-    // -1, //LDC_W
-    // -1, //LDC2_W
-    // 2, //ILOAD
-    // 2, //LLOAD
-    // 2, //FLOAD
-    // 2, //DLOAD
-    // 2, //ALOAD
-    // -1, //ILOAD_0
-    // -1, //ILOAD_1
-    // -1, //ILOAD_2
-    // -1, //ILOAD_3
-    // -1, //LLOAD_0
-    // -1, //LLOAD_1
-    // -1, //LLOAD_2
-    // -1, //LLOAD_3
-    // -1, //FLOAD_0
-    // -1, //FLOAD_1
-    // -1, //FLOAD_2
-    // -1, //FLOAD_3
-    // -1, //DLOAD_0
-    // -1, //DLOAD_1
-    // -1, //DLOAD_2
-    // -1, //DLOAD_3
-    // -1, //ALOAD_0
-    // -1, //ALOAD_1
-    // -1, //ALOAD_2
-    // -1, //ALOAD_3
-    // 0, //IALOAD
-    // 0, //LALOAD
-    // 0, //FALOAD
-    // 0, //DALOAD
-    // 0, //AALOAD
-    // 0, //BALOAD
-    // 0, //CALOAD
-    // 0, //SALOAD
-    // 2, //ISTORE
-    // 2, //LSTORE
-    // 2, //FSTORE
-    // 2, //DSTORE
-    // 2, //ASTORE
-    // -1, //ISTORE_0
-    // -1, //ISTORE_1
-    // -1, //ISTORE_2
-    // -1, //ISTORE_3
-    // -1, //LSTORE_0
-    // -1, //LSTORE_1
-    // -1, //LSTORE_2
-    // -1, //LSTORE_3
-    // -1, //FSTORE_0
-    // -1, //FSTORE_1
-    // -1, //FSTORE_2
-    // -1, //FSTORE_3
-    // -1, //DSTORE_0
-    // -1, //DSTORE_1
-    // -1, //DSTORE_2
-    // -1, //DSTORE_3
-    // -1, //ASTORE_0
-    // -1, //ASTORE_1
-    // -1, //ASTORE_2
-    // -1, //ASTORE_3
-    // 0, //IASTORE
-    // 0, //LASTORE
-    // 0, //FASTORE
-    // 0, //DASTORE
-    // 0, //AASTORE
-    // 0, //BASTORE
-    // 0, //CASTORE
-    // 0, //SASTORE
-    // 0, //POP
-    // 0, //POP2
-    // 0, //DUP
-    // 0, //DUP_X1
-    // 0, //DUP_X2
-    // 0, //DUP2
-    // 0, //DUP2_X1
-    // 0, //DUP2_X2
-    // 0, //SWAP
-    // 0, //IADD
-    // 0, //LADD
-    // 0, //FADD
-    // 0, //DADD
-    // 0, //ISUB
-    // 0, //LSUB
-    // 0, //FSUB
-    // 0, //DSUB
-    // 0, //IMUL
-    // 0, //LMUL
-    // 0, //FMUL
-    // 0, //DMUL
-    // 0, //IDIV
-    // 0, //LDIV
-    // 0, //FDIV
-    // 0, //DDIV
-    // 0, //IREM
-    // 0, //LREM
-    // 0, //FREM
-    // 0, //DREM
-    // 0, //INEG
-    // 0, //LNEG
-    // 0, //FNEG
-    // 0, //DNEG
-    // 0, //ISHL
-    // 0, //LSHL
-    // 0, //ISHR
-    // 0, //LSHR
-    // 0, //IUSHR
-    // 0, //LUSHR
-    // 0, //IAND
-    // 0, //LAND
-    // 0, //IOR
-    // 0, //LOR
-    // 0, //IXOR
-    // 0, //LXOR
-    // 8, //IINC
-    // 0, //I2L
-    // 0, //I2F
-    // 0, //I2D
-    // 0, //L2I
-    // 0, //L2F
-    // 0, //L2D
-    // 0, //F2I
-    // 0, //F2L
-    // 0, //F2D
-    // 0, //D2I
-    // 0, //D2L
-    // 0, //D2F
-    // 0, //I2B
-    // 0, //I2C
-    // 0, //I2S
-    // 0, //LCMP
-    // 0, //FCMPL
-    // 0, //FCMPG
-    // 0, //DCMPL
-    // 0, //DCMPG
-    // 6, //IFEQ
-    // 6, //IFNE
-    // 6, //IFLT
-    // 6, //IFGE
-    // 6, //IFGT
-    // 6, //IFLE
-    // 6, //IF_ICMPEQ
-    // 6, //IF_ICMPNE
-    // 6, //IF_ICMPLT
-    // 6, //IF_ICMPGE
-    // 6, //IF_ICMPGT
-    // 6, //IF_ICMPLE
-    // 6, //IF_ACMPEQ
-    // 6, //IF_ACMPNE
-    // 6, //GOTO
-    // 6, //JSR
-    // 2, //RET
-    // 9, //TABLESWITCH
-    // 10, //LOOKUPSWITCH
-    // 0, //IRETURN
-    // 0, //LRETURN
-    // 0, //FRETURN
-    // 0, //DRETURN
-    // 0, //ARETURN
-    // 0, //RETURN
-    // 4, //GETSTATIC
-    // 4, //PUTSTATIC
-    // 4, //GETFIELD
-    // 4, //PUTFIELD
-    // 5, //INVOKEVIRTUAL
-    // 5, //INVOKESPECIAL
-    // 5, //INVOKESTATIC
-    // 5, //INVOKEINTERFACE
-    // 5, //INVOKEDYNAMIC
-    // 3, //NEW
-    // 1, //NEWARRAY
-    // 3, //ANEWARRAY
-    // 0, //ARRAYLENGTH
-    // 0, //ATHROW
-    // 3, //CHECKCAST
-    // 3, //INSTANCEOF
-    // 0, //MONITORENTER
-    // 0, //MONITOREXIT
-    // -1, //WIDE
-    // 11, //MULTIANEWARRAY
-    // 6, //IFNULL
-    // 6, //IFNONNULL
-    // -1, //GOTO_W
-    // -1 //JSR_W
-    // };
-    // for (int i = 0; i < TYPE.length; ++i) {
-    // System.out.print((char)(TYPE[i] + 1 + 'A'));
-    // }
-    // System.out.println();
-    // }
-
-    /**
-     * Constructs a new {@link CheckMethodAdapter} object. This method adapter
-     * will not perform any data flow check (see {@link 
-     * CheckMethodAdapter(int,String,String,MethodVisitor,Map)}).
-     * 
-     * @param mv the method visitor to which this adapter must delegate calls.
-     */
-    public CheckMethodAdapter(final MethodVisitor mv) {
-        this(mv, new HashMap());
-    }
-
-    /**
-     * Constructs a new {@link CheckMethodAdapter} object. This method adapter
-     * will not perform any data flow check (see {@link 
-     * CheckMethodAdapter(int,String,String,MethodVisitor,Map)}).
-     * 
-     * @param mv the method visitor to which this adapter must delegate calls.
-     * @param labels a map of already visited labels (in other methods).
-     */
-    public CheckMethodAdapter(final MethodVisitor mv, final Map labels) {
-        super(mv);
-        this.labels = labels;
-    }
-
-    /**
-     * Constructs a new {@link CheckMethodAdapter} object. This method adapter
-     * will perform basic data flow checks. For instance in a method whose
-     * signature is <tt>void m ()</tt>, the invalid instruction IRETURN, or
-     * the invalid sequence IADD L2I will be detected.
-     * 
-     * @param access the method's access flags.
-     * @param name the method's name.
-     * @param desc the method's descriptor (see {@link Type Type}).
-     * @param mv the method visitor to which this adapter must delegate calls.
-     * @param labels a map of already visited labels (in other methods).
-     */
-    public CheckMethodAdapter(
-        final int access,
-        final String name,
-        final String desc,
-        final MethodVisitor mv,
-        final Map labels)
-    {
-        this(new MethodNode(access, name, desc, null, null) {
-            public void visitEnd() {
-                Analyzer a = new Analyzer(new BasicVerifier());
-                try {
-                    a.analyze("dummy", this);
-                } catch (Exception e) {
-                    if (e instanceof IndexOutOfBoundsException
-                            && maxLocals == 0 && maxStack == 0)
-                    {
-                        throw new RuntimeException("Data flow checking option requires valid, non zero maxLocals and maxStack values.");
-                    }
-                    e.printStackTrace();
-                    StringWriter sw = new StringWriter();
-                    PrintWriter pw = new PrintWriter(sw, true);
-                    CheckClassAdapter.printAnalyzerResult(this, a, pw);
-                    pw.close();
-                    throw new RuntimeException(e.getMessage() + ' ' + sw.toString());
-                }
-                accept(mv);
-            }
-        }, labels);
-    }
-    
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        checkEndMethod();
-        checkDesc(desc, false);
-        return new CheckAnnotationAdapter(mv.visitAnnotation(desc, visible));
-    }
-
-    public AnnotationVisitor visitAnnotationDefault() {
-        checkEndMethod();
-        return new CheckAnnotationAdapter(mv.visitAnnotationDefault(), false);
-    }
-
-    public AnnotationVisitor visitParameterAnnotation(
-        final int parameter,
-        final String desc,
-        final boolean visible)
-    {
-        checkEndMethod();
-        checkDesc(desc, false);
-        return new CheckAnnotationAdapter(mv.visitParameterAnnotation(parameter,
-                desc,
-                visible));
-    }
-
-    public void visitAttribute(final Attribute attr) {
-        checkEndMethod();
-        if (attr == null) {
-            throw new IllegalArgumentException("Invalid attribute (must not be null)");
-        }
-        mv.visitAttribute(attr);
-    }
-
-    public void visitCode() {
-        startCode = true;
-        mv.visitCode();
-    }
-
-    public void visitFrame(
-        final int type,
-        final int nLocal,
-        final Object[] local,
-        final int nStack,
-        final Object[] stack)
-    {
-        int mLocal;
-        int mStack;
-        switch (type) {
-            case Opcodes.F_NEW:
-            case Opcodes.F_FULL:
-                mLocal = Integer.MAX_VALUE;
-                mStack = Integer.MAX_VALUE;
-                break;
-
-            case Opcodes.F_SAME:
-                mLocal = 0;
-                mStack = 0;
-                break;
-
-            case Opcodes.F_SAME1:
-                mLocal = 0;
-                mStack = 1;
-                break;
-
-            case Opcodes.F_APPEND:
-            case Opcodes.F_CHOP:
-                mLocal = 3;
-                mStack = 0;
-                break;
-
-            default:
-                throw new IllegalArgumentException("Invalid frame type " + type);
-        }
-
-        if (nLocal > mLocal) {
-            throw new IllegalArgumentException("Invalid nLocal=" + nLocal
-                    + " for frame type " + type);
-        }
-        if (nStack > mStack) {
-            throw new IllegalArgumentException("Invalid nStack=" + nStack
-                    + " for frame type " + type);
-        }
-
-        if (type != Opcodes.F_CHOP) {
-            if (nLocal > 0 && (local == null || local.length < nLocal)) {
-                throw new IllegalArgumentException("Array local[] is shorter than nLocal");
-            }
-            for (int i = 0; i < nLocal; ++i) {
-                checkFrameValue(local[i]);
-            }
-        }
-        if (nStack > 0 && (stack == null || stack.length < nStack)) {
-            throw new IllegalArgumentException("Array stack[] is shorter than nStack");
-        }
-        for (int i = 0; i < nStack; ++i) {
-            checkFrameValue(stack[i]);
-        }
-
-        mv.visitFrame(type, nLocal, local, nStack, stack);
-    }
-
-    public void visitInsn(final int opcode) {
-        checkStartCode();
-        checkEndCode();
-        checkOpcode(opcode, 0);
-        mv.visitInsn(opcode);
-    }
-
-    public void visitIntInsn(final int opcode, final int operand) {
-        checkStartCode();
-        checkEndCode();
-        checkOpcode(opcode, 1);
-        switch (opcode) {
-            case Opcodes.BIPUSH:
-                checkSignedByte(operand, "Invalid operand");
-                break;
-            case Opcodes.SIPUSH:
-                checkSignedShort(operand, "Invalid operand");
-                break;
-            // case Constants.NEWARRAY:
-            default:
-                if (operand < Opcodes.T_BOOLEAN || operand > Opcodes.T_LONG) {
-                    throw new IllegalArgumentException("Invalid operand (must be an array type code T_...): "
-                            + operand);
-                }
-        }
-        mv.visitIntInsn(opcode, operand);
-    }
-
-    public void visitVarInsn(final int opcode, final int var) {
-        checkStartCode();
-        checkEndCode();
-        checkOpcode(opcode, 2);
-        checkUnsignedShort(var, "Invalid variable index");
-        mv.visitVarInsn(opcode, var);
-    }
-
-    public void visitTypeInsn(final int opcode, final String type) {
-        checkStartCode();
-        checkEndCode();
-        checkOpcode(opcode, 3);
-        checkInternalName(type, "type");
-        if (opcode == Opcodes.NEW && type.charAt(0) == '[') {
-            throw new IllegalArgumentException("NEW cannot be used to create arrays: "
-                    + type);
-        }
-        mv.visitTypeInsn(opcode, type);
-    }
-
-    public void visitFieldInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        checkStartCode();
-        checkEndCode();
-        checkOpcode(opcode, 4);
-        checkInternalName(owner, "owner");
-        checkUnqualifiedName(version, name, "name");
-        checkDesc(desc, false);
-        mv.visitFieldInsn(opcode, owner, name, desc);
-    }
-
-    public void visitMethodInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        checkStartCode();
-        checkEndCode();
-        checkOpcode(opcode, 5);
-        checkMethodIdentifier(version, name, "name");
-        checkInternalName(owner, "owner");
-        checkMethodDesc(desc);
-        if (opcode == Opcodes.INVOKEDYNAMIC && owner != Opcodes.INVOKEDYNAMIC_OWNER) {
-            throw new IllegalArgumentException("INVOKEDYNAMIC cannot be used with another owner than INVOKEDYNAMIC_OWNER");
-        }
-        mv.visitMethodInsn(opcode, owner, name, desc);
-    }
-
-    public void visitJumpInsn(final int opcode, final Label label) {
-        checkStartCode();
-        checkEndCode();
-        checkOpcode(opcode, 6);
-        checkLabel(label, false, "label");
-        checkNonDebugLabel(label);
-        mv.visitJumpInsn(opcode, label);
-    }
-
-    public void visitLabel(final Label label) {
-        checkStartCode();
-        checkEndCode();
-        checkLabel(label, false, "label");
-        if (labels.get(label) != null) {
-            throw new IllegalArgumentException("Already visited label");
-        }
-        labels.put(label, new Integer(labels.size()));
-        mv.visitLabel(label);
-    }
-
-    public void visitLdcInsn(final Object cst) {
-        checkStartCode();
-        checkEndCode();
-        if (!(cst instanceof Type)) {
-            checkConstant(cst);
-        }
-        mv.visitLdcInsn(cst);
-    }
-
-    public void visitIincInsn(final int var, final int increment) {
-        checkStartCode();
-        checkEndCode();
-        checkUnsignedShort(var, "Invalid variable index");
-        checkSignedShort(increment, "Invalid increment");
-        mv.visitIincInsn(var, increment);
-    }
-
-    public void visitTableSwitchInsn(
-        final int min,
-        final int max,
-        final Label dflt,
-        final Label[] labels)
-    {
-        checkStartCode();
-        checkEndCode();
-        if (max < min) {
-            throw new IllegalArgumentException("Max = " + max
-                    + " must be greater than or equal to min = " + min);
-        }
-        checkLabel(dflt, false, "default label");
-        checkNonDebugLabel(dflt);
-        if (labels == null || labels.length != max - min + 1) {
-            throw new IllegalArgumentException("There must be max - min + 1 labels");
-        }
-        for (int i = 0; i < labels.length; ++i) {
-            checkLabel(labels[i], false, "label at index " + i);
-            checkNonDebugLabel(labels[i]);
-        }
-        mv.visitTableSwitchInsn(min, max, dflt, labels);
-    }
-
-    public void visitLookupSwitchInsn(
-        final Label dflt,
-        final int[] keys,
-        final Label[] labels)
-    {
-        checkEndCode();
-        checkStartCode();
-        checkLabel(dflt, false, "default label");
-        checkNonDebugLabel(dflt);
-        if (keys == null || labels == null || keys.length != labels.length) {
-            throw new IllegalArgumentException("There must be the same number of keys and labels");
-        }
-        for (int i = 0; i < labels.length; ++i) {
-            checkLabel(labels[i], false, "label at index " + i);
-            checkNonDebugLabel(labels[i]);
-        }
-        mv.visitLookupSwitchInsn(dflt, keys, labels);
-    }
-
-    public void visitMultiANewArrayInsn(final String desc, final int dims) {
-        checkStartCode();
-        checkEndCode();
-        checkDesc(desc, false);
-        if (desc.charAt(0) != '[') {
-            throw new IllegalArgumentException("Invalid descriptor (must be an array type descriptor): "
-                    + desc);
-        }
-        if (dims < 1) {
-            throw new IllegalArgumentException("Invalid dimensions (must be greater than 0): "
-                    + dims);
-        }
-        if (dims > desc.lastIndexOf('[') + 1) {
-            throw new IllegalArgumentException("Invalid dimensions (must not be greater than dims(desc)): "
-                    + dims);
-        }
-        mv.visitMultiANewArrayInsn(desc, dims);
-    }
-
-    public void visitTryCatchBlock(
-        final Label start,
-        final Label end,
-        final Label handler,
-        final String type)
-    {
-        checkStartCode();
-        checkEndCode();
-        checkLabel(start, false, "start label");
-        checkLabel(end, false, "end label");
-        checkLabel(handler, false, "handler label");
-        checkNonDebugLabel(start);
-        checkNonDebugLabel(end);
-        checkNonDebugLabel(handler);
-        if (labels.get(start) != null || labels.get(end) != null || labels.get(handler) != null) {
-            throw new IllegalStateException("Try catch blocks must be visited before their labels");
-        }
-        if (type != null) {
-            checkInternalName(type, "type");
-        }
-        mv.visitTryCatchBlock(start, end, handler, type);
-    }
-
-    public void visitLocalVariable(
-        final String name,
-        final String desc,
-        final String signature,
-        final Label start,
-        final Label end,
-        final int index)
-    {
-        checkStartCode();
-        checkEndCode();
-        checkUnqualifiedName(version, name, "name");
-        checkDesc(desc, false);
-        checkLabel(start, true, "start label");
-        checkLabel(end, true, "end label");
-        checkUnsignedShort(index, "Invalid variable index");
-        int s = ((Integer) labels.get(start)).intValue();
-        int e = ((Integer) labels.get(end)).intValue();
-        if (e < s) {
-            throw new IllegalArgumentException("Invalid start and end labels (end must be greater than start)");
-        }
-        mv.visitLocalVariable(name, desc, signature, start, end, index);
-    }
-
-    public void visitLineNumber(final int line, final Label start) {
-        checkStartCode();
-        checkEndCode();
-        checkUnsignedShort(line, "Invalid line number");
-        checkLabel(start, true, "start label");
-        mv.visitLineNumber(line, start);
-    }
-
-    public void visitMaxs(final int maxStack, final int maxLocals) {
-        checkStartCode();
-        checkEndCode();
-        endCode = true;
-        checkUnsignedShort(maxStack, "Invalid max stack");
-        checkUnsignedShort(maxLocals, "Invalid max locals");
-        mv.visitMaxs(maxStack, maxLocals);
-    }
-
-    public void visitEnd() {
-        checkEndMethod();
-        endMethod = true;
-        mv.visitEnd();
-    }
-
-    // -------------------------------------------------------------------------
-
-    /**
-     * Checks that the visitCode method has been called.
-     */
-    void checkStartCode() {
-        if (!startCode) {
-            throw new IllegalStateException("Cannot visit instructions before visitCode has been called.");
-        }
-    }
-
-    /**
-     * Checks that the visitMaxs method has not been called.
-     */
-    void checkEndCode() {
-        if (endCode) {
-            throw new IllegalStateException("Cannot visit instructions after visitMaxs has been called.");
-        }
-    }
-
-    /**
-     * Checks that the visitEnd method has not been called.
-     */
-    void checkEndMethod() {
-        if (endMethod) {
-            throw new IllegalStateException("Cannot visit elements after visitEnd has been called.");
-        }
-    }
-
-    /**
-     * Checks a stack frame value.
-     * 
-     * @param value the value to be checked.
-     */
-    static void checkFrameValue(final Object value) {
-        if (value == Opcodes.TOP || value == Opcodes.INTEGER
-                || value == Opcodes.FLOAT || value == Opcodes.LONG
-                || value == Opcodes.DOUBLE || value == Opcodes.NULL
-                || value == Opcodes.UNINITIALIZED_THIS)
-        {
-            return;
-        }
-        if (value instanceof String) {
-            checkInternalName((String) value, "Invalid stack frame value");
-            return;
-        }
-        if (!(value instanceof Label)) {
-            throw new IllegalArgumentException("Invalid stack frame value: "
-                    + value);
-        }
-    }
-
-    /**
-     * Checks that the type of the given opcode is equal to the given type.
-     * 
-     * @param opcode the opcode to be checked.
-     * @param type the expected opcode type.
-     */
-    static void checkOpcode(final int opcode, final int type) {
-        if (opcode < 0 || opcode > 199 || TYPE[opcode] != type) {
-            throw new IllegalArgumentException("Invalid opcode: " + opcode);
-        }
-    }
-
-    /**
-     * Checks that the given value is a signed byte.
-     * 
-     * @param value the value to be checked.
-     * @param msg an message to be used in case of error.
-     */
-    static void checkSignedByte(final int value, final String msg) {
-        if (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {
-            throw new IllegalArgumentException(msg
-                    + " (must be a signed byte): " + value);
-        }
-    }
-
-    /**
-     * Checks that the given value is a signed short.
-     * 
-     * @param value the value to be checked.
-     * @param msg an message to be used in case of error.
-     */
-    static void checkSignedShort(final int value, final String msg) {
-        if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {
-            throw new IllegalArgumentException(msg
-                    + " (must be a signed short): " + value);
-        }
-    }
-
-    /**
-     * Checks that the given value is an unsigned short.
-     * 
-     * @param value the value to be checked.
-     * @param msg an message to be used in case of error.
-     */
-    static void checkUnsignedShort(final int value, final String msg) {
-        if (value < 0 || value > 65535) {
-            throw new IllegalArgumentException(msg
-                    + " (must be an unsigned short): " + value);
-        }
-    }
-
-    /**
-     * Checks that the given value is an {@link Integer}, a{@link Float}, a
-     * {@link Long}, a {@link Double} or a {@link String}.
-     * 
-     * @param cst the value to be checked.
-     */
-    static void checkConstant(final Object cst) {
-        if (!(cst instanceof Integer) && !(cst instanceof Float)
-                && !(cst instanceof Long) && !(cst instanceof Double)
-                && !(cst instanceof String))
-        {
-            throw new IllegalArgumentException("Invalid constant: " + cst);
-        }
-    }
-
-    /**
-     * Checks that the given string is a valid unqualified name.
-     * 
-     * @param version the class version.
-     * @param name the string to be checked.
-     * @param msg a message to be used in case of error.
-     */
-    static void checkUnqualifiedName(int version, final String name, final String msg) {
-        if ((version & 0xFFFF) < Opcodes.V1_5) {
-            checkIdentifier(name, msg);
-        } else {
-            for (int i = 0; i < name.length(); ++i) {
-                if (".;[/".indexOf(name.charAt(i)) != -1) {
-                    throw new IllegalArgumentException("Invalid " + msg
-                            + " (must be a valid unqualified name): " + name);                    
-                }
-            }
-        }
-    }
-    
-    /**
-     * Checks that the given string is a valid Java identifier.
-     * 
-     * @param name the string to be checked.
-     * @param msg a message to be used in case of error.
-     */
-    static void checkIdentifier(final String name, final String msg) {
-        checkIdentifier(name, 0, -1, msg);
-    }
-
-    /**
-     * Checks that the given substring is a valid Java identifier.
-     * 
-     * @param name the string to be checked.
-     * @param start index of the first character of the identifier (inclusive).
-     * @param end index of the last character of the identifier (exclusive). -1
-     *        is equivalent to <tt>name.length()</tt> if name is not
-     *        <tt>null</tt>.
-     * @param msg a message to be used in case of error.
-     */
-    static void checkIdentifier(
-        final String name,
-        final int start,
-        final int end,
-        final String msg)
-    {
-        if (name == null || (end == -1 ? name.length() <= start : end <= start))
-        {
-            throw new IllegalArgumentException("Invalid " + msg
-                    + " (must not be null or empty)");
-        }
-        if (!Character.isJavaIdentifierStart(name.charAt(start))) {
-            throw new IllegalArgumentException("Invalid " + msg
-                    + " (must be a valid Java identifier): " + name);
-        }
-        int max = end == -1 ? name.length() : end;
-        for (int i = start + 1; i < max; ++i) {
-            if (!Character.isJavaIdentifierPart(name.charAt(i))) {
-                throw new IllegalArgumentException("Invalid " + msg
-                        + " (must be a valid Java identifier): " + name);
-            }
-        }
-    }
-
-    /**
-     * Checks that the given string is a valid Java identifier or is equal to
-     * '&lt;init&gt;' or '&lt;clinit&gt;'.
-     * 
-     * @param version the class version.
-     * @param name the string to be checked.
-     * @param msg a message to be used in case of error.
-     */
-    static void checkMethodIdentifier(int version, final String name, final String msg) {
-        if (name == null || name.length() == 0) {
-            throw new IllegalArgumentException("Invalid " + msg
-                    + " (must not be null or empty)");
-        }
-        if ("<init>".equals(name) || "<clinit>".equals(name)) {
-            return;
-        }
-        if ((version & 0xFFFF) >= Opcodes.V1_5) {
-            for (int i = 0; i < name.length(); ++i) {
-                if (".;[/<>".indexOf(name.charAt(i)) != -1) {
-                    throw new IllegalArgumentException("Invalid " + msg
-                            + " (must be a valid unqualified name): " + name);                    
-                }
-            }
-            return;
-        }
-        if (!Character.isJavaIdentifierStart(name.charAt(0))) {
-            throw new IllegalArgumentException("Invalid "
-                    + msg
-                    + " (must be a '<init>', '<clinit>' or a valid Java identifier): "
-                    + name);
-        }
-        for (int i = 1; i < name.length(); ++i) {
-            if (!Character.isJavaIdentifierPart(name.charAt(i))) {
-                throw new IllegalArgumentException("Invalid "
-                        + msg
-                        + " (must be '<init>' or '<clinit>' or a valid Java identifier): "
-                        + name);
-            }
-        }
-    }
-
-    /**
-     * Checks that the given string is a valid internal class name.
-     * 
-     * @param name the string to be checked.
-     * @param msg a message to be used in case of error.
-     */
-    static void checkInternalName(final String name, final String msg) {
-        if (name == null || name.length() == 0) {
-            throw new IllegalArgumentException("Invalid " + msg
-                    + " (must not be null or empty)");
-        }
-        if (name.charAt(0) == '[') {
-            checkDesc(name, false);
-        } else {
-            checkInternalName(name, 0, -1, msg);
-        }
-    }
-
-    /**
-     * Checks that the given substring is a valid internal class name.
-     * 
-     * @param name the string to be checked.
-     * @param start index of the first character of the identifier (inclusive).
-     * @param end index of the last character of the identifier (exclusive). -1
-     *        is equivalent to <tt>name.length()</tt> if name is not
-     *        <tt>null</tt>.
-     * @param msg a message to be used in case of error.
-     */
-    static void checkInternalName(
-        final String name,
-        final int start,
-        final int end,
-        final String msg)
-    {
-        int max = end == -1 ? name.length() : end;
-        try {
-            int begin = start;
-            int slash;
-            do {
-                slash = name.indexOf('/', begin + 1);
-                if (slash == -1 || slash > max) {
-                    slash = max;
-                }
-                checkIdentifier(name, begin, slash, null);
-                begin = slash + 1;
-            } while (slash != max);
-        } catch (IllegalArgumentException _) {
-            throw new IllegalArgumentException("Invalid "
-                    + msg
-                    + " (must be a fully qualified class name in internal form): "
-                    + name);
-        }
-    }
-
-    /**
-     * Checks that the given string is a valid type descriptor.
-     * 
-     * @param desc the string to be checked.
-     * @param canBeVoid <tt>true</tt> if <tt>V</tt> can be considered valid.
-     */
-    static void checkDesc(final String desc, final boolean canBeVoid) {
-        int end = checkDesc(desc, 0, canBeVoid);
-        if (end != desc.length()) {
-            throw new IllegalArgumentException("Invalid descriptor: " + desc);
-        }
-    }
-
-    /**
-     * Checks that a the given substring is a valid type descriptor.
-     * 
-     * @param desc the string to be checked.
-     * @param start index of the first character of the identifier (inclusive).
-     * @param canBeVoid <tt>true</tt> if <tt>V</tt> can be considered valid.
-     * @return the index of the last character of the type decriptor, plus one.
-     */
-    static int checkDesc(
-        final String desc,
-        final int start,
-        final boolean canBeVoid)
-    {
-        if (desc == null || start >= desc.length()) {
-            throw new IllegalArgumentException("Invalid type descriptor (must not be null or empty)");
-        }
-        int index;
-        switch (desc.charAt(start)) {
-            case 'V':
-                if (canBeVoid) {
-                    return start + 1;
-                } else {
-                    throw new IllegalArgumentException("Invalid descriptor: "
-                            + desc);
-                }
-            case 'Z':
-            case 'C':
-            case 'B':
-            case 'S':
-            case 'I':
-            case 'F':
-            case 'J':
-            case 'D':
-                return start + 1;
-            case '[':
-                index = start + 1;
-                while (index < desc.length() && desc.charAt(index) == '[') {
-                    ++index;
-                }
-                if (index < desc.length()) {
-                    return checkDesc(desc, index, false);
-                } else {
-                    throw new IllegalArgumentException("Invalid descriptor: "
-                            + desc);
-                }
-            case 'L':
-                index = desc.indexOf(';', start);
-                if (index == -1 || index - start < 2) {
-                    throw new IllegalArgumentException("Invalid descriptor: "
-                            + desc);
-                }
-                try {
-                    checkInternalName(desc, start + 1, index, null);
-                } catch (IllegalArgumentException _) {
-                    throw new IllegalArgumentException("Invalid descriptor: "
-                            + desc);
-                }
-                return index + 1;
-            default:
-                throw new IllegalArgumentException("Invalid descriptor: "
-                        + desc);
-        }
-    }
-
-    /**
-     * Checks that the given string is a valid method descriptor.
-     * 
-     * @param desc the string to be checked.
-     */
-    static void checkMethodDesc(final String desc) {
-        if (desc == null || desc.length() == 0) {
-            throw new IllegalArgumentException("Invalid method descriptor (must not be null or empty)");
-        }
-        if (desc.charAt(0) != '(' || desc.length() < 3) {
-            throw new IllegalArgumentException("Invalid descriptor: " + desc);
-        }
-        int start = 1;
-        if (desc.charAt(start) != ')') {
-            do {
-                if (desc.charAt(start) == 'V') {
-                    throw new IllegalArgumentException("Invalid descriptor: "
-                            + desc);
-                }
-                start = checkDesc(desc, start, false);
-            } while (start < desc.length() && desc.charAt(start) != ')');
-        }
-        start = checkDesc(desc, start + 1, true);
-        if (start != desc.length()) {
-            throw new IllegalArgumentException("Invalid descriptor: " + desc);
-        }
-    }
-
-    /**
-     * Checks a class signature.
-     * 
-     * @param signature a string containing the signature that must be checked.
-     */
-    static void checkClassSignature(final String signature) {
-        // ClassSignature:
-        // FormalTypeParameters? ClassTypeSignature ClassTypeSignature*
-
-        int pos = 0;
-        if (getChar(signature, 0) == '<') {
-            pos = checkFormalTypeParameters(signature, pos);
-        }
-        pos = checkClassTypeSignature(signature, pos);
-        while (getChar(signature, pos) == 'L') {
-            pos = checkClassTypeSignature(signature, pos);
-        }
-        if (pos != signature.length()) {
-            throw new IllegalArgumentException(signature + ": error at index "
-                    + pos);
-        }
-    }
-
-    /**
-     * Checks a method signature.
-     * 
-     * @param signature a string containing the signature that must be checked.
-     */
-    static void checkMethodSignature(final String signature) {
-        // MethodTypeSignature:
-        // FormalTypeParameters? ( TypeSignature* ) ( TypeSignature | V ) (
-        // ^ClassTypeSignature | ^TypeVariableSignature )*
-
-        int pos = 0;
-        if (getChar(signature, 0) == '<') {
-            pos = checkFormalTypeParameters(signature, pos);
-        }
-        pos = checkChar('(', signature, pos);
-        while ("ZCBSIFJDL[T".indexOf(getChar(signature, pos)) != -1) {
-            pos = checkTypeSignature(signature, pos);
-        }
-        pos = checkChar(')', signature, pos);
-        if (getChar(signature, pos) == 'V') {
-            ++pos;
-        } else {
-            pos = checkTypeSignature(signature, pos);
-        }
-        while (getChar(signature, pos) == '^') {
-            ++pos;
-            if (getChar(signature, pos) == 'L') {
-                pos = checkClassTypeSignature(signature, pos);
-            } else {
-                pos = checkTypeVariableSignature(signature, pos);
-            }
-        }
-        if (pos != signature.length()) {
-            throw new IllegalArgumentException(signature + ": error at index "
-                    + pos);
-        }
-    }
-
-    /**
-     * Checks a field signature.
-     * 
-     * @param signature a string containing the signature that must be checked.
-     */
-    static void checkFieldSignature(final String signature) {
-        int pos = checkFieldTypeSignature(signature, 0);
-        if (pos != signature.length()) {
-            throw new IllegalArgumentException(signature + ": error at index "
-                    + pos);
-        }
-    }
-
-    /**
-     * Checks the formal type parameters of a class or method signature.
-     * 
-     * @param signature a string containing the signature that must be checked.
-     * @param pos index of first character to be checked.
-     * @return the index of the first character after the checked part.
-     */
-    private static int checkFormalTypeParameters(final String signature, int pos)
-    {
-        // FormalTypeParameters:
-        // < FormalTypeParameter+ >
-
-        pos = checkChar('<', signature, pos);
-        pos = checkFormalTypeParameter(signature, pos);
-        while (getChar(signature, pos) != '>') {
-            pos = checkFormalTypeParameter(signature, pos);
-        }
-        return pos + 1;
-    }
-
-    /**
-     * Checks a formal type parameter of a class or method signature.
-     * 
-     * @param signature a string containing the signature that must be checked.
-     * @param pos index of first character to be checked.
-     * @return the index of the first character after the checked part.
-     */
-    private static int checkFormalTypeParameter(final String signature, int pos)
-    {
-        // FormalTypeParameter:
-        // Identifier : FieldTypeSignature? (: FieldTypeSignature)*
-
-        pos = checkIdentifier(signature, pos);
-        pos = checkChar(':', signature, pos);
-        if ("L[T".indexOf(getChar(signature, pos)) != -1) {
-            pos = checkFieldTypeSignature(signature, pos);
-        }
-        while (getChar(signature, pos) == ':') {
-            pos = checkFieldTypeSignature(signature, pos + 1);
-        }
-        return pos;
-    }
-
-    /**
-     * Checks a field type signature.
-     * 
-     * @param signature a string containing the signature that must be checked.
-     * @param pos index of first character to be checked.
-     * @return the index of the first character after the checked part.
-     */
-    private static int checkFieldTypeSignature(final String signature, int pos)
-    {
-        // FieldTypeSignature:
-        // ClassTypeSignature | ArrayTypeSignature | TypeVariableSignature
-        //
-        // ArrayTypeSignature:
-        // [ TypeSignature
-
-        switch (getChar(signature, pos)) {
-            case 'L':
-                return checkClassTypeSignature(signature, pos);
-            case '[':
-                return checkTypeSignature(signature, pos + 1);
-            default:
-                return checkTypeVariableSignature(signature, pos);
-        }
-    }
-
-    /**
-     * Checks a class type signature.
-     * 
-     * @param signature a string containing the signature that must be checked.
-     * @param pos index of first character to be checked.
-     * @return the index of the first character after the checked part.
-     */
-    private static int checkClassTypeSignature(final String signature, int pos)
-    {
-        // ClassTypeSignature:
-        // L Identifier ( / Identifier )* TypeArguments? ( . Identifier
-        // TypeArguments? )* ;
-
-        pos = checkChar('L', signature, pos);
-        pos = checkIdentifier(signature, pos);
-        while (getChar(signature, pos) == '/') {
-            pos = checkIdentifier(signature, pos + 1);
-        }
-        if (getChar(signature, pos) == '<') {
-            pos = checkTypeArguments(signature, pos);
-        }
-        while (getChar(signature, pos) == '.') {
-            pos = checkIdentifier(signature, pos + 1);
-            if (getChar(signature, pos) == '<') {
-                pos = checkTypeArguments(signature, pos);
-            }
-        }
-        return checkChar(';', signature, pos);
-    }
-
-    /**
-     * Checks the type arguments in a class type signature.
-     * 
-     * @param signature a string containing the signature that must be checked.
-     * @param pos index of first character to be checked.
-     * @return the index of the first character after the checked part.
-     */
-    private static int checkTypeArguments(final String signature, int pos) {
-        // TypeArguments:
-        // < TypeArgument+ >
-
-        pos = checkChar('<', signature, pos);
-        pos = checkTypeArgument(signature, pos);
-        while (getChar(signature, pos) != '>') {
-            pos = checkTypeArgument(signature, pos);
-        }
-        return pos + 1;
-    }
-
-    /**
-     * Checks a type argument in a class type signature.
-     * 
-     * @param signature a string containing the signature that must be checked.
-     * @param pos index of first character to be checked.
-     * @return the index of the first character after the checked part.
-     */
-    private static int checkTypeArgument(final String signature, int pos) {
-        // TypeArgument:
-        // * | ( ( + | - )? FieldTypeSignature )
-
-        char c = getChar(signature, pos);
-        if (c == '*') {
-            return pos + 1;
-        } else if (c == '+' || c == '-') {
-            pos++;
-        }
-        return checkFieldTypeSignature(signature, pos);
-    }
-
-    /**
-     * Checks a type variable signature.
-     * 
-     * @param signature a string containing the signature that must be checked.
-     * @param pos index of first character to be checked.
-     * @return the index of the first character after the checked part.
-     */
-    private static int checkTypeVariableSignature(
-        final String signature,
-        int pos)
-    {
-        // TypeVariableSignature:
-        // T Identifier ;
-
-        pos = checkChar('T', signature, pos);
-        pos = checkIdentifier(signature, pos);
-        return checkChar(';', signature, pos);
-    }
-
-    /**
-     * Checks a type signature.
-     * 
-     * @param signature a string containing the signature that must be checked.
-     * @param pos index of first character to be checked.
-     * @return the index of the first character after the checked part.
-     */
-    private static int checkTypeSignature(final String signature, int pos) {
-        // TypeSignature:
-        // Z | C | B | S | I | F | J | D | FieldTypeSignature
-
-        switch (getChar(signature, pos)) {
-            case 'Z':
-            case 'C':
-            case 'B':
-            case 'S':
-            case 'I':
-            case 'F':
-            case 'J':
-            case 'D':
-                return pos + 1;
-            default:
-                return checkFieldTypeSignature(signature, pos);
-        }
-    }
-
-    /**
-     * Checks an identifier.
-     * 
-     * @param signature a string containing the signature that must be checked.
-     * @param pos index of first character to be checked.
-     * @return the index of the first character after the checked part.
-     */
-    private static int checkIdentifier(final String signature, int pos) {
-        if (!Character.isJavaIdentifierStart(getChar(signature, pos))) {
-            throw new IllegalArgumentException(signature
-                    + ": identifier expected at index " + pos);
-        }
-        ++pos;
-        while (Character.isJavaIdentifierPart(getChar(signature, pos))) {
-            ++pos;
-        }
-        return pos;
-    }
-
-    /**
-     * Checks a single character.
-     * 
-     * @param signature a string containing the signature that must be checked.
-     * @param pos index of first character to be checked.
-     * @return the index of the first character after the checked part.
-     */
-    private static int checkChar(final char c, final String signature, int pos)
-    {
-        if (getChar(signature, pos) == c) {
-            return pos + 1;
-        }
-        throw new IllegalArgumentException(signature + ": '" + c
-                + "' expected at index " + pos);
-    }
-
-    /**
-     * Returns the signature car at the given index.
-     * 
-     * @param signature a signature.
-     * @param pos an index in signature.
-     * @return the character at the given index, or 0 if there is no such
-     *         character.
-     */
-    private static char getChar(final String signature, int pos) {
-        return pos < signature.length() ? signature.charAt(pos) : (char) 0;
-    }
-
-    /**
-     * Checks that the given label is not null. This method can also check that
-     * the label has been visited.
-     * 
-     * @param label the label to be checked.
-     * @param checkVisited <tt>true</tt> to check that the label has been
-     *        visited.
-     * @param msg a message to be used in case of error.
-     */
-    void checkLabel(
-        final Label label,
-        final boolean checkVisited,
-        final String msg)
-    {
-        if (label == null) {
-            throw new IllegalArgumentException("Invalid " + msg
-                    + " (must not be null)");
-        }
-        if (checkVisited && labels.get(label) == null) {
-            throw new IllegalArgumentException("Invalid " + msg
-                    + " (must be visited first)");
-        }
-    }
-
-    /**
-     * Checks that the given lavel is not a label used only for debug purposes.
-     * 
-     * @param label the label to be checked.
-     */
-    private static void checkNonDebugLabel(final Label label) {
-        Field f = getLabelStatusField();
-        int status = 0;
-        try {
-            status = f == null ? 0 : ((Integer) f.get(label)).intValue();
-        } catch (IllegalAccessException e) { throw new Error("Internal error"); }
-        if ((status & 0x01) != 0) {
-            throw new IllegalArgumentException("Labels used for debug info cannot be reused for control flow");
-        }
-    }
-    
-    /**
-     * Returns the Field object corresponding to the Label.status field.
-     * 
-     * @return the Field object corresponding to the Label.status field.
-     */
-    private static Field getLabelStatusField() {
-        if (labelStatusField == null) {
-            labelStatusField = getLabelField("a");
-            if (labelStatusField == null) {
-                labelStatusField = getLabelField("status");
-            }
-        }
-        return labelStatusField;
-    }
-    
-    /**
-     * Returns the field of the Label class whose name is given.
-     * 
-     * @param name a field name.
-     * @return the field of the Label class whose name is given, or null.
-     */
-    private static Field getLabelField(final String name) {
-        try {
-            Field f = Label.class.getDeclaredField(name);
-            f.setAccessible(true);
-            return f;
-        } catch (NoSuchFieldException e) {
-            return null;
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/CheckSignatureAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/CheckSignatureAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/CheckSignatureAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/CheckSignatureAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,290 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import org.eclipse.persistence.internal.libraries.asm.signature.SignatureVisitor;
-
-/**
- * A {@link SignatureVisitor} that checks that its methods are properly used.
- * 
- * @author Eric Bruneton
- */
-public class CheckSignatureAdapter implements SignatureVisitor {
-
-    /**
-     * Type to be used to check class signatures. See
-     * {@link #CheckSignatureAdapter(int, SignatureVisitor) CheckSignatureAdapter}.
-     */
-    public static final int CLASS_SIGNATURE = 0;
-
-    /**
-     * Type to be used to check method signatures. See
-     * {@link #CheckSignatureAdapter(int, SignatureVisitor) CheckSignatureAdapter}.
-     */
-    public static final int METHOD_SIGNATURE = 1;
-
-    /**
-     * Type to be used to check type signatures.See
-     * {@link #CheckSignatureAdapter(int, SignatureVisitor) CheckSignatureAdapter}.
-     */
-    public static final int TYPE_SIGNATURE = 2;
-
-    private static final int EMPTY = 1;
-
-    private static final int FORMAL = 2;
-
-    private static final int BOUND = 4;
-
-    private static final int SUPER = 8;
-
-    private static final int PARAM = 16;
-
-    private static final int RETURN = 32;
-
-    private static final int SIMPLE_TYPE = 64;
-
-    private static final int CLASS_TYPE = 128;
-
-    private static final int END = 256;
-
-    /**
-     * Type of the signature to be checked.
-     */
-    private final int type;
-
-    /**
-     * State of the automaton used to check the order of method calls.
-     */
-    private int state;
-
-    /**
-     * <tt>true</tt> if the checked type signature can be 'V'.
-     */
-    private boolean canBeVoid;
-
-    /**
-     * The visitor to which this adapter must delegate calls. May be
-     * <tt>null</tt>.
-     */
-    private final SignatureVisitor sv;
-
-    /**
-     * Creates a new {@link CheckSignatureAdapter} object.
-     * 
-     * @param type the type of signature to be checked. See
-     *        {@link #CLASS_SIGNATURE}, {@link #METHOD_SIGNATURE} and
-     *        {@link #TYPE_SIGNATURE}.
-     * @param sv the visitor to which this adapter must delegate calls. May be
-     *        <tt>null</tt>.
-     */
-    public CheckSignatureAdapter(final int type, final SignatureVisitor sv) {
-        this.type = type;
-        this.state = EMPTY;
-        this.sv = sv;
-    }
-
-    // class and method signatures
-
-    public void visitFormalTypeParameter(final String name) {
-        if (type == TYPE_SIGNATURE
-                || (state != EMPTY && state != FORMAL && state != BOUND))
-        {
-            throw new IllegalStateException();
-        }
-        CheckMethodAdapter.checkIdentifier(name, "formal type parameter");
-        state = FORMAL;
-        if (sv != null) {
-            sv.visitFormalTypeParameter(name);
-        }
-    }
-
-    public SignatureVisitor visitClassBound() {
-        if (state != FORMAL) {
-            throw new IllegalStateException();
-        }
-        state = BOUND;
-        SignatureVisitor v = sv == null ? null : sv.visitClassBound();
-        return new CheckSignatureAdapter(TYPE_SIGNATURE, v);
-    }
-
-    public SignatureVisitor visitInterfaceBound() {
-        if (state != FORMAL && state != BOUND) {
-            throw new IllegalArgumentException();
-        }
-        SignatureVisitor v = sv == null ? null : sv.visitInterfaceBound();
-        return new CheckSignatureAdapter(TYPE_SIGNATURE, v);
-    }
-
-    // class signatures
-
-    public SignatureVisitor visitSuperclass() {
-        if (type != CLASS_SIGNATURE || (state & (EMPTY | FORMAL | BOUND)) == 0)
-        {
-            throw new IllegalArgumentException();
-        }
-        state = SUPER;
-        SignatureVisitor v = sv == null ? null : sv.visitSuperclass();
-        return new CheckSignatureAdapter(TYPE_SIGNATURE, v);
-    }
-
-    public SignatureVisitor visitInterface() {
-        if (state != SUPER) {
-            throw new IllegalStateException();
-        }
-        SignatureVisitor v = sv == null ? null : sv.visitInterface();
-        return new CheckSignatureAdapter(TYPE_SIGNATURE, v);
-    }
-
-    // method signatures
-
-    public SignatureVisitor visitParameterType() {
-        if (type != METHOD_SIGNATURE
-                || (state & (EMPTY | FORMAL | BOUND | PARAM)) == 0)
-        {
-            throw new IllegalArgumentException();
-        }
-        state = PARAM;
-        SignatureVisitor v = sv == null ? null : sv.visitParameterType();
-        return new CheckSignatureAdapter(TYPE_SIGNATURE, v);
-    }
-
-    public SignatureVisitor visitReturnType() {
-        if (type != METHOD_SIGNATURE
-                || (state & (EMPTY | FORMAL | BOUND | PARAM)) == 0)
-        {
-            throw new IllegalArgumentException();
-        }
-        state = RETURN;
-        SignatureVisitor v = sv == null ? null : sv.visitReturnType();
-        CheckSignatureAdapter cv = new CheckSignatureAdapter(TYPE_SIGNATURE, v);
-        cv.canBeVoid = true;
-        return cv;
-    }
-
-    public SignatureVisitor visitExceptionType() {
-        if (state != RETURN) {
-            throw new IllegalStateException();
-        }
-        SignatureVisitor v = sv == null ? null : sv.visitExceptionType();
-        return new CheckSignatureAdapter(TYPE_SIGNATURE, v);
-    }
-
-    // type signatures
-
-    public void visitBaseType(final char descriptor) {
-        if (type != TYPE_SIGNATURE || state != EMPTY) {
-            throw new IllegalStateException();
-        }
-        if (descriptor == 'V') {
-            if (!canBeVoid) {
-                throw new IllegalArgumentException();
-            }
-        } else {
-            if ("ZCBSIFJD".indexOf(descriptor) == -1) {
-                throw new IllegalArgumentException();
-            }
-        }
-        state = SIMPLE_TYPE;
-        if (sv != null) {
-            sv.visitBaseType(descriptor);
-        }
-    }
-
-    public void visitTypeVariable(final String name) {
-        if (type != TYPE_SIGNATURE || state != EMPTY) {
-            throw new IllegalStateException();
-        }
-        CheckMethodAdapter.checkIdentifier(name, "type variable");
-        state = SIMPLE_TYPE;
-        if (sv != null) {
-            sv.visitTypeVariable(name);
-        }
-    }
-
-    public SignatureVisitor visitArrayType() {
-        if (type != TYPE_SIGNATURE || state != EMPTY) {
-            throw new IllegalStateException();
-        }
-        state = SIMPLE_TYPE;
-        SignatureVisitor v = sv == null ? null : sv.visitArrayType();
-        return new CheckSignatureAdapter(TYPE_SIGNATURE, v);
-    }
-
-    public void visitClassType(final String name) {
-        if (type != TYPE_SIGNATURE || state != EMPTY) {
-            throw new IllegalStateException();
-        }
-        CheckMethodAdapter.checkInternalName(name, "class name");
-        state = CLASS_TYPE;
-        if (sv != null) {
-            sv.visitClassType(name);
-        }
-    }
-
-    public void visitInnerClassType(final String name) {
-        if (state != CLASS_TYPE) {
-            throw new IllegalStateException();
-        }
-        CheckMethodAdapter.checkIdentifier(name, "inner class name");
-        if (sv != null) {
-            sv.visitInnerClassType(name);
-        }
-    }
-
-    public void visitTypeArgument() {
-        if (state != CLASS_TYPE) {
-            throw new IllegalStateException();
-        }
-        if (sv != null) {
-            sv.visitTypeArgument();
-        }
-    }
-
-    public SignatureVisitor visitTypeArgument(final char wildcard) {
-        if (state != CLASS_TYPE) {
-            throw new IllegalStateException();
-        }
-        if ("+-=".indexOf(wildcard) == -1) {
-            throw new IllegalArgumentException();
-        }
-        SignatureVisitor v = sv == null ? null : sv.visitTypeArgument(wildcard);
-        return new CheckSignatureAdapter(TYPE_SIGNATURE, v);
-    }
-
-    public void visitEnd() {
-        if (state != CLASS_TYPE) {
-            throw new IllegalStateException();
-        }
-        state = END;
-        if (sv != null) {
-            sv.visitEnd();
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/package.html eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/package.html
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/package.html	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/package.html	1970-01-01 01:00:00.000000000 +0100
@@ -1,40 +0,0 @@
-<html>
-<!--
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2005 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
--->
-<body>
-Provides ASM visitors that can be useful for programming and
-debugging purposes. These class visitors are normally not used by applications
-at runtime. This is why they are bundled in an optional <tt>asm-util.jar</tt>
-library that is separated from (but requires) the <tt>asm.jar</tt> library,
-which contains the core ASM framework.
-
-@since ASM 1.3.2
-</body>
-</html>
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/Traceable.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/Traceable.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/Traceable.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/Traceable.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,52 +0,0 @@
-/**
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import java.util.Map;
-
-/**
- * An attribute that can print eadable representation of the attribute.
- * 
- * Implementation should construct readable output from an attribute data
- * structures for current attribute state. Such representation could be used in
- * unit test assertions.
- * 
- * @author Eugene Kuleshov
- */
-public interface Traceable {
-
-    /**
-     * Build a human readable representation of the attribute.
-     * 
-     * @param buf A buffer used for printing Java code.
-     * @param labelNames map of label instances to their names.
-     */
-    void trace(StringBuffer buf, Map labelNames);
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/TraceAbstractVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/TraceAbstractVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/TraceAbstractVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/TraceAbstractVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,179 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-
-/**
- * An abstract trace visitor.
- * 
- * @author Eric Bruneton
- */
-public abstract class TraceAbstractVisitor extends AbstractVisitor {
-
-    /**
-     * Constant used in {@link #appendDescriptor appendDescriptor} for internal
-     * type names in bytecode notation.
-     */
-    public static final int INTERNAL_NAME = 0;
-
-    /**
-     * Constant used in {@link #appendDescriptor appendDescriptor} for field
-     * descriptors, formatted in bytecode notation
-     */
-    public static final int FIELD_DESCRIPTOR = 1;
-
-    /**
-     * Constant used in {@link #appendDescriptor appendDescriptor} for field
-     * signatures, formatted in bytecode notation
-     */
-    public static final int FIELD_SIGNATURE = 2;
-
-    /**
-     * Constant used in {@link #appendDescriptor appendDescriptor} for method
-     * descriptors, formatted in bytecode notation
-     */
-    public static final int METHOD_DESCRIPTOR = 3;
-
-    /**
-     * Constant used in {@link #appendDescriptor appendDescriptor} for method
-     * signatures, formatted in bytecode notation
-     */
-    public static final int METHOD_SIGNATURE = 4;
-
-    /**
-     * Constant used in {@link #appendDescriptor appendDescriptor} for class
-     * signatures, formatted in bytecode notation
-     */
-    public static final int CLASS_SIGNATURE = 5;
-
-    /**
-     * Constant used in {@link #appendDescriptor appendDescriptor} for field or
-     * method return value signatures, formatted in default Java notation
-     * (non-bytecode)
-     */
-    public static final int TYPE_DECLARATION = 6;
-
-    /**
-     * Constant used in {@link #appendDescriptor appendDescriptor} for class
-     * signatures, formatted in default Java notation (non-bytecode)
-     */
-    public static final int CLASS_DECLARATION = 7;
-
-    /**
-     * Constant used in {@link #appendDescriptor appendDescriptor} for method
-     * parameter signatures, formatted in default Java notation (non-bytecode)
-     */
-    public static final int PARAMETERS_DECLARATION = 8;
-
-    /**
-     * Tab for class members.
-     */
-    protected String tab = "  ";
-
-    /**
-     * Prints a disassembled view of the given annotation.
-     * 
-     * @param desc the class descriptor of the annotation class.
-     * @param visible <tt>true</tt> if the annotation is visible at runtime.
-     * @return a visitor to visit the annotation values.
-     */
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        buf.setLength(0);
-        buf.append(tab).append('@');
-        appendDescriptor(FIELD_DESCRIPTOR, desc);
-        buf.append('(');
-        text.add(buf.toString());
-        TraceAnnotationVisitor tav = createTraceAnnotationVisitor();
-        text.add(tav.getText());
-        text.add(visible ? ")\n" : ") // invisible\n");
-        return tav;
-    }
-
-    /**
-     * Prints a disassembled view of the given attribute.
-     * 
-     * @param attr an attribute.
-     */
-    public void visitAttribute(final Attribute attr) {
-        buf.setLength(0);
-        buf.append(tab).append("ATTRIBUTE ");
-        appendDescriptor(-1, attr.type);
-
-        if (attr instanceof Traceable) {
-            ((Traceable) attr).trace(buf, null);
-        } else {
-            buf.append(" : unknown\n");
-        }
-
-        text.add(buf.toString());
-    }
-
-    /**
-     * Does nothing.
-     */
-    public void visitEnd() {
-        // does nothing
-    }
-
-    // ------------------------------------------------------------------------
-    // Utility methods
-    // ------------------------------------------------------------------------
-
-    protected TraceAnnotationVisitor createTraceAnnotationVisitor() {
-        return new TraceAnnotationVisitor();
-    }
-
-    /**
-     * Appends an internal name, a type descriptor or a type signature to
-     * {@link #buf buf}.
-     * 
-     * @param type indicates if desc is an internal name, a field descriptor, a
-     *        method descriptor, a class signature, ...
-     * @param desc an internal name, type descriptor, or type signature. May be
-     *        <tt>null</tt>.
-     */
-    protected void appendDescriptor(final int type, final String desc) {
-        if (type == CLASS_SIGNATURE || type == FIELD_SIGNATURE
-                || type == METHOD_SIGNATURE)
-        {
-            if (desc != null) {
-                buf.append("// signature ").append(desc).append('\n');
-            }
-        } else {
-            buf.append(desc);
-        }
-    }
-
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/TraceAnnotationVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/TraceAnnotationVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/TraceAnnotationVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/TraceAnnotationVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,266 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-
-/**
- * An {@link AnnotationVisitor} that prints a disassembled view of the
- * annotations it visits.
- * 
- * @author Eric Bruneton
- */
-public class TraceAnnotationVisitor extends TraceAbstractVisitor implements
-        AnnotationVisitor
-{
-
-    /**
-     * The {@link AnnotationVisitor} to which this visitor delegates calls. May
-     * be <tt>null</tt>.
-     */
-    protected AnnotationVisitor av;
-
-    private int valueNumber = 0;
-
-    /**
-     * Constructs a new {@link TraceAnnotationVisitor}.
-     */
-    public TraceAnnotationVisitor() {
-        // ignore
-    }
-
-    // ------------------------------------------------------------------------
-    // Implementation of the AnnotationVisitor interface
-    // ------------------------------------------------------------------------
-
-    public void visit(final String name, final Object value) {
-        buf.setLength(0);
-        appendComa(valueNumber++);
-
-        if (name != null) {
-            buf.append(name).append('=');
-        }
-
-        if (value instanceof String) {
-            visitString((String) value);
-        } else if (value instanceof Type) {
-            visitType((Type) value);
-        } else if (value instanceof Byte) {
-            visitByte(((Byte) value).byteValue());
-        } else if (value instanceof Boolean) {
-            visitBoolean(((Boolean) value).booleanValue());
-        } else if (value instanceof Short) {
-            visitShort(((Short) value).shortValue());
-        } else if (value instanceof Character) {
-            visitChar(((Character) value).charValue());
-        } else if (value instanceof Integer) {
-            visitInt(((Integer) value).intValue());
-        } else if (value instanceof Float) {
-            visitFloat(((Float) value).floatValue());
-        } else if (value instanceof Long) {
-            visitLong(((Long) value).longValue());
-        } else if (value instanceof Double) {
-            visitDouble(((Double) value).doubleValue());
-        } else if (value.getClass().isArray()) {
-            buf.append('{');
-            if (value instanceof byte[]) {
-                byte[] v = (byte[]) value;
-                for (int i = 0; i < v.length; i++) {
-                    appendComa(i);
-                    visitByte(v[i]);
-                }
-            } else if (value instanceof boolean[]) {
-                boolean[] v = (boolean[]) value;
-                for (int i = 0; i < v.length; i++) {
-                    appendComa(i);
-                    visitBoolean(v[i]);
-                }
-            } else if (value instanceof short[]) {
-                short[] v = (short[]) value;
-                for (int i = 0; i < v.length; i++) {
-                    appendComa(i);
-                    visitShort(v[i]);
-                }
-            } else if (value instanceof char[]) {
-                char[] v = (char[]) value;
-                for (int i = 0; i < v.length; i++) {
-                    appendComa(i);
-                    visitChar(v[i]);
-                }
-            } else if (value instanceof int[]) {
-                int[] v = (int[]) value;
-                for (int i = 0; i < v.length; i++) {
-                    appendComa(i);
-                    visitInt(v[i]);
-                }
-            } else if (value instanceof long[]) {
-                long[] v = (long[]) value;
-                for (int i = 0; i < v.length; i++) {
-                    appendComa(i);
-                    visitLong(v[i]);
-                }
-            } else if (value instanceof float[]) {
-                float[] v = (float[]) value;
-                for (int i = 0; i < v.length; i++) {
-                    appendComa(i);
-                    visitFloat(v[i]);
-                }
-            } else if (value instanceof double[]) {
-                double[] v = (double[]) value;
-                for (int i = 0; i < v.length; i++) {
-                    appendComa(i);
-                    visitDouble(v[i]);
-                }
-            }
-            buf.append('}');
-        }
-
-        text.add(buf.toString());
-
-        if (av != null) {
-            av.visit(name, value);
-        }
-    }
-
-    private void visitInt(final int value) {
-        buf.append(value);
-    }
-
-    private void visitLong(final long value) {
-        buf.append(value).append('L');
-    }
-
-    private void visitFloat(final float value) {
-        buf.append(value).append('F');
-    }
-
-    private void visitDouble(final double value) {
-        buf.append(value).append('D');
-    }
-
-    private void visitChar(final char value) {
-        buf.append("(char)").append((int) value);
-    }
-
-    private void visitShort(final short value) {
-        buf.append("(short)").append(value);
-    }
-
-    private void visitByte(final byte value) {
-        buf.append("(byte)").append(value);
-    }
-
-    private void visitBoolean(final boolean value) {
-        buf.append(value);
-    }
-
-    private void visitString(final String value) {
-        appendString(buf, value);
-    }
-
-    private void visitType(final Type value) {
-        buf.append(value.getClassName()).append(".class");
-    }
-
-    public void visitEnum(
-        final String name,
-        final String desc,
-        final String value)
-    {
-        buf.setLength(0);
-        appendComa(valueNumber++);
-        if (name != null) {
-            buf.append(name).append('=');
-        }
-        appendDescriptor(FIELD_DESCRIPTOR, desc);
-        buf.append('.').append(value);
-        text.add(buf.toString());
-
-        if (av != null) {
-            av.visitEnum(name, desc, value);
-        }
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String name,
-        final String desc)
-    {
-        buf.setLength(0);
-        appendComa(valueNumber++);
-        if (name != null) {
-            buf.append(name).append('=');
-        }
-        buf.append('@');
-        appendDescriptor(FIELD_DESCRIPTOR, desc);
-        buf.append('(');
-        text.add(buf.toString());
-        TraceAnnotationVisitor tav = createTraceAnnotationVisitor();
-        text.add(tav.getText());
-        text.add(")");
-        if (av != null) {
-            tav.av = av.visitAnnotation(name, desc);
-        }
-        return tav;
-    }
-
-    public AnnotationVisitor visitArray(final String name) {
-        buf.setLength(0);
-        appendComa(valueNumber++);
-        if (name != null) {
-            buf.append(name).append('=');
-        }
-        buf.append('{');
-        text.add(buf.toString());
-        TraceAnnotationVisitor tav = createTraceAnnotationVisitor();
-        text.add(tav.getText());
-        text.add("}");
-        if (av != null) {
-            tav.av = av.visitArray(name);
-        }
-        return tav;
-    }
-
-    public void visitEnd() {
-        if (av != null) {
-            av.visitEnd();
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Utility methods
-    // ------------------------------------------------------------------------
-
-    private void appendComa(final int i) {
-        if (i != 0) {
-            buf.append(", ");
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/TraceClassVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/TraceClassVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/TraceClassVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/TraceClassVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,523 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import java.io.FileInputStream;
-import java.io.PrintWriter;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-import org.eclipse.persistence.internal.libraries.asm.ClassReader;
-import org.eclipse.persistence.internal.libraries.asm.ClassVisitor;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.signature.SignatureReader;
-
-/**
- * A {@link ClassVisitor} that prints a disassembled view of the classes it
- * visits. This class visitor can be used alone (see the {@link #main main}
- * method) to disassemble a class. It can also be used in the middle of class
- * visitor chain to trace the class that is visited at a given point in this
- * chain. This may be uselful for debugging purposes. <p> The trace printed when
- * visiting the <tt>Hello</tt> class is the following: <p> <blockquote>
- * 
- * <pre>
- * // class version 49.0 (49)
- * // access flags 0x21
- * public class Hello {
- *
- *  // compiled from: Hello.java
- *
- *   // access flags 0x1
- *   public &lt;init&gt; ()V
- *     ALOAD 0
- *     INVOKESPECIAL java/lang/Object &lt;init&gt; ()V
- *     RETURN
- *     MAXSTACK = 1
- *     MAXLOCALS = 1
- *
- *   // access flags 0x9
- *   public static main ([Ljava/lang/String;)V
- *     GETSTATIC java/lang/System out Ljava/io/PrintStream;
- *     LDC &quot;hello&quot;
- *     INVOKEVIRTUAL java/io/PrintStream println (Ljava/lang/String;)V
- *     RETURN
- *     MAXSTACK = 2
- *     MAXLOCALS = 1
- * }
- * </pre>
- * 
- * </blockquote> where <tt>Hello</tt> is defined by: <p> <blockquote>
- * 
- * <pre>
- * public class Hello {
- *
- *     public static void main(String[] args) {
- *         System.out.println(&quot;hello&quot;);
- *     }
- * }
- * </pre>
- * 
- * </blockquote>
- * 
- * @author Eric Bruneton
- * @author Eugene Kuleshov
- */
-public class TraceClassVisitor extends TraceAbstractVisitor implements
-        ClassVisitor
-{
-
-    /**
-     * The {@link ClassVisitor} to which this visitor delegates calls. May be
-     * <tt>null</tt>.
-     */
-    protected final ClassVisitor cv;
-
-    /**
-     * The print writer to be used to print the class.
-     */
-    protected final PrintWriter pw;
-
-    /**
-     * Prints a disassembled view of the given class to the standard output. <p>
-     * Usage: TraceClassVisitor [-debug] &lt;fully qualified class name or class
-     * file name &gt;
-     * 
-     * @param args the command line arguments.
-     * 
-     * @throws Exception if the class cannot be found, or if an IO exception
-     *         occurs.
-     */
-    public static void main(final String[] args) throws Exception {
-        int i = 0;
-        int flags = ClassReader.SKIP_DEBUG;
-
-        boolean ok = true;
-        if (args.length < 1 || args.length > 2) {
-            ok = false;
-        }
-        if (ok && "-debug".equals(args[0])) {
-            i = 1;
-            flags = 0;
-            if (args.length != 2) {
-                ok = false;
-            }
-        }
-        if (!ok) {
-            System.err.println("Prints a disassembled view of the given class.");
-            System.err.println("Usage: TraceClassVisitor [-debug] "
-                    + "<fully qualified class name or class file name>");
-            return;
-        }
-        ClassReader cr;
-        if (args[i].endsWith(".class") || args[i].indexOf('\\') > -1
-                || args[i].indexOf('/') > -1)
-        {
-            cr = new ClassReader(new FileInputStream(args[i]));
-        } else {
-            cr = new ClassReader(args[i]);
-        }
-        cr.accept(new TraceClassVisitor(new PrintWriter(System.out)),
-                getDefaultAttributes(),
-                flags);
-    }
-
-    /**
-     * Constructs a new {@link TraceClassVisitor}.
-     * 
-     * @param pw the print writer to be used to print the class.
-     */
-    public TraceClassVisitor(final PrintWriter pw) {
-        this(null, pw);
-    }
-
-    /**
-     * Constructs a new {@link TraceClassVisitor}.
-     * 
-     * @param cv the {@link ClassVisitor} to which this visitor delegates calls.
-     *        May be <tt>null</tt>.
-     * @param pw the print writer to be used to print the class.
-     */
-    public TraceClassVisitor(final ClassVisitor cv, final PrintWriter pw) {
-        this.cv = cv;
-        this.pw = pw;
-    }
-
-    // ------------------------------------------------------------------------
-    // Implementation of the ClassVisitor interface
-    // ------------------------------------------------------------------------
-
-    public void visit(
-        final int version,
-        final int access,
-        final String name,
-        final String signature,
-        final String superName,
-        final String[] interfaces)
-    {
-        int major = version & 0xFFFF;
-        int minor = version >>> 16;
-        buf.setLength(0);
-        buf.append("// class version ")
-                .append(major)
-                .append('.')
-                .append(minor)
-                .append(" (")
-                .append(version)
-                .append(")\n");
-        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
-            buf.append("// DEPRECATED\n");
-        }
-        buf.append("// access flags 0x").append(Integer.toHexString(access).toUpperCase()).append('\n');
-
-        appendDescriptor(CLASS_SIGNATURE, signature);
-        if (signature != null) {
-            TraceSignatureVisitor sv = new TraceSignatureVisitor(access);
-            SignatureReader r = new SignatureReader(signature);
-            r.accept(sv);
-            buf.append("// declaration: ")
-                    .append(name)
-                    .append(sv.getDeclaration())
-                    .append('\n');
-        }
-
-        appendAccess(access & ~Opcodes.ACC_SUPER);
-        if ((access & Opcodes.ACC_ANNOTATION) != 0) {
-            buf.append("@interface ");
-        } else if ((access & Opcodes.ACC_INTERFACE) != 0) {
-            buf.append("interface ");
-        } else if ((access & Opcodes.ACC_ENUM) == 0) {
-            buf.append("class ");
-        }
-        appendDescriptor(INTERNAL_NAME, name);
-
-        if (superName != null && !"java/lang/Object".equals(superName)) {
-            buf.append(" extends ");
-            appendDescriptor(INTERNAL_NAME, superName);
-            buf.append(' ');
-        }
-        if (interfaces != null && interfaces.length > 0) {
-            buf.append(" implements ");
-            for (int i = 0; i < interfaces.length; ++i) {
-                appendDescriptor(INTERNAL_NAME, interfaces[i]);
-                buf.append(' ');
-            }
-        }
-        buf.append(" {\n\n");
-
-        text.add(buf.toString());
-
-        if (cv != null) {
-            cv.visit(version, access, name, signature, superName, interfaces);
-        }
-    }
-
-    public void visitSource(final String file, final String debug) {
-        buf.setLength(0);
-        if (file != null) {
-            buf.append(tab)
-                    .append("// compiled from: ")
-                    .append(file)
-                    .append('\n');
-        }
-        if (debug != null) {
-            buf.append(tab)
-                    .append("// debug info: ")
-                    .append(debug)
-                    .append('\n');
-        }
-        if (buf.length() > 0) {
-            text.add(buf.toString());
-        }
-
-        if (cv != null) {
-            cv.visitSource(file, debug);
-        }
-    }
-
-    public void visitOuterClass(
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        buf.setLength(0);
-        buf.append(tab).append("OUTERCLASS ");
-        appendDescriptor(INTERNAL_NAME, owner);
-        buf.append(' ');
-        if (name != null) {
-            buf.append(name).append(' ');
-        }
-        appendDescriptor(METHOD_DESCRIPTOR, desc);
-        buf.append('\n');
-        text.add(buf.toString());
-
-        if (cv != null) {
-            cv.visitOuterClass(owner, name, desc);
-        }
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        text.add("\n");
-        AnnotationVisitor tav = super.visitAnnotation(desc, visible);
-        if (cv != null) {
-            ((TraceAnnotationVisitor) tav).av = cv.visitAnnotation(desc,
-                    visible);
-        }
-        return tav;
-    }
-
-    public void visitAttribute(final Attribute attr) {
-        text.add("\n");
-        super.visitAttribute(attr);
-
-        if (cv != null) {
-            cv.visitAttribute(attr);
-        }
-    }
-
-    public void visitInnerClass(
-        final String name,
-        final String outerName,
-        final String innerName,
-        final int access)
-    {
-        buf.setLength(0);
-        buf.append(tab).append("// access flags 0x");
-        buf.append(Integer.toHexString(access & ~Opcodes.ACC_SUPER).toUpperCase()).append('\n');
-        buf.append(tab);
-        appendAccess(access);
-        buf.append("INNERCLASS ");
-        appendDescriptor(INTERNAL_NAME, name);
-        buf.append(' ');
-        appendDescriptor(INTERNAL_NAME, outerName);
-        buf.append(' ');
-        appendDescriptor(INTERNAL_NAME, innerName);
-        buf.append('\n');
-        text.add(buf.toString());
-
-        if (cv != null) {
-            cv.visitInnerClass(name, outerName, innerName, access);
-        }
-    }
-
-    public FieldVisitor visitField(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final Object value)
-    {
-        buf.setLength(0);
-        buf.append('\n');
-        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
-            buf.append(tab).append("// DEPRECATED\n");
-        }
-        buf.append(tab).append("// access flags 0x").append(Integer.toHexString(access).toUpperCase()).append('\n');
-        if (signature != null) {
-            buf.append(tab);
-            appendDescriptor(FIELD_SIGNATURE, signature);
-
-            TraceSignatureVisitor sv = new TraceSignatureVisitor(0);
-            SignatureReader r = new SignatureReader(signature);
-            r.acceptType(sv);
-            buf.append(tab)
-                    .append("// declaration: ")
-                    .append(sv.getDeclaration())
-                    .append('\n');
-        }
-
-        buf.append(tab);
-        appendAccess(access);
-
-        appendDescriptor(FIELD_DESCRIPTOR, desc);
-        buf.append(' ').append(name);
-        if (value != null) {
-            buf.append(" = ");
-            if (value instanceof String) {
-                buf.append('\"').append(value).append('\"');
-            } else {
-                buf.append(value);
-            }
-        }
-
-        buf.append('\n');
-        text.add(buf.toString());
-
-        TraceFieldVisitor tav = createTraceFieldVisitor();
-        text.add(tav.getText());
-
-        if (cv != null) {
-            tav.fv = cv.visitField(access, name, desc, signature, value);
-        }
-
-        return tav;
-    }
-
-    public MethodVisitor visitMethod(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final String[] exceptions)
-    {
-        buf.setLength(0);
-        buf.append('\n');
-        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
-            buf.append(tab).append("// DEPRECATED\n");
-        }
-        buf.append(tab).append("// access flags 0x").append(Integer.toHexString(access).toUpperCase()).append('\n');
-
-        if (signature != null) {
-            buf.append(tab);
-            appendDescriptor(METHOD_SIGNATURE, signature);
-
-            TraceSignatureVisitor v = new TraceSignatureVisitor(0);
-            SignatureReader r = new SignatureReader(signature);
-            r.accept(v);
-            String genericDecl = v.getDeclaration();
-            String genericReturn = v.getReturnType();
-            String genericExceptions = v.getExceptions();
-
-            buf.append(tab)
-                    .append("// declaration: ")
-                    .append(genericReturn)
-                    .append(' ')
-                    .append(name)
-                    .append(genericDecl);
-            if (genericExceptions != null) {
-                buf.append(" throws ").append(genericExceptions);
-            }
-            buf.append('\n');
-        }
-
-        buf.append(tab);
-        appendAccess(access);
-        if ((access & Opcodes.ACC_NATIVE) != 0) {
-            buf.append("native ");
-        }
-        if ((access & Opcodes.ACC_VARARGS) != 0) {
-            buf.append("varargs ");
-        }
-        if ((access & Opcodes.ACC_BRIDGE) != 0) {
-            buf.append("bridge ");
-        }
-
-        buf.append(name);
-        appendDescriptor(METHOD_DESCRIPTOR, desc);
-        if (exceptions != null && exceptions.length > 0) {
-            buf.append(" throws ");
-            for (int i = 0; i < exceptions.length; ++i) {
-                appendDescriptor(INTERNAL_NAME, exceptions[i]);
-                buf.append(' ');
-            }
-        }
-
-        buf.append('\n');
-        text.add(buf.toString());
-
-        TraceMethodVisitor tcv = createTraceMethodVisitor();
-        text.add(tcv.getText());
-
-        if (cv != null) {
-            tcv.mv = cv.visitMethod(access, name, desc, signature, exceptions);
-        }
-
-        return tcv;
-    }
-
-    public void visitEnd() {
-        text.add("}\n");
-
-        print(pw);
-        pw.flush();
-
-        if (cv != null) {
-            cv.visitEnd();
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Utility methods
-    // ------------------------------------------------------------------------
-
-    protected TraceFieldVisitor createTraceFieldVisitor() {
-        return new TraceFieldVisitor();
-    }
-
-    protected TraceMethodVisitor createTraceMethodVisitor() {
-        return new TraceMethodVisitor();
-    }
-
-    /**
-     * Appends a string representation of the given access modifiers to {@link
-     * #buf buf}.
-     * 
-     * @param access some access modifiers.
-     */
-    private void appendAccess(final int access) {
-        if ((access & Opcodes.ACC_PUBLIC) != 0) {
-            buf.append("public ");
-        }
-        if ((access & Opcodes.ACC_PRIVATE) != 0) {
-            buf.append("private ");
-        }
-        if ((access & Opcodes.ACC_PROTECTED) != 0) {
-            buf.append("protected ");
-        }
-        if ((access & Opcodes.ACC_FINAL) != 0) {
-            buf.append("final ");
-        }
-        if ((access & Opcodes.ACC_STATIC) != 0) {
-            buf.append("static ");
-        }
-        if ((access & Opcodes.ACC_SYNCHRONIZED) != 0) {
-            buf.append("synchronized ");
-        }
-        if ((access & Opcodes.ACC_VOLATILE) != 0) {
-            buf.append("volatile ");
-        }
-        if ((access & Opcodes.ACC_TRANSIENT) != 0) {
-            buf.append("transient ");
-        }
-        if ((access & Opcodes.ACC_ABSTRACT) != 0) {
-            buf.append("abstract ");
-        }
-        if ((access & Opcodes.ACC_STRICT) != 0) {
-            buf.append("strictfp ");
-        }
-        if ((access & Opcodes.ACC_ENUM) != 0) {
-            buf.append("enum ");
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/TraceFieldVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/TraceFieldVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/TraceFieldVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/TraceFieldVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,78 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-
-/**
- * A {@link FieldVisitor} that prints a disassembled view of the fields it
- * visits.
- * 
- * @author Eric Bruneton
- */
-public class TraceFieldVisitor extends TraceAbstractVisitor implements
-        FieldVisitor
-{
-
-    /**
-     * The {@link FieldVisitor} to which this visitor delegates calls. May be
-     * <tt>null</tt>.
-     */
-    protected FieldVisitor fv;
-
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        AnnotationVisitor av = super.visitAnnotation(desc, visible);
-        if (fv != null) {
-            ((TraceAnnotationVisitor) av).av = fv.visitAnnotation(desc, visible);
-        }
-        return av;
-    }
-
-    public void visitAttribute(final Attribute attr) {
-        super.visitAttribute(attr);
-
-        if (fv != null) {
-            fv.visitAttribute(attr);
-        }
-    }
-
-    public void visitEnd() {
-        super.visitEnd();
-
-        if (fv != null) {
-            fv.visitEnd();
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/TraceMethodVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/TraceMethodVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/TraceMethodVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/TraceMethodVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,567 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-import org.eclipse.persistence.internal.libraries.asm.signature.SignatureReader;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * A {@link MethodVisitor} that prints a disassembled view of the methods it
- * visits.
- * 
- * @author Eric Bruneton
- */
-public class TraceMethodVisitor extends TraceAbstractVisitor implements
-        MethodVisitor
-{
-
-    /**
-     * The {@link MethodVisitor} to which this visitor delegates calls. May be
-     * <tt>null</tt>.
-     */
-    protected MethodVisitor mv;
-
-    /**
-     * Tab for bytecode instructions.
-     */
-    protected String tab2 = "    ";
-
-    /**
-     * Tab for table and lookup switch instructions.
-     */
-    protected String tab3 = "      ";
-
-    /**
-     * Tab for labels.
-     */
-    protected String ltab = "   ";
-
-    /**
-     * The label names. This map associate String values to Label keys.
-     */
-    protected final Map labelNames;
-
-    /**
-     * Constructs a new {@link TraceMethodVisitor}.
-     */
-    public TraceMethodVisitor() {
-        this(null);
-    }
-
-    /**
-     * Constructs a new {@link TraceMethodVisitor}.
-     * 
-     * @param mv the {@link MethodVisitor} to which this visitor delegates
-     *        calls. May be <tt>null</tt>.
-     */
-    public TraceMethodVisitor(final MethodVisitor mv) {
-        this.labelNames = new HashMap();
-        this.mv = mv;
-    }
-
-    // ------------------------------------------------------------------------
-    // Implementation of the MethodVisitor interface
-    // ------------------------------------------------------------------------
-
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        AnnotationVisitor av = super.visitAnnotation(desc, visible);
-        if (mv != null) {
-            ((TraceAnnotationVisitor) av).av = mv.visitAnnotation(desc, visible);
-        }
-        return av;
-    }
-
-    public void visitAttribute(final Attribute attr) {
-        buf.setLength(0);
-        buf.append(tab).append("ATTRIBUTE ");
-        appendDescriptor(-1, attr.type);
-
-        if (attr instanceof Traceable) {
-            ((Traceable) attr).trace(buf, labelNames);
-        } else {
-            buf.append(" : unknown\n");
-        }
-
-        text.add(buf.toString());
-        if (mv != null) {
-            mv.visitAttribute(attr);
-        }
-    }
-
-    public AnnotationVisitor visitAnnotationDefault() {
-        text.add(tab2 + "default=");
-        TraceAnnotationVisitor tav = createTraceAnnotationVisitor();
-        text.add(tav.getText());
-        text.add("\n");
-        if (mv != null) {
-            tav.av = mv.visitAnnotationDefault();
-        }
-        return tav;
-    }
-
-    public AnnotationVisitor visitParameterAnnotation(
-        final int parameter,
-        final String desc,
-        final boolean visible)
-    {
-        buf.setLength(0);
-        buf.append(tab2).append('@');
-        appendDescriptor(FIELD_DESCRIPTOR, desc);
-        buf.append('(');
-        text.add(buf.toString());
-        TraceAnnotationVisitor tav = createTraceAnnotationVisitor();
-        text.add(tav.getText());
-        text.add(visible ? ") // parameter " : ") // invisible, parameter ");
-        text.add(new Integer(parameter));
-        text.add("\n");
-        if (mv != null) {
-            tav.av = mv.visitParameterAnnotation(parameter, desc, visible);
-        }
-        return tav;
-    }
-
-    public void visitCode() {
-        if (mv != null) {
-            mv.visitCode();
-        }
-    }
-
-    public void visitFrame(
-        final int type,
-        final int nLocal,
-        final Object[] local,
-        final int nStack,
-        final Object[] stack)
-    {
-        buf.setLength(0);
-        buf.append(ltab);
-        buf.append("FRAME ");
-        switch (type) {
-            case Opcodes.F_NEW:
-            case Opcodes.F_FULL:
-                buf.append("FULL [");
-                appendFrameTypes(nLocal, local);
-                buf.append("] [");
-                appendFrameTypes(nStack, stack);
-                buf.append(']');
-                break;
-            case Opcodes.F_APPEND:
-                buf.append("APPEND [");
-                appendFrameTypes(nLocal, local);
-                buf.append(']');
-                break;
-            case Opcodes.F_CHOP:
-                buf.append("CHOP ").append(nLocal);
-                break;
-            case Opcodes.F_SAME:
-                buf.append("SAME");
-                break;
-            case Opcodes.F_SAME1:
-                buf.append("SAME1 ");
-                appendFrameTypes(1, stack);
-                break;
-        }
-        buf.append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitFrame(type, nLocal, local, nStack, stack);
-        }
-    }
-
-    public void visitInsn(final int opcode) {
-        buf.setLength(0);
-        buf.append(tab2).append(OPCODES[opcode]).append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitInsn(opcode);
-        }
-    }
-
-    public void visitIntInsn(final int opcode, final int operand) {
-        buf.setLength(0);
-        buf.append(tab2)
-                .append(OPCODES[opcode])
-                .append(' ')
-                .append(opcode == Opcodes.NEWARRAY
-                        ? TYPES[operand]
-                        : Integer.toString(operand))
-                .append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitIntInsn(opcode, operand);
-        }
-    }
-
-    public void visitVarInsn(final int opcode, final int var) {
-        buf.setLength(0);
-        buf.append(tab2)
-                .append(OPCODES[opcode])
-                .append(' ')
-                .append(var)
-                .append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitVarInsn(opcode, var);
-        }
-    }
-
-    public void visitTypeInsn(final int opcode, final String type) {
-        buf.setLength(0);
-        buf.append(tab2).append(OPCODES[opcode]).append(' ');
-        appendDescriptor(INTERNAL_NAME, type);
-        buf.append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitTypeInsn(opcode, type);
-        }
-    }
-
-    public void visitFieldInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        buf.setLength(0);
-        buf.append(tab2).append(OPCODES[opcode]).append(' ');
-        appendDescriptor(INTERNAL_NAME, owner);
-        buf.append('.').append(name).append(" : ");
-        appendDescriptor(FIELD_DESCRIPTOR, desc);
-        buf.append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitFieldInsn(opcode, owner, name, desc);
-        }
-    }
-
-    public void visitMethodInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        buf.setLength(0);
-        buf.append(tab2).append(OPCODES[opcode]).append(' ');
-        appendDescriptor(INTERNAL_NAME, owner);
-        buf.append('.').append(name).append(' ');
-        appendDescriptor(METHOD_DESCRIPTOR, desc);
-        buf.append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitMethodInsn(opcode, owner, name, desc);
-        }
-    }
-
-    public void visitJumpInsn(final int opcode, final Label label) {
-        buf.setLength(0);
-        buf.append(tab2).append(OPCODES[opcode]).append(' ');
-        appendLabel(label);
-        buf.append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitJumpInsn(opcode, label);
-        }
-    }
-
-    public void visitLabel(final Label label) {
-        buf.setLength(0);
-        buf.append(ltab);
-        appendLabel(label);
-        buf.append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitLabel(label);
-        }
-    }
-
-    public void visitLdcInsn(final Object cst) {
-        buf.setLength(0);
-        buf.append(tab2).append("LDC ");
-        if (cst instanceof String) {
-            AbstractVisitor.appendString(buf, (String) cst);
-        } else if (cst instanceof Type) {
-            buf.append(((Type) cst).getDescriptor()).append(".class");
-        } else {
-            buf.append(cst);
-        }
-        buf.append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitLdcInsn(cst);
-        }
-    }
-
-    public void visitIincInsn(final int var, final int increment) {
-        buf.setLength(0);
-        buf.append(tab2)
-                .append("IINC ")
-                .append(var)
-                .append(' ')
-                .append(increment)
-                .append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitIincInsn(var, increment);
-        }
-    }
-
-    public void visitTableSwitchInsn(
-        final int min,
-        final int max,
-        final Label dflt,
-        final Label[] labels)
-    {
-        buf.setLength(0);
-        buf.append(tab2).append("TABLESWITCH\n");
-        for (int i = 0; i < labels.length; ++i) {
-            buf.append(tab3).append(min + i).append(": ");
-            appendLabel(labels[i]);
-            buf.append('\n');
-        }
-        buf.append(tab3).append("default: ");
-        appendLabel(dflt);
-        buf.append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitTableSwitchInsn(min, max, dflt, labels);
-        }
-    }
-
-    public void visitLookupSwitchInsn(
-        final Label dflt,
-        final int[] keys,
-        final Label[] labels)
-    {
-        buf.setLength(0);
-        buf.append(tab2).append("LOOKUPSWITCH\n");
-        for (int i = 0; i < labels.length; ++i) {
-            buf.append(tab3).append(keys[i]).append(": ");
-            appendLabel(labels[i]);
-            buf.append('\n');
-        }
-        buf.append(tab3).append("default: ");
-        appendLabel(dflt);
-        buf.append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitLookupSwitchInsn(dflt, keys, labels);
-        }
-    }
-
-    public void visitMultiANewArrayInsn(final String desc, final int dims) {
-        buf.setLength(0);
-        buf.append(tab2).append("MULTIANEWARRAY ");
-        appendDescriptor(FIELD_DESCRIPTOR, desc);
-        buf.append(' ').append(dims).append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitMultiANewArrayInsn(desc, dims);
-        }
-    }
-
-    public void visitTryCatchBlock(
-        final Label start,
-        final Label end,
-        final Label handler,
-        final String type)
-    {
-        buf.setLength(0);
-        buf.append(tab2).append("TRYCATCHBLOCK ");
-        appendLabel(start);
-        buf.append(' ');
-        appendLabel(end);
-        buf.append(' ');
-        appendLabel(handler);
-        buf.append(' ');
-        appendDescriptor(INTERNAL_NAME, type);
-        buf.append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitTryCatchBlock(start, end, handler, type);
-        }
-    }
-
-    public void visitLocalVariable(
-        final String name,
-        final String desc,
-        final String signature,
-        final Label start,
-        final Label end,
-        final int index)
-    {
-        buf.setLength(0);
-        buf.append(tab2).append("LOCALVARIABLE ").append(name).append(' ');
-        appendDescriptor(FIELD_DESCRIPTOR, desc);
-        buf.append(' ');
-        appendLabel(start);
-        buf.append(' ');
-        appendLabel(end);
-        buf.append(' ').append(index).append('\n');
-
-        if (signature != null) {
-            buf.append(tab2);
-            appendDescriptor(FIELD_SIGNATURE, signature);
-
-            TraceSignatureVisitor sv = new TraceSignatureVisitor(0);
-            SignatureReader r = new SignatureReader(signature);
-            r.acceptType(sv);
-            buf.append(tab2)
-                    .append("// declaration: ")
-                    .append(sv.getDeclaration())
-                    .append('\n');
-        }
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitLocalVariable(name, desc, signature, start, end, index);
-        }
-    }
-
-    public void visitLineNumber(final int line, final Label start) {
-        buf.setLength(0);
-        buf.append(tab2).append("LINENUMBER ").append(line).append(' ');
-        appendLabel(start);
-        buf.append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitLineNumber(line, start);
-        }
-    }
-
-    public void visitMaxs(final int maxStack, final int maxLocals) {
-        buf.setLength(0);
-        buf.append(tab2).append("MAXSTACK = ").append(maxStack).append('\n');
-        text.add(buf.toString());
-
-        buf.setLength(0);
-        buf.append(tab2).append("MAXLOCALS = ").append(maxLocals).append('\n');
-        text.add(buf.toString());
-
-        if (mv != null) {
-            mv.visitMaxs(maxStack, maxLocals);
-        }
-    }
-
-    public void visitEnd() {
-        super.visitEnd();
-
-        if (mv != null) {
-            mv.visitEnd();
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    // Utility methods
-    // ------------------------------------------------------------------------
-
-    private void appendFrameTypes(final int n, final Object[] o) {
-        for (int i = 0; i < n; ++i) {
-            if (i > 0) {
-                buf.append(' ');
-            }
-            if (o[i] instanceof String) {
-                String desc = (String) o[i];
-                if (desc.startsWith("[")) {
-                    appendDescriptor(FIELD_DESCRIPTOR, desc);
-                } else {
-                    appendDescriptor(INTERNAL_NAME, desc);
-                }
-            } else if (o[i] instanceof Integer) {
-                switch (((Integer) o[i]).intValue()) {
-                    case 0:
-                        appendDescriptor(FIELD_DESCRIPTOR, "T");
-                        break;
-                    case 1:
-                        appendDescriptor(FIELD_DESCRIPTOR, "I");
-                        break;
-                    case 2:
-                        appendDescriptor(FIELD_DESCRIPTOR, "F");
-                        break;
-                    case 3:
-                        appendDescriptor(FIELD_DESCRIPTOR, "D");
-                        break;
-                    case 4:
-                        appendDescriptor(FIELD_DESCRIPTOR, "J");
-                        break;
-                    case 5:
-                        appendDescriptor(FIELD_DESCRIPTOR, "N");
-                        break;
-                    case 6:
-                        appendDescriptor(FIELD_DESCRIPTOR, "U");
-                        break;
-                }
-            } else {
-                appendLabel((Label) o[i]);
-            }
-        }
-    }
-
-    /**
-     * Appends the name of the given label to {@link #buf buf}. Creates a new
-     * label name if the given label does not yet have one.
-     * 
-     * @param l a label.
-     */
-    protected void appendLabel(final Label l) {
-        String name = (String) labelNames.get(l);
-        if (name == null) {
-            name = "L" + labelNames.size();
-            labelNames.put(l, name);
-        }
-        buf.append(name);
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/TraceSignatureVisitor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/TraceSignatureVisitor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/util/TraceSignatureVisitor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/util/TraceSignatureVisitor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,300 +0,0 @@
-/***
- * ASM: a very small and fast Java bytecode manipulation framework
- * Copyright (c) 2000-2007 INRIA, France Telecom
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.util;
-
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.signature.SignatureVisitor;
-
-/**
- * A {@link SignatureVisitor} that prints a disassembled view of the signature
- * it visits.
- * 
- * @author Eugene Kuleshov
- * @author Eric Bruneton
- */
-public class TraceSignatureVisitor implements SignatureVisitor {
-
-    private final StringBuffer declaration;
-
-    private boolean isInterface;
-
-    private boolean seenFormalParameter;
-
-    private boolean seenInterfaceBound;
-
-    private boolean seenParameter;
-
-    private boolean seenInterface;
-
-    private StringBuffer returnType;
-
-    private StringBuffer exceptions;
-
-    /**
-     * Stack used to keep track of class types that have arguments. Each element
-     * of this stack is a boolean encoded in one bit. The top of the stack is
-     * the lowest order bit. Pushing false = *2, pushing true = *2+1, popping =
-     * /2.
-     */
-    private int argumentStack;
-
-    /**
-     * Stack used to keep track of array class types. Each element of this stack
-     * is a boolean encoded in one bit. The top of the stack is the lowest order
-     * bit. Pushing false = *2, pushing true = *2+1, popping = /2.
-     */
-    private int arrayStack;
-
-    private String separator = "";
-
-    public TraceSignatureVisitor(final int access) {
-        isInterface = (access & Opcodes.ACC_INTERFACE) != 0;
-        this.declaration = new StringBuffer();
-    }
-
-    private TraceSignatureVisitor(final StringBuffer buf) {
-        this.declaration = buf;
-    }
-
-    public void visitFormalTypeParameter(final String name) {
-        declaration.append(seenFormalParameter ? ", " : "<").append(name);
-        seenFormalParameter = true;
-        seenInterfaceBound = false;
-    }
-
-    public SignatureVisitor visitClassBound() {
-        separator = " extends ";
-        startType();
-        return this;
-    }
-
-    public SignatureVisitor visitInterfaceBound() {
-        separator = seenInterfaceBound ? ", " : " extends ";
-        seenInterfaceBound = true;
-        startType();
-        return this;
-    }
-
-    public SignatureVisitor visitSuperclass() {
-        endFormals();
-        separator = " extends ";
-        startType();
-        return this;
-    }
-
-    public SignatureVisitor visitInterface() {
-        separator = seenInterface ? ", " : isInterface
-                ? " extends "
-                : " implements ";
-        seenInterface = true;
-        startType();
-        return this;
-    }
-
-    public SignatureVisitor visitParameterType() {
-        endFormals();
-        if (seenParameter) {
-            declaration.append(", ");
-        } else {
-            seenParameter = true;
-            declaration.append('(');
-        }
-        startType();
-        return this;
-    }
-
-    public SignatureVisitor visitReturnType() {
-        endFormals();
-        if (seenParameter) {
-            seenParameter = false;
-        } else {
-            declaration.append('(');
-        }
-        declaration.append(')');
-        returnType = new StringBuffer();
-        return new TraceSignatureVisitor(returnType);
-    }
-
-    public SignatureVisitor visitExceptionType() {
-        if (exceptions == null) {
-            exceptions = new StringBuffer();
-        } else {
-            exceptions.append(", ");
-        }
-        // startType();
-        return new TraceSignatureVisitor(exceptions);
-    }
-
-    public void visitBaseType(final char descriptor) {
-        switch (descriptor) {
-            case 'V':
-                declaration.append("void");
-                break;
-            case 'B':
-                declaration.append("byte");
-                break;
-            case 'J':
-                declaration.append("long");
-                break;
-            case 'Z':
-                declaration.append("boolean");
-                break;
-            case 'I':
-                declaration.append("int");
-                break;
-            case 'S':
-                declaration.append("short");
-                break;
-            case 'C':
-                declaration.append("char");
-                break;
-            case 'F':
-                declaration.append("float");
-                break;
-            // case 'D':
-            default:
-                declaration.append("double");
-                break;
-        }
-        endType();
-    }
-
-    public void visitTypeVariable(final String name) {
-        declaration.append(name);
-        endType();
-    }
-
-    public SignatureVisitor visitArrayType() {
-        startType();
-        arrayStack |= 1;
-        return this;
-    }
-
-    public void visitClassType(final String name) {
-        if ("java/lang/Object".equals(name)) {
-            // Map<java.lang.Object,java.util.List>
-            // or
-            // abstract public V get(Object key); (seen in Dictionary.class)
-            // should have Object
-            // but java.lang.String extends java.lang.Object is unnecessary
-            boolean needObjectClass = argumentStack % 2 != 0 || seenParameter;
-            if (needObjectClass) {
-                declaration.append(separator).append(name.replace('/', '.'));
-            }
-        } else {
-            declaration.append(separator).append(name.replace('/', '.'));
-        }
-        separator = "";
-        argumentStack *= 2;
-    }
-
-    public void visitInnerClassType(final String name) {
-        if (argumentStack % 2 != 0) {
-            declaration.append('>');
-        }
-        argumentStack /= 2;
-        declaration.append('.');
-        declaration.append(separator).append(name.replace('/', '.'));
-        separator = "";
-        argumentStack *= 2;
-    }
-
-    public void visitTypeArgument() {
-        if (argumentStack % 2 == 0) {
-            ++argumentStack;
-            declaration.append('<');
-        } else {
-            declaration.append(", ");
-        }
-        declaration.append('?');
-    }
-
-    public SignatureVisitor visitTypeArgument(final char tag) {
-        if (argumentStack % 2 == 0) {
-            ++argumentStack;
-            declaration.append('<');
-        } else {
-            declaration.append(", ");
-        }
-
-        if (tag == EXTENDS) {
-            declaration.append("? extends ");
-        } else if (tag == SUPER) {
-            declaration.append("? super ");
-        }
-
-        startType();
-        return this;
-    }
-
-    public void visitEnd() {
-        if (argumentStack % 2 != 0) {
-            declaration.append('>');
-        }
-        argumentStack /= 2;
-        endType();
-    }
-
-    public String getDeclaration() {
-        return declaration.toString();
-    }
-
-    public String getReturnType() {
-        return returnType == null ? null : returnType.toString();
-    }
-
-    public String getExceptions() {
-        return exceptions == null ? null : exceptions.toString();
-    }
-
-    // -----------------------------------------------
-
-    private void endFormals() {
-        if (seenFormalParameter) {
-            declaration.append('>');
-            seenFormalParameter = false;
-        }
-    }
-
-    private void startType() {
-        arrayStack *= 2;
-    }
-
-    private void endType() {
-        if (arrayStack % 2 == 0) {
-            arrayStack /= 2;
-        } else {
-            while (arrayStack % 2 != 0) {
-                arrayStack /= 2;
-                declaration.append("[]");
-            }
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/ASMContentHandler.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/ASMContentHandler.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/ASMContentHandler.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/ASMContentHandler.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,1279 +0,0 @@
-/***
- * ASM XML Adapter
- * Copyright (c) 2004, Eugene Kuleshov
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.xml;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.ClassVisitor;
-import org.eclipse.persistence.internal.libraries.asm.ClassWriter;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-import org.xml.sax.Attributes;
-import org.xml.sax.SAXException;
-import org.xml.sax.helpers.DefaultHandler;
-
-/**
- * A {@link org.xml.sax.ContentHandler ContentHandler} that transforms XML
- * document into Java class file. This class can be feeded by any kind of SAX
- * 2.0 event producers, e.g. XML parser, XSLT or XPath engines, or custom code.
- *
- * @see org.eclipse.persistence.internal.libraries.asm.xml.SAXClassAdapter
- * @see org.eclipse.persistence.internal.libraries.asm.xml.Processor
- *
- * @author Eugene Kuleshov
- */
-public class ASMContentHandler extends DefaultHandler implements Opcodes {
-
-    /**
-     * Stack of the intermediate processing contexts.
-     */
-    private final List stack = new ArrayList();
-
-    /**
-     * Complete name of the current element.
-     */
-    String match = "";
-
-    /**
-     * <tt>true</tt> if the maximum stack size and number of local variables
-     * must be automatically computed.
-     */
-    protected boolean computeMax;
-
-    /**
-     * Output stream to write result bytecode.
-     */
-    protected OutputStream os;
-
-    /**
-     * Current instance of the {@link ClassWriter ClassWriter} used to write
-     * class bytecode.
-     */
-    protected ClassWriter cw;
-
-    /**
-     * Map of the active {@link Label Label} instances for current method.
-     */
-    protected Map labels;
-
-    private static final String BASE = "class";
-
-    private final RuleSet RULES = new RuleSet();
-    {
-        RULES.add(BASE, new ClassRule());
-        RULES.add(BASE + "/interfaces/interface", new InterfaceRule());
-        RULES.add(BASE + "/interfaces", new InterfacesRule());
-        RULES.add(BASE + "/outerclass", new OuterClassRule());
-        RULES.add(BASE + "/innerclass", new InnerClassRule());
-        RULES.add(BASE + "/source", new SourceRule());
-        RULES.add(BASE + "/field", new FieldRule());
-
-        RULES.add(BASE + "/method", new MethodRule());
-        RULES.add(BASE + "/method/exceptions/exception", new ExceptionRule());
-        RULES.add(BASE + "/method/exceptions", new ExceptionsRule());
-
-        RULES.add(BASE + "/method/annotationDefault",
-                new AnnotationDefaultRule());
-
-        RULES.add(BASE + "/method/code/*", new OpcodesRule()); // opcodes
-
-        RULES.add(BASE + "/method/code/frame", new FrameRule());
-        RULES.add(BASE + "/method/code/frame/local", new FrameTypeRule());
-        RULES.add(BASE + "/method/code/frame/stack", new FrameTypeRule());
-
-        RULES.add(BASE + "/method/code/TABLESWITCH", new TableSwitchRule());
-        RULES.add(BASE + "/method/code/TABLESWITCH/label",
-                new TableSwitchLabelRule());
-        RULES.add(BASE + "/method/code/LOOKUPSWITCH", new LookupSwitchRule());
-        RULES.add(BASE + "/method/code/LOOKUPSWITCH/label",
-                new LookupSwitchLabelRule());
-
-        RULES.add(BASE + "/method/code/Label", new LabelRule());
-        RULES.add(BASE + "/method/code/TryCatch", new TryCatchRule());
-        RULES.add(BASE + "/method/code/LineNumber", new LineNumberRule());
-        RULES.add(BASE + "/method/code/LocalVar", new LocalVarRule());
-        RULES.add(BASE + "/method/code/Max", new MaxRule());
-
-        RULES.add("*/annotation", new AnnotationRule());
-        RULES.add("*/parameterAnnotation", new AnnotationParameterRule());
-        RULES.add("*/annotationValue", new AnnotationValueRule());
-        RULES.add("*/annotationValueAnnotation",
-                new AnnotationValueAnnotationRule());
-        RULES.add("*/annotationValueEnum", new AnnotationValueEnumRule());
-        RULES.add("*/annotationValueArray", new AnnotationValueArrayRule());
-    }
-
-    private static interface OpcodeGroup {
-        public static final int INSN = 0;
-        public static final int INSN_INT = 1;
-        public static final int INSN_VAR = 2;
-        public static final int INSN_TYPE = 3;
-        public static final int INSN_FIELD = 4;
-        public static final int INSN_METHOD = 5;
-        public static final int INSN_JUMP = 6;
-        public static final int INSN_LDC = 7;
-        public static final int INSN_IINC = 8;
-        public static final int INSN_MULTIANEWARRAY = 9;
-    }
-
-    /**
-     * Map of the opcode names to opcode and opcode group
-     */
-    static final Map OPCODES = new HashMap();
-    static {
-        addOpcode("NOP", NOP, OpcodeGroup.INSN);
-        addOpcode("ACONST_NULL", ACONST_NULL, OpcodeGroup.INSN);
-        addOpcode("ICONST_M1", ICONST_M1, OpcodeGroup.INSN);
-        addOpcode("ICONST_0", ICONST_0, OpcodeGroup.INSN);
-        addOpcode("ICONST_1", ICONST_1, OpcodeGroup.INSN);
-        addOpcode("ICONST_2", ICONST_2, OpcodeGroup.INSN);
-        addOpcode("ICONST_3", ICONST_3, OpcodeGroup.INSN);
-        addOpcode("ICONST_4", ICONST_4, OpcodeGroup.INSN);
-        addOpcode("ICONST_5", ICONST_5, OpcodeGroup.INSN);
-        addOpcode("LCONST_0", LCONST_0, OpcodeGroup.INSN);
-        addOpcode("LCONST_1", LCONST_1, OpcodeGroup.INSN);
-        addOpcode("FCONST_0", FCONST_0, OpcodeGroup.INSN);
-        addOpcode("FCONST_1", FCONST_1, OpcodeGroup.INSN);
-        addOpcode("FCONST_2", FCONST_2, OpcodeGroup.INSN);
-        addOpcode("DCONST_0", DCONST_0, OpcodeGroup.INSN);
-        addOpcode("DCONST_1", DCONST_1, OpcodeGroup.INSN);
-        addOpcode("BIPUSH", BIPUSH, OpcodeGroup.INSN_INT);
-        addOpcode("SIPUSH", SIPUSH, OpcodeGroup.INSN_INT);
-        addOpcode("LDC", LDC, OpcodeGroup.INSN_LDC);
-        addOpcode("ILOAD", ILOAD, OpcodeGroup.INSN_VAR);
-        addOpcode("LLOAD", LLOAD, OpcodeGroup.INSN_VAR);
-        addOpcode("FLOAD", FLOAD, OpcodeGroup.INSN_VAR);
-        addOpcode("DLOAD", DLOAD, OpcodeGroup.INSN_VAR);
-        addOpcode("ALOAD", ALOAD, OpcodeGroup.INSN_VAR);
-        addOpcode("IALOAD", IALOAD, OpcodeGroup.INSN);
-        addOpcode("LALOAD", LALOAD, OpcodeGroup.INSN);
-        addOpcode("FALOAD", FALOAD, OpcodeGroup.INSN);
-        addOpcode("DALOAD", DALOAD, OpcodeGroup.INSN);
-        addOpcode("AALOAD", AALOAD, OpcodeGroup.INSN);
-        addOpcode("BALOAD", BALOAD, OpcodeGroup.INSN);
-        addOpcode("CALOAD", CALOAD, OpcodeGroup.INSN);
-        addOpcode("SALOAD", SALOAD, OpcodeGroup.INSN);
-        addOpcode("ISTORE", ISTORE, OpcodeGroup.INSN_VAR);
-        addOpcode("LSTORE", LSTORE, OpcodeGroup.INSN_VAR);
-        addOpcode("FSTORE", FSTORE, OpcodeGroup.INSN_VAR);
-        addOpcode("DSTORE", DSTORE, OpcodeGroup.INSN_VAR);
-        addOpcode("ASTORE", ASTORE, OpcodeGroup.INSN_VAR);
-        addOpcode("IASTORE", IASTORE, OpcodeGroup.INSN);
-        addOpcode("LASTORE", LASTORE, OpcodeGroup.INSN);
-        addOpcode("FASTORE", FASTORE, OpcodeGroup.INSN);
-        addOpcode("DASTORE", DASTORE, OpcodeGroup.INSN);
-        addOpcode("AASTORE", AASTORE, OpcodeGroup.INSN);
-        addOpcode("BASTORE", BASTORE, OpcodeGroup.INSN);
-        addOpcode("CASTORE", CASTORE, OpcodeGroup.INSN);
-        addOpcode("SASTORE", SASTORE, OpcodeGroup.INSN);
-        addOpcode("POP", POP, OpcodeGroup.INSN);
-        addOpcode("POP2", POP2, OpcodeGroup.INSN);
-        addOpcode("DUP", DUP, OpcodeGroup.INSN);
-        addOpcode("DUP_X1", DUP_X1, OpcodeGroup.INSN);
-        addOpcode("DUP_X2", DUP_X2, OpcodeGroup.INSN);
-        addOpcode("DUP2", DUP2, OpcodeGroup.INSN);
-        addOpcode("DUP2_X1", DUP2_X1, OpcodeGroup.INSN);
-        addOpcode("DUP2_X2", DUP2_X2, OpcodeGroup.INSN);
-        addOpcode("SWAP", SWAP, OpcodeGroup.INSN);
-        addOpcode("IADD", IADD, OpcodeGroup.INSN);
-        addOpcode("LADD", LADD, OpcodeGroup.INSN);
-        addOpcode("FADD", FADD, OpcodeGroup.INSN);
-        addOpcode("DADD", DADD, OpcodeGroup.INSN);
-        addOpcode("ISUB", ISUB, OpcodeGroup.INSN);
-        addOpcode("LSUB", LSUB, OpcodeGroup.INSN);
-        addOpcode("FSUB", FSUB, OpcodeGroup.INSN);
-        addOpcode("DSUB", DSUB, OpcodeGroup.INSN);
-        addOpcode("IMUL", IMUL, OpcodeGroup.INSN);
-        addOpcode("LMUL", LMUL, OpcodeGroup.INSN);
-        addOpcode("FMUL", FMUL, OpcodeGroup.INSN);
-        addOpcode("DMUL", DMUL, OpcodeGroup.INSN);
-        addOpcode("IDIV", IDIV, OpcodeGroup.INSN);
-        addOpcode("LDIV", LDIV, OpcodeGroup.INSN);
-        addOpcode("FDIV", FDIV, OpcodeGroup.INSN);
-        addOpcode("DDIV", DDIV, OpcodeGroup.INSN);
-        addOpcode("IREM", IREM, OpcodeGroup.INSN);
-        addOpcode("LREM", LREM, OpcodeGroup.INSN);
-        addOpcode("FREM", FREM, OpcodeGroup.INSN);
-        addOpcode("DREM", DREM, OpcodeGroup.INSN);
-        addOpcode("INEG", INEG, OpcodeGroup.INSN);
-        addOpcode("LNEG", LNEG, OpcodeGroup.INSN);
-        addOpcode("FNEG", FNEG, OpcodeGroup.INSN);
-        addOpcode("DNEG", DNEG, OpcodeGroup.INSN);
-        addOpcode("ISHL", ISHL, OpcodeGroup.INSN);
-        addOpcode("LSHL", LSHL, OpcodeGroup.INSN);
-        addOpcode("ISHR", ISHR, OpcodeGroup.INSN);
-        addOpcode("LSHR", LSHR, OpcodeGroup.INSN);
-        addOpcode("IUSHR", IUSHR, OpcodeGroup.INSN);
-        addOpcode("LUSHR", LUSHR, OpcodeGroup.INSN);
-        addOpcode("IAND", IAND, OpcodeGroup.INSN);
-        addOpcode("LAND", LAND, OpcodeGroup.INSN);
-        addOpcode("IOR", IOR, OpcodeGroup.INSN);
-        addOpcode("LOR", LOR, OpcodeGroup.INSN);
-        addOpcode("IXOR", IXOR, OpcodeGroup.INSN);
-        addOpcode("LXOR", LXOR, OpcodeGroup.INSN);
-        addOpcode("IINC", IINC, OpcodeGroup.INSN_IINC);
-        addOpcode("I2L", I2L, OpcodeGroup.INSN);
-        addOpcode("I2F", I2F, OpcodeGroup.INSN);
-        addOpcode("I2D", I2D, OpcodeGroup.INSN);
-        addOpcode("L2I", L2I, OpcodeGroup.INSN);
-        addOpcode("L2F", L2F, OpcodeGroup.INSN);
-        addOpcode("L2D", L2D, OpcodeGroup.INSN);
-        addOpcode("F2I", F2I, OpcodeGroup.INSN);
-        addOpcode("F2L", F2L, OpcodeGroup.INSN);
-        addOpcode("F2D", F2D, OpcodeGroup.INSN);
-        addOpcode("D2I", D2I, OpcodeGroup.INSN);
-        addOpcode("D2L", D2L, OpcodeGroup.INSN);
-        addOpcode("D2F", D2F, OpcodeGroup.INSN);
-        addOpcode("I2B", I2B, OpcodeGroup.INSN);
-        addOpcode("I2C", I2C, OpcodeGroup.INSN);
-        addOpcode("I2S", I2S, OpcodeGroup.INSN);
-        addOpcode("LCMP", LCMP, OpcodeGroup.INSN);
-        addOpcode("FCMPL", FCMPL, OpcodeGroup.INSN);
-        addOpcode("FCMPG", FCMPG, OpcodeGroup.INSN);
-        addOpcode("DCMPL", DCMPL, OpcodeGroup.INSN);
-        addOpcode("DCMPG", DCMPG, OpcodeGroup.INSN);
-        addOpcode("IFEQ", IFEQ, OpcodeGroup.INSN_JUMP);
-        addOpcode("IFNE", IFNE, OpcodeGroup.INSN_JUMP);
-        addOpcode("IFLT", IFLT, OpcodeGroup.INSN_JUMP);
-        addOpcode("IFGE", IFGE, OpcodeGroup.INSN_JUMP);
-        addOpcode("IFGT", IFGT, OpcodeGroup.INSN_JUMP);
-        addOpcode("IFLE", IFLE, OpcodeGroup.INSN_JUMP);
-        addOpcode("IF_ICMPEQ", IF_ICMPEQ, OpcodeGroup.INSN_JUMP);
-        addOpcode("IF_ICMPNE", IF_ICMPNE, OpcodeGroup.INSN_JUMP);
-        addOpcode("IF_ICMPLT", IF_ICMPLT, OpcodeGroup.INSN_JUMP);
-        addOpcode("IF_ICMPGE", IF_ICMPGE, OpcodeGroup.INSN_JUMP);
-        addOpcode("IF_ICMPGT", IF_ICMPGT, OpcodeGroup.INSN_JUMP);
-        addOpcode("IF_ICMPLE", IF_ICMPLE, OpcodeGroup.INSN_JUMP);
-        addOpcode("IF_ACMPEQ", IF_ACMPEQ, OpcodeGroup.INSN_JUMP);
-        addOpcode("IF_ACMPNE", IF_ACMPNE, OpcodeGroup.INSN_JUMP);
-        addOpcode("GOTO", GOTO, OpcodeGroup.INSN_JUMP);
-        addOpcode("JSR", JSR, OpcodeGroup.INSN_JUMP);
-        addOpcode("RET", RET, OpcodeGroup.INSN_VAR);
-        addOpcode("IRETURN", IRETURN, OpcodeGroup.INSN);
-        addOpcode("LRETURN", LRETURN, OpcodeGroup.INSN);
-        addOpcode("FRETURN", FRETURN, OpcodeGroup.INSN);
-        addOpcode("DRETURN", DRETURN, OpcodeGroup.INSN);
-        addOpcode("ARETURN", ARETURN, OpcodeGroup.INSN);
-        addOpcode("RETURN", RETURN, OpcodeGroup.INSN);
-        addOpcode("GETSTATIC", GETSTATIC, OpcodeGroup.INSN_FIELD);
-        addOpcode("PUTSTATIC", PUTSTATIC, OpcodeGroup.INSN_FIELD);
-        addOpcode("GETFIELD", GETFIELD, OpcodeGroup.INSN_FIELD);
-        addOpcode("PUTFIELD", PUTFIELD, OpcodeGroup.INSN_FIELD);
-        addOpcode("INVOKEVIRTUAL", INVOKEVIRTUAL, OpcodeGroup.INSN_METHOD);
-        addOpcode("INVOKESPECIAL", INVOKESPECIAL, OpcodeGroup.INSN_METHOD);
-        addOpcode("INVOKESTATIC", INVOKESTATIC, OpcodeGroup.INSN_METHOD);
-        addOpcode("INVOKEINTERFACE", INVOKEINTERFACE, OpcodeGroup.INSN_METHOD);
-        addOpcode("INVOKEDYNAMIC", INVOKEDYNAMIC, OpcodeGroup.INSN_METHOD);
-        addOpcode("NEW", NEW, OpcodeGroup.INSN_TYPE);
-        addOpcode("NEWARRAY", NEWARRAY, OpcodeGroup.INSN_INT);
-        addOpcode("ANEWARRAY", ANEWARRAY, OpcodeGroup.INSN_TYPE);
-        addOpcode("ARRAYLENGTH", ARRAYLENGTH, OpcodeGroup.INSN);
-        addOpcode("ATHROW", ATHROW, OpcodeGroup.INSN);
-        addOpcode("CHECKCAST", CHECKCAST, OpcodeGroup.INSN_TYPE);
-        addOpcode("INSTANCEOF", INSTANCEOF, OpcodeGroup.INSN_TYPE);
-        addOpcode("MONITORENTER", MONITORENTER, OpcodeGroup.INSN);
-        addOpcode("MONITOREXIT", MONITOREXIT, OpcodeGroup.INSN);
-        addOpcode("MULTIANEWARRAY", MULTIANEWARRAY, OpcodeGroup.INSN_MULTIANEWARRAY);
-        addOpcode("IFNULL", IFNULL, OpcodeGroup.INSN_JUMP);
-        addOpcode("IFNONNULL", IFNONNULL, OpcodeGroup.INSN_JUMP);
-    }
-
-    private static void addOpcode(String operStr, int oper, int group) {
-        OPCODES.put(operStr, new Opcode(oper, group));
-    }
-
-    static final Map TYPES = new HashMap();
-    static {
-        String[] types = SAXCodeAdapter.TYPES;
-        for (int i = 0; i < types.length; i++) {
-            TYPES.put(types[i], new Integer(i));
-        }
-    }
-
-    /**
-     * Constructs a new {@link ASMContentHandler ASMContentHandler} object.
-     *
-     * @param os output stream to write generated class.
-     * @param computeMax <tt>true</tt> if the maximum stack size and the
-     *        maximum number of local variables must be automatically computed.
-     *        This value is passed to {@link ClassWriter ClassWriter} instance.
-     */
-    public ASMContentHandler(final OutputStream os, final boolean computeMax) {
-        this.os = os;
-        this.computeMax = computeMax;
-    }
-
-    /**
-     * Returns the bytecode of the class that was build with underneath class
-     * writer.
-     *
-     * @return the bytecode of the class that was build with underneath class
-     *         writer or null if there are no classwriter created.
-     */
-    public byte[] toByteArray() {
-        return cw == null ? null : cw.toByteArray();
-    }
-
-    /**
-     * Process notification of the start of an XML element being reached.
-     *
-     * @param ns - The Namespace URI, or the empty string if the element has no
-     *        Namespace URI or if Namespace processing is not being performed.
-     * @param lName - The local name (without prefix), or the empty string if
-     *        Namespace processing is not being performed.
-     * @param qName - The qualified name (with prefix), or the empty string if
-     *        qualified names are not available.
-     * @param list - The attributes attached to the element. If there are no
-     *        attributes, it shall be an empty Attributes object.
-     * @exception SAXException if a parsing error is to be reported
-     */
-    public final void startElement(
-        final String ns,
-        final String lName,
-        final String qName,
-        final Attributes list) throws SAXException
-    {
-        // the actual element name is either in lName or qName, depending
-        // on whether the parser is namespace aware
-        String name = lName == null || lName.length() == 0 ? qName : lName;
-
-        // Compute the current matching rule
-        StringBuffer sb = new StringBuffer(match);
-        if (match.length() > 0) {
-            sb.append('/');
-        }
-        sb.append(name);
-        match = sb.toString();
-
-        // Fire "begin" events for all relevant rules
-        Rule r = (Rule) RULES.match(match);
-        if (r != null) {
-            r.begin(name, list);
-        }
-    }
-
-    /**
-     * Process notification of the end of an XML element being reached.
-     *
-     * @param ns - The Namespace URI, or the empty string if the element has no
-     *        Namespace URI or if Namespace processing is not being performed.
-     * @param lName - The local name (without prefix), or the empty string if
-     *        Namespace processing is not being performed.
-     * @param qName - The qualified XML 1.0 name (with prefix), or the empty
-     *        string if qualified names are not available.
-     *
-     * @exception SAXException if a parsing error is to be reported
-     */
-    public final void endElement(
-        final String ns,
-        final String lName,
-        final String qName) throws SAXException
-    {
-        // the actual element name is either in lName or qName, depending
-        // on whether the parser is namespace aware
-        String name = lName == null || lName.length() == 0 ? qName : lName;
-
-        // Fire "end" events for all relevant rules in reverse order
-        Rule r = (Rule) RULES.match(match);
-        if (r != null) {
-            r.end(name);
-        }
-
-        // Recover the previous match expression
-        int slash = match.lastIndexOf('/');
-        if (slash >= 0) {
-            match = match.substring(0, slash);
-        } else {
-            match = "";
-        }
-    }
-
-    /**
-     * Process notification of the end of a document and write generated
-     * bytecode into output stream.
-     *
-     * @exception SAXException if parsing or writing error is to be reported.
-     */
-    public final void endDocument() throws SAXException {
-        try {
-            os.write(toByteArray());
-        } catch (IOException ex) {
-            throw new SAXException(ex.toString(), ex);
-        }
-    }
-
-    /**
-     * Return the top object on the stack without removing it. If there are no
-     * objects on the stack, return <code>null</code>.
-     *
-     * @return the top object on the stack without removing it.
-     */
-    final Object peek() {
-        int size = stack.size();
-        return size == 0 ? null : stack.get(size - 1);
-    }
-
-    /**
-     * Pop the top object off of the stack, and return it. If there are no
-     * objects on the stack, return <code>null</code>.
-     *
-     * @return the top object off of the stack.
-     */
-    final Object pop() {
-        int size = stack.size();
-        return size == 0 ? null : stack.remove(size - 1);
-    }
-
-    /**
-     * Push a new object onto the top of the object stack.
-     *
-     * @param object The new object
-     */
-    final void push(final Object object) {
-        stack.add(object);
-    }
-
-    static final class RuleSet {
-
-        private final Map rules = new HashMap();
-
-        private final List lpatterns = new ArrayList();
-
-        private final List rpatterns = new ArrayList();
-
-        public void add(final String path, final Object rule) {
-            String pattern = path;
-            if (path.startsWith("*/")) {
-                pattern = path.substring(1);
-                lpatterns.add(pattern);
-            } else if (path.endsWith("/*")) {
-                pattern = path.substring(0, path.length() - 1);
-                rpatterns.add(pattern);
-            }
-            rules.put(pattern, rule);
-        }
-
-        public Object match(final String path) {
-            if (rules.containsKey(path)) {
-                return rules.get(path);
-            }
-
-            int n = path.lastIndexOf('/');
-            for (Iterator it = lpatterns.iterator(); it.hasNext();) {
-                String pattern = (String) it.next();
-                if (path.substring(n).endsWith(pattern)) {
-                    return rules.get(pattern);
-                }
-            }
-
-            for (Iterator it = rpatterns.iterator(); it.hasNext();) {
-                String pattern = (String) it.next();
-                if (path.startsWith(pattern)) {
-                    return rules.get(pattern);
-                }
-            }
-
-            return null;
-        }
-    }
-
-    /**
-     * Rule
-     */
-    protected abstract class Rule {
-
-        public void begin(final String name, final Attributes attrs)
-                throws SAXException
-        {
-        }
-
-        public void end(final String name) {
-        }
-
-        protected final Object getValue(final String desc, final String val)
-                throws SAXException
-        {
-            Object value = null;
-            if (val != null) {
-                if ("Ljava/lang/String;".equals(desc)) {
-                    value = decode(val);
-                } else if ("Ljava/lang/Integer;".equals(desc)
-                        || "I".equals(desc) || "S".equals(desc)
-                        || "B".equals(desc) || "C".equals(desc)
-                        || "Z".equals(desc))
-                {
-                    value = new Integer(val);
-
-                } else if ("Ljava/lang/Short;".equals(desc)) {
-                    value = new Short(val);
-
-                } else if ("Ljava/lang/Byte;".equals(desc)) {
-                    value = new Byte(val);
-
-                } else if ("Ljava/lang/Character;".equals(desc)) {
-                    value = new Character(decode(val).charAt(0));
-
-                } else if ("Ljava/lang/Boolean;".equals(desc)) {
-                    value = Boolean.valueOf(val);
-
-                } else if ("Ljava/lang/Long;".equals(desc) || "J".equals(desc))
-                {
-                    value = new Long(val);
-                } else if ("Ljava/lang/Float;".equals(desc) || "F".equals(desc))
-                {
-                    value = new Float(val);
-                } else if ("Ljava/lang/Double;".equals(desc)
-                        || "D".equals(desc))
-                {
-                    value = new Double(val);
-                } else if (Type.getDescriptor(Type.class).equals(desc)) {
-                    value = Type.getType(val);
-
-                } else {
-                    // TODO use of default toString().
-                    throw new SAXException("Invalid value:" + val + " desc:"
-                            + desc + " ctx:" + this);
-                }
-            }
-            return value;
-        }
-
-        private final String decode(final String val) throws SAXException {
-            StringBuffer sb = new StringBuffer(val.length());
-            try {
-                int n = 0;
-                while (n < val.length()) {
-                    char c = val.charAt(n);
-                    if (c == '\\') {
-                        n++;
-                        c = val.charAt(n);
-                        if (c == '\\') {
-                            sb.append('\\');
-                        } else {
-                            n++; // skip 'u'
-                            sb.append((char) Integer.parseInt(val.substring(n,
-                                    n + 4), 16));
-                            n += 3;
-                        }
-                    } else {
-                        sb.append(c);
-                    }
-                    n++;
-                }
-
-            } catch (RuntimeException ex) {
-                throw new SAXException(ex);
-            }
-            return sb.toString();
-        }
-
-        protected final Label getLabel(final Object label) {
-            Label lbl = (Label) labels.get(label);
-            if (lbl == null) {
-                lbl = new Label();
-                labels.put(label, lbl);
-            }
-            return lbl;
-        }
-
-        // TODO verify move to stack
-        protected final MethodVisitor getCodeVisitor() {
-            return (MethodVisitor) peek();
-        }
-
-        protected final int getAccess(final String s) {
-            int access = 0;
-            if (s.indexOf("public") != -1) {
-                access |= ACC_PUBLIC;
-            }
-            if (s.indexOf("private") != -1) {
-                access |= ACC_PRIVATE;
-            }
-            if (s.indexOf("protected") != -1) {
-                access |= ACC_PROTECTED;
-            }
-            if (s.indexOf("static") != -1) {
-                access |= ACC_STATIC;
-            }
-            if (s.indexOf("final") != -1) {
-                access |= ACC_FINAL;
-            }
-            if (s.indexOf("super") != -1) {
-                access |= ACC_SUPER;
-            }
-            if (s.indexOf("synchronized") != -1) {
-                access |= ACC_SYNCHRONIZED;
-            }
-            if (s.indexOf("volatile") != -1) {
-                access |= ACC_VOLATILE;
-            }
-            if (s.indexOf("bridge") != -1) {
-                access |= ACC_BRIDGE;
-            }
-            if (s.indexOf("varargs") != -1) {
-                access |= ACC_VARARGS;
-            }
-            if (s.indexOf("transient") != -1) {
-                access |= ACC_TRANSIENT;
-            }
-            if (s.indexOf("native") != -1) {
-                access |= ACC_NATIVE;
-            }
-            if (s.indexOf("interface") != -1) {
-                access |= ACC_INTERFACE;
-            }
-            if (s.indexOf("abstract") != -1) {
-                access |= ACC_ABSTRACT;
-            }
-            if (s.indexOf("strict") != -1) {
-                access |= ACC_STRICT;
-            }
-            if (s.indexOf("synthetic") != -1) {
-                access |= ACC_SYNTHETIC;
-            }
-            if (s.indexOf("annotation") != -1) {
-                access |= ACC_ANNOTATION;
-            }
-            if (s.indexOf("enum") != -1) {
-                access |= ACC_ENUM;
-            }
-            if (s.indexOf("deprecated") != -1) {
-                access |= ACC_DEPRECATED;
-            }
-            return access;
-        }
-    }
-
-    /**
-     * ClassRule
-     */
-    final class ClassRule extends Rule {
-
-        public final void begin(final String name, final Attributes attrs) {
-            int major = Integer.parseInt(attrs.getValue("major"));
-            int minor = Integer.parseInt(attrs.getValue("minor"));
-            cw = new ClassWriter(computeMax ? ClassWriter.COMPUTE_MAXS : 0);
-            Map vals = new HashMap();
-            vals.put("version", new Integer(minor << 16 | major));
-            vals.put("access", attrs.getValue("access"));
-            vals.put("name", attrs.getValue("name"));
-            vals.put("parent", attrs.getValue("parent"));
-            vals.put("source", attrs.getValue("source"));
-            vals.put("signature", attrs.getValue("signature"));
-            vals.put("interfaces", new ArrayList());
-            push(vals);
-            // values will be extracted in InterfacesRule.end();
-        }
-    }
-
-    final class SourceRule extends Rule {
-
-        public void begin(final String name, final Attributes attrs) {
-            String file = attrs.getValue("file");
-            String debug = attrs.getValue("debug");
-            cw.visitSource(file, debug);
-        }
-    }
-
-    /**
-     * InterfaceRule
-     */
-    final class InterfaceRule extends Rule {
-
-        public final void begin(final String name, final Attributes attrs) {
-            ((List) ((HashMap) peek()).get("interfaces")).add(attrs.getValue("name"));
-        }
-    }
-
-    /**
-     * InterfacesRule
-     */
-    final class InterfacesRule extends Rule {
-
-        public final void end(final String element) {
-            Map vals = (Map) pop();
-            int version = ((Integer) vals.get("version")).intValue();
-            int access = getAccess((String) vals.get("access"));
-            String name = (String) vals.get("name");
-            String signature = (String) vals.get("signature");
-            String parent = (String) vals.get("parent");
-            List infs = (List) vals.get("interfaces");
-            String[] interfaces = (String[]) infs.toArray(new String[infs.size()]);
-            cw.visit(version, access, name, signature, parent, interfaces);
-            push(cw);
-        }
-    }
-
-    /**
-     * OuterClassRule
-     */
-    final class OuterClassRule extends Rule {
-
-        public final void begin(final String element, final Attributes attrs) {
-            String owner = attrs.getValue("owner");
-            String name = attrs.getValue("name");
-            String desc = attrs.getValue("desc");
-            cw.visitOuterClass(owner, name, desc);
-        }
-    }
-
-    /**
-     * InnerClassRule
-     */
-    final class InnerClassRule extends Rule {
-
-        public final void begin(final String element, final Attributes attrs) {
-            int access = getAccess(attrs.getValue("access"));
-            String name = attrs.getValue("name");
-            String outerName = attrs.getValue("outerName");
-            String innerName = attrs.getValue("innerName");
-            cw.visitInnerClass(name, outerName, innerName, access);
-        }
-    }
-
-    /**
-     * FieldRule
-     */
-    final class FieldRule extends Rule {
-
-        public final void begin(final String element, final Attributes attrs)
-                throws SAXException
-        {
-            int access = getAccess(attrs.getValue("access"));
-            String name = attrs.getValue("name");
-            String signature = attrs.getValue("signature");
-            String desc = attrs.getValue("desc");
-            Object value = getValue(desc, attrs.getValue("value"));
-            push(cw.visitField(access, name, desc, signature, value));
-        }
-
-        public void end(final String name) {
-            ((FieldVisitor) pop()).visitEnd();
-        }
-    }
-
-    /**
-     * MethodRule
-     */
-    final class MethodRule extends Rule {
-
-        public final void begin(final String name, final Attributes attrs) {
-            labels = new HashMap();
-            Map vals = new HashMap();
-            vals.put("access", attrs.getValue("access"));
-            vals.put("name", attrs.getValue("name"));
-            vals.put("desc", attrs.getValue("desc"));
-            vals.put("signature", attrs.getValue("signature"));
-            vals.put("exceptions", new ArrayList());
-            push(vals);
-            // values will be extracted in ExceptionsRule.end();
-        }
-
-        public final void end(final String name) {
-            ((MethodVisitor) pop()).visitEnd();
-            labels = null;
-        }
-    }
-
-    /**
-     * ExceptionRule
-     */
-    final class ExceptionRule extends Rule {
-
-        public final void begin(final String name, final Attributes attrs) {
-            ((List) ((HashMap) peek()).get("exceptions")).add(attrs.getValue("name"));
-        }
-    }
-
-    /**
-     * ExceptionsRule
-     */
-    final class ExceptionsRule extends Rule {
-
-        public final void end(final String element) {
-            Map vals = (Map) pop();
-            int access = getAccess((String) vals.get("access"));
-            String name = (String) vals.get("name");
-            String desc = (String) vals.get("desc");
-            String signature = (String) vals.get("signature");
-            List excs = (List) vals.get("exceptions");
-            String[] exceptions = (String[]) excs.toArray(new String[excs.size()]);
-
-            push(cw.visitMethod(access, name, desc, signature, exceptions));
-        }
-    }
-
-    /**
-     * TableSwitchRule
-     */
-    class TableSwitchRule extends Rule {
-
-        public final void begin(final String name, final Attributes attrs) {
-            Map vals = new HashMap();
-            vals.put("min", attrs.getValue("min"));
-            vals.put("max", attrs.getValue("max"));
-            vals.put("dflt", attrs.getValue("dflt"));
-            vals.put("labels", new ArrayList());
-            push(vals);
-        }
-
-        public final void end(final String name) {
-            Map vals = (Map) pop();
-            int min = Integer.parseInt((String) vals.get("min"));
-            int max = Integer.parseInt((String) vals.get("max"));
-            Label dflt = getLabel(vals.get("dflt"));
-            List lbls = (List) vals.get("labels");
-            Label[] labels = (Label[]) lbls.toArray(new Label[lbls.size()]);
-            getCodeVisitor().visitTableSwitchInsn(min, max, dflt, labels);
-        }
-    }
-
-    /**
-     * TableSwitchLabelRule
-     */
-    final class TableSwitchLabelRule extends Rule {
-
-        public final void begin(final String name, final Attributes attrs) {
-            ((List) ((HashMap) peek()).get("labels")).add(getLabel(attrs.getValue("name")));
-        }
-    }
-
-    /**
-     * LookupSwitchRule
-     */
-    final class LookupSwitchRule extends Rule {
-
-        public final void begin(final String name, final Attributes attrs) {
-            Map vals = new HashMap();
-            vals.put("dflt", attrs.getValue("dflt"));
-            vals.put("labels", new ArrayList());
-            vals.put("keys", new ArrayList());
-            push(vals);
-        }
-
-        public final void end(final String name) {
-            Map vals = (Map) pop();
-            Label dflt = getLabel(vals.get("dflt"));
-            List keyList = (List) vals.get("keys");
-            List lbls = (List) vals.get("labels");
-            Label[] labels = (Label[]) lbls.toArray(new Label[lbls.size()]);
-            int[] keys = new int[keyList.size()];
-            for (int i = 0; i < keys.length; i++) {
-                keys[i] = Integer.parseInt((String) keyList.get(i));
-            }
-            getCodeVisitor().visitLookupSwitchInsn(dflt, keys, labels);
-        }
-    }
-
-    /**
-     * LookupSwitchLabelRule
-     */
-    final class LookupSwitchLabelRule extends Rule {
-
-        public final void begin(final String name, final Attributes attrs) {
-            Map vals = (Map) peek();
-            ((List) vals.get("labels")).add(getLabel(attrs.getValue("name")));
-            ((List) vals.get("keys")).add(attrs.getValue("key"));
-        }
-    }
-
-    /**
-     * FrameRule
-     */
-    final class FrameRule extends Rule {
-
-        public void begin(final String name, final Attributes attrs) {
-            Map typeLists = new HashMap();
-            typeLists.put("local", new ArrayList());
-            typeLists.put("stack", new ArrayList());
-            push(attrs.getValue("type"));
-            push(attrs.getValue("count") == null
-                    ? "0"
-                    : attrs.getValue("count"));
-            push(typeLists);
-        }
-
-        public void end(final String name) {
-            Map typeLists = (Map) pop();
-            List locals = (List) typeLists.get("local");
-            int nLocal = locals.size();
-            Object[] local = locals.toArray();
-            List stacks = (List) typeLists.get("stack");
-            int nStack = stacks.size();
-            Object[] stack = stacks.toArray();
-            String count = (String) pop();
-            String type = (String) pop();
-            if ("NEW".equals(type)) {
-                getCodeVisitor().visitFrame(F_NEW,
-                        nLocal,
-                        local,
-                        nStack,
-                        stack);
-            } else if ("FULL".equals(type)) {
-                getCodeVisitor().visitFrame(F_FULL,
-                        nLocal,
-                        local,
-                        nStack,
-                        stack);
-            } else if ("APPEND".equals(type)) {
-                getCodeVisitor().visitFrame(F_APPEND,
-                        nLocal,
-                        local,
-                        0,
-                        null);
-            } else if ("CHOP".equals(type)) {
-                getCodeVisitor().visitFrame(F_CHOP,
-                        Integer.parseInt(count),
-                        null,
-                        0,
-                        null);
-            } else if ("SAME".equals(type)) {
-                getCodeVisitor().visitFrame(F_SAME, 0, null, 0, null);
-            } else if ("SAME1".equals(type)) {
-                getCodeVisitor().visitFrame(F_SAME1,
-                        0,
-                        null,
-                        nStack,
-                        stack);
-            }
-        }
-    }
-
-    final class FrameTypeRule extends Rule {
-
-        public void begin(final String name, final Attributes attrs) {
-            List types = (List) ((HashMap) peek()).get(name);
-            String type = attrs.getValue("type");
-            if ("uninitialized".equals(type)) {
-                types.add(getLabel(attrs.getValue("label")));
-            } else {
-                Integer t = (Integer) TYPES.get(type);
-                if (t == null) {
-                    types.add(type);
-                } else {
-                    types.add(t);
-                }
-            }
-        }
-    }
-
-    /**
-     * LabelRule
-     */
-    final class LabelRule extends Rule {
-
-        public final void begin(final String name, final Attributes attrs) {
-            getCodeVisitor().visitLabel(getLabel(attrs.getValue("name")));
-        }
-    }
-
-    /**
-     * TryCatchRule
-     */
-    final class TryCatchRule extends Rule {
-
-        public final void begin(final String name, final Attributes attrs) {
-            Label start = getLabel(attrs.getValue("start"));
-            Label end = getLabel(attrs.getValue("end"));
-            Label handler = getLabel(attrs.getValue("handler"));
-            String type = attrs.getValue("type");
-            getCodeVisitor().visitTryCatchBlock(start, end, handler, type);
-        }
-    }
-
-    /**
-     * LineNumberRule
-     */
-    final class LineNumberRule extends Rule {
-
-        public final void begin(final String name, final Attributes attrs) {
-            int line = Integer.parseInt(attrs.getValue("line"));
-            Label start = getLabel(attrs.getValue("start"));
-            getCodeVisitor().visitLineNumber(line, start);
-        }
-    }
-
-    /**
-     * LocalVarRule
-     */
-    final class LocalVarRule extends Rule {
-
-        public final void begin(final String element, final Attributes attrs) {
-            String name = attrs.getValue("name");
-            String desc = attrs.getValue("desc");
-            String signature = attrs.getValue("signature");
-            Label start = getLabel(attrs.getValue("start"));
-            Label end = getLabel(attrs.getValue("end"));
-            int var = Integer.parseInt(attrs.getValue("var"));
-            getCodeVisitor().visitLocalVariable(name,
-                    desc,
-                    signature,
-                    start,
-                    end,
-                    var);
-        }
-    }
-
-    /**
-     * OpcodesRule
-     */
-    final class OpcodesRule extends Rule {
-
-        // public boolean match( String match, String element) {
-        // return match.startsWith( path) && OPCODES.containsKey( element);
-        // }
-
-        public final void begin(final String element, final Attributes attrs)
-                throws SAXException
-        {
-            Opcode o = (Opcode) OPCODES.get(element);
-            if (o == null) {
-                throw new SAXException("Invalid element: " + element + " at "
-                        + match);
-            }
-
-            switch (o.type) {
-                case OpcodeGroup.INSN:
-                    getCodeVisitor().visitInsn(o.opcode);
-                    break;
-
-                case OpcodeGroup.INSN_FIELD:
-                    getCodeVisitor().visitFieldInsn(o.opcode,
-                            attrs.getValue("owner"),
-                            attrs.getValue("name"),
-                            attrs.getValue("desc"));
-                    break;
-
-                case OpcodeGroup.INSN_INT:
-                    getCodeVisitor().visitIntInsn(o.opcode,
-                            Integer.parseInt(attrs.getValue("value")));
-                    break;
-
-                case OpcodeGroup.INSN_JUMP:
-                    getCodeVisitor().visitJumpInsn(o.opcode,
-                            getLabel(attrs.getValue("label")));
-                    break;
-
-                case OpcodeGroup.INSN_METHOD:
-                    getCodeVisitor().visitMethodInsn(o.opcode,
-                            (o.opcode != Opcodes.INVOKEDYNAMIC)?
-                                    attrs.getValue("owner"):
-                                    Opcodes.INVOKEDYNAMIC_OWNER,
-                            attrs.getValue("name"),
-                            attrs.getValue("desc"));
-                    break;
-
-                case OpcodeGroup.INSN_TYPE:
-                    getCodeVisitor().visitTypeInsn(o.opcode,
-                            attrs.getValue("desc"));
-                    break;
-
-                case OpcodeGroup.INSN_VAR:
-                    getCodeVisitor().visitVarInsn(o.opcode,
-                            Integer.parseInt(attrs.getValue("var")));
-                    break;
-
-                case OpcodeGroup.INSN_IINC:
-                    getCodeVisitor().visitIincInsn(Integer.parseInt(attrs.getValue("var")),
-                            Integer.parseInt(attrs.getValue("inc")));
-                    break;
-
-                case OpcodeGroup.INSN_LDC:
-                    getCodeVisitor().visitLdcInsn(getValue(attrs.getValue("desc"),
-                            attrs.getValue("cst")));
-                    break;
-
-                case OpcodeGroup.INSN_MULTIANEWARRAY:
-                    getCodeVisitor().visitMultiANewArrayInsn(attrs.getValue("desc"),
-                            Integer.parseInt(attrs.getValue("dims")));
-                    break;
-
-                default:
-                    throw new Error("Internal error");
-
-            }
-        }
-    }
-
-    /**
-     * MaxRule
-     */
-    final class MaxRule extends Rule {
-
-        public final void begin(final String element, final Attributes attrs) {
-            int maxStack = Integer.parseInt(attrs.getValue("maxStack"));
-            int maxLocals = Integer.parseInt(attrs.getValue("maxLocals"));
-            getCodeVisitor().visitMaxs(maxStack, maxLocals);
-        }
-    }
-
-    final class AnnotationRule extends Rule {
-
-        public void begin(final String name, final Attributes attrs) {
-            String desc = attrs.getValue("desc");
-            boolean visible = Boolean.valueOf(attrs.getValue("visible"))
-                    .booleanValue();
-
-            Object v = peek();
-            if (v instanceof ClassVisitor) {
-                push(((ClassVisitor) v).visitAnnotation(desc, visible));
-            } else if (v instanceof FieldVisitor) {
-                push(((FieldVisitor) v).visitAnnotation(desc, visible));
-            } else if (v instanceof MethodVisitor) {
-                push(((MethodVisitor) v).visitAnnotation(desc, visible));
-            }
-        }
-
-        public void end(final String name) {
-            AnnotationVisitor av = (AnnotationVisitor) pop();
-            if (av != null) {
-                av.visitEnd();
-            }
-        }
-    }
-
-    final class AnnotationParameterRule extends Rule {
-
-        public void begin(final String name, final Attributes attrs) {
-            int parameter = Integer.parseInt(attrs.getValue("parameter"));
-            String desc = attrs.getValue("desc");
-            boolean visible = Boolean.valueOf(attrs.getValue("visible"))
-                    .booleanValue();
-
-            push(((MethodVisitor) peek()).visitParameterAnnotation(parameter,
-                    desc,
-                    visible));
-        }
-
-        public void end(final String name) {
-            AnnotationVisitor av = (AnnotationVisitor) pop();
-            if (av != null) {
-                av.visitEnd();
-            }
-        }
-    }
-
-    final class AnnotationValueRule extends Rule {
-
-        public void begin(final String nm, final Attributes attrs)
-                throws SAXException
-        {
-            AnnotationVisitor av = (AnnotationVisitor) peek();
-            if (av != null) {
-                av.visit(attrs.getValue("name"),
-                        getValue(attrs.getValue("desc"),
-                                attrs.getValue("value")));
-            }
-        }
-    }
-
-    final class AnnotationValueEnumRule extends Rule {
-
-        public void begin(final String nm, final Attributes attrs) {
-            AnnotationVisitor av = (AnnotationVisitor) peek();
-            if (av != null) {
-                av.visitEnum(attrs.getValue("name"),
-                        attrs.getValue("desc"),
-                        attrs.getValue("value"));
-            }
-        }
-    }
-
-    final class AnnotationValueAnnotationRule extends Rule {
-
-        public void begin(final String nm, final Attributes attrs) {
-            AnnotationVisitor av = (AnnotationVisitor) peek();
-            push(av == null ? null : av.visitAnnotation(attrs.getValue("name"),
-                    attrs.getValue("desc")));
-        }
-
-        public void end(final String name) {
-            AnnotationVisitor av = (AnnotationVisitor) pop();
-            if (av != null) {
-                av.visitEnd();
-            }
-        }
-    }
-
-    final class AnnotationValueArrayRule extends Rule {
-
-        public void begin(final String nm, final Attributes attrs) {
-            AnnotationVisitor av = (AnnotationVisitor) peek();
-            push(av == null ? null : av.visitArray(attrs.getValue("name")));
-        }
-
-        public void end(final String name) {
-            AnnotationVisitor av = (AnnotationVisitor) pop();
-            if (av != null) {
-                av.visitEnd();
-            }
-        }
-    }
-
-    final class AnnotationDefaultRule extends Rule {
-
-        public void begin(final String nm, final Attributes attrs) {
-            MethodVisitor av = (MethodVisitor) peek();
-            push(av == null ? null : av.visitAnnotationDefault());
-        }
-
-        public void end(final String name) {
-            AnnotationVisitor av = (AnnotationVisitor) pop();
-            if (av != null) {
-                av.visitEnd();
-            }
-        }
-    }
-
-    /**
-     * Opcode
-     */
-    static final class Opcode {
-
-        public final int opcode;
-
-        public final int type;
-
-        Opcode(final int opcode, final int type) {
-            this.opcode = opcode;
-            this.type = type;
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/asm-xml.dtd eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/asm-xml.dtd
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/asm-xml.dtd	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/asm-xml.dtd	1970-01-01 01:00:00.000000000 +0100
@@ -1,343 +0,0 @@
-<!--
-  ASM XML Adapter
-  Copyright (c) 2004, Eugene Kuleshov
-  All rights reserved.
-  
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-  1. Redistributions of source code must retain the above copyright
-     notice, this list of conditions and the following disclaimer.
-  2. Redistributions in binary form must reproduce the above copyright
-     notice, this list of conditions and the following disclaimer in the
-     documentation and/or other materials provided with the distribution.
-  3. Neither the name of the copyright holders nor the names of its
-     contributors may be used to endorse or promote products derived from
-     this software without specific prior written permission.
-  
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-  THE POSSIBILITY OF SUCH DAMAGE.
--->
-
-<!--
-  This DTD must be used to create XML documents to be processed by
-  org.objectweb.asm.xml.ASMContentHandler
--->
-
-<!--
-  Root element used to aggregate multiple classes into single document.
--->
-<!ELEMENT classes ( class+ )>
-
-<!--
-  Root element for a single class.
--->
-<!ELEMENT class ( interfaces, ( field | innerclass | method )*)>
-<!ATTLIST class access CDATA #REQUIRED>
-<!ATTLIST class name CDATA #REQUIRED>
-<!ATTLIST class parent CDATA #REQUIRED>
-<!ATTLIST class major CDATA #REQUIRED>
-<!ATTLIST class minor CDATA #REQUIRED>
-<!ATTLIST class source CDATA #IMPLIED>
-
-<!ELEMENT interfaces ( interface* )>
-<!ELEMENT interface EMPTY>
-<!ATTLIST interface name CDATA #REQUIRED>
-
-<!ELEMENT field EMPTY>
-<!ATTLIST field access CDATA #REQUIRED>
-<!ATTLIST field desc CDATA #REQUIRED>
-<!ATTLIST field name CDATA #REQUIRED>
-<!--
-  All characters out of interval 0x20 to 0x7f (inclusive) must
-  be encoded (\uXXXX) and character '\' must be replaced by "\\"
--->
-<!ATTLIST field value CDATA #IMPLIED>
-
-<!ELEMENT innerclass EMPTY>
-<!ATTLIST innerclass access CDATA #REQUIRED>
-<!ATTLIST innerclass innerName CDATA #IMPLIED>
-<!ATTLIST innerclass name CDATA #REQUIRED>
-<!ATTLIST innerclass outerName CDATA #IMPLIED>
-
-<!--
-  Root element for method definition.
--->
-<!ELEMENT method ( exceptions, code? )>
-<!ATTLIST method access CDATA #REQUIRED>
-<!ATTLIST method desc CDATA #REQUIRED>
-<!ATTLIST method name CDATA #REQUIRED>
-
-<!ELEMENT exceptions ( exception* )>
-<!ELEMENT exception EMPTY>
-<!ATTLIST exception name CDATA #REQUIRED>
-
-<!--
-  code element contains bytecode instructions and definitions for labels, line numbers, try/catch and max
--->
-<!ELEMENT code (( AALOAD | AASTORE | ACONST_NULL | ALOAD | ANEWARRAY | ARETURN | ARRAYLENGTH | ASTORE | ATHROW | BALOAD | BASTORE | BIPUSH | CALOAD | CASTORE | CHECKCAST | D2F | D2I | D2L | DADD | DALOAD | DASTORE | DCMPG | DCMPL | DCONST_0 | DCONST_1 | DDIV | DLOAD | DMUL | DNEG | DREM | DRETURN | DSTORE | DSUB | DUP | DUP2 | DUP2_X1 | DUP2_X2 | DUP_X1 | DUP_X2 | F2D | F2I | F2L | FADD | FALOAD | FASTORE | FCMPG | FCMPL | FCONST_0 | FCONST_1 | FCONST_2 | FDIV | FLOAD | FMUL | FNEG | FRETURN | FSTORE | FSUB | GETFIELD | GETSTATIC | GOTO | I2B | I2C | I2D | I2F | I2L | I2S | IADD | IALOAD | IAND | IASTORE | ICONST_0 | ICONST_1 | ICONST_2 | ICONST_3 | ICONST_4 | ICONST_5 | ICONST_M1 | IDIV | IFEQ | IFGE | IFGT | IFLE | IFLT | IFNE | IFNONNULL | IFNULL | IF_ACMPEQ | IF_ACMPNE | IF_ICMPEQ | IF_ICMPGE | IF_ICMPGT | IF_ICMPLE | IF_ICMPLT | IF_ICMPNE | IINC | ILOAD | IMUL | INEG | INSTANCEOF | INVOKEINTERFACE | INVOKESPECIAL | INVOKESTATIC | INVOKEVIRTUAL | IOR | IREM | IRETURN | ISHL | ISHR | ISTORE | ISUB | IUSHR | IXOR | JSR | L2D | L2F | L2I | LADD | LALOAD | LAND | LASTORE | LCMP | LCONST_0 | LCONST_1 | LDC | LDIV | LLOAD | LMUL | LNEG | LOOKUPSWITCH | LOR | LREM | LRETURN | LSHL | LSHR | LSTORE | LSUB | LUSHR | LXOR | MONITORENTER | MONITOREXIT | MULTIANEWARRAY | NEW | NEWARRAY | NOP | POP | POP2 | PUTFIELD | PUTSTATIC | RET | RETURN | SALOAD | SASTORE | SIPUSH | TABLESWITCH | Label | LineNumber | TryCatch )*, Max)>
-
-<!ELEMENT Label EMPTY>
-<!ATTLIST Label name CDATA #REQUIRED>
-
-<!ELEMENT TryCatch EMPTY>
-<!ATTLIST TryCatch end CDATA #REQUIRED>
-<!ATTLIST TryCatch handler CDATA #REQUIRED>
-<!ATTLIST TryCatch start CDATA #REQUIRED>
-<!ATTLIST TryCatch type CDATA #IMPLIED>
-
-<!ELEMENT LineNumber EMPTY>
-<!ATTLIST LineNumber line CDATA #REQUIRED>
-<!ATTLIST LineNumber start CDATA #REQUIRED>
-
-<!ELEMENT Max EMPTY>
-<!ATTLIST Max maxLocals CDATA #REQUIRED>
-<!ATTLIST Max maxStack CDATA #REQUIRED>
-
-<!ELEMENT AALOAD EMPTY>
-<!ELEMENT AASTORE EMPTY>
-<!ELEMENT ACONST_NULL EMPTY>
-<!ELEMENT ALOAD EMPTY>
-<!ATTLIST ALOAD var CDATA #REQUIRED>
-<!ELEMENT ANEWARRAY EMPTY>
-<!ATTLIST ANEWARRAY desc CDATA #REQUIRED>
-<!ELEMENT ARETURN EMPTY>
-<!ELEMENT ARRAYLENGTH EMPTY>
-<!ELEMENT ASTORE EMPTY>
-<!ATTLIST ASTORE var CDATA #REQUIRED>
-<!ELEMENT ATHROW EMPTY>
-<!ELEMENT BALOAD EMPTY>
-<!ELEMENT BASTORE EMPTY>
-<!ELEMENT BIPUSH EMPTY>
-<!ATTLIST BIPUSH value CDATA #REQUIRED>
-<!ELEMENT CALOAD EMPTY>
-<!ELEMENT CASTORE EMPTY>
-<!ELEMENT CHECKCAST EMPTY>
-<!ATTLIST CHECKCAST desc CDATA #REQUIRED>
-<!ELEMENT D2F EMPTY>
-<!ELEMENT D2I EMPTY>
-<!ELEMENT D2L EMPTY>
-<!ELEMENT DADD EMPTY>
-<!ELEMENT DALOAD EMPTY>
-<!ELEMENT DASTORE EMPTY>
-<!ELEMENT DCMPG EMPTY>
-<!ELEMENT DCMPL EMPTY>
-<!ELEMENT DCONST_0 EMPTY>
-<!ELEMENT DCONST_1 EMPTY>
-<!ELEMENT DDIV EMPTY>
-<!ELEMENT DLOAD EMPTY>
-<!ATTLIST DLOAD var CDATA #REQUIRED>
-<!ELEMENT DMUL EMPTY>
-<!ELEMENT DNEG EMPTY>
-<!ELEMENT DREM EMPTY>
-<!ELEMENT DRETURN EMPTY>
-<!ELEMENT DSTORE EMPTY>
-<!ATTLIST DSTORE var CDATA #REQUIRED>
-<!ELEMENT DSUB EMPTY>
-<!ELEMENT DUP EMPTY>
-<!ELEMENT DUP2 EMPTY>
-<!ELEMENT DUP2_X1 EMPTY>
-<!ELEMENT DUP2_X2 EMPTY>
-<!ELEMENT DUP_X1 EMPTY>
-<!ELEMENT DUP_X2 EMPTY>
-<!ELEMENT F2D EMPTY>
-<!ELEMENT F2I EMPTY>
-<!ELEMENT F2L EMPTY>
-<!ELEMENT FADD EMPTY>
-<!ELEMENT FALOAD EMPTY>
-<!ELEMENT FASTORE EMPTY>
-<!ELEMENT FCMPG EMPTY>
-<!ELEMENT FCMPL EMPTY>
-<!ELEMENT FCONST_0 EMPTY>
-<!ELEMENT FCONST_1 EMPTY>
-<!ELEMENT FCONST_2 EMPTY>
-<!ELEMENT FDIV EMPTY>
-<!ELEMENT FLOAD EMPTY>
-<!ATTLIST FLOAD var CDATA #REQUIRED>
-<!ELEMENT FMUL EMPTY>
-<!ELEMENT FNEG EMPTY>
-<!ELEMENT FRETURN EMPTY>
-<!ELEMENT FSTORE EMPTY>
-<!ATTLIST FSTORE var CDATA #REQUIRED>
-<!ELEMENT FSUB EMPTY>
-<!ELEMENT GETFIELD EMPTY>
-<!ATTLIST GETFIELD desc CDATA #REQUIRED>
-<!ATTLIST GETFIELD name CDATA #REQUIRED>
-<!ATTLIST GETFIELD owner CDATA #REQUIRED>
-<!ELEMENT GETSTATIC EMPTY>
-<!ATTLIST GETSTATIC desc CDATA #REQUIRED>
-<!ATTLIST GETSTATIC name CDATA #REQUIRED>
-<!ATTLIST GETSTATIC owner CDATA #REQUIRED>
-<!ELEMENT GOTO EMPTY>
-<!ATTLIST GOTO label CDATA #REQUIRED>
-<!ELEMENT I2B EMPTY>
-<!ELEMENT I2C EMPTY>
-<!ELEMENT I2D EMPTY>
-<!ELEMENT I2F EMPTY>
-<!ELEMENT I2L EMPTY>
-<!ELEMENT I2S EMPTY>
-<!ELEMENT IADD EMPTY>
-<!ELEMENT IALOAD EMPTY>
-<!ELEMENT IAND EMPTY>
-<!ELEMENT IASTORE EMPTY>
-<!ELEMENT ICONST_0 EMPTY>
-<!ELEMENT ICONST_1 EMPTY>
-<!ELEMENT ICONST_2 EMPTY>
-<!ELEMENT ICONST_3 EMPTY>
-<!ELEMENT ICONST_4 EMPTY>
-<!ELEMENT ICONST_5 EMPTY>
-<!ELEMENT ICONST_M1 EMPTY>
-<!ELEMENT IDIV EMPTY>
-<!ELEMENT IFEQ EMPTY>
-<!ATTLIST IFEQ label CDATA #REQUIRED>
-<!ELEMENT IFGE EMPTY>
-<!ATTLIST IFGE label CDATA #REQUIRED>
-<!ELEMENT IFGT EMPTY>
-<!ATTLIST IFGT label CDATA #REQUIRED>
-<!ELEMENT IFLE EMPTY>
-<!ATTLIST IFLE label CDATA #REQUIRED>
-<!ELEMENT IFLT EMPTY>
-<!ATTLIST IFLT label CDATA #REQUIRED>
-<!ELEMENT IFNE EMPTY>
-<!ATTLIST IFNE label CDATA #REQUIRED>
-<!ELEMENT IFNONNULL EMPTY>
-<!ATTLIST IFNONNULL label CDATA #REQUIRED>
-<!ELEMENT IFNULL EMPTY>
-<!ATTLIST IFNULL label CDATA #REQUIRED>
-<!ELEMENT IF_ACMPEQ EMPTY>
-<!ATTLIST IF_ACMPEQ label CDATA #REQUIRED>
-<!ELEMENT IF_ACMPNE EMPTY>
-<!ATTLIST IF_ACMPNE label CDATA #REQUIRED>
-<!ELEMENT IF_ICMPEQ EMPTY>
-<!ATTLIST IF_ICMPEQ label CDATA #REQUIRED>
-<!ELEMENT IF_ICMPGE EMPTY>
-<!ATTLIST IF_ICMPGE label CDATA #REQUIRED>
-<!ELEMENT IF_ICMPGT EMPTY>
-<!ATTLIST IF_ICMPGT label CDATA #REQUIRED>
-<!ELEMENT IF_ICMPLE EMPTY>
-<!ATTLIST IF_ICMPLE label CDATA #REQUIRED>
-<!ELEMENT IF_ICMPLT EMPTY>
-<!ATTLIST IF_ICMPLT label CDATA #REQUIRED>
-<!ELEMENT IF_ICMPNE EMPTY>
-<!ATTLIST IF_ICMPNE label CDATA #REQUIRED>
-<!ELEMENT IINC EMPTY>
-<!ATTLIST IINC inc CDATA #REQUIRED>
-<!ATTLIST IINC var CDATA #REQUIRED>
-<!ELEMENT ILOAD EMPTY>
-<!ATTLIST ILOAD var CDATA #REQUIRED>
-<!ELEMENT IMUL EMPTY>
-<!ELEMENT INEG EMPTY>
-<!ELEMENT INSTANCEOF EMPTY>
-<!ATTLIST INSTANCEOF desc CDATA #REQUIRED>
-<!ELEMENT INVOKEINTERFACE EMPTY>
-<!ATTLIST INVOKEINTERFACE desc CDATA #REQUIRED>
-<!ATTLIST INVOKEINTERFACE name CDATA #REQUIRED>
-<!ATTLIST INVOKEINTERFACE owner CDATA #REQUIRED>
-<!ELEMENT INVOKESPECIAL EMPTY>
-<!ATTLIST INVOKESPECIAL desc CDATA #REQUIRED>
-<!ATTLIST INVOKESPECIAL name CDATA #REQUIRED>
-<!ATTLIST INVOKESPECIAL owner CDATA #REQUIRED>
-<!ELEMENT INVOKESTATIC EMPTY>
-<!ATTLIST INVOKESTATIC desc CDATA #REQUIRED>
-<!ATTLIST INVOKESTATIC name CDATA #REQUIRED>
-<!ATTLIST INVOKESTATIC owner CDATA #REQUIRED>
-<!ELEMENT INVOKEVIRTUAL EMPTY>
-<!ATTLIST INVOKEVIRTUAL desc CDATA #REQUIRED>
-<!ATTLIST INVOKEVIRTUAL name CDATA #REQUIRED>
-<!ATTLIST INVOKEVIRTUAL owner CDATA #REQUIRED>
-<!ELEMENT INVOKEDYNAMIC EMPTY>
-<!ATTLIST INVOKEDYNAMIC desc CDATA #REQUIRED>
-<!ATTLIST INVOKEDYNAMIC name CDATA #REQUIRED>
-<!ELEMENT IOR EMPTY>
-<!ELEMENT IREM EMPTY>
-<!ELEMENT IRETURN EMPTY>
-<!ELEMENT ISHL EMPTY>
-<!ELEMENT ISHR EMPTY>
-<!ELEMENT ISTORE EMPTY>
-<!ATTLIST ISTORE var CDATA #REQUIRED>
-<!ELEMENT ISUB EMPTY>
-<!ELEMENT IUSHR EMPTY>
-<!ELEMENT IXOR EMPTY>
-<!ELEMENT JSR EMPTY>
-<!ATTLIST JSR label CDATA #REQUIRED>
-<!ELEMENT L2D EMPTY>
-<!ELEMENT L2F EMPTY>
-<!ELEMENT L2I EMPTY>
-<!ELEMENT LADD EMPTY>
-<!ELEMENT LALOAD EMPTY>
-<!ELEMENT LAND EMPTY>
-<!ELEMENT LASTORE EMPTY>
-<!ELEMENT LCMP EMPTY>
-<!ELEMENT LCONST_0 EMPTY>
-<!ELEMENT LCONST_1 EMPTY>
-<!ELEMENT LDC EMPTY>
-<!--
-  All characters out of interval 0x20 to 0x7f (inclusive) must
-  be encoded (\uXXXX) and character '\' must be replaced by "\\"
--->
-<!ATTLIST LDC cst CDATA #REQUIRED>
-<!ATTLIST LDC desc CDATA #REQUIRED>
-<!ELEMENT LDIV EMPTY>
-<!ELEMENT LLOAD EMPTY>
-<!ATTLIST LLOAD var CDATA #REQUIRED>
-<!ELEMENT LMUL EMPTY>
-<!ELEMENT LNEG EMPTY>
-<!ELEMENT LOR EMPTY>
-<!ELEMENT LREM EMPTY>
-<!ELEMENT LRETURN EMPTY>
-<!ELEMENT LSHL EMPTY>
-<!ELEMENT LSHR EMPTY>
-<!ELEMENT LSTORE EMPTY>
-<!ATTLIST LSTORE var CDATA #REQUIRED>
-<!ELEMENT LSUB EMPTY>
-<!ELEMENT LUSHR EMPTY>
-<!ELEMENT LXOR EMPTY>
-<!ELEMENT MONITORENTER EMPTY>
-<!ELEMENT MONITOREXIT EMPTY>
-<!ELEMENT MULTIANEWARRAY EMPTY>
-<!ATTLIST MULTIANEWARRAY desc CDATA #REQUIRED>
-<!ATTLIST MULTIANEWARRAY dims CDATA #REQUIRED>
-<!ELEMENT NEW EMPTY>
-<!ATTLIST NEW desc CDATA #REQUIRED>
-<!ELEMENT NEWARRAY EMPTY>
-<!ATTLIST NEWARRAY value CDATA #REQUIRED>
-<!ELEMENT NOP EMPTY>
-<!ELEMENT POP EMPTY>
-<!ELEMENT POP2 EMPTY>
-<!ELEMENT PUTFIELD EMPTY>
-<!ATTLIST PUTFIELD desc CDATA #REQUIRED>
-<!ATTLIST PUTFIELD name CDATA #REQUIRED>
-<!ATTLIST PUTFIELD owner CDATA #REQUIRED>
-<!ELEMENT PUTSTATIC EMPTY>
-<!ATTLIST PUTSTATIC desc CDATA #REQUIRED>
-<!ATTLIST PUTSTATIC name CDATA #REQUIRED>
-<!ATTLIST PUTSTATIC owner CDATA #REQUIRED>
-<!ELEMENT RET EMPTY>
-<!ATTLIST RET var CDATA #REQUIRED>
-<!ELEMENT RETURN EMPTY>
-<!ELEMENT SALOAD EMPTY>
-<!ELEMENT SASTORE EMPTY>
-<!ELEMENT SIPUSH EMPTY>
-<!ATTLIST SIPUSH value CDATA #REQUIRED>
-
-<!ELEMENT LOOKUPSWITCH ( label+ )>
-<!ATTLIST LOOKUPSWITCH dflt CDATA #REQUIRED>
-
-<!ELEMENT TABLESWITCH ( label+ )>
-<!ATTLIST TABLESWITCH dflt CDATA #REQUIRED>
-<!ATTLIST TABLESWITCH max CDATA #REQUIRED>
-<!ATTLIST TABLESWITCH min CDATA #REQUIRED>
-
-<!ELEMENT label EMPTY>
-<!ATTLIST label key CDATA #IMPLIED>
-<!ATTLIST label name CDATA #REQUIRED>
-
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/package.html eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/package.html
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/package.html	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/package.html	1970-01-01 01:00:00.000000000 +0100
@@ -1,96 +0,0 @@
-<html>
-<!--
- * ASM XML Adapter
- * Copyright (c) 2004, Eugene Kuleshov
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
--->
-<body>
-Provides <a href="http://sax.sourceforge.net/">SAX 2.0</a> adapters for ASM 
-visitors to convert classes to and from XML.
-These adapters can be chained with other SAX compliant content handlers and 
-filters, eg. XSLT or XQuery engines. This package is bundled as
-a separate <tt>asm-xml.jar</tt> library and requires <tt>asm.jar</tt>.
-<p>
-<tt>ASMContentHandler</tt> and <tt>SAXClassAdapter/SAXCodeAdapter</tt>
-are using <a href="asm-xml.dtd">asm-xml.dtd</a>. 
-Here is the example of bytecode to bytecode XSLT transformation.
-  
-<pre>
-    SAXTransformerFactory saxtf = ( SAXTransformerFactory) TransformerFactory.newInstance();
-    Templates templates = saxtf.newTemplates( xsltSource);
-
-    TransformerHandler handler = saxtf.newTransformerHandler( templates);
-    handler.setResult( new SAXResult( new ASMContentHandler( outputStream, computeMax)));
-
-    ClassReader cr = new ClassReader( bytecode);
-    cr.accept( new SAXClassAdapter( handler, cr.getVersion(), false), false);
-</pre>
-
-See JAXP and SAX documentation for more detils. 
-
-<p>
-There are few illustrations of the bytecode transformation with XSLT in
-examples directory. The following XSLT procesors has been tested.
-
-<blockquote>
-<table border="1" cellspacing="0" cellpadding="3">
-<tr>
-<th>Engine</td>
-<th>javax.xml.transform.TransformerFactory property</td>   
-</tr>
-
-<tr>
-<td>jd.xslt</td>
-<td>jd.xml.xslt.trax.TransformerFactoryImpl</td>   
-</tr>
-
-<tr>
-<td>Saxon</td>
-<td>net.sf.saxon.TransformerFactoryImpl</td>
-</tr>
-
-<tr>
-<td>Caucho</td>
-<td>com.caucho.xsl.Xsl</td>   
-</tr>
-
-<tr>
-<td>Xalan interpeter</td>   
-<td>org.apache.xalan.processor.TransformerFactory</td>
-</tr>
-
-<tr>
-<td>Xalan xsltc</td>
-<td>org.apache.xalan.xsltc.trax.TransformerFactoryImpl</td>
-</tr>
-</table>
-</blockquote>
-
-@since ASM 1.4.3
-
-</body>
-</html>
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/Processor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/Processor.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/Processor.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/Processor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,1073 +0,0 @@
-/***
- * ASM XML Adapter
- * Copyright (c) 2004, Eugene Kuleshov
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.xml;
-
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipInputStream;
-import java.util.zip.ZipOutputStream;
-
-import javax.xml.transform.Source;
-import javax.xml.transform.Templates;
-import javax.xml.transform.TransformerConfigurationException;
-import javax.xml.transform.TransformerException;
-import javax.xml.transform.TransformerFactory;
-import javax.xml.transform.sax.SAXResult;
-import javax.xml.transform.sax.SAXSource;
-import javax.xml.transform.sax.SAXTransformerFactory;
-import javax.xml.transform.sax.TransformerHandler;
-import javax.xml.transform.stream.StreamSource;
-
-import org.eclipse.persistence.internal.libraries.asm.ClassReader;
-
-import org.xml.sax.Attributes;
-import org.xml.sax.ContentHandler;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
-import org.xml.sax.ext.LexicalHandler;
-import org.xml.sax.helpers.AttributesImpl;
-import org.xml.sax.helpers.DefaultHandler;
-import org.xml.sax.helpers.XMLReaderFactory;
-
-/**
- * Processor is a command line tool that can be used for bytecode waving
- * directed by XSL transformation. <p> In order to use a concrete XSLT engine,
- * system property <tt>javax.xml.transform.TransformerFactory</tt> must be set
- * to one of the following values.
- * 
- * <blockquote> <table border="1" cellspacing="0" cellpadding="3"> <tr> <td>jd.xslt</td>
- * <td>jd.xml.xslt.trax.TransformerFactoryImpl</td> </tr>
- * 
- * <tr> <td>Saxon</td> <td>net.sf.saxon.TransformerFactoryImpl</td> </tr>
- * 
- * <tr> <td>Caucho</td> <td>com.caucho.xsl.Xsl</td> </tr>
- * 
- * <tr> <td>Xalan interpeter</td> <td>org.apache.xalan.processor.TransformerFactory</td>
- * </tr>
- * 
- * <tr> <td>Xalan xsltc</td> <td>org.apache.xalan.xsltc.trax.TransformerFactoryImpl</td>
- * </tr> </table> </blockquote>
- * 
- * @author Eugene Kuleshov
- */
-public class Processor {
-
-    public static final int BYTECODE = 1;
-
-    public static final int MULTI_XML = 2;
-
-    public static final int SINGLE_XML = 3;
-
-    private static final String SINGLE_XML_NAME = "classes.xml";
-
-    private final int inRepresentation;
-
-    private final int outRepresentation;
-
-    private final InputStream input;
-
-    private final OutputStream output;
-
-    private final Source xslt;
-
-    private final boolean computeMax;
-
-    private int n = 0;
-
-    public Processor(
-        final int inRepresenation,
-        final int outRepresentation,
-        final InputStream input,
-        final OutputStream output,
-        final Source xslt)
-    {
-        this.inRepresentation = inRepresenation;
-        this.outRepresentation = outRepresentation;
-        this.input = input;
-        this.output = output;
-        this.xslt = xslt;
-        this.computeMax = true;
-    }
-
-    public int process() throws TransformerException, IOException, SAXException
-    {
-        ZipInputStream zis = new ZipInputStream(input);
-        final ZipOutputStream zos = new ZipOutputStream(output);
-        final OutputStreamWriter osw = new OutputStreamWriter(zos);
-
-        Thread.currentThread()
-                .setContextClassLoader(getClass().getClassLoader());
-
-        TransformerFactory tf = TransformerFactory.newInstance();
-        if (!tf.getFeature(SAXSource.FEATURE)
-                || !tf.getFeature(SAXResult.FEATURE))
-        {
-            return 0;
-        }
-
-        SAXTransformerFactory saxtf = (SAXTransformerFactory) tf;
-        Templates templates = null;
-        if (xslt != null) {
-            templates = saxtf.newTemplates(xslt);
-        }
-
-        // configuring outHandlerFactory
-        // ///////////////////////////////////////////////////////
-
-        EntryElement entryElement = getEntryElement(zos);
-
-        ContentHandler outDocHandler = null;
-        switch (outRepresentation) {
-            case BYTECODE:
-                outDocHandler = new OutputSlicingHandler(new ASMContentHandlerFactory(zos,
-                        computeMax),
-                        entryElement,
-                        false);
-                break;
-
-            case MULTI_XML:
-                outDocHandler = new OutputSlicingHandler(new SAXWriterFactory(osw,
-                        true),
-                        entryElement,
-                        true);
-                break;
-
-            case SINGLE_XML:
-                ZipEntry outputEntry = new ZipEntry(SINGLE_XML_NAME);
-                zos.putNextEntry(outputEntry);
-                outDocHandler = new SAXWriter(osw, false);
-                break;
-
-        }
-
-        // configuring inputDocHandlerFactory
-        // /////////////////////////////////////////////////
-        ContentHandler inDocHandler;
-        if (templates == null) {
-            inDocHandler = outDocHandler;
-        } else {
-            inDocHandler = new InputSlicingHandler("class",
-                    outDocHandler,
-                    new TransformerHandlerFactory(saxtf,
-                            templates,
-                            outDocHandler));
-        }
-        ContentHandlerFactory inDocHandlerFactory = new SubdocumentHandlerFactory(inDocHandler);
-
-        if (inDocHandler != null && inRepresentation != SINGLE_XML) {
-            inDocHandler.startDocument();
-            inDocHandler.startElement("",
-                    "classes",
-                    "classes",
-                    new AttributesImpl());
-        }
-
-        int i = 0;
-        ZipEntry ze;
-        while ((ze = zis.getNextEntry()) != null) {
-            update(ze.getName(), n++);
-            if (isClassEntry(ze)) {
-                processEntry(zis, ze, inDocHandlerFactory);
-            } else {
-                OutputStream os = entryElement.openEntry(getName(ze));
-                copyEntry(zis, os);
-                entryElement.closeEntry();
-            }
-
-            i++;
-        }
-
-        if (inDocHandler != null && inRepresentation != SINGLE_XML) {
-            inDocHandler.endElement("", "classes", "classes");
-            inDocHandler.endDocument();
-        }
-
-        if (outRepresentation == SINGLE_XML) {
-            zos.closeEntry();
-        }
-        zos.flush();
-        zos.close();
-
-        return i;
-    }
-
-    private void copyEntry(final InputStream is, final OutputStream os)
-            throws IOException
-    {
-        if (outRepresentation == SINGLE_XML) {
-            return;
-        }
-
-        byte[] buff = new byte[2048];
-        int i;
-        while ((i = is.read(buff)) != -1) {
-            os.write(buff, 0, i);
-        }
-    }
-
-    private boolean isClassEntry(final ZipEntry ze) {
-        String name = ze.getName();
-        return inRepresentation == SINGLE_XML && name.equals(SINGLE_XML_NAME)
-                || name.endsWith(".class") || name.endsWith(".class.xml");
-    }
-
-    private void processEntry(
-        final ZipInputStream zis,
-        final ZipEntry ze,
-        final ContentHandlerFactory handlerFactory)
-    {
-        ContentHandler handler = handlerFactory.createContentHandler();
-        try {
-
-            // if (CODE2ASM.equals(command)) { // read bytecode and process it
-            // // with TraceClassVisitor
-            // ClassReader cr = new ClassReader(readEntry(zis, ze));
-            // cr.accept(new TraceClassVisitor(null, new PrintWriter(os)),
-            // false);
-            // }
-
-            boolean singleInputDocument = inRepresentation == SINGLE_XML;
-            if (inRepresentation == BYTECODE) { // read bytecode and process it
-                // with handler
-                ClassReader cr = new ClassReader(readEntry(zis, ze));
-                cr.accept(new SAXClassAdapter(handler, singleInputDocument), 0);
-
-            } else { // read XML and process it with handler
-                XMLReader reader = XMLReaderFactory.createXMLReader();
-                reader.setContentHandler(handler);
-                reader.parse(new InputSource(singleInputDocument
-                        ? (InputStream) new ProtectedInputStream(zis)
-                        : new ByteArrayInputStream(readEntry(zis, ze))));
-
-            }
-        } catch (Exception ex) {
-            update(ze.getName(), 0);
-            update(ex, 0);
-        }
-    }
-
-    private EntryElement getEntryElement(final ZipOutputStream zos) {
-        if (outRepresentation == SINGLE_XML) {
-            return new SingleDocElement(zos);
-        }
-        return new ZipEntryElement(zos);
-    }
-
-    // private ContentHandlerFactory getHandlerFactory(
-    // OutputStream os,
-    // SAXTransformerFactory saxtf,
-    // Templates templates)
-    // {
-    // ContentHandlerFactory factory = null;
-    // if (templates == null) {
-    // if (outputRepresentation == BYTECODE) { // factory used to write
-    // // bytecode
-    // factory = new ASMContentHandlerFactory(os, computeMax);
-    // } else { // factory used to write XML
-    // factory = new SAXWriterFactory(os, true);
-    // }
-    // } else {
-    // if (outputRepresentation == BYTECODE) { // factory used to transform
-    // // and then write bytecode
-    // factory = new ASMTransformerHandlerFactory(saxtf,
-    // templates,
-    // os,
-    // computeMax);
-    // } else { // factory used to transformand then write XML
-    // factory = new TransformerHandlerFactory(saxtf,
-    // templates,
-    // os,
-    // outputRepresentation == SINGLE_XML);
-    // }
-    // }
-    // return factory;
-    // }
-
-    private String getName(final ZipEntry ze) {
-        String name = ze.getName();
-        if (isClassEntry(ze)) {
-            if (inRepresentation != BYTECODE && outRepresentation == BYTECODE) {
-                name = name.substring(0, name.length() - 4); // .class.xml to
-                // .class
-            } else if (inRepresentation == BYTECODE
-                    && outRepresentation != BYTECODE)
-            {
-                name += ".xml"; // .class to .class.xml
-            }
-            // } else if( CODE2ASM.equals( command)) {
-            // name = name.substring( 0, name.length()-6).concat( ".asm");
-        }
-        return name;
-    }
-
-    private static byte[] readEntry(final InputStream zis, final ZipEntry ze)
-            throws IOException
-    {
-        long size = ze.getSize();
-        if (size > -1) {
-            byte[] buff = new byte[(int) size];
-            int k = 0;
-            int n;
-            while ((n = zis.read(buff, k, buff.length - k)) > 0) {
-                k += n;
-            }
-            return buff;
-        }
-
-        ByteArrayOutputStream bos = new ByteArrayOutputStream();
-        byte[] buff = new byte[4096];
-        int i;
-        while ((i = zis.read(buff)) != -1) {
-            bos.write(buff, 0, i);
-        }
-        return bos.toByteArray();
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
-     */
-    protected void update(final Object arg, final int n) {
-        if (arg instanceof Throwable) {
-            ((Throwable) arg).printStackTrace();
-        } else {
-            if (n % 100 == 0) {
-                System.err.println(n + " " + arg);
-            }
-        }
-    }
-
-    public static void main(final String[] args) throws Exception {
-        if (args.length < 2) {
-            showUsage();
-            return;
-        }
-
-        int inRepresentation = getRepresentation(args[0]);
-        int outRepresentation = getRepresentation(args[1]);
-
-        InputStream is = System.in;
-        OutputStream os = new BufferedOutputStream(System.out);
-
-        Source xslt = null;
-        // boolean computeMax = true;
-
-        for (int i = 2; i < args.length; i++) {
-            if ("-in".equals(args[i])) {
-                is = new FileInputStream(args[++i]);
-
-            } else if ("-out".equals(args[i])) {
-                os = new BufferedOutputStream(new FileOutputStream(args[++i]));
-
-            } else if ("-xslt".equals(args[i])) {
-                xslt = new StreamSource(new FileInputStream(args[++i]));
-
-                // } else if( "-computemax".equals( args[ i].toLowerCase())) {
-                // computeMax = true;
-
-            } else {
-                showUsage();
-                return;
-
-            }
-        }
-
-        if (inRepresentation == 0 || outRepresentation == 0) {
-            showUsage();
-            return;
-        }
-
-        Processor m = new Processor(inRepresentation,
-                outRepresentation,
-                is,
-                os,
-                xslt);
-
-        long l1 = System.currentTimeMillis();
-        int n = m.process();
-        long l2 = System.currentTimeMillis();
-        System.err.println(n);
-        System.err.println((l2 - l1) + "ms  " + 1000f * n / (l2 - l1)
-                + " resources/sec");
-    }
-
-    private static int getRepresentation(final String s) {
-        if ("code".equals(s)) {
-            return BYTECODE;
-        } else if ("xml".equals(s)) {
-            return MULTI_XML;
-        } else if ("singlexml".equals(s)) {
-            return SINGLE_XML;
-        }
-        return 0;
-    }
-
-    private static void showUsage() {
-        System.err.println("Usage: Main <in format> <out format> [-in <input jar>] [-out <output jar>] [-xslt <xslt fiel>]");
-        System.err.println("  when -in or -out is omitted sysin and sysout would be used");
-        System.err.println("  <in format> and <out format> - code | xml | singlexml");
-    }
-
-    /**
-     * IputStream wrapper class used to protect input streams from being closed
-     * by some stupid XML parsers.
-     */
-    private static final class ProtectedInputStream extends InputStream {
-        private final InputStream is;
-
-        ProtectedInputStream(final InputStream is) {
-            this.is = is;
-        }
-
-        public final void close() throws IOException {
-        }
-
-        public final int read() throws IOException {
-            return is.read();
-        }
-
-        public final int read(final byte[] b, final int off, final int len)
-                throws IOException
-        {
-            return is.read(b, off, len);
-        }
-
-        public final int available() throws IOException {
-            return is.available();
-        }
-    }
-
-    /**
-     * A {@link ContentHandlerFactory ContentHandlerFactory} is used to create
-     * {@link org.xml.sax.ContentHandler ContentHandler} instances for concrete
-     * context.
-     */
-    private static interface ContentHandlerFactory {
-
-        /**
-         * Creates an instance of the content handler.
-         * 
-         * @return content handler
-         */
-        ContentHandler createContentHandler();
-
-    }
-
-    /**
-     * SAXWriterFactory
-     */
-    private static final class SAXWriterFactory implements
-            ContentHandlerFactory
-    {
-        private final Writer w;
-
-        private final boolean optimizeEmptyElements;
-
-        SAXWriterFactory(
-            final Writer w,
-            final boolean optimizeEmptyElements)
-        {
-            this.w = w;
-            this.optimizeEmptyElements = optimizeEmptyElements;
-        }
-
-        public final ContentHandler createContentHandler() {
-            return new SAXWriter(w, optimizeEmptyElements);
-        }
-
-    }
-
-    /**
-     * ASMContentHandlerFactory
-     */
-    private static final class ASMContentHandlerFactory implements
-            ContentHandlerFactory
-    {
-        private OutputStream os;
-
-        private final boolean computeMax;
-
-        ASMContentHandlerFactory(
-            final OutputStream os,
-            final boolean computeMax)
-        {
-            this.os = os;
-            this.computeMax = computeMax;
-        }
-
-        public final ContentHandler createContentHandler() {
-            return new ASMContentHandler(os, computeMax);
-        }
-
-    }
-
-    /**
-     * TransformerHandlerFactory
-     */
-    private static final class TransformerHandlerFactory implements
-            ContentHandlerFactory
-    {
-        private SAXTransformerFactory saxtf;
-
-        private final Templates templates;
-
-        private ContentHandler outputHandler;
-
-        TransformerHandlerFactory(
-            final SAXTransformerFactory saxtf,
-            final Templates templates,
-            final ContentHandler outputHandler)
-        {
-            this.saxtf = saxtf;
-            this.templates = templates;
-            this.outputHandler = outputHandler;
-        }
-
-        public final ContentHandler createContentHandler() {
-            try {
-                TransformerHandler handler = saxtf.newTransformerHandler(templates);
-                handler.setResult(new SAXResult(outputHandler));
-                return handler;
-            } catch (TransformerConfigurationException ex) {
-                throw new RuntimeException(ex.toString());
-            }
-        }
-    }
-
-    /**
-     * SubdocumentHandlerFactory
-     */
-    private static final class SubdocumentHandlerFactory implements
-            ContentHandlerFactory
-    {
-        private final ContentHandler subdocumentHandler;
-
-        SubdocumentHandlerFactory(final ContentHandler subdocumentHandler)
-        {
-            this.subdocumentHandler = subdocumentHandler;
-        }
-
-        public final ContentHandler createContentHandler() {
-            return subdocumentHandler;
-        }
-
-    }
-
-    /**
-     * A {@link org.xml.sax.ContentHandler ContentHandler} and
-     * {@link org.xml.sax.ext.LexicalHandler LexicalHandler} that serializes XML
-     * from SAX 2.0 events into {@link java.io.Writer Writer}.
-     * 
-     * <i><blockquote> This implementation does not support namespaces, entity
-     * definitions (uncluding DTD), CDATA and text elements. </blockquote></i>
-     */
-    private static final class SAXWriter extends DefaultHandler implements
-            LexicalHandler
-    {
-        private static final char[] OFF = "                                                                                                        ".toCharArray();
-
-        private Writer w;
-
-        private final boolean optimizeEmptyElements;
-
-        private boolean openElement = false;
-
-        private int ident = 0;
-
-        /**
-         * Creates <code>SAXWriter</code>.
-         * 
-         * @param w writer
-         * @param optimizeEmptyElements if set to <code>true</code>, short
-         *        XML syntax will be used for empty elements
-         */
-        SAXWriter(final Writer w, final boolean optimizeEmptyElements) {
-            this.w = w;
-            this.optimizeEmptyElements = optimizeEmptyElements;
-        }
-
-        public final void startElement(
-            final String ns,
-            final String localName,
-            final String qName,
-            final Attributes atts) throws SAXException
-        {
-            try {
-                closeElement();
-
-                writeIdent();
-                w.write('<' + qName);
-                if (atts != null && atts.getLength() > 0) {
-                    writeAttributes(atts);
-                }
-
-                if (optimizeEmptyElements) {
-                    openElement = true;
-                } else {
-                    w.write(">\n");
-                }
-                ident += 2;
-
-            } catch (IOException ex) {
-                throw new SAXException(ex);
-
-            }
-        }
-
-        public final void endElement(
-            final String ns,
-            final String localName,
-            final String qName) throws SAXException
-        {
-            ident -= 2;
-            try {
-                if (openElement) {
-                    w.write("/>\n");
-                    openElement = false;
-                } else {
-                    writeIdent();
-                    w.write("</" + qName + ">\n");
-                }
-
-            } catch (IOException ex) {
-                throw new SAXException(ex);
-
-            }
-        }
-
-        public final void endDocument() throws SAXException {
-            try {
-                w.flush();
-
-            } catch (IOException ex) {
-                throw new SAXException(ex);
-
-            }
-        }
-
-        public final void comment(final char[] ch, final int off, final int len)
-                throws SAXException
-        {
-            try {
-                closeElement();
-
-                writeIdent();
-                w.write("<!-- ");
-                w.write(ch, off, len);
-                w.write(" -->\n");
-
-            } catch (IOException ex) {
-                throw new SAXException(ex);
-
-            }
-        }
-
-        public final void startDTD(
-            final String arg0,
-            final String arg1,
-            final String arg2) throws SAXException
-        {
-        }
-
-        public final void endDTD() throws SAXException {
-        }
-
-        public final void startEntity(final String arg0) throws SAXException {
-        }
-
-        public final void endEntity(final String arg0) throws SAXException {
-        }
-
-        public final void startCDATA() throws SAXException {
-        }
-
-        public final void endCDATA() throws SAXException {
-        }
-
-        private final void writeAttributes(final Attributes atts)
-                throws IOException
-        {
-            StringBuffer sb = new StringBuffer();
-            int len = atts.getLength();
-            for (int i = 0; i < len; i++) {
-                sb.append(' ')
-                        .append(atts.getLocalName(i))
-                        .append("=\"")
-                        .append(esc(atts.getValue(i)))
-                        .append('\"');
-            }
-            w.write(sb.toString());
-        }
-
-        /**
-         * Encode string with escaping.
-         * 
-         * @param str string to encode.
-         * @return encoded string
-         */
-        private static final String esc(final String str) {
-            StringBuffer sb = new StringBuffer(str.length());
-            for (int i = 0; i < str.length(); i++) {
-                char ch = str.charAt(i);
-                switch (ch) {
-                    case '&':
-                        sb.append("&amp;");
-                        break;
-
-                    case '<':
-                        sb.append("&lt;");
-                        break;
-
-                    case '>':
-                        sb.append("&gt;");
-                        break;
-
-                    case '\"':
-                        sb.append("&quot;");
-                        break;
-
-                    default:
-                        if (ch > 0x7f) {
-                            sb.append("&#")
-                                    .append(Integer.toString(ch))
-                                    .append(';');
-                        } else {
-                            sb.append(ch);
-                        }
-
-                }
-            }
-            return sb.toString();
-        }
-
-        private final void writeIdent() throws IOException {
-            int n = ident;
-            while (n > 0) {
-                if (n > OFF.length) {
-                    w.write(OFF);
-                    n -= OFF.length;
-                } else {
-                    w.write(OFF, 0, n);
-                    n = 0;
-                }
-            }
-        }
-
-        private final void closeElement() throws IOException {
-            if (openElement) {
-                w.write(">\n");
-            }
-            openElement = false;
-        }
-
-    }
-
-    /**
-     * A {@link org.xml.sax.ContentHandler ContentHandler} that splits XML
-     * documents into smaller chunks. Each chunk is processed by the nested
-     * {@link org.xml.sax.ContentHandler ContentHandler} obtained from
-     * {@link java.net.ContentHandlerFactory ContentHandlerFactory}. This is
-     * useful for running XSLT engine against large XML document that will
-     * hardly fit into the memory all together. <p> TODO use complete path for
-     * subdocumentRoot
-     */
-    private static final class InputSlicingHandler extends DefaultHandler {
-        private String subdocumentRoot;
-
-        private final ContentHandler rootHandler;
-
-        private ContentHandlerFactory subdocumentHandlerFactory;
-
-        private boolean subdocument = false;
-
-        private ContentHandler subdocumentHandler;
-
-        /**
-         * Constructs a new {@link InputSlicingHandler SubdocumentHandler}
-         * object.
-         * 
-         * @param subdocumentRoot name/path to the root element of the
-         *        subdocument
-         * @param rootHandler content handler for the entire document
-         *        (subdocument envelope).
-         * @param subdocumentHandlerFactory a
-         *        {@link ContentHandlerFactory ContentHandlerFactory} used to
-         *        create {@link ContentHandler ContentHandler} instances for
-         *        subdocuments.
-         */
-        InputSlicingHandler(
-            final String subdocumentRoot,
-            final ContentHandler rootHandler,
-            final ContentHandlerFactory subdocumentHandlerFactory)
-        {
-            this.subdocumentRoot = subdocumentRoot;
-            this.rootHandler = rootHandler;
-            this.subdocumentHandlerFactory = subdocumentHandlerFactory;
-        }
-
-        public final void startElement(
-            final String namespaceURI,
-            final String localName,
-            final String qName,
-            final Attributes list) throws SAXException
-        {
-            if (subdocument) {
-                subdocumentHandler.startElement(namespaceURI,
-                        localName,
-                        qName,
-                        list);
-            } else if (localName.equals(subdocumentRoot)) {
-                subdocumentHandler = subdocumentHandlerFactory.createContentHandler();
-                subdocumentHandler.startDocument();
-                subdocumentHandler.startElement(namespaceURI,
-                        localName,
-                        qName,
-                        list);
-                subdocument = true;
-            } else if (rootHandler != null) {
-                rootHandler.startElement(namespaceURI, localName, qName, list);
-            }
-        }
-
-        public final void endElement(
-            final String namespaceURI,
-            final String localName,
-            final String qName) throws SAXException
-        {
-            if (subdocument) {
-                subdocumentHandler.endElement(namespaceURI, localName, qName);
-                if (localName.equals(subdocumentRoot)) {
-                    subdocumentHandler.endDocument();
-                    subdocument = false;
-                }
-            } else if (rootHandler != null) {
-                rootHandler.endElement(namespaceURI, localName, qName);
-            }
-        }
-
-        public final void startDocument() throws SAXException {
-            if (rootHandler != null) {
-                rootHandler.startDocument();
-            }
-        }
-
-        public final void endDocument() throws SAXException {
-            if (rootHandler != null) {
-                rootHandler.endDocument();
-
-            }
-        }
-
-        public final void characters(
-            final char[] buff,
-            final int offset,
-            final int size) throws SAXException
-        {
-            if (subdocument) {
-                subdocumentHandler.characters(buff, offset, size);
-            } else if (rootHandler != null) {
-                rootHandler.characters(buff, offset, size);
-            }
-        }
-
-    }
-
-    /**
-     * A {@link org.xml.sax.ContentHandler ContentHandler} that splits XML
-     * documents into smaller chunks. Each chunk is processed by the nested
-     * {@link org.xml.sax.ContentHandler ContentHandler} obtained from
-     * {@link java.net.ContentHandlerFactory ContentHandlerFactory}. This is
-     * useful for running XSLT engine against large XML document that will
-     * hardly fit into the memory all together.
-     * 
-     * <p> TODO use complete path for subdocumentRoot
-     */
-    private static final class OutputSlicingHandler extends DefaultHandler {
-        private final String subdocumentRoot;
-
-        private ContentHandlerFactory subdocumentHandlerFactory;
-
-        private final EntryElement entryElement;
-
-        private boolean isXml;
-
-        private boolean subdocument = false;
-
-        private ContentHandler subdocumentHandler;
-
-        /**
-         * Constructs a new {@link OutputSlicingHandler SubdocumentHandler}
-         * object.
-         * 
-         * @param subdocumentHandlerFactory a
-         *        {@link ContentHandlerFactory ContentHandlerFactory} used to
-         *        create {@link ContentHandler ContentHandler} instances for
-         *        subdocuments.
-         * @param entryElement TODO.
-         * @param isXml TODO.
-         */
-        OutputSlicingHandler(
-            final ContentHandlerFactory subdocumentHandlerFactory,
-            final EntryElement entryElement,
-            final boolean isXml)
-        {
-            this.subdocumentRoot = "class";
-            this.subdocumentHandlerFactory = subdocumentHandlerFactory;
-            this.entryElement = entryElement;
-            this.isXml = isXml;
-        }
-
-        public final void startElement(
-            final String namespaceURI,
-            final String localName,
-            final String qName,
-            final Attributes list) throws SAXException
-        {
-            if (subdocument) {
-                subdocumentHandler.startElement(namespaceURI,
-                        localName,
-                        qName,
-                        list);
-            } else if (localName.equals(subdocumentRoot)) {
-                String name = list.getValue("name");
-                if (name == null || name.length() == 0) {
-                    throw new SAXException("Class element without name attribute.");
-                }
-                try {
-                    entryElement.openEntry(isXml
-                            ? name + ".class.xml"
-                            : name + ".class");
-                } catch (IOException ex) {
-                    throw new SAXException(ex.toString(), ex);
-                }
-                subdocumentHandler = subdocumentHandlerFactory.createContentHandler();
-                subdocumentHandler.startDocument();
-                subdocumentHandler.startElement(namespaceURI,
-                        localName,
-                        qName,
-                        list);
-                subdocument = true;
-            }
-        }
-
-        public final void endElement(
-            final String namespaceURI,
-            final String localName,
-            final String qName) throws SAXException
-        {
-            if (subdocument) {
-                subdocumentHandler.endElement(namespaceURI, localName, qName);
-                if (localName.equals(subdocumentRoot)) {
-                    subdocumentHandler.endDocument();
-                    subdocument = false;
-                    try {
-                        entryElement.closeEntry();
-                    } catch (IOException ex) {
-                        throw new SAXException(ex.toString(), ex);
-                    }
-                }
-            }
-        }
-
-        public final void startDocument() throws SAXException {
-        }
-
-        public final void endDocument() throws SAXException {
-        }
-
-        public final void characters(
-            final char[] buff,
-            final int offset,
-            final int size) throws SAXException
-        {
-            if (subdocument) {
-                subdocumentHandler.characters(buff, offset, size);
-            }
-        }
-
-    }
-
-    private static interface EntryElement {
-
-        OutputStream openEntry(String name) throws IOException;
-
-        void closeEntry() throws IOException;
-
-    }
-
-    private static final class SingleDocElement implements EntryElement {
-        private final OutputStream os;
-
-        SingleDocElement(final OutputStream os) {
-            this.os = os;
-        }
-
-        public OutputStream openEntry(final String name) throws IOException {
-            return os;
-        }
-
-        public void closeEntry() throws IOException {
-            os.flush();
-        }
-
-    }
-
-    private static final class ZipEntryElement implements EntryElement {
-        private ZipOutputStream zos;
-
-        ZipEntryElement(final ZipOutputStream zos) {
-            this.zos = zos;
-        }
-
-        public OutputStream openEntry(final String name) throws IOException {
-            ZipEntry entry = new ZipEntry(name);
-            zos.putNextEntry(entry);
-            return zos;
-        }
-
-        public void closeEntry() throws IOException {
-            zos.flush();
-            zos.closeEntry();
-        }
-
-    }
-
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/SAXAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/SAXAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/SAXAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/SAXAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,94 +0,0 @@
-/***
- * ASM XML Adapter
- * Copyright (c) 2004, Eugene Kuleshov
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.xml;
-
-import org.eclipse.persistence.internal.libraries.asm.Attribute;
-import org.xml.sax.Attributes;
-import org.xml.sax.ContentHandler;
-import org.xml.sax.SAXException;
-
-/**
- * SAXAdapter
- * 
- * @author Eugene Kuleshov
- */
-public abstract class SAXAdapter {
-
-    private final ContentHandler h;
-
-    protected SAXAdapter(final ContentHandler h) {
-        this.h = h;
-    }
-
-    protected ContentHandler getContentHandler() {
-        return h;
-    }
-
-    protected void addDocumentStart() {
-        try {
-            h.startDocument();
-        } catch (SAXException ex) {
-            throw new RuntimeException(ex.getException());
-        }
-    }
-
-    protected void addDocumentEnd() {
-        try {
-            h.endDocument();
-        } catch (SAXException ex) {
-            throw new RuntimeException(ex.toString());
-        }
-    }
-
-    protected final void addStart(final String name, final Attributes attrs) {
-        try {
-            h.startElement("", name, name, attrs);
-        } catch (SAXException ex) {
-            throw new RuntimeException(ex.toString());
-        }
-    }
-
-    protected final void addEnd(final String name) {
-        try {
-            h.endElement("", name, name);
-        } catch (SAXException ex) {
-            throw new RuntimeException(ex.toString());
-        }
-    }
-
-    protected final void addElement(final String name, final Attributes attrs) {
-        addStart(name, attrs);
-        addEnd(name);
-    }
-
-    public void visitAttribute(final Attribute attr) {
-        // nothing to do
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/SAXAnnotationAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/SAXAnnotationAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/SAXAnnotationAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/SAXAnnotationAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,218 +0,0 @@
-/***
- * ASM XML Adapter
- * Copyright (c) 2004, Eugene Kuleshov
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.xml;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-import org.xml.sax.ContentHandler;
-import org.xml.sax.helpers.AttributesImpl;
-
-/**
- * SAXAnnotationAdapter
- * 
- * @author Eugene Kuleshov
- */
-public class SAXAnnotationAdapter extends SAXAdapter implements
-        AnnotationVisitor
-{
-    private final String elementName;
-
-    public SAXAnnotationAdapter(
-        final ContentHandler h,
-        final String elementName,
-        final int visible,
-        final String name,
-        final String desc)
-    {
-        this(h, elementName, visible, desc, name, -1);
-    }
-
-    public SAXAnnotationAdapter(
-        final ContentHandler h,
-        final String elementName,
-        final int visible,
-        final int parameter,
-        final String desc)
-    {
-        this(h, elementName, visible, desc, null, parameter);
-    }
-
-    private SAXAnnotationAdapter(
-        final ContentHandler h,
-        final String elementName,
-        final int visible,
-        final String desc,
-        final String name,
-        final int parameter)
-    {
-        super(h);
-        this.elementName = elementName;
-
-        AttributesImpl att = new AttributesImpl();
-        if (name != null) {
-            att.addAttribute("", "name", "name", "", name);
-        }
-        if (visible != 0) {
-            att.addAttribute("", "visible", "visible", "", visible > 0
-                    ? "true"
-                    : "false");
-        }
-        if (parameter != -1) {
-            att.addAttribute("",
-                    "parameter",
-                    "parameter",
-                    "",
-                    Integer.toString(parameter));
-        }
-        if (desc != null) {
-            att.addAttribute("", "desc", "desc", "", desc);
-        }
-
-        addStart(elementName, att);
-    }
-
-    public void visit(final String name, final Object value) {
-        Class c = value.getClass();
-        if (c.isArray()) {
-            AnnotationVisitor av = visitArray(name);
-            if (value instanceof byte[]) {
-                byte[] b = (byte[]) value;
-                for (int i = 0; i < b.length; i++) {
-                    av.visit(null, new Byte(b[i]));
-                }
-
-            } else if (value instanceof char[]) {
-                char[] b = (char[]) value;
-                for (int i = 0; i < b.length; i++) {
-                    av.visit(null, new Character(b[i]));
-                }
-
-            } else if (value instanceof short[]) {
-                short[] b = (short[]) value;
-                for (int i = 0; i < b.length; i++) {
-                    av.visit(null, new Short(b[i]));
-                }
-
-            } else if (value instanceof boolean[]) {
-                boolean[] b = (boolean[]) value;
-                for (int i = 0; i < b.length; i++) {
-                    av.visit(null, Boolean.valueOf(b[i]));
-                }
-
-            } else if (value instanceof int[]) {
-                int[] b = (int[]) value;
-                for (int i = 0; i < b.length; i++) {
-                    av.visit(null, new Integer(b[i]));
-                }
-
-            } else if (value instanceof long[]) {
-                long[] b = (long[]) value;
-                for (int i = 0; i < b.length; i++) {
-                    av.visit(null, new Long(b[i]));
-                }
-
-            } else if (value instanceof float[]) {
-                float[] b = (float[]) value;
-                for (int i = 0; i < b.length; i++) {
-                    av.visit(null, new Float(b[i]));
-                }
-
-            } else if (value instanceof double[]) {
-                double[] b = (double[]) value;
-                for (int i = 0; i < b.length; i++) {
-                    av.visit(null, new Double(b[i]));
-                }
-
-            }
-            av.visitEnd();
-        } else {
-            addValueElement("annotationValue",
-                    name,
-                    Type.getDescriptor(c),
-                    value.toString());
-        }
-    }
-
-    public void visitEnum(
-        final String name,
-        final String desc,
-        final String value)
-    {
-        addValueElement("annotationValueEnum", name, desc, value);
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String name,
-        final String desc)
-    {
-        return new SAXAnnotationAdapter(getContentHandler(),
-                "annotationValueAnnotation",
-                0,
-                name,
-                desc);
-    }
-
-    public AnnotationVisitor visitArray(final String name) {
-        return new SAXAnnotationAdapter(getContentHandler(),
-                "annotationValueArray",
-                0,
-                name,
-                null);
-    }
-
-    public void visitEnd() {
-        addEnd(elementName);
-    }
-
-    private void addValueElement(
-        final String element,
-        final String name,
-        final String desc,
-        final String value)
-    {
-        AttributesImpl att = new AttributesImpl();
-        if (name != null) {
-            att.addAttribute("", "name", "name", "", name);
-        }
-        if (desc != null) {
-            att.addAttribute("", "desc", "desc", "", desc);
-        }
-        if (value != null) {
-            att.addAttribute("",
-                    "value",
-                    "value",
-                    "",
-                    SAXClassAdapter.encode(value));
-        }
-
-        addElement(element, att);
-    }
-
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/SAXClassAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/SAXClassAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/SAXClassAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/SAXClassAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,349 +0,0 @@
-/***
- * ASM XML Adapter
- * Copyright (c) 2004, Eugene Kuleshov
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.xml;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.ClassVisitor;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.xml.sax.ContentHandler;
-import org.xml.sax.helpers.AttributesImpl;
-
-/**
- * A {@link org.eclipse.persistence.internal.libraries.asm.ClassVisitor ClassVisitor} that generates SAX 2.0
- * events from the visited class. It can feed any kind of
- * {@link org.xml.sax.ContentHandler ContentHandler}, e.g. XML serializer, XSLT
- * or XQuery engines.
- * 
- * @see org.eclipse.persistence.internal.libraries.asm.xml.Processor
- * @see org.eclipse.persistence.internal.libraries.asm.xml.ASMContentHandler
- * 
- * @author Eugene Kuleshov
- */
-public final class SAXClassAdapter extends SAXAdapter implements ClassVisitor {
-    private final boolean singleDocument;
-
-    /**
-     * Pseudo access flag used to distinguish class access flags.
-     */
-    private static final int ACCESS_CLASS = 262144;
-
-    /**
-     * Pseudo access flag used to distinguish field access flags.
-     */
-    private static final int ACCESS_FIELD = 524288;
-
-    /**
-     * Pseudo access flag used to distinguish inner class flags.
-     */
-    private static final int ACCESS_INNER = 1048576;
-
-    /**
-     * Constructs a new {@link SAXClassAdapter SAXClassAdapter} object.
-     * 
-     * @param h content handler that will be used to send SAX 2.0 events.
-     * @param singleDocument if <tt>true</tt> adapter will not produce
-     *        {@link ContentHandler#startDocument() startDocument()} and
-     *        {@link ContentHandler#endDocument() endDocument()} events.
-     */
-    public SAXClassAdapter(final ContentHandler h, boolean singleDocument) {
-        super(h);
-        this.singleDocument = singleDocument;
-        if (!singleDocument) {
-            addDocumentStart();
-        }
-    }
-
-    public void visitSource(final String source, final String debug) {
-        AttributesImpl att = new AttributesImpl();
-        if (source != null) {
-            att.addAttribute("", "file", "file", "", encode(source));
-        }
-        if (debug != null) {
-            att.addAttribute("", "debug", "debug", "", encode(debug));
-        }
-
-        addElement("source", att);
-    }
-
-    public void visitOuterClass(
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        AttributesImpl att = new AttributesImpl();
-        att.addAttribute("", "owner", "owner", "", owner);
-        if (name != null) {
-            att.addAttribute("", "name", "name", "", name);
-        }
-        if (desc != null) {
-            att.addAttribute("", "desc", "desc", "", desc);
-        }
-
-        addElement("outerclass", att);
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        return new SAXAnnotationAdapter(getContentHandler(),
-                "annotation",
-                visible ? 1 : -1,
-                null,
-                desc);
-    }
-
-    public void visit(
-        final int version,
-        final int access,
-        final String name,
-        final String signature,
-        final String superName,
-        final String[] interfaces)
-    {
-        StringBuffer sb = new StringBuffer();
-        appendAccess(access | ACCESS_CLASS, sb);
-
-        AttributesImpl att = new AttributesImpl();
-        att.addAttribute("", "access", "access", "", sb.toString());
-        if (name != null) {
-            att.addAttribute("", "name", "name", "", name);
-        }
-        if (signature != null) {
-            att.addAttribute("",
-                    "signature",
-                    "signature",
-                    "",
-                    encode(signature));
-        }
-        if (superName != null) {
-            att.addAttribute("", "parent", "parent", "", superName);
-        }
-        att.addAttribute("",
-                "major",
-                "major",
-                "",
-                Integer.toString(version & 0xFFFF));
-        att.addAttribute("",
-                "minor",
-                "minor",
-                "",
-                Integer.toString(version >>> 16));
-        addStart("class", att);
-
-        addStart("interfaces", new AttributesImpl());
-        if (interfaces != null && interfaces.length > 0) {
-            for (int i = 0; i < interfaces.length; i++) {
-                AttributesImpl att2 = new AttributesImpl();
-                att2.addAttribute("", "name", "name", "", interfaces[i]);
-                addElement("interface", att2);
-            }
-        }
-        addEnd("interfaces");
-    }
-
-    public FieldVisitor visitField(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final Object value)
-    {
-        StringBuffer sb = new StringBuffer();
-        appendAccess(access | ACCESS_FIELD, sb);
-
-        AttributesImpl att = new AttributesImpl();
-        att.addAttribute("", "access", "access", "", sb.toString());
-        att.addAttribute("", "name", "name", "", name);
-        att.addAttribute("", "desc", "desc", "", desc);
-        if (signature != null) {
-            att.addAttribute("",
-                    "signature",
-                    "signature",
-                    "",
-                    encode(signature));
-        }
-        if (value != null) {
-            att.addAttribute("", "value", "value", "", encode(value.toString()));
-        }
-
-        return new SAXFieldAdapter(getContentHandler(), att);
-    }
-
-    public MethodVisitor visitMethod(
-        final int access,
-        final String name,
-        final String desc,
-        final String signature,
-        final String[] exceptions)
-    {
-        StringBuffer sb = new StringBuffer();
-        appendAccess(access, sb);
-
-        AttributesImpl att = new AttributesImpl();
-        att.addAttribute("", "access", "access", "", sb.toString());
-        att.addAttribute("", "name", "name", "", name);
-        att.addAttribute("", "desc", "desc", "", desc);
-        if (signature != null) {
-            att.addAttribute("", "signature", "signature", "", signature);
-        }
-        addStart("method", att);
-
-        addStart("exceptions", new AttributesImpl());
-        if (exceptions != null && exceptions.length > 0) {
-            for (int i = 0; i < exceptions.length; i++) {
-                AttributesImpl att2 = new AttributesImpl();
-                att2.addAttribute("", "name", "name", "", exceptions[i]);
-                addElement("exception", att2);
-            }
-        }
-        addEnd("exceptions");
-
-        return new SAXCodeAdapter(getContentHandler(), access);
-    }
-
-    public final void visitInnerClass(
-        final String name,
-        final String outerName,
-        final String innerName,
-        final int access)
-    {
-        StringBuffer sb = new StringBuffer();
-        appendAccess(access | ACCESS_INNER, sb);
-
-        AttributesImpl att = new AttributesImpl();
-        att.addAttribute("", "access", "access", "", sb.toString());
-        if (name != null) {
-            att.addAttribute("", "name", "name", "", name);
-        }
-        if (outerName != null) {
-            att.addAttribute("", "outerName", "outerName", "", outerName);
-        }
-        if (innerName != null) {
-            att.addAttribute("", "innerName", "innerName", "", innerName);
-        }
-        addElement("innerclass", att);
-    }
-
-    public final void visitEnd() {
-        addEnd("class");
-        if (!singleDocument) {
-            addDocumentEnd();
-        }
-    }
-
-    static final String encode(final String s) {
-        StringBuffer sb = new StringBuffer();
-        for (int i = 0; i < s.length(); i++) {
-            char c = s.charAt(i);
-            if (c == '\\') {
-                sb.append("\\\\");
-            } else if (c < 0x20 || c > 0x7f) {
-                sb.append("\\u");
-                if (c < 0x10) {
-                    sb.append("000");
-                } else if (c < 0x100) {
-                    sb.append("00");
-                } else if (c < 0x1000) {
-                    sb.append('0');
-                }
-                sb.append(Integer.toString(c, 16));
-            } else {
-                sb.append(c);
-            }
-        }
-        return sb.toString();
-    }
-
-    static void appendAccess(final int access, final StringBuffer sb) {
-        if ((access & Opcodes.ACC_PUBLIC) != 0) {
-            sb.append("public ");
-        }
-        if ((access & Opcodes.ACC_PRIVATE) != 0) {
-            sb.append("private ");
-        }
-        if ((access & Opcodes.ACC_PROTECTED) != 0) {
-            sb.append("protected ");
-        }
-        if ((access & Opcodes.ACC_FINAL) != 0) {
-            sb.append("final ");
-        }
-        if ((access & Opcodes.ACC_STATIC) != 0) {
-            sb.append("static ");
-        }
-        if ((access & Opcodes.ACC_SUPER) != 0) {
-            if ((access & ACCESS_CLASS) == 0) {
-                sb.append("synchronized ");
-            } else {
-                sb.append("super ");
-            }
-        }
-        if ((access & Opcodes.ACC_VOLATILE) != 0) {
-            if ((access & ACCESS_FIELD) == 0) {
-                sb.append("bridge ");
-            } else {
-                sb.append("volatile ");
-            }
-        }
-        if ((access & Opcodes.ACC_TRANSIENT) != 0) {
-            if ((access & ACCESS_FIELD) == 0) {
-                sb.append("varargs ");
-            } else {
-                sb.append("transient ");
-            }
-        }
-        if ((access & Opcodes.ACC_NATIVE) != 0) {
-            sb.append("native ");
-        }
-        if ((access & Opcodes.ACC_STRICT) != 0) {
-            sb.append("strict ");
-        }
-        if ((access & Opcodes.ACC_INTERFACE) != 0) {
-            sb.append("interface ");
-        }
-        if ((access & Opcodes.ACC_ABSTRACT) != 0) {
-            sb.append("abstract ");
-        }
-        if ((access & Opcodes.ACC_SYNTHETIC) != 0) {
-            sb.append("synthetic ");
-        }
-        if ((access & Opcodes.ACC_ANNOTATION) != 0) {
-            sb.append("annotation ");
-        }
-        if ((access & Opcodes.ACC_ENUM) != 0) {
-            sb.append("enum ");
-        }
-        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
-            sb.append("deprecated ");
-        }
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/SAXCodeAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/SAXCodeAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/SAXCodeAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/SAXCodeAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,397 +0,0 @@
-/***
- * ASM XML Adapter
- * Copyright (c) 2004, Eugene Kuleshov
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.xml;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
-import org.eclipse.persistence.internal.libraries.asm.util.AbstractVisitor;
-import org.xml.sax.ContentHandler;
-import org.xml.sax.helpers.AttributesImpl;
-
-/**
- * A {@link MethodVisitor} that generates SAX 2.0 events from the visited
- * method.
- * 
- * @see org.eclipse.persistence.internal.libraries.asm.xml.SAXClassAdapter
- * @see org.eclipse.persistence.internal.libraries.asm.xml.Processor
- * 
- * @author Eugene Kuleshov
- */
-public final class SAXCodeAdapter extends SAXAdapter implements MethodVisitor {
-
-    static final String[] TYPES = {
-        "top",
-        "int",
-        "float",
-        "double",
-        "long",
-        "null",
-        "uninitializedThis" };
-
-    private final Map labelNames;
-
-    /**
-     * Constructs a new {@link SAXCodeAdapter SAXCodeAdapter} object.
-     * 
-     * @param h content handler that will be used to send SAX 2.0 events.
-     */
-    public SAXCodeAdapter(final ContentHandler h, final int access) {
-        super(h);
-        labelNames = new HashMap();
-
-        if ((access & (Opcodes.ACC_ABSTRACT | Opcodes.ACC_INTERFACE | Opcodes.ACC_NATIVE)) == 0)
-        {
-            addStart("code", new AttributesImpl());
-        }
-    }
-
-    public final void visitCode() {
-    }
-
-    public void visitFrame(
-        final int type,
-        final int nLocal,
-        final Object[] local,
-        final int nStack,
-        final Object[] stack)
-    {
-        AttributesImpl attrs = new AttributesImpl();
-        switch (type) {
-            case Opcodes.F_NEW:
-            case Opcodes.F_FULL:
-                if (type == Opcodes.F_NEW) {
-                    attrs.addAttribute("", "type", "type", "", "NEW");
-                } else {
-                    attrs.addAttribute("", "type", "type", "", "FULL");
-                }
-                addStart("frame", attrs);
-                appendFrameTypes(true, nLocal, local);
-                appendFrameTypes(false, nStack, stack);
-                break;
-            case Opcodes.F_APPEND:
-                attrs.addAttribute("", "type", "type", "", "APPEND");
-                addStart("frame", attrs);
-                appendFrameTypes(true, nLocal, local);
-                break;
-            case Opcodes.F_CHOP:
-                attrs.addAttribute("", "type", "type", "", "CHOP");
-                attrs.addAttribute("",
-                        "count",
-                        "count",
-                        "",
-                        Integer.toString(nLocal));
-                addStart("frame", attrs);
-                break;
-            case Opcodes.F_SAME:
-                attrs.addAttribute("", "type", "type", "", "SAME");
-                addStart("frame", attrs);
-                break;
-            case Opcodes.F_SAME1:
-                attrs.addAttribute("", "type", "type", "", "SAME1");
-                addStart("frame", attrs);
-                appendFrameTypes(false, 1, stack);
-                break;
-        }
-        addEnd("frame");
-    }
-
-    private void appendFrameTypes(
-        final boolean local,
-        final int n,
-        final Object[] types)
-    {
-        for (int i = 0; i < n; ++i) {
-            Object type = types[i];
-            AttributesImpl attrs = new AttributesImpl();
-            if (type instanceof String) {
-                attrs.addAttribute("", "type", "type", "", (String) type);
-            } else if (type instanceof Integer) {
-                attrs.addAttribute("",
-                        "type",
-                        "type",
-                        "",
-                        TYPES[((Integer) type).intValue()]);
-            } else {
-                attrs.addAttribute("", "type", "type", "", "uninitialized");
-                attrs.addAttribute("",
-                        "label",
-                        "label",
-                        "",
-                        getLabel((Label) type));
-            }
-            addElement(local ? "local" : "stack", attrs);
-        }
-    }
-
-    public final void visitInsn(final int opcode) {
-        addElement(AbstractVisitor.OPCODES[opcode], new AttributesImpl());
-    }
-
-    public final void visitIntInsn(final int opcode, final int operand) {
-        AttributesImpl attrs = new AttributesImpl();
-        attrs.addAttribute("", "value", "value", "", Integer.toString(operand));
-        addElement(AbstractVisitor.OPCODES[opcode], attrs);
-    }
-
-    public final void visitVarInsn(final int opcode, final int var) {
-        AttributesImpl attrs = new AttributesImpl();
-        attrs.addAttribute("", "var", "var", "", Integer.toString(var));
-        addElement(AbstractVisitor.OPCODES[opcode], attrs);
-    }
-
-    public final void visitTypeInsn(final int opcode, final String type) {
-        AttributesImpl attrs = new AttributesImpl();
-        attrs.addAttribute("", "desc", "desc", "", type);
-        addElement(AbstractVisitor.OPCODES[opcode], attrs);
-    }
-
-    public final void visitFieldInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        AttributesImpl attrs = new AttributesImpl();
-        attrs.addAttribute("", "owner", "owner", "", owner);
-        attrs.addAttribute("", "name", "name", "", name);
-        attrs.addAttribute("", "desc", "desc", "", desc);
-        addElement(AbstractVisitor.OPCODES[opcode], attrs);
-    }
-
-    public final void visitMethodInsn(
-        final int opcode,
-        final String owner,
-        final String name,
-        final String desc)
-    {
-        AttributesImpl attrs = new AttributesImpl();
-        if (opcode != Opcodes.INVOKEDYNAMIC) {
-            attrs.addAttribute("", "owner", "owner", "", owner);
-        }
-        attrs.addAttribute("", "name", "name", "", name);
-        attrs.addAttribute("", "desc", "desc", "", desc);
-        addElement(AbstractVisitor.OPCODES[opcode], attrs);
-    }
-
-    public final void visitJumpInsn(final int opcode, final Label label) {
-        AttributesImpl attrs = new AttributesImpl();
-        attrs.addAttribute("", "label", "label", "", getLabel(label));
-        addElement(AbstractVisitor.OPCODES[opcode], attrs);
-    }
-
-    public final void visitLabel(final Label label) {
-        AttributesImpl attrs = new AttributesImpl();
-        attrs.addAttribute("", "name", "name", "", getLabel(label));
-        addElement("Label", attrs);
-    }
-
-    public final void visitLdcInsn(final Object cst) {
-        AttributesImpl attrs = new AttributesImpl();
-        attrs.addAttribute("",
-                "cst",
-                "cst",
-                "",
-                SAXClassAdapter.encode(cst.toString()));
-        attrs.addAttribute("",
-                "desc",
-                "desc",
-                "",
-                Type.getDescriptor(cst.getClass()));
-        addElement(AbstractVisitor.OPCODES[Opcodes.LDC], attrs);
-    }
-
-    public final void visitIincInsn(final int var, final int increment) {
-        AttributesImpl attrs = new AttributesImpl();
-        attrs.addAttribute("", "var", "var", "", Integer.toString(var));
-        attrs.addAttribute("", "inc", "inc", "", Integer.toString(increment));
-        addElement(AbstractVisitor.OPCODES[Opcodes.IINC], attrs);
-    }
-
-    public final void visitTableSwitchInsn(
-        final int min,
-        final int max,
-        final Label dflt,
-        final Label[] labels)
-    {
-        AttributesImpl attrs = new AttributesImpl();
-        attrs.addAttribute("", "min", "min", "", Integer.toString(min));
-        attrs.addAttribute("", "max", "max", "", Integer.toString(max));
-        attrs.addAttribute("", "dflt", "dflt", "", getLabel(dflt));
-        String o = AbstractVisitor.OPCODES[Opcodes.TABLESWITCH];
-        addStart(o, attrs);
-        for (int i = 0; i < labels.length; i++) {
-            AttributesImpl att2 = new AttributesImpl();
-            att2.addAttribute("", "name", "name", "", getLabel(labels[i]));
-            addElement("label", att2);
-        }
-        addEnd(o);
-    }
-
-    public final void visitLookupSwitchInsn(
-        final Label dflt,
-        final int[] keys,
-        final Label[] labels)
-    {
-        AttributesImpl att = new AttributesImpl();
-        att.addAttribute("", "dflt", "dflt", "", getLabel(dflt));
-        String o = AbstractVisitor.OPCODES[Opcodes.LOOKUPSWITCH];
-        addStart(o, att);
-        for (int i = 0; i < labels.length; i++) {
-            AttributesImpl att2 = new AttributesImpl();
-            att2.addAttribute("", "name", "name", "", getLabel(labels[i]));
-            att2.addAttribute("", "key", "key", "", Integer.toString(keys[i]));
-            addElement("label", att2);
-        }
-        addEnd(o);
-    }
-
-    public final void visitMultiANewArrayInsn(final String desc, final int dims)
-    {
-        AttributesImpl attrs = new AttributesImpl();
-        attrs.addAttribute("", "desc", "desc", "", desc);
-        attrs.addAttribute("", "dims", "dims", "", Integer.toString(dims));
-        addElement(AbstractVisitor.OPCODES[Opcodes.MULTIANEWARRAY], attrs);
-    }
-
-    public final void visitTryCatchBlock(
-        final Label start,
-        final Label end,
-        final Label handler,
-        final String type)
-    {
-        AttributesImpl attrs = new AttributesImpl();
-        attrs.addAttribute("", "start", "start", "", getLabel(start));
-        attrs.addAttribute("", "end", "end", "", getLabel(end));
-        attrs.addAttribute("", "handler", "handler", "", getLabel(handler));
-        if (type != null) {
-            attrs.addAttribute("", "type", "type", "", type);
-        }
-        addElement("TryCatch", attrs);
-    }
-
-    public final void visitMaxs(final int maxStack, final int maxLocals) {
-        AttributesImpl attrs = new AttributesImpl();
-        attrs.addAttribute("",
-                "maxStack",
-                "maxStack",
-                "",
-                Integer.toString(maxStack));
-        attrs.addAttribute("",
-                "maxLocals",
-                "maxLocals",
-                "",
-                Integer.toString(maxLocals));
-        addElement("Max", attrs);
-
-        addEnd("code");
-    }
-
-    public void visitLocalVariable(
-        final String name,
-        final String desc,
-        final String signature,
-        final Label start,
-        final Label end,
-        final int index)
-    {
-        AttributesImpl attrs = new AttributesImpl();
-        attrs.addAttribute("", "name", "name", "", name);
-        attrs.addAttribute("", "desc", "desc", "", desc);
-        if (signature != null) {
-            attrs.addAttribute("",
-                    "signature",
-                    "signature",
-                    "",
-                    SAXClassAdapter.encode(signature));
-        }
-        attrs.addAttribute("", "start", "start", "", getLabel(start));
-        attrs.addAttribute("", "end", "end", "", getLabel(end));
-        attrs.addAttribute("", "var", "var", "", Integer.toString(index));
-        addElement("LocalVar", attrs);
-    }
-
-    public final void visitLineNumber(final int line, final Label start) {
-        AttributesImpl attrs = new AttributesImpl();
-        attrs.addAttribute("", "line", "line", "", Integer.toString(line));
-        attrs.addAttribute("", "start", "start", "", getLabel(start));
-        addElement("LineNumber", attrs);
-    }
-
-    public AnnotationVisitor visitAnnotationDefault() {
-        return new SAXAnnotationAdapter(getContentHandler(),
-                "annotationDefault",
-                0,
-                null,
-                null);
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        return new SAXAnnotationAdapter(getContentHandler(),
-                "annotation",
-                visible ? 1 : -1,
-                null,
-                desc);
-    }
-
-    public AnnotationVisitor visitParameterAnnotation(
-        final int parameter,
-        final String desc,
-        final boolean visible)
-    {
-        return new SAXAnnotationAdapter(getContentHandler(),
-                "parameterAnnotation",
-                visible ? 1 : -1,
-                parameter,
-                desc);
-    }
-
-    public void visitEnd() {
-        addEnd("method");
-    }
-
-    private final String getLabel(final Label label) {
-        String name = (String) labelNames.get(label);
-        if (name == null) {
-            name = Integer.toString(labelNames.size());
-            labelNames.put(label, name);
-        }
-        return name;
-    }
-
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/SAXFieldAdapter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/SAXFieldAdapter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/libraries/asm/xml/SAXFieldAdapter.java	2012-11-03 21:24:14.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/libraries/asm/xml/SAXFieldAdapter.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
-/***
- * ASM XML Adapter
- * Copyright (c) 2004, Eugene Kuleshov
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- */
-package org.eclipse.persistence.internal.libraries.asm.xml;
-
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-import org.xml.sax.Attributes;
-import org.xml.sax.ContentHandler;
-
-/**
- * SAXFieldAdapter
- * 
- * @author Eugene Kuleshov
- */
-public class SAXFieldAdapter extends SAXAdapter implements FieldVisitor {
-
-    public SAXFieldAdapter(final ContentHandler h, final Attributes att) {
-        super(h);
-        addStart("field", att);
-    }
-
-    public AnnotationVisitor visitAnnotation(
-        final String desc,
-        final boolean visible)
-    {
-        return new SAXAnnotationAdapter(getContentHandler(),
-                "annotation",
-                visible ? 1 : -1,
-                null,
-                desc);
-    }
-
-    public void visitEnd() {
-        addEnd("field");
-    }
-}
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/oxm/record/json/JSONLexer.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/oxm/record/json/JSONLexer.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/oxm/record/json/JSONLexer.java	2014-03-19 07:47:20.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/oxm/record/json/JSONLexer.java	2015-11-01 14:16:15.948054525 +0100
@@ -12,7 +12,7 @@
  ******************************************************************************/
 package org.eclipse.persistence.internal.oxm.record.json;
 
-import org.eclipse.persistence.internal.libraries.antlr.runtime.*;
+import org.antlr.runtime.*;
 
 class JSONLexer extends Lexer {
     public static final int EOF=-1;
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/oxm/record/json/JSONParser.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/oxm/record/json/JSONParser.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/oxm/record/json/JSONParser.java	2014-03-19 07:47:20.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/oxm/record/json/JSONParser.java	2015-11-01 14:16:15.950054419 +0100
@@ -12,8 +12,8 @@
  ******************************************************************************/
 package org.eclipse.persistence.internal.oxm.record.json;
 
-import org.eclipse.persistence.internal.libraries.antlr.runtime.*;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.tree.*;
+import org.antlr.runtime.*;
+import org.antlr.runtime.tree.*;
 
 class JSONParser extends Parser {
     public static final String[] tokenNames = new String[] {
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/oxm/record/json/JSONReader.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/oxm/record/json/JSONReader.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/oxm/record/json/JSONReader.java	2014-03-19 07:47:20.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/oxm/record/json/JSONReader.java	2015-11-01 14:16:15.952054314 +0100
@@ -27,14 +27,14 @@
 import javax.xml.namespace.QName;
 
 import org.eclipse.persistence.exceptions.XMLMarshalException;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.ANTLRInputStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.ANTLRReaderStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.CharStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.RecognitionException;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.TokenRewriteStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.TokenStream;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.tree.CommonTree;
-import org.eclipse.persistence.internal.libraries.antlr.runtime.tree.Tree;
+import org.antlr.runtime.ANTLRInputStream;
+import org.antlr.runtime.ANTLRReaderStream;
+import org.antlr.runtime.CharStream;
+import org.antlr.runtime.RecognitionException;
+import org.antlr.runtime.TokenRewriteStream;
+import org.antlr.runtime.TokenStream;
+import org.antlr.runtime.tree.CommonTree;
+import org.antlr.runtime.tree.Tree;
 import org.eclipse.persistence.internal.oxm.CollectionGroupingElementNodeValue;
 import org.eclipse.persistence.internal.oxm.Constants;
 import org.eclipse.persistence.internal.oxm.ContainerValue;
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/internal/xr/XRClassWriter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/xr/XRClassWriter.java
--- eclipselink-2.5.2/org/eclipse/persistence/internal/xr/XRClassWriter.java	2014-03-19 07:46:38.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/internal/xr/XRClassWriter.java	2015-11-01 14:16:15.866058850 +0100
@@ -17,21 +17,21 @@
 //EclipseLink imports
 import org.eclipse.persistence.dynamic.DynamicClassLoader;
 import org.eclipse.persistence.dynamic.DynamicClassWriter;
-import org.eclipse.persistence.internal.libraries.asm.ClassWriter;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
 import static org.eclipse.persistence.internal.dynamic.DynamicPropertiesManager.PROPERTIES_MANAGER_FIELD;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ACC_PUBLIC;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ACC_STATIC;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ACC_SUPER;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ALOAD;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.ARETURN;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.DUP;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.GETSTATIC;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.INVOKESPECIAL;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.NEW;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.PUTSTATIC;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.RETURN;
-import static org.eclipse.persistence.internal.libraries.asm.Opcodes.V1_5;
+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
+import static org.objectweb.asm.Opcodes.ACC_STATIC;
+import static org.objectweb.asm.Opcodes.ACC_SUPER;
+import static org.objectweb.asm.Opcodes.ALOAD;
+import static org.objectweb.asm.Opcodes.ARETURN;
+import static org.objectweb.asm.Opcodes.DUP;
+import static org.objectweb.asm.Opcodes.GETSTATIC;
+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;
+import static org.objectweb.asm.Opcodes.NEW;
+import static org.objectweb.asm.Opcodes.PUTSTATIC;
+import static org.objectweb.asm.Opcodes.RETURN;
+import static org.objectweb.asm.Opcodes.V1_5;
 import static org.eclipse.persistence.internal.xr.XRDynamicClassLoader.COLLECTION_WRAPPER_SUFFIX;
 
 /**
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/jaxb/compiler/AnnotationsProcessor.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/jaxb/compiler/AnnotationsProcessor.java
--- eclipselink-2.5.2/org/eclipse/persistence/jaxb/compiler/AnnotationsProcessor.java	2014-03-19 07:47:24.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/jaxb/compiler/AnnotationsProcessor.java	2015-11-01 14:16:15.877058270 +0100
@@ -81,13 +81,13 @@
 import org.eclipse.persistence.internal.jaxb.many.ManyValue;
 import org.eclipse.persistence.internal.jaxb.many.MultiDimensionalArrayValue;
 import org.eclipse.persistence.internal.jaxb.many.MultiDimensionalCollectionValue;
-import org.eclipse.persistence.internal.libraries.asm.AnnotationVisitor;
-import org.eclipse.persistence.internal.libraries.asm.ClassWriter;
-import org.eclipse.persistence.internal.libraries.asm.FieldVisitor;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Label;
-import org.eclipse.persistence.internal.libraries.asm.Type;
+import org.objectweb.asm.AnnotationVisitor;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.FieldVisitor;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Label;
+import org.objectweb.asm.Type;
 import org.eclipse.persistence.internal.oxm.Constants;
 import org.eclipse.persistence.internal.oxm.Namespace;
 import org.eclipse.persistence.internal.oxm.XMLConversionManager;
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/jaxb/compiler/MappingsGenerator.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/jaxb/compiler/MappingsGenerator.java
--- eclipselink-2.5.2/org/eclipse/persistence/jaxb/compiler/MappingsGenerator.java	2014-03-19 07:47:24.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/jaxb/compiler/MappingsGenerator.java	2015-11-01 14:16:15.886057795 +0100
@@ -72,10 +72,10 @@
 import org.eclipse.persistence.internal.jaxb.many.ManyValue;
 import org.eclipse.persistence.internal.jaxb.many.MapValue;
 import org.eclipse.persistence.internal.jaxb.many.MapValueAttributeAccessor;
-import org.eclipse.persistence.internal.libraries.asm.ClassWriter;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
 import org.eclipse.persistence.internal.oxm.Constants;
 import org.eclipse.persistence.internal.oxm.NamespaceResolver;
 import org.eclipse.persistence.internal.oxm.XMLConversionManager;
diff -Nru eclipselink-2.5.2/org/eclipse/persistence/sdo/helper/DynamicClassWriter.java eclipselink-2.5.2.system-libraries/org/eclipse/persistence/sdo/helper/DynamicClassWriter.java
--- eclipselink-2.5.2/org/eclipse/persistence/sdo/helper/DynamicClassWriter.java	2014-03-19 07:47:24.000000000 +0100
+++ eclipselink-2.5.2.system-libraries/org/eclipse/persistence/sdo/helper/DynamicClassWriter.java	2015-11-01 14:16:15.887057742 +0100
@@ -25,10 +25,10 @@
 import org.eclipse.persistence.sdo.SDOProperty;
 import org.eclipse.persistence.sdo.SDOType;
 import org.eclipse.persistence.sdo.helper.extension.SDOUtil;
-import org.eclipse.persistence.internal.libraries.asm.ClassWriter;
-import org.eclipse.persistence.internal.libraries.asm.MethodVisitor;
-import org.eclipse.persistence.internal.libraries.asm.Opcodes;
-import org.eclipse.persistence.internal.libraries.asm.Type;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
 import org.eclipse.persistence.internal.security.PrivilegedAccessHelper;
 
 import commonj.sdo.helper.HelperContext;
