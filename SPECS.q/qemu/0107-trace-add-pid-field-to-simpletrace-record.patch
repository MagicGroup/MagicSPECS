From 32f3e4afa3c9e67c6448b2f3e3aefc4d7cf5a0d3 Mon Sep 17 00:00:00 2001
From: Stefan Hajnoczi <stefanha@redhat.com>
Date: Wed, 7 May 2014 19:24:10 +0200
Subject: [PATCH] trace: add pid field to simpletrace record

It is useful to know the QEMU process ID when working with traces from
multiple VMs.  Although the trace filename may contain the pid, tools
that aggregate traces or even trace globally need somewhere to record
the pid.

There is a reserved field in the trace event header struct that we can
use.

It is not necessary to bump the simpletrace file format version number
because it has already been incremented for the QEMU 2.1 release cycle
in commit "trace: [simple] Bump up log version number".

Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
(cherry picked from commit 26896cbf353e3017f76da8193074839b6e875250)
---
 trace/simple.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/trace/simple.c b/trace/simple.c
index aaa010e..1584bf7 100644
--- a/trace/simple.c
+++ b/trace/simple.c
@@ -75,6 +75,7 @@ uint8_t trace_buf[TRACE_BUF_LEN];
 static volatile gint trace_idx;
 static unsigned int writeout_idx;
 static volatile gint dropped_events;
+static uint32_t trace_pid;
 static FILE *trace_fp;
 static char *trace_file_name;
 
@@ -83,7 +84,7 @@ typedef struct {
     uint64_t event; /*   TraceEventID */
     uint64_t timestamp_ns;
     uint32_t length;   /*    in bytes */
-    uint32_t reserved; /*    unused */
+    uint32_t pid;
     uint64_t arguments[];
 } TraceRecord;
 
@@ -190,7 +191,7 @@ static gpointer writeout_thread(gpointer opaque)
             dropped.rec.event = DROPPED_EVENT_ID,
             dropped.rec.timestamp_ns = get_clock();
             dropped.rec.length = sizeof(TraceRecord) + sizeof(uint64_t),
-            dropped.rec.reserved = 0;
+            dropped.rec.pid = trace_pid;
             do {
                 dropped_count = g_atomic_int_get(&dropped_events);
             } while (!g_atomic_int_compare_and_exchange(&dropped_events,
@@ -249,6 +250,7 @@ int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasi
     rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));
     rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));
     rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));
+    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));
 
     rec->tbuf_idx = idx;
     rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;
@@ -414,6 +416,8 @@ bool trace_backend_init(const char *events, const char *file)
 {
     GThread *thread;
 
+    trace_pid = getpid();
+
 #if !GLIB_CHECK_VERSION(2, 31, 0)
     trace_available_cond = g_cond_new();
     trace_empty_cond = g_cond_new();
