http://sourceware.org/ml/binutils-cvs/2011-07/msg00116.html

### src/include/ChangeLog	2011/07/22 14:37:50	1.546
### src/include/ChangeLog	2011/07/22 20:37:50	1.547
## -1,5 +1,8 @@
 2011-07-22  Jakub Jelinek  <jakub@redhat.com>
 
+	* dwarf2.h (DW_AT_GNU_macros): New.
+	(enum dwarf_macro_record_type): New enum.  Add DW_MACRO_GNU_*.
+
 	PR c++/49756
 	* libiberty.h (stack_limit_increase): New prototype.
 
--- src/include/dwarf2.h	2011/06/22 15:03:19	1.26
+++ src/include/dwarf2.h	2011/07/22 20:37:50	1.27
@@ -366,6 +366,8 @@
     DW_AT_GNU_all_tail_call_sites = 0x2116,
     DW_AT_GNU_all_call_sites = 0x2117,
     DW_AT_GNU_all_source_call_sites = 0x2118,
+    /* Section offset into .debug_macro section.  */
+    DW_AT_GNU_macros = 0x2119,
     /* VMS extensions.  */
     DW_AT_VMS_rtnbeg_pd_address = 0x2201,
     /* GNAT extensions.  */
@@ -879,6 +881,20 @@
     DW_MACINFO_end_file = 4,
     DW_MACINFO_vendor_ext = 255
   };
+
+/* Names and codes for new style macro information.  */
+enum dwarf_macro_record_type
+  {
+    DW_MACRO_GNU_define = 1,
+    DW_MACRO_GNU_undef = 2,
+    DW_MACRO_GNU_start_file = 3,
+    DW_MACRO_GNU_end_file = 4,
+    DW_MACRO_GNU_define_indirect = 5,
+    DW_MACRO_GNU_undef_indirect = 6,
+    DW_MACRO_GNU_transparent_include = 7,
+    DW_MACRO_GNU_lo_user = 0xe0,
+    DW_MACRO_GNU_hi_user = 0xff
+  };
 
 /* @@@ For use with GNU frame unwind information.  */
 



FYI: implement new DWARF macro proposal
http://sourceware.org/ml/gdb-patches/2011-07/msg00732.html
http://sourceware.org/ml/gdb-cvs/2011-07/msg00212.html

### src/gdb/ChangeLog	2011/07/26 15:24:01	1.13224
### src/gdb/ChangeLog	2011/07/26 17:04:21	1.13225
## -1,3 +1,20 @@
+2011-07-26  Tom Tromey  <tromey@redhat.com>
+
+	* symfile.h (struct dwarf2_debug_sections) <macro>: New field.
+	* dwarf2read.c (read_indirect_string_at_offset): New function.
+	(read_indirect_string): Use it.
+	(dwarf_decode_macro_bytes): New function, taken from
+	dwarf_decode_macros.  Handle DW_MACRO_GNU_*.
+	(dwarf_decode_macros): Use it.  handle DW_MACRO_GNU_*.
+	(dwarf_parse_macro_header, skip_form_bytes, skip_unknown_opcode):
+	New functions.
+	(struct dwarf2_per_objfile) <macro>: New field.
+	(dwarf2_elf_names): Add .debug_macro.
+	(dwarf2_macros_too_long_complaint): Add 'section' argument.
+	(dwarf2_locate_sections): Handle new section.
+	(read_file_scope): Handle DW_AT_GNU_macros.
+	(dwarf2_per_objfile_free): Unmap the .debug_macro section.
+
 2011-07-26  Paul Pluzhnikov  <ppluzhnikov@google.com>
 
 	* NEWS: Mention dcache configuration.
--- src/gdb/dwarf2read.c	2011/07/20 15:13:49	1.554
+++ src/gdb/dwarf2read.c	2011/07/26 17:04:23	1.555
@@ -187,6 +187,7 @@
   struct dwarf2_section_info line;
   struct dwarf2_section_info loc;
   struct dwarf2_section_info macinfo;
+  struct dwarf2_section_info macro;
   struct dwarf2_section_info str;
   struct dwarf2_section_info ranges;
   struct dwarf2_section_info frame;
@@ -264,6 +265,7 @@
   { ".debug_line", ".zdebug_line" },
   { ".debug_loc", ".zdebug_loc" },
   { ".debug_macinfo", ".zdebug_macinfo" },
+  { ".debug_macro", ".zdebug_macro" },
   { ".debug_str", ".zdebug_str" },
   { ".debug_ranges", ".zdebug_ranges" },
   { ".debug_types", ".zdebug_types" },
@@ -858,10 +860,11 @@
 }
 
 static void
-dwarf2_macros_too_long_complaint (void)
+dwarf2_macros_too_long_complaint (struct dwarf2_section_info *section)
 {
   complaint (&symfile_complaints,
-	     _("macro info runs off end of `.debug_macinfo' section"));
+	     _("macro info runs off end of `%s' section"),
+	     section->asection->name);
 }
 
 static void
@@ -1233,7 +1236,9 @@
 				 struct dwarf2_cu *);
 
 static void dwarf_decode_macros (struct line_header *, unsigned int,
-                                 char *, bfd *, struct dwarf2_cu *);
+                                 char *, bfd *, struct dwarf2_cu *,
+				 struct dwarf2_section_info *,
+				 int);
 
 static int attr_form_is_block (struct attribute *);
 
@@ -1438,6 +1443,11 @@
       dwarf2_per_objfile->macinfo.asection = sectp;
       dwarf2_per_objfile->macinfo.size = bfd_get_section_size (sectp);
     }
+  else if (section_is_p (sectp->name, &names->macro))
+    {
+      dwarf2_per_objfile->macro.asection = sectp;
+      dwarf2_per_objfile->macro.size = bfd_get_section_size (sectp);
+    }
   else if (section_is_p (sectp->name, &names->str))
     {
       dwarf2_per_objfile->str.asection = sectp;
@@ -5641,13 +5651,28 @@
      refers to information in the line number info statement program
      header, so we can only read it if we've read the header
      successfully.  */
-  attr = dwarf2_attr (die, DW_AT_macro_info, cu);
+  attr = dwarf2_attr (die, DW_AT_GNU_macros, cu);
   if (attr && cu->line_header)
     {
-      unsigned int macro_offset = DW_UNSND (attr);
+      if (dwarf2_attr (die, DW_AT_macro_info, cu))
+	complaint (&symfile_complaints,
+		   _("CU refers to both DW_AT_GNU_macros and DW_AT_macro_info"));
+
+      dwarf_decode_macros (cu->line_header, DW_UNSND (attr),
+			   comp_dir, abfd, cu,
+			   &dwarf2_per_objfile->macro, 1);
+    }
+  else
+    {
+      attr = dwarf2_attr (die, DW_AT_macro_info, cu);
+      if (attr && cu->line_header)
+	{
+	  unsigned int macro_offset = DW_UNSND (attr);
 
-      dwarf_decode_macros (cu->line_header, macro_offset,
-                           comp_dir, abfd, cu);
+	  dwarf_decode_macros (cu->line_header, macro_offset,
+			       comp_dir, abfd, cu,
+			       &dwarf2_per_objfile->macinfo, 0);
+	}
     }
   do_cleanups (back_to);
 }
@@ -10262,32 +10287,32 @@
 }
 
 static char *
-read_indirect_string (bfd *abfd, gdb_byte *buf,
-		      const struct comp_unit_head *cu_header,
-		      unsigned int *bytes_read_ptr)
+read_indirect_string_at_offset (bfd *abfd, LONGEST str_offset)
 {
-  LONGEST str_offset = read_offset (abfd, buf, cu_header, bytes_read_ptr);
-
   dwarf2_read_section (dwarf2_per_objfile->objfile, &dwarf2_per_objfile->str);
   if (dwarf2_per_objfile->str.buffer == NULL)
-    {
-      error (_("DW_FORM_strp used without .debug_str section [in module %s]"),
-		      bfd_get_filename (abfd));
-      return NULL;
-    }
+    error (_("DW_FORM_strp used without .debug_str section [in module %s]"),
+	   bfd_get_filename (abfd));
   if (str_offset >= dwarf2_per_objfile->str.size)
-    {
-      error (_("DW_FORM_strp pointing outside of "
-	       ".debug_str section [in module %s]"),
-	     bfd_get_filename (abfd));
-      return NULL;
-    }
+    error (_("DW_FORM_strp pointing outside of "
+	     ".debug_str section [in module %s]"),
+	   bfd_get_filename (abfd));
   gdb_assert (HOST_CHAR_BIT == 8);
   if (dwarf2_per_objfile->str.buffer[str_offset] == '\0')
     return NULL;
   return (char *) (dwarf2_per_objfile->str.buffer + str_offset);
 }
 
+static char *
+read_indirect_string (bfd *abfd, gdb_byte *buf,
+		      const struct comp_unit_head *cu_header,
+		      unsigned int *bytes_read_ptr)
+{
+  LONGEST str_offset = read_offset (abfd, buf, cu_header, bytes_read_ptr);
+
+  return read_indirect_string_at_offset (abfd, str_offset);
+}
+
 static unsigned long
 read_unsigned_leb128 (bfd *abfd, gdb_byte *buf, unsigned int *bytes_read_ptr)
 {
@@ -14669,117 +14694,205 @@
     dwarf2_macro_malformed_definition_complaint (body);
 }
 
+/* Skip some bytes from BYTES according to the form given in FORM.
+   Returns the new pointer.  */
 
-static void
-dwarf_decode_macros (struct line_header *lh, unsigned int offset,
-                     char *comp_dir, bfd *abfd,
-                     struct dwarf2_cu *cu)
+static gdb_byte *
+skip_form_bytes (bfd *abfd, gdb_byte *bytes,
+		 enum dwarf_form form,
+		 unsigned int offset_size,
+		 struct dwarf2_section_info *section)
 {
-  gdb_byte *mac_ptr, *mac_end;
-  struct macro_source_file *current_file = 0;
-  enum dwarf_macinfo_record_type macinfo_type;
-  int at_commandline;
+  unsigned int bytes_read;
 
-  dwarf2_read_section (dwarf2_per_objfile->objfile,
-		       &dwarf2_per_objfile->macinfo);
-  if (dwarf2_per_objfile->macinfo.buffer == NULL)
+  switch (form)
     {
-      complaint (&symfile_complaints, _("missing .debug_macinfo section"));
-      return;
+    case DW_FORM_data1:
+    case DW_FORM_flag:
+      ++bytes;
+      break;
+
+    case DW_FORM_data2:
+      bytes += 2;
+      break;
+
+    case DW_FORM_data4:
+      bytes += 4;
+      break;
+
+    case DW_FORM_data8:
+      bytes += 8;
+      break;
+
+    case DW_FORM_string:
+      read_direct_string (abfd, bytes, &bytes_read);
+      bytes += bytes_read;
+      break;
+
+    case DW_FORM_sec_offset:
+    case DW_FORM_strp:
+      bytes += offset_size;
+      break;
+
+    case DW_FORM_block:
+      bytes += read_unsigned_leb128 (abfd, bytes, &bytes_read);
+      bytes += bytes_read;
+      break;
+
+    case DW_FORM_block1:
+      bytes += 1 + read_1_byte (abfd, bytes);
+      break;
+    case DW_FORM_block2:
+      bytes += 2 + read_2_bytes (abfd, bytes);
+      break;
+    case DW_FORM_block4:
+      bytes += 4 + read_4_bytes (abfd, bytes);
+      break;
+
+    case DW_FORM_sdata:
+    case DW_FORM_udata:
+      bytes = skip_leb128 (abfd, bytes);
+      break;
+
+    default:
+      {
+      complain:
+	complaint (&symfile_complaints,
+		   _("invalid form 0x%x in `%s'"),
+		   form,
+		   section->asection->name);
+	return NULL;
+      }
     }
 
-  /* First pass: Find the name of the base filename.
-     This filename is needed in order to process all macros whose definition
-     (or undefinition) comes from the command line.  These macros are defined
-     before the first DW_MACINFO_start_file entry, and yet still need to be
-     associated to the base file.
+  return bytes;
+}
 
-     To determine the base file name, we scan the macro definitions until we
-     reach the first DW_MACINFO_start_file entry.  We then initialize
-     CURRENT_FILE accordingly so that any macro definition found before the
-     first DW_MACINFO_start_file can still be associated to the base file.  */
+/* A helper for dwarf_decode_macros that handles skipping an unknown
+   opcode.  Returns an updated pointer to the macro data buffer; or,
+   on error, issues a complaint and returns NULL.  */
 
-  mac_ptr = dwarf2_per_objfile->macinfo.buffer + offset;
-  mac_end = dwarf2_per_objfile->macinfo.buffer
-    + dwarf2_per_objfile->macinfo.size;
+static gdb_byte *
+skip_unknown_opcode (unsigned int opcode,
+		     gdb_byte **opcode_definitions,
+		     gdb_byte *mac_ptr,
+		     bfd *abfd,
+		     unsigned int offset_size,
+		     struct dwarf2_section_info *section)
+{
+  unsigned int bytes_read, i;
+  unsigned long arg;
+  gdb_byte *defn;
 
-  do
+  if (opcode_definitions[opcode] == NULL)
     {
-      /* Do we at least have room for a macinfo type byte?  */
-      if (mac_ptr >= mac_end)
-        {
-	  /* Complaint is printed during the second pass as GDB will probably
-	     stop the first pass earlier upon finding
-	     DW_MACINFO_start_file.  */
-	  break;
-        }
+      complaint (&symfile_complaints,
+		 _("unrecognized DW_MACFINO opcode 0x%x"),
+		 opcode);
+      return NULL;
+    }
 
-      macinfo_type = read_1_byte (abfd, mac_ptr);
-      mac_ptr++;
+  defn = opcode_definitions[opcode];
+  arg = read_unsigned_leb128 (abfd, defn, &bytes_read);
+  defn += bytes_read;
 
-      switch (macinfo_type)
-        {
-          /* A zero macinfo type indicates the end of the macro
-             information.  */
-        case 0:
-	  break;
+  for (i = 0; i < arg; ++i)
+    {
+      mac_ptr = skip_form_bytes (abfd, mac_ptr, defn[i], offset_size, section);
+      if (mac_ptr == NULL)
+	{
+	  /* skip_form_bytes already issued the complaint.  */
+	  return NULL;
+	}
+    }
 
-	case DW_MACINFO_define:
-	case DW_MACINFO_undef:
-	  /* Only skip the data by MAC_PTR.  */
-	  {
-	    unsigned int bytes_read;
+  return mac_ptr;
+}
 
-	    read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
-	    mac_ptr += bytes_read;
-	    read_direct_string (abfd, mac_ptr, &bytes_read);
-	    mac_ptr += bytes_read;
-	  }
-	  break;
+/* A helper function which parses the header of a macro section.
+   If the macro section is the extended (for now called "GNU") type,
+   then this updates *OFFSET_SIZE.  Returns a pointer to just after
+   the header, or issues a complaint and returns NULL on error.  */
 
-	case DW_MACINFO_start_file:
-	  {
-	    unsigned int bytes_read;
-	    int line, file;
+static gdb_byte *
+dwarf_parse_macro_header (gdb_byte **opcode_definitions,
+			  bfd *abfd,
+			  gdb_byte *mac_ptr,
+			  unsigned int *offset_size,
+			  int section_is_gnu)
+{
+  memset (opcode_definitions, 0, 256 * sizeof (gdb_byte *));
 
-	    line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
-	    mac_ptr += bytes_read;
-	    file = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
-	    mac_ptr += bytes_read;
+  if (section_is_gnu)
+    {
+      unsigned int version, flags;
 
-	    current_file = macro_start_file (file, line, current_file,
-					     comp_dir, lh, cu->objfile);
-	  }
-	  break;
+      version = read_2_bytes (abfd, mac_ptr);
+      if (version != 4)
+	{
+	  complaint (&symfile_complaints,
+		     _("unrecognized version `%d' in .debug_macro section"),
+		     version);
+	  return NULL;
+	}
+      mac_ptr += 2;
 
-	case DW_MACINFO_end_file:
-	  /* No data to skip by MAC_PTR.  */
-	  break;
+      flags = read_1_byte (abfd, mac_ptr);
+      ++mac_ptr;
+      *offset_size = (flags & 1) ? 8 : 4;
 
-	case DW_MACINFO_vendor_ext:
-	  /* Only skip the data by MAC_PTR.  */
-	  {
-	    unsigned int bytes_read;
+      if ((flags & 2) != 0)
+	/* We don't need the line table offset.  */
+	mac_ptr += *offset_size;
 
-	    read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
-	    mac_ptr += bytes_read;
-	    read_direct_string (abfd, mac_ptr, &bytes_read);
-	    mac_ptr += bytes_read;
-	  }
-	  break;
+      /* Vendor opcode descriptions.  */
+      if ((flags & 4) != 0)
+	{
+	  unsigned int i, count;
 
-	default:
-	  break;
+	  count = read_1_byte (abfd, mac_ptr);
+	  ++mac_ptr;
+	  for (i = 0; i < count; ++i)
+	    {
+	      unsigned int opcode, bytes_read;
+	      unsigned long arg;
+
+	      opcode = read_1_byte (abfd, mac_ptr);
+	      ++mac_ptr;
+	      opcode_definitions[opcode] = mac_ptr;
+	      arg = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
+	      mac_ptr += bytes_read;
+	      mac_ptr += arg;
+	    }
 	}
-    } while (macinfo_type != 0 && current_file == NULL);
+    }
 
-  /* Second pass: Process all entries.
+  return mac_ptr;
+}
 
-     Use the AT_COMMAND_LINE flag to determine whether we are still processing
-     command-line macro definitions/undefinitions.  This flag is unset when we
-     reach the first DW_MACINFO_start_file entry.  */
+/* A helper for dwarf_decode_macros that handles the GNU extensions,
+   including DW_GNU_MACINFO_transparent_include.  */
+
+static void
+dwarf_decode_macro_bytes (bfd *abfd, gdb_byte *mac_ptr, gdb_byte *mac_end,
+			  struct macro_source_file *current_file,
+			  struct line_header *lh, char *comp_dir,
+			  struct dwarf2_section_info *section,
+			  int section_is_gnu,
+			  unsigned int offset_size,
+			  struct objfile *objfile)
+{
+  enum dwarf_macro_record_type macinfo_type;
+  int at_commandline;
+  gdb_byte *opcode_definitions[256];
 
-  mac_ptr = dwarf2_per_objfile->macinfo.buffer + offset;
+  mac_ptr = dwarf_parse_macro_header (opcode_definitions, abfd, mac_ptr,
+				      &offset_size, section_is_gnu);
+  if (mac_ptr == NULL)
+    {
+      /* We already issued a complaint.  */
+      return;
+    }
 
   /* Determines if GDB is still before first DW_MACINFO_start_file.  If true
      GDB is still reading the definitions from command line.  First
@@ -14795,13 +14908,15 @@
       /* Do we at least have room for a macinfo type byte?  */
       if (mac_ptr >= mac_end)
 	{
-	  dwarf2_macros_too_long_complaint ();
+	  dwarf2_macros_too_long_complaint (section);
 	  break;
 	}
 
       macinfo_type = read_1_byte (abfd, mac_ptr);
       mac_ptr++;
 
+      /* Note that we rely on the fact that the corresponding GNU and
+	 DWARF constants are the same.  */
       switch (macinfo_type)
 	{
 	  /* A zero macinfo type indicates the end of the macro
@@ -14809,29 +14924,45 @@
 	case 0:
 	  break;
 
-        case DW_MACINFO_define:
-        case DW_MACINFO_undef:
+        case DW_MACRO_GNU_define:
+        case DW_MACRO_GNU_undef:
+	case DW_MACRO_GNU_define_indirect:
+	case DW_MACRO_GNU_undef_indirect:
           {
             unsigned int bytes_read;
             int line;
             char *body;
+	    int is_define;
 
-            line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
-            mac_ptr += bytes_read;
-            body = read_direct_string (abfd, mac_ptr, &bytes_read);
-            mac_ptr += bytes_read;
+	    line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
+	    mac_ptr += bytes_read;
+
+	    if (macinfo_type == DW_MACRO_GNU_define
+		|| macinfo_type == DW_MACRO_GNU_undef)
+	      {
+		body = read_direct_string (abfd, mac_ptr, &bytes_read);
+		mac_ptr += bytes_read;
+	      }
+	    else
+	      {
+		LONGEST str_offset;
+
+		str_offset = read_offset_1 (abfd, mac_ptr, offset_size);
+		mac_ptr += offset_size;
 
+		body = read_indirect_string_at_offset (abfd, str_offset);
+	      }
+
+	    is_define = (macinfo_type == DW_MACRO_GNU_define
+			 || macinfo_type == DW_MACRO_GNU_define_indirect);
             if (! current_file)
 	      {
 		/* DWARF violation as no main source is present.  */
 		complaint (&symfile_complaints,
 			   _("debug info with no main source gives macro %s "
 			     "on line %d: %s"),
-			   macinfo_type == DW_MACINFO_define ?
-			     _("definition") :
-			       macinfo_type == DW_MACINFO_undef ?
-				 _("undefinition") :
-				 _("something-or-other"), line, body);
+			   is_define ? _("definition") : _("undefinition"),
+			   line, body);
 		break;
 	      }
 	    if ((line == 0 && !at_commandline)
@@ -14839,21 +14970,21 @@
 	      complaint (&symfile_complaints,
 			 _("debug info gives %s macro %s with %s line %d: %s"),
 			 at_commandline ? _("command-line") : _("in-file"),
-			 macinfo_type == DW_MACINFO_define ?
-			   _("definition") :
-			     macinfo_type == DW_MACINFO_undef ?
-			       _("undefinition") :
-			       _("something-or-other"),
+			 is_define ? _("definition") : _("undefinition"),
 			 line == 0 ? _("zero") : _("non-zero"), line, body);
 
-	    if (macinfo_type == DW_MACINFO_define)
+	    if (is_define)
 	      parse_macro_definition (current_file, line, body);
-	    else if (macinfo_type == DW_MACINFO_undef)
-	      macro_undef (current_file, line, body);
+	    else
+	      {
+		gdb_assert (macinfo_type == DW_MACRO_GNU_undef
+			    || macinfo_type == DW_MACRO_GNU_undef_indirect);
+		macro_undef (current_file, line, body);
+	      }
           }
           break;
 
-        case DW_MACINFO_start_file:
+        case DW_MACRO_GNU_start_file:
           {
             unsigned int bytes_read;
             int line, file;
@@ -14873,17 +15004,18 @@
 
 	    if (at_commandline)
 	      {
-		/* This DW_MACINFO_start_file was executed in the pass one.  */
+		/* This DW_MACRO_GNU_start_file was executed in the
+		   pass one.  */
 		at_commandline = 0;
 	      }
 	    else
 	      current_file = macro_start_file (file, line,
 					       current_file, comp_dir,
-					       lh, cu->objfile);
+					       lh, objfile);
           }
           break;
 
-        case DW_MACINFO_end_file:
+        case DW_MACRO_GNU_end_file:
           if (! current_file)
 	    complaint (&symfile_complaints,
 		       _("macro debug info has an unmatched "
@@ -14893,7 +15025,7 @@
               current_file = current_file->included_by;
               if (! current_file)
                 {
-                  enum dwarf_macinfo_record_type next_type;
+                  enum dwarf_macro_record_type next_type;
 
                   /* GCC circa March 2002 doesn't produce the zero
                      type byte marking the end of the compilation
@@ -14903,7 +15035,7 @@
                   /* Do we at least have room for a macinfo type byte?  */
                   if (mac_ptr >= mac_end)
                     {
-		      dwarf2_macros_too_long_complaint ();
+		      dwarf2_macros_too_long_complaint (section);
                       return;
                     }
 
@@ -14920,23 +15052,199 @@
             }
           break;
 
+	case DW_MACRO_GNU_transparent_include:
+	  {
+	    LONGEST offset;
+
+	    offset = read_offset_1 (abfd, mac_ptr, offset_size);
+	    mac_ptr += offset_size;
+
+	    dwarf_decode_macro_bytes (abfd,
+				      section->buffer + offset,
+				      mac_end, current_file,
+				      lh, comp_dir,
+				      section, section_is_gnu,
+				      offset_size, objfile);
+	  }
+	  break;
+
         case DW_MACINFO_vendor_ext:
-          {
-            unsigned int bytes_read;
-            int constant;
+	  if (!section_is_gnu)
+	    {
+	      unsigned int bytes_read;
+	      int constant;
 
-            constant = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
-            mac_ptr += bytes_read;
-            read_direct_string (abfd, mac_ptr, &bytes_read);
-            mac_ptr += bytes_read;
+	      constant = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
+	      mac_ptr += bytes_read;
+	      read_direct_string (abfd, mac_ptr, &bytes_read);
+	      mac_ptr += bytes_read;
 
-            /* We don't recognize any vendor extensions.  */
-          }
-          break;
+	      /* We don't recognize any vendor extensions.  */
+	      break;
+	    }
+	  /* FALLTHROUGH */
+
+	default:
+	  mac_ptr = skip_unknown_opcode (macinfo_type, opcode_definitions,
+					 mac_ptr, abfd, offset_size,
+					 section);
+	  if (mac_ptr == NULL)
+	    return;
+	  break;
         }
     } while (macinfo_type != 0);
 }
 
+static void
+dwarf_decode_macros (struct line_header *lh, unsigned int offset,
+                     char *comp_dir, bfd *abfd,
+                     struct dwarf2_cu *cu,
+		     struct dwarf2_section_info *section,
+		     int section_is_gnu)
+{
+  gdb_byte *mac_ptr, *mac_end;
+  struct macro_source_file *current_file = 0;
+  enum dwarf_macro_record_type macinfo_type;
+  unsigned int offset_size = cu->header.offset_size;
+  gdb_byte *opcode_definitions[256];
+
+  dwarf2_read_section (dwarf2_per_objfile->objfile, section);
+  if (section->buffer == NULL)
+    {
+      complaint (&symfile_complaints, _("missing %s section"),
+		 section->asection->name);
+      return;
+    }
+
+  /* First pass: Find the name of the base filename.
+     This filename is needed in order to process all macros whose definition
+     (or undefinition) comes from the command line.  These macros are defined
+     before the first DW_MACINFO_start_file entry, and yet still need to be
+     associated to the base file.
+
+     To determine the base file name, we scan the macro definitions until we
+     reach the first DW_MACINFO_start_file entry.  We then initialize
+     CURRENT_FILE accordingly so that any macro definition found before the
+     first DW_MACINFO_start_file can still be associated to the base file.  */
+
+  mac_ptr = section->buffer + offset;
+  mac_end = section->buffer + section->size;
+
+  mac_ptr = dwarf_parse_macro_header (opcode_definitions, abfd, mac_ptr,
+				      &offset_size, section_is_gnu);
+  if (mac_ptr == NULL)
+    {
+      /* We already issued a complaint.  */
+      return;
+    }
+
+  do
+    {
+      /* Do we at least have room for a macinfo type byte?  */
+      if (mac_ptr >= mac_end)
+        {
+	  /* Complaint is printed during the second pass as GDB will probably
+	     stop the first pass earlier upon finding
+	     DW_MACINFO_start_file.  */
+	  break;
+        }
+
+      macinfo_type = read_1_byte (abfd, mac_ptr);
+      mac_ptr++;
+
+      /* Note that we rely on the fact that the corresponding GNU and
+	 DWARF constants are the same.  */
+      switch (macinfo_type)
+        {
+          /* A zero macinfo type indicates the end of the macro
+             information.  */
+        case 0:
+	  break;
+
+	case DW_MACRO_GNU_define:
+	case DW_MACRO_GNU_undef:
+	  /* Only skip the data by MAC_PTR.  */
+	  {
+	    unsigned int bytes_read;
+
+	    read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
+	    mac_ptr += bytes_read;
+	    read_direct_string (abfd, mac_ptr, &bytes_read);
+	    mac_ptr += bytes_read;
+	  }
+	  break;
+
+	case DW_MACRO_GNU_start_file:
+	  {
+	    unsigned int bytes_read;
+	    int line, file;
+
+	    line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
+	    mac_ptr += bytes_read;
+	    file = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
+	    mac_ptr += bytes_read;
+
+	    current_file = macro_start_file (file, line, current_file,
+					     comp_dir, lh, cu->objfile);
+	  }
+	  break;
+
+	case DW_MACRO_GNU_end_file:
+	  /* No data to skip by MAC_PTR.  */
+	  break;
+
+	case DW_MACRO_GNU_define_indirect:
+	case DW_MACRO_GNU_undef_indirect:
+	  {
+	    unsigned int bytes_read;
+
+	    read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
+	    mac_ptr += bytes_read;
+	    mac_ptr += offset_size;
+	  }
+	  break;
+
+	case DW_MACRO_GNU_transparent_include:
+	  /* Note that, according to the spec, a transparent include
+	     chain cannot call DW_MACRO_GNU_start_file.  So, we can just
+	     skip this opcode.  */
+	  mac_ptr += offset_size;
+	  break;
+
+	case DW_MACINFO_vendor_ext:
+	  /* Only skip the data by MAC_PTR.  */
+	  if (!section_is_gnu)
+	    {
+	      unsigned int bytes_read;
+
+	      read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
+	      mac_ptr += bytes_read;
+	      read_direct_string (abfd, mac_ptr, &bytes_read);
+	      mac_ptr += bytes_read;
+	    }
+	  /* FALLTHROUGH */
+
+	default:
+	  mac_ptr = skip_unknown_opcode (macinfo_type, opcode_definitions,
+					 mac_ptr, abfd, offset_size,
+					 section);
+	  if (mac_ptr == NULL)
+	    return;
+	  break;
+	}
+    } while (macinfo_type != 0 && current_file == NULL);
+
+  /* Second pass: Process all entries.
+
+     Use the AT_COMMAND_LINE flag to determine whether we are still processing
+     command-line macro definitions/undefinitions.  This flag is unset when we
+     reach the first DW_MACINFO_start_file entry.  */
+
+  dwarf_decode_macro_bytes (abfd, section->buffer + offset, mac_end,
+			    current_file, lh, comp_dir, section, section_is_gnu,
+			    offset_size, cu->objfile);
+}
+
 /* Check if the attribute's form is a DW_FORM_block*
    if so return true else false.  */
 static int
@@ -15663,6 +15971,7 @@
   munmap_section_buffer (&data->line);
   munmap_section_buffer (&data->loc);
   munmap_section_buffer (&data->macinfo);
+  munmap_section_buffer (&data->macro);
   munmap_section_buffer (&data->str);
   munmap_section_buffer (&data->ranges);
   munmap_section_buffer (&data->frame);
--- src/gdb/symfile.h	2011/06/10 21:48:04	1.93
+++ src/gdb/symfile.h	2011/07/26 17:04:23	1.94
@@ -582,6 +582,7 @@
   struct dwarf2_section_names line;
   struct dwarf2_section_names loc;
   struct dwarf2_section_names macinfo;
+  struct dwarf2_section_names macro;
   struct dwarf2_section_names str;
   struct dwarf2_section_names ranges;
   struct dwarf2_section_names types;



Re: FYI: implement new DWARF macro proposal
http://sourceware.org/ml/gdb-patches/2011-07/msg00759.html
http://sourceware.org/ml/gdb-cvs/2011-07/msg00224.html

### src/gdb/ChangeLog	2011/07/26 21:09:05	1.13229
### src/gdb/ChangeLog	2011/07/27 14:45:36	1.13230
## -1,3 +1,10 @@
+2011-07-27  Tom Tromey  <tromey@redhat.com>
+
+	* xcoffread.c (dwarf2_xcoff_names): Add 'macro' and 'sentinel'
+	entries.
+	* symfile.h (struct dwarf2_debug_sections) <sentinel>: New field.
+	* dwarf2read.c (dwarf2_elf_names): Add sentinel entry.
+
 2011-07-26  Sterling Augustine  <saugustine@google.com>
 
 	* cli/cli-dump.c (dump_binary_file): Change parameter type to
--- src/gdb/dwarf2read.c	2011/07/26 17:04:23	1.555
+++ src/gdb/dwarf2read.c	2011/07/27 14:45:37	1.556
@@ -271,7 +271,8 @@
   { ".debug_types", ".zdebug_types" },
   { ".debug_frame", ".zdebug_frame" },
   { ".eh_frame", NULL },
-  { ".gdb_index", ".zgdb_index" }
+  { ".gdb_index", ".zgdb_index" },
+  23
 };
 
 /* local data types */
--- src/gdb/symfile.h	2011/07/26 17:04:23	1.94
+++ src/gdb/symfile.h	2011/07/27 14:45:37	1.95
@@ -589,6 +589,9 @@
   struct dwarf2_section_names frame;
   struct dwarf2_section_names eh_frame;
   struct dwarf2_section_names gdb_index;
+  /* This field has no meaning, but exists solely to catch changes to
+     this structure which are not reflected in some instance.  */
+  int sentinel;
 };
 
 extern int dwarf2_has_info (struct objfile *,
--- src/gdb/xcoffread.c	2011/06/07 12:31:07	1.89
+++ src/gdb/xcoffread.c	2011/07/27 14:45:37	1.90
@@ -160,12 +160,14 @@
   { ".dwline", NULL },
   { ".dwloc", NULL },
   { NULL, NULL }, /* debug_macinfo */
+  { NULL, NULL }, /* debug_macro */
   { ".dwstr", NULL },
   { ".dwrnges", NULL },
   { NULL, NULL }, /* debug_types */
   { ".dwframe", NULL },
   { NULL, NULL }, /* eh_frame */
-  { NULL, NULL } /* gdb_index */
+  { NULL, NULL }, /* gdb_index */
+  23
 };
 
 static void



[patch][python] Fix sigsegv when a printer fails to return a value and string_print is set.
http://sourceware.org/ml/gdb-patches/2011-07/msg00719.html
http://sourceware.org/ml/gdb-cvs/2011-07/msg00234.html

### src/gdb/ChangeLog	2011/07/27 19:31:30	1.13236
### src/gdb/ChangeLog	2011/07/28 10:36:37	1.13237
## -1,3 +1,8 @@
+2011-07-28  Phil Muldoon  <pmuldoon@redhat.com>
+
+	* varobj.c (value_get_print_value): Move hint check later into the
+	function.  Comment function.  Free thevalue before reusing it.
+
 2011-07-27  Jan Kratochvil  <jan.kratochvil@redhat.com>
 	    Pedro Alves  <pedro@codesourcery.com>
 
--- src/gdb/varobj.c	2011/07/18 09:21:43	1.180
+++ src/gdb/varobj.c	2011/07/28 10:36:40	1.181
@@ -2610,25 +2610,21 @@
 
 	if (PyObject_HasAttr (value_formatter, gdbpy_to_string_cst))
 	  {
-	    char *hint;
 	    struct value *replacement;
 	    PyObject *output = NULL;
 
-	    hint = gdbpy_get_display_hint (value_formatter);
-	    if (hint)
-	      {
-		if (!strcmp (hint, "string"))
-		  string_print = 1;
-		xfree (hint);
-	      }
-
 	    output = apply_varobj_pretty_printer (value_formatter,
 						  &replacement,
 						  stb);
+
+	    /* If we have string like output ...  */
 	    if (output)
 	      {
 		make_cleanup_py_decref (output);
 
+		/* If this is a lazy string, extract it.  For lazy
+		   strings we always print as a string, so set
+		   string_print.  */
 		if (gdbpy_is_lazy_string (output))
 		  {
 		    gdbpy_extract_lazy_string (output, &str_addr, &type,
@@ -2638,12 +2634,27 @@
 		  }
 		else
 		  {
+		    /* If it is a regular (non-lazy) string, extract
+		       it and copy the contents into THEVALUE.  If the
+		       hint says to print it as a string, set
+		       string_print.  Otherwise just return the extracted
+		       string as a value.  */
+
 		    PyObject *py_str
 		      = python_string_to_target_python_string (output);
 
 		    if (py_str)
 		      {
 			char *s = PyString_AsString (py_str);
+			char *hint;
+
+			hint = gdbpy_get_display_hint (value_formatter);
+			if (hint)
+			  {
+			    if (!strcmp (hint, "string"))
+			      string_print = 1;
+			    xfree (hint);
+			  }
 
 			len = PyString_Size (py_str);
 			thevalue = xmemdup (s, len + 1, len + 1);
@@ -2662,6 +2673,9 @@
 		      gdbpy_print_stack ();
 		  }
 	      }
+	    /* If the printer returned a replacement value, set VALUE
+	       to REPLACEMENT.  If there is not a replacement value,
+	       just use the value passed to this function.  */
 	    if (replacement)
 	      value = replacement;
 	  }
@@ -2672,12 +2686,18 @@
   get_formatted_print_options (&opts, format_code[(int) format]);
   opts.deref_ref = 0;
   opts.raw = 1;
+
+  /* If the THEVALUE has contents, it is a regular string.  */
   if (thevalue)
     LA_PRINT_STRING (stb, type, thevalue, len, encoding, 0, &opts);
   else if (string_print)
+    /* Otherwise, if string_print is set, and it is not a regular
+       string, it is a lazy string.  */
     val_print_string (type, encoding, str_addr, len, stb, &opts);
   else
+    /* All other cases.  */
     common_val_print (value, stb, 0, &opts, current_language);
+
   thevalue = ui_file_xstrdup (stb, NULL);
 
   do_cleanups (old_chain);
### src/gdb/testsuite/ChangeLog	2011/07/27 21:18:39	1.2816
### src/gdb/testsuite/ChangeLog	2011/07/28 10:36:40	1.2817
## -1,3 +1,10 @@
+2011-07-28  Phil Muldoon  <pmuldoon@redhat.com>
+
+	* gdb.python/py-mi.exp: Test printers returning string hint, and
+	also not returning a value.
+	* gdb.python/py-prettyprint.c: Add testcase for above.
+	* gdb.python/py-prettyprint.py: Add test printer for above.
+
 2011-07-27  Jan Kratochvil  <jan.kratochvil@redhat.com>
 
 	* gdb.dwarf2/dw2-simple-locdesc.S: Change DWARF version to 3.
--- src/gdb/testsuite/gdb.python/py-mi.exp	2011/07/26 18:38:55	1.13
+++ src/gdb/testsuite/gdb.python/py-mi.exp	2011/07/28 10:36:40	1.14
@@ -284,6 +284,13 @@ mi_list_varobj_children nstype2 {
     { {nstype2.<error at 0>} {<error at 0>} 6 {char \[6\]} }
 } "list children after setting exception flag"
 
+mi_create_varobj me me \
+  "create me varobj"
+
+mi_gdb_test "-var-evaluate-expression me" \
+	"\\^done,value=\"<error reading variable: Cannot access memory.>.*\"" \
+	"evaluate me varobj"
+
 # C++ MI tests
 gdb_exit
 if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" \
--- src/gdb/testsuite/gdb.python/py-prettyprint.c	2011/04/29 12:45:46	1.12
+++ src/gdb/testsuite/gdb.python/py-prettyprint.c	2011/07/28 10:36:40	1.13
@@ -149,6 +149,11 @@
 
 typedef struct justchildren nostring_type;
 
+struct memory_error
+{
+  const char *s;
+};
+
 struct container
 {
   string name;
@@ -227,6 +232,7 @@
   /* Clearing by being `static' could invoke an other GDB C++ bug.  */
   struct nullstr nullstr;
   nostring_type nstype, nstype2;
+  struct memory_error me;
   struct ns ns, ns2;
   struct lazystring estring, estring2;
   struct hint_error hint_error;
@@ -234,6 +240,8 @@
   nstype.elements = narray;
   nstype.len = 0;
 
+  me.s = "blah";
+
   init_ss(&ss, 1, 2);
   init_ss(ssa+0, 3, 4);
   init_ss(ssa+1, 5, 6);
--- src/gdb/testsuite/gdb.python/py-prettyprint.py	2011/04/11 17:40:41	1.11
+++ src/gdb/testsuite/gdb.python/py-prettyprint.py	2011/07/28 10:36:40	1.12
@@ -17,6 +17,7 @@
 # printers.
 
 import re
+import gdb
 
 # Test returning a Value from a printer.
 class string_print:
@@ -186,6 +187,18 @@
         yield 's', self.val['s']
         yield 'x', self.val['x']
 
+class MemoryErrorString:
+    "Raise an error"
+
+    def __init__(self, val):
+        self.val = val
+
+    def to_string(self):
+        raise gdb.MemoryError ("Cannot access memory.");
+
+    def display_hint (self):
+        return 'string'
+
 def lookup_function (val):
     "Look-up and return a pretty-printer that can print val."
 
@@ -261,6 +274,8 @@
     pretty_printers_dict[re.compile ('^struct hint_error$')]  = pp_hint_error
     pretty_printers_dict[re.compile ('^hint_error$')]  = pp_hint_error
 
+    pretty_printers_dict[re.compile ('^memory_error$')]  = MemoryErrorString
+
 pretty_printers_dict = {}
 
 register_pretty_printers ()



commit 84be2b4d0a55c95697c9ecc72bb31c2fbd316127
Author: ian <ian@138bc75d-0d04-0410-961f-82ee72b054a4>
Date:   Tue Jul 26 14:28:23 2011 +0000

    	* cp-demangle.c (d_print_init): Initialize pack_index field.
    	(d_print_comp): Check for NULL template argument.
    	* testsuite/demangle-expected: Add test case.
    
    
    git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@176791 138bc75d-0d04-0410-961f-82ee72b054a4

### a/libiberty/ChangeLog
### b/libiberty/ChangeLog
## -1,3 +1,9 @@
+2011-07-26  Ian Lance Taylor  <iant@google.com>
+
+	* cp-demangle.c (d_print_init): Initialize pack_index field.
+	(d_print_comp): Check for NULL template argument.
+	* testsuite/demangle-expected: Add test case.
+
 2011-07-22  Gerald Pfeifer  <gerald@pfeifer.com>
 
 	PR target/49817
--- a/libiberty/cp-demangle.c
+++ b/libiberty/cp-demangle.c
@@ -1,5 +1,5 @@
 /* Demangler for g++ V3 ABI.
-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
    Free Software Foundation, Inc.
    Written by Ian Lance Taylor <ian@wasabisystems.com>.
 
@@ -3306,6 +3306,7 @@ d_print_init (struct d_print_info *dpi, demangle_callbackref callback,
   dpi->last_char = '\0';
   dpi->templates = NULL;
   dpi->modifiers = NULL;
+  dpi->pack_index = 0;
   dpi->flush_count = 0;
 
   dpi->callback = callback;
@@ -3893,6 +3894,13 @@ d_print_comp (struct d_print_info *dpi, int options,
 	    struct demangle_component *a = d_lookup_template_argument (dpi, sub);
 	    if (a && a->type == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)
 	      a = d_index_template_argument (a, dpi->pack_index);
+
+	    if (a == NULL)
+	      {
+		d_print_error (dpi);
+		return;
+	      }
+
 	    sub = a;
 	  }
 
--- a/libiberty/testsuite/demangle-expected
+++ b/libiberty/testsuite/demangle-expected
@@ -4010,6 +4010,12 @@ K<1, &S::m>::f()
 _ZN1KILi1EXadL_ZN1S1mEEEE1fEv
 K<1, &S::m>::f()
 #
+# Used to crash -- binutils PR 13030.
+--format=gnu-v3
+_ZSt10_ConstructI10CellBorderIS0_EEvPT_DpOT0_
+_ZSt10_ConstructI10CellBorderIS0_EEvPT_DpOT0_
+_ZSt10_ConstructI10CellBorderIS0_EEvPT_DpOT0_
+#
 # Ada (GNAT) tests.
 #
 # Simple test.



http://sourceware.org/ml/gdb-cvs/2011-08/msg00047.html

### src/gdb/ChangeLog	2011/08/08 21:41:12	1.13259
### src/gdb/ChangeLog	2011/08/09 12:45:39	1.13260
## -1,3 +1,13 @@
+2011-08-09  Phil Muldoon  <pmuldoon@redhat.com>
+
+	* python/lib/gdb/__init__.py: Auto-load files in command and
+	function directories.
+	* python/python.c (finish_python_initialization): Use
+	os.path.join.
+	* python/lib/gdb/command/pretty_printers.py: Self register
+	command.
+	* NEWS: Document auto-loading.
+
 2011-08-08  Jan Kratochvil  <jan.kratochvil@redhat.com>
 
 	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full) <DWARF_VALUE_STACK>
--- src/gdb/NEWS	2011/07/26 20:57:53	1.446
+++ src/gdb/NEWS	2011/08/09 12:45:39	1.447
@@ -23,6 +23,11 @@
   ** A prompt subsitution hook (prompt_hook) is now available to the
      Python API.
 
+  ** Python commands and convenience-functions located in
+    'data-directory'/python/gdb/command and
+    'data-directory'/python/gdb/function are now automatically loaded
+     on GDB start-up.
+
 * libthread-db-search-path now supports two special values: $sdir and $pdir.
   $sdir specifies the default system locations of shared libraries.
   $pdir specifies the directory where the libpthread used by the application
### src/gdb/doc/ChangeLog	2011/07/26 16:59:23	1.1202
### src/gdb/doc/ChangeLog	2011/08/09 12:45:39	1.1203
## -1,3 +1,8 @@
+2011-08-09  Phil Muldoon  <pmuldoon@redhat.com>
+
+	* gdb.texinfo (Python): Document command and function
+	auto-loading.
+
 2011-07-26  Jan Kratochvil  <jan.kratochvil@redhat.com>
 	    Eli Zaretskii  <eliz@gnu.org>
 
--- src/gdb/doc/gdb.texinfo	2011/07/26 20:57:54	1.851
+++ src/gdb/doc/gdb.texinfo	2011/08/09 12:45:39	1.852
@@ -20845,6 +20845,12 @@
 is automatically added to the Python Search Path in order to allow
 the Python interpreter to locate all scripts installed at this location.
 
+Additionally, @value{GDBN} commands and convenience functions which
+are written in Python and are located in the
+@file{@var{data-directory}/python/gdb/command} or
+@file{@var{data-directory}/python/gdb/function} directories are
+automatically imported when @value{GDBN} starts.
+
 @menu
 * Python Commands::             Accessing Python from @value{GDBN}.
 * Python API::                  Accessing @value{GDBN} from Python.
--- src/gdb/python/python.c	2011/07/22 09:22:50	1.68
+++ src/gdb/python/python.c	2011/08/09 12:45:40	1.69
@@ -1302,13 +1302,13 @@
   sys.path.insert (0, gdb.PYTHONDIR)\n\
 \n\
   # Tell python where to find submodules of gdb.\n\
-  gdb.__path__ = [gdb.PYTHONDIR + '/gdb']\n\
+  gdb.__path__ = [os.path.join (gdb.PYTHONDIR, 'gdb')]\n\
 \n\
   # The gdb module is implemented in C rather than in Python.  As a result,\n\
   # the associated __init.py__ script is not not executed by default when\n\
   # the gdb module gets imported.  Execute that script manually if it\n\
   # exists.\n\
-  ipy = gdb.PYTHONDIR + '/gdb/__init__.py'\n\
+  ipy = os.path.join (gdb.PYTHONDIR, 'gdb', '__init__.py')\n\
   if os.path.exists (ipy):\n\
     execfile (ipy)\n\
 \n\
--- src/gdb/python/lib/gdb/__init__.py	2011/01/01 15:33:26	1.3
+++ src/gdb/python/lib/gdb/__init__.py	2011/08/09 12:45:40	1.4
@@ -13,6 +13,29 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-import gdb.command.pretty_printers
+import traceback
 
-gdb.command.pretty_printers.register_pretty_printer_commands()
+# Auto-load all functions/commands.
+
+# Modules to auto-load, and the paths where those modules exist.
+
+module_dict = {
+  'gdb.function': os.path.join(gdb.PYTHONDIR, 'gdb', 'function'),
+  'gdb.command': os.path.join(gdb.PYTHONDIR, 'gdb', 'command')
+}
+
+# Iterate the dictionary, collating the Python files in each module
+# path.  Construct the module name, and import.
+
+for module, location in module_dict.iteritems():
+  if os.path.exists(location):
+     py_files = filter(lambda x: x.endswith('.py') and x != '__init__.py',
+                       os.listdir(location))
+
+     for py_file in py_files:
+       # Construct from foo.py, gdb.module.foo
+       py_file = module + '.' + py_file[:-3]
+       try:
+         exec('import ' + py_file)
+       except:
+         print >> sys.stderr, traceback.format_exc()
--- src/gdb/python/lib/gdb/command/pretty_printers.py	2011/01/01 15:33:27	1.4
+++ src/gdb/python/lib/gdb/command/pretty_printers.py	2011/08/09 12:45:40	1.5
@@ -368,3 +368,5 @@
     InfoPrettyPrinter()
     EnablePrettyPrinter()
     DisablePrettyPrinter()
+
+register_pretty_printer_commands()



http://sourceware.org/ml/gdb-patches/2011-08/msg00505.html
Subject: fix "info os processes" race -> crash (ext-run.exp racy FAIL)
http://sourceware.org/ml/gdb-cvs/2011-08/msg00116.html

### src/gdb/ChangeLog	2011/08/26 17:58:57	1.13281
### src/gdb/ChangeLog	2011/08/26 18:58:02	1.13282
## -1,3 +1,8 @@
+2011-08-26  Pedro Alves  <pedro@codesourcery.com>
+
+	* common/linux-osdata.c (get_cores_used_by_process): Don't assume
+	opening /proc/PID/task always succeeds.
+
 2011-08-26  Aleksandar Ristovski <aristovski@qnx.com>
 
 	* linespec.c (symtab_from_filename): Check for the end of string.
--- src/gdb/common/linux-osdata.c	2011/07/21 23:46:09	1.1
+++ src/gdb/common/linux-osdata.c	2011/08/26 18:58:04	1.2
@@ -259,27 +259,29 @@
 
   sprintf (taskdir, "/proc/%d/task", pid);
   dir = opendir (taskdir);
-
-  while ((dp = readdir (dir)) != NULL)
+  if (dir)
     {
-      pid_t tid;
-      int core;
+      while ((dp = readdir (dir)) != NULL)
+	{
+	  pid_t tid;
+	  int core;
 
-      if (!isdigit (dp->d_name[0])
-	  || NAMELEN (dp) > sizeof ("4294967295") - 1)
-	continue;
+	  if (!isdigit (dp->d_name[0])
+	      || NAMELEN (dp) > sizeof ("4294967295") - 1)
+	    continue;
 
-      tid = atoi (dp->d_name);
-      core = linux_common_core_of_thread (ptid_build (pid, tid, 0));
+	  tid = atoi (dp->d_name);
+	  core = linux_common_core_of_thread (ptid_build (pid, tid, 0));
 
-      if (core >= 0)
-	{
-	  ++cores[core];
-	  ++task_count;
+	  if (core >= 0)
+	    {
+	      ++cores[core];
+	      ++task_count;
+	    }
 	}
-    }
 
-  closedir (dir);
+      closedir (dir);
+    }
 
   return task_count;
 }



Fix for https://bugzilla.redhat.com/show_bug.cgi?id=750341
http://sourceware.org/ml/gdb-patches/2011-10/msg00570.html


http://sourceware.org/ml/gdb-cvs/2011-10/msg00154.html

### src/gdb/ChangeLog	2011/10/20 13:34:13	1.13446
### src/gdb/ChangeLog	2011/10/20 20:06:11	1.13447
## -1,3 +1,15 @@
+2011-10-20  Aleksandar Ristovski  <aristovski@qnx.com>
+
+	* cp-namespace.c (cp_scan_for_anonymous_namespaces): Changed function
+	arguments by adding OBJFILE.  Instead of getting objfile from
+	symbol's symtab, use new argument OBJFILE.
+	* cp-support.h (cp_scan_for_anonymous_namespaces): Changed function
+	arguments by adding OBJFILE.
+	* gdb/dwarf2read.c (new_symbol_full): Change call to
+	cp_scan_for_anonymous_namespaces to match new signature.
+	* gdb/stabsread.c (define_symbol): Change call to
+	cp_scan_for_anonymous_namespaces to match new signature.
+
 2011-10-20  Phil Muldoon  <pmuldoon@redhat.com>
 
         PR python/13308
--- src/gdb/cp-namespace.c	2011/06/29 22:05:15	1.54
+++ src/gdb/cp-namespace.c	2011/10/20 20:06:13	1.55
@@ -53,7 +53,8 @@
    anonymous namespace; if so, add an appropriate using directive.  */
 
 void
-cp_scan_for_anonymous_namespaces (const struct symbol *symbol)
+cp_scan_for_anonymous_namespaces (const struct symbol *const symbol,
+				  struct objfile *const objfile)
 {
   if (SYMBOL_DEMANGLED_NAME (symbol) != NULL)
     {
@@ -96,7 +97,7 @@
 		 namespace given by the previous component if there is
 		 one, or to the global namespace if there isn't.  */
 	      cp_add_using_directive (dest, src, NULL, NULL, NULL,
-	                              &SYMBOL_SYMTAB (symbol)->objfile->objfile_obstack);
+	                              &objfile->objfile_obstack);
 	    }
 	  /* The "+ 2" is for the "::".  */
 	  previous_component = next_component + 2;
--- src/gdb/cp-support.h	2011/08/18 16:17:38	1.45
+++ src/gdb/cp-support.h	2011/10/20 20:06:13	1.46
@@ -197,7 +197,8 @@
 				const char *processing_current_prefix,
 				int processing_has_namespace_info);
 
-extern void cp_scan_for_anonymous_namespaces (const struct symbol *symbol);
+extern void cp_scan_for_anonymous_namespaces (const struct symbol *symbol,
+					      struct objfile *objfile);
 
 extern struct symbol *cp_lookup_symbol_nonlocal (const char *name,
 						 const struct block *block,
--- src/gdb/dwarf2read.c	2011/10/20 01:11:34	1.576
+++ src/gdb/dwarf2read.c	2011/10/20 20:06:13	1.577
@@ -11992,7 +11992,7 @@
 	 namespaces based on the demangled name.  */
       if (!processing_has_namespace_info
 	  && cu->language == language_cplus)
-	cp_scan_for_anonymous_namespaces (sym);
+	cp_scan_for_anonymous_namespaces (sym, objfile);
     }
   return (sym);
 }
--- src/gdb/stabsread.c	2011/05/18 16:30:36	1.138
+++ src/gdb/stabsread.c	2011/10/20 20:06:14	1.139
@@ -729,7 +729,7 @@
 	SYMBOL_SET_NAMES (sym, string, p - string, 1, objfile);
 
       if (SYMBOL_LANGUAGE (sym) == language_cplus)
-	cp_scan_for_anonymous_namespaces (sym);
+	cp_scan_for_anonymous_namespaces (sym, objfile);
 
     }
   p++;
