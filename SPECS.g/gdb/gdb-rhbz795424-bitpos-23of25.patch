http://sourceware.org/ml/gdb-patches/2012-09/msg00630.html
Subject: [PATCH 4/4] Bitpos expansion - tdep changes


--MP_/X_WjDOvz/B_fvlsrmCwRdxe
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Hi,

This is the last part of the bitpos change.  This patch does the same
thing that patch 1/4 does, except that it does so in the *-tdep files
wherever necessary.  I separated these changes mainly because they are
related and can be reviewed independently.  Tested on Fedora 16 x86_64.

Regards,
Siddhesh

--MP_/X_WjDOvz/B_fvlsrmCwRdxe
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename=ChangeLog-tdep

gdb/ChangeLog

	* alpha-tdep.c (alpha_push_dummy_call): Expand ACCUMULATE_SIZE,
	REQUIRED_ARG_REGS, OFFSET, LEN, TLEN to ssize_t.
	(struct alpha_arg): Expand members LEN, OFFSET to ssize_t.
	* amd64-tdep.c (amd64_push_arguments): Expand NUM_ELEMENTS,
	ELEMENT and LEN to LONGEST.
	(amd64_return_value): Expand LEN to LONGEST.
	* amd64-windows-tdep.c (amd64_windows_return_value): Expand LEN
	to LONGEST.
	* arm-tdep.c (arm_vfp_cprc_sub_candidate): Return LONGEST.
	Expand COUNT, SUB_COUNT to LONGEST.
	(arm_vfp_call_candidate): Expand C to LONGEST.
	(arm_push_dummy_call): Expand LEN to LONGEST.
	* avr-tdep.c (struct stack_item): Expand member LEN to ssize_t.
	(push_stack_item): Expand parameter LEN to ssize_t.
	(avr_push_dummy_call): Expand LAST_REGNUM, J, LEN to ssize_t.
	* bfin-tdep.c (bfin_push_dummy_call): Expand TOTAL_LEN,
	CONTAINER_LEN to ssize_t.
	* cris-tdep.c (struct stack_item): Expand member LEN to ssize_t.
	(push_stack_item): Expand parameter LEN to ssize_t.
	(cris_push_dummy_call): Expand LEN, REG_DEMAND, I to ssize_t.
	* h8300-tdep.c (h8300_push_dummy_call): Expand STACK_ALLOC,
	STACK_OFFSET to LONGEST.  Expand LEN, PADDED_LEN, OFFSET to
	ssize_t.
	* hppa-tdep.c (hppa64_push_dummy_call): Expand LEN to LONGEST.
	(hppa64_return_value): Likewise.
	* i386-darwin-tdep.c (i386_darwin_push_dummy_call): Expand
	ARGS_SPACE to LONGEST.
	* i386-tdep.c (i386_push_dummy_call): Expand ARG_SPACE,
	ARG_SPACE_USED, LEN to LONGEST.
	(i386_reg_struct_return_p): Expand LEN to LONGEST.
	(i386_convert_register_p): Likewise.
	(i386_register_to_value): Likewise.
	(i386_value_to_register): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Expand ARGOFFSET, LEN,
	NSLOTS, MEMSLOTS to LONGEST.
	* iq2000-tdep.c (iq2000_push_dummy_call): Expand TYPELEN,
	STACKSPACE to LONGEST.
	* m32r-tdep.c (m32r_push_dummy_call): Expand LEN to LONGEST.
	* m68k-tdep.c (m68k_reg_struct_return_p): Expand LEN to LONGEST.
	(m68k_push_dummy_call): Expand LEN, CONTAINER_LEN, OFFSET to
	LONGEST.
	* m88k-tdep.c (m88k_store_arguments): Expand NUM_STACK_WORDS,
	LEN, STACK_WORD to LONGEST.
	* mep-tdep.c (push_large_arguments): Expand ARG_LEN to ULONGEST.
	* microblaze-tdep.c (microblaze_store_return_value): Expand LEN to
	LONGEST.
	* mips-tdep.c (mips_xfer_register): Expand parameter BUF_OFFSET to
	LONGEST.  Use plongest to format print BUF_OFFSET.
	(mips_eabi_push_dummy_call): Expand LEN to LONGEST.  Use plongest
	to format print LEN.
	(mips_n32n64_fp_arg_chunk_p): Expand parameter OFFSET to LONGEST.
	Expand POS to LONGEST.
	(mips_n32n64_push_dummy_call): Expand LEN to LONGEST.
	(mips_n32n64_return_value): Expand OFFSET to LONGEST.  Use
	plongest to format print OFFSET.
	(mips_o32_push_dummy_call): Expand LEN to LONGEST.  Use plongest
	to format print LEN.
	(mips_o64_push_dummy_call): Expand LEN, STACK_OFFSET to LONGEST.
	Use plongest to format print LEN.
	* mn10300-tdep.c (mn10300_push_dummy_call): Expand LEN to
	LONGEST.
	* mt-tdep.c (mt_push_dummy_call): Expand STACK_DEST, TYPELEN to
	LONGEST.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Expand
	ARGSPACE, ARGOFFSET, STRUCTOFFSET, LEN, to LONGEST.
	(ppc64_sysv_abi_push_dummy_call): Expand BYTE, LEN to ssize_t.
	* rl78-tdep.c (rl78_push_dummy_call): Expand LEN, CONTAINER_LEN
	to LONGEST.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call): Expand ARGBYTES,
	LEN to LONGEST.
	(ran_out_of_registers_for_arguments): Expand SPACE, JJ to
	LONGEST.
	* s390-linux-tdep.c (s390_value_from_register): Expand LEN to LONGEST.
	(is_power_of_two): Expand parameter N to ULONGEST.
	(s390_push_dummy_call): Expand LENGTH to ULONGEST.
	* score-tdep.c (score_push_dummy_call): Expand ARGLEN to
	LONGEST.
	* sh-tdep.c (sh_use_struct_convention) Expand len to LONGEST.
	(sh_justify_value_in_reg): Expand parameter LEN to LONGEST.
	(sh_push_dummy_call_fpu): Expand LEN to LONGEST.  Expand REG_SIZE
	to ssize_t.
	(sh_push_dummy_call_nofpu): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call): Expand STACK_OFFSET,
	STACK_ALLOC, LEN to LONGEST.
	* sparc-tdep.c (sparc32_store_arguments): Expand LEN to LONGEST.
	* sparc64-tdep.c (sparc64_store_floating_fields): Expand
	parameter BITPOS to LONGEST.  Expand SUBPOS to LONGEST.
	(sparc64_extract_floating_fields): Likewise.
	(sparc64_store_arguments): Expand LEN to LONGEST.
	* spu-tdep.c (spu_push_dummy_call): Expand N_REGS, LEN to LONGEST.
	(spu_value_from_register): Expand LEN to LONGEST.
	* tic6x-tdep.c (tic6x_push_dummy_call): Expand REFERENCES_OFFST,
	LEN to LONGEST.  Expand LEN to ssize_t.  Use plongest to format
	print LEN.
	* tilegx-tdep.c (tilegx_push_dummy_call): Expand TYPELEN,
	SLACKLEN, ALIGNLEN to LONGEST.
	* v850-tdep.c (v850_push_dummy_call): Expand LEN to LONGEST.
	* vax-tdep.c (vax_store_arguments): Expand COUNT, LEN to LONGEST.
	(vax_return_value): Expand LEN to LONGEST.
	* xstormy16-tdep.c (xstormy16_push_dummy_call): Expand J, TYPELEN
	to LONGEST.
	* xtensa-tdep.c (xtensa_store_return_value): Print LEN instead of
	TYPE_LENGTH..
	(struct argument_info): Expoand member LENGTH to ssize_t.
	(struct argument_info.u): Expand member OFFSET to ssize_t.
	(xtensa_push_dummy_call): Expand SIZE, ONSTACK_SIZE to LONGEST.
	Expand N to ssize_t.  Use pulongest to format print TYPE_LENGTH.

--MP_/X_WjDOvz/B_fvlsrmCwRdxe
Content-Type: text/x-patch
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment; filename=bitpos-tdep.patch

Index: gdb-7.6.90.20140127/gdb/alpha-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/alpha-tdep.c	2014-02-06 18:20:52.970747716 +0100
+++ gdb-7.6.90.20140127/gdb/alpha-tdep.c	2014-02-06 18:20:57.294752362 +0100
@@ -299,18 +299,18 @@ alpha_push_dummy_call (struct gdbarch *g
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   int i;
-  int accumulate_size = struct_return ? 8 : 0;
+  ssize_t accumulate_size = struct_return ? 8 : 0;
   struct alpha_arg
     {
       const gdb_byte *contents;
-      int len;
-      int offset;
+      ssize_t len;
+      ssize_t offset;
     };
   struct alpha_arg *alpha_args
     = (struct alpha_arg *) alloca (nargs * sizeof (struct alpha_arg));
   struct alpha_arg *m_arg;
   gdb_byte arg_reg_buffer[ALPHA_REGISTER_SIZE * ALPHA_NUM_ARG_REGS];
-  int required_arg_regs;
+  ssize_t required_arg_regs;
   CORE_ADDR func_addr = find_function_addr (function, NULL);
 
   /* The ABI places the address of the called function in T12.  */
@@ -430,8 +430,8 @@ alpha_push_dummy_call (struct gdbarch *g
   for (i = nargs; m_arg--, --i >= 0;)
     {
       const gdb_byte *contents = m_arg->contents;
-      int offset = m_arg->offset;
-      int len = m_arg->len;
+      ssize_t offset = m_arg->offset;
+      ssize_t len = m_arg->len;
 
       /* Copy the bytes destined for registers into arg_reg_buffer.  */
       if (offset < sizeof(arg_reg_buffer))
@@ -443,7 +443,7 @@ alpha_push_dummy_call (struct gdbarch *g
 	    }
 	  else
 	    {
-	      int tlen = sizeof(arg_reg_buffer) - offset;
+	      ssize_t tlen = sizeof(arg_reg_buffer) - offset;
 	      memcpy (arg_reg_buffer + offset, contents, tlen);
 	      offset += tlen;
 	      contents += tlen;
Index: gdb-7.6.90.20140127/gdb/amd64-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/amd64-tdep.c	2014-02-06 18:20:52.972747718 +0100
+++ gdb-7.6.90.20140127/gdb/amd64-tdep.c	2014-02-06 18:21:51.106810814 +0100
@@ -633,7 +633,7 @@ amd64_return_value (struct gdbarch *gdba
 		    gdb_byte *readbuf, const gdb_byte *writebuf)
 {
   enum amd64_reg_class class[2];
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
   static int integer_regnum[] = { AMD64_RAX_REGNUM, AMD64_RDX_REGNUM };
   static int sse_regnum[] = { AMD64_XMM0_REGNUM, AMD64_XMM1_REGNUM };
   int integer_reg = 0;
@@ -784,8 +784,8 @@ amd64_push_arguments (struct regcache *r
   };
   struct value **stack_args = alloca (nargs * sizeof (struct value *));
   int num_stack_args = 0;
-  int num_elements = 0;
-  int element = 0;
+  LONGEST num_elements = 0;
+  LONGEST element = 0;
   int integer_reg = 0;
   int sse_reg = 0;
   int i;
@@ -797,7 +797,7 @@ amd64_push_arguments (struct regcache *r
   for (i = 0; i < nargs; i++)
     {
       struct type *type = value_type (args[i]);
-      int len = TYPE_LENGTH (type);
+      LONGEST len = TYPE_LENGTH (type);
       enum amd64_reg_class class[2];
       int needed_integer_regs = 0;
       int needed_sse_regs = 0;
Index: gdb-7.6.90.20140127/gdb/amd64-windows-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/amd64-windows-tdep.c	2014-02-06 18:20:52.973747720 +0100
+++ gdb-7.6.90.20140127/gdb/amd64-windows-tdep.c	2014-02-06 18:20:57.296752364 +0100
@@ -288,7 +288,7 @@ amd64_windows_return_value (struct gdbar
 			    struct type *type, struct regcache *regcache,
 			    gdb_byte *readbuf, const gdb_byte *writebuf)
 {
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
   int regnum = -1;
 
   /* See if our value is returned through a register.  If it is, then
Index: gdb-7.6.90.20140127/gdb/arm-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/arm-tdep.c	2014-02-06 18:20:52.978747725 +0100
+++ gdb-7.6.90.20140127/gdb/arm-tdep.c	2014-02-06 18:20:57.299752367 +0100
@@ -3498,7 +3498,7 @@ arm_vfp_cprc_reg_char (enum arm_vfp_cprc
    array).  Vectors and complex types are not currently supported,
    matching the generic AAPCS support.  */
 
-static int
+static LONGEST
 arm_vfp_cprc_sub_candidate (struct type *t,
 			    enum arm_vfp_cprc_base_type *base_type)
 {
@@ -3529,7 +3529,7 @@ arm_vfp_cprc_sub_candidate (struct type
 
     case TYPE_CODE_ARRAY:
       {
-	int count;
+	LONGEST count;
 	unsigned unitlen;
 	count = arm_vfp_cprc_sub_candidate (TYPE_TARGET_TYPE (t), base_type);
 	if (count == -1)
@@ -3549,13 +3549,15 @@ arm_vfp_cprc_sub_candidate (struct type
 
     case TYPE_CODE_STRUCT:
       {
-	int count = 0;
+	LONGEST count = 0;
 	unsigned unitlen;
 	int i;
 	for (i = 0; i < TYPE_NFIELDS (t); i++)
 	  {
-	    int sub_count = arm_vfp_cprc_sub_candidate (TYPE_FIELD_TYPE (t, i),
-							base_type);
+	    LONGEST sub_count;
+
+	    sub_count = arm_vfp_cprc_sub_candidate (TYPE_FIELD_TYPE (t, i),
+						    base_type);
 	    if (sub_count == -1)
 	      return -1;
 	    count += sub_count;
@@ -3575,13 +3577,15 @@ arm_vfp_cprc_sub_candidate (struct type
 
     case TYPE_CODE_UNION:
       {
-	int count = 0;
+	LONGEST count = 0;
 	unsigned unitlen;
 	int i;
 	for (i = 0; i < TYPE_NFIELDS (t); i++)
 	  {
-	    int sub_count = arm_vfp_cprc_sub_candidate (TYPE_FIELD_TYPE (t, i),
-							base_type);
+	    LONGEST sub_count;
+
+	    sub_count = arm_vfp_cprc_sub_candidate (TYPE_FIELD_TYPE (t, i),
+						    base_type);
 	    if (sub_count == -1)
 	      return -1;
 	    count = (count > sub_count ? count : sub_count);
@@ -3617,7 +3621,7 @@ arm_vfp_call_candidate (struct type *t,
 			int *count)
 {
   enum arm_vfp_cprc_base_type b = VFP_CPRC_UNKNOWN;
-  int c = arm_vfp_cprc_sub_candidate (t, &b);
+  LONGEST c = arm_vfp_cprc_sub_candidate (t, &b);
   if (c <= 0 || c > 4)
     return 0;
   *base_type = b;
@@ -3698,7 +3702,7 @@ arm_push_dummy_call (struct gdbarch *gdb
 
   for (argnum = 0; argnum < nargs; argnum++)
     {
-      int len;
+      LONGEST len;
       struct type *arg_type;
       struct type *target_type;
       enum type_code typecode;
Index: gdb-7.6.90.20140127/gdb/avr-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/avr-tdep.c	2014-02-06 18:20:52.980747727 +0100
+++ gdb-7.6.90.20140127/gdb/avr-tdep.c	2014-02-06 18:20:57.299752367 +0100
@@ -1167,13 +1167,14 @@ avr_dummy_id (struct gdbarch *gdbarch, s
 
 struct stack_item
 {
-  int len;
+  ssize_t len;
   struct stack_item *prev;
   void *data;
 };
 
 static struct stack_item *
-push_stack_item (struct stack_item *prev, const bfd_byte *contents, int len)
+push_stack_item (struct stack_item *prev, const bfd_byte *contents,
+		 ssize_t len)
 {
   struct stack_item *si;
   si = xmalloc (sizeof (struct stack_item));
@@ -1262,12 +1263,12 @@ avr_push_dummy_call (struct gdbarch *gdb
 
   for (i = 0; i < nargs; i++)
     {
-      int last_regnum;
-      int j;
+      ssize_t last_regnum;
+      ssize_t j;
       struct value *arg = args[i];
       struct type *type = check_typedef (value_type (arg));
       const bfd_byte *contents = value_contents (arg);
-      int len = TYPE_LENGTH (type);
+      ssize_t len = TYPE_LENGTH (type);
 
       /* Calculate the potential last register needed.  */
       last_regnum = regnum - (len + (len & 1));
Index: gdb-7.6.90.20140127/gdb/bfin-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/bfin-tdep.c	2014-02-06 18:20:52.980747727 +0100
+++ gdb-7.6.90.20140127/gdb/bfin-tdep.c	2014-02-06 18:20:57.300752368 +0100
@@ -506,7 +506,7 @@ bfin_push_dummy_call (struct gdbarch *gd
   gdb_byte buf[4];
   int i;
   long reg_r0, reg_r1, reg_r2;
-  int total_len = 0;
+  ssize_t total_len = 0;
   enum bfin_abi abi = bfin_abi (gdbarch);
   CORE_ADDR func_addr = find_function_addr (function, NULL);
 
@@ -530,7 +530,7 @@ bfin_push_dummy_call (struct gdbarch *gd
     {
       struct type *value_type = value_enclosing_type (args[i]);
       struct type *arg_type = check_typedef (value_type);
-      int container_len = (TYPE_LENGTH (value_type) + 3) & ~3;
+      ssize_t container_len = (TYPE_LENGTH (value_type) + 3) & ~3;
 
       sp -= container_len;
       write_memory (sp, value_contents_writeable (args[i]), container_len);
Index: gdb-7.6.90.20140127/gdb/cris-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/cris-tdep.c	2014-02-06 18:20:52.981747728 +0100
+++ gdb-7.6.90.20140127/gdb/cris-tdep.c	2014-02-06 18:20:57.301752369 +0100
@@ -665,13 +665,13 @@ static CORE_ADDR cris_unwind_sp (struct
 
 struct stack_item
 {
-  int len;
+  ssize_t len;
   struct stack_item *prev;
   void *data;
 };
 
 static struct stack_item *
-push_stack_item (struct stack_item *prev, const gdb_byte *contents, int len)
+push_stack_item (struct stack_item *prev, const gdb_byte *contents, ssize_t len)
 {
   struct stack_item *si;
   si = xmalloc (sizeof (struct stack_item));
@@ -844,13 +844,13 @@ cris_push_dummy_call (struct gdbarch *gd
 
   for (argnum = 0; argnum < nargs; argnum++)
     {
-      int len;
+      ssize_t len;
       const gdb_byte *val;
-      int reg_demand;
-      int i;
+      ssize_t reg_demand;
+      ssize_t i;
       
-      len = TYPE_LENGTH (value_type (args[argnum]));
       val = value_contents (args[argnum]);
+      len = TYPE_LENGTH (value_type (args[argnum]));
       
       /* How may registers worth of storage do we need for this argument?  */
       reg_demand = (len / 4) + (len % 4 != 0 ? 1 : 0);
Index: gdb-7.6.90.20140127/gdb/h8300-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/h8300-tdep.c	2014-02-06 18:20:52.981747728 +0100
+++ gdb-7.6.90.20140127/gdb/h8300-tdep.c	2014-02-06 18:20:57.301752369 +0100
@@ -640,7 +640,7 @@ h8300_push_dummy_call (struct gdbarch *g
 		       int struct_return, CORE_ADDR struct_addr)
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  int stack_alloc = 0, stack_offset = 0;
+  LONGEST stack_alloc = 0, stack_offset = 0;
   int wordsize = BINWORD (gdbarch);
   int reg = E_ARG0_REGNUM;
   int argument;
@@ -667,11 +667,11 @@ h8300_push_dummy_call (struct gdbarch *g
     {
       struct cleanup *back_to;
       struct type *type = value_type (args[argument]);
-      int len = TYPE_LENGTH (type);
       char *contents = (char *) value_contents (args[argument]);
+      ssize_t len = TYPE_LENGTH (type);
 
       /* Pad the argument appropriately.  */
-      int padded_len = align_up (len, wordsize);
+      ssize_t padded_len = align_up (len, wordsize);
       gdb_byte *padded = xmalloc (padded_len);
       back_to = make_cleanup (xfree, padded);
 
@@ -700,7 +700,7 @@ h8300_push_dummy_call (struct gdbarch *g
 	      /* Heavens to Betsy --- it's really going in registers!
 	         Note that on the h8/300s, there are gaps between the
 	         registers in the register file.  */
-	      int offset;
+	      ssize_t offset;
 
 	      for (offset = 0; offset < padded_len; offset += wordsize)
 		{
Index: gdb-7.6.90.20140127/gdb/hppa-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/hppa-tdep.c	2014-02-06 18:20:52.982747729 +0100
+++ gdb-7.6.90.20140127/gdb/hppa-tdep.c	2014-02-06 18:20:57.302752371 +0100
@@ -961,7 +961,7 @@ hppa64_push_dummy_call (struct gdbarch *
     {
       struct value *arg = args[i];
       struct type *type = value_type (arg);
-      int len = TYPE_LENGTH (type);
+      LONGEST len = TYPE_LENGTH (type);
       const bfd_byte *valbuf;
       bfd_byte fptrbuf[8];
       int regnum;
@@ -1156,7 +1156,7 @@ hppa64_return_value (struct gdbarch *gdb
 		     struct type *type, struct regcache *regcache,
 		     gdb_byte *readbuf, const gdb_byte *writebuf)
 {
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
   int regnum, offset;
 
   if (len > 16)
Index: gdb-7.6.90.20140127/gdb/i386-darwin-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/i386-darwin-tdep.c	2014-02-06 18:20:52.982747729 +0100
+++ gdb-7.6.90.20140127/gdb/i386-darwin-tdep.c	2014-02-06 18:20:57.302752371 +0100
@@ -164,7 +164,7 @@ i386_darwin_push_dummy_call (struct gdba
 
   for (write_pass = 0; write_pass < 2; write_pass++)
     {
-      int args_space = 0;
+      LONGEST args_space = 0;
       int num_m128 = 0;
 
       if (struct_return)
Index: gdb-7.6.90.20140127/gdb/i386-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/i386-tdep.c	2014-02-06 18:20:52.985747732 +0100
+++ gdb-7.6.90.20140127/gdb/i386-tdep.c	2014-02-06 18:20:57.303752372 +0100
@@ -2473,7 +2473,7 @@ i386_push_dummy_call (struct gdbarch *gd
   gdb_byte buf[4];
   int i;
   int write_pass;
-  int args_space = 0;
+  LONGEST args_space = 0;
 
   /* Determine the total space required for arguments and struct
      return address in a first pass (allowing for 16-byte-aligned
@@ -2481,7 +2481,7 @@ i386_push_dummy_call (struct gdbarch *gd
 
   for (write_pass = 0; write_pass < 2; write_pass++)
     {
-      int args_space_used = 0;
+      LONGEST args_space_used = 0;
 
       if (struct_return)
 	{
@@ -2498,7 +2498,7 @@ i386_push_dummy_call (struct gdbarch *gd
 
       for (i = 0; i < nargs; i++)
 	{
-	  int len = TYPE_LENGTH (value_enclosing_type (args[i]));
+	  LONGEST len = TYPE_LENGTH (value_enclosing_type (args[i]));
 
 	  if (write_pass)
 	    {
@@ -2705,7 +2705,7 @@ i386_reg_struct_return_p (struct gdbarch
 {
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
   enum type_code code = TYPE_CODE (type);
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
 
   gdb_assert (code == TYPE_CODE_STRUCT
               || code == TYPE_CODE_UNION
@@ -3249,7 +3249,7 @@ static int
 i386_convert_register_p (struct gdbarch *gdbarch,
 			 int regnum, struct type *type)
 {
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
 
   /* Values may be spread across multiple registers.  Most debugging
      formats aren't expressive enough to specify the locations, so
@@ -3282,7 +3282,7 @@ i386_register_to_value (struct frame_inf
 			int *optimizedp, int *unavailablep)
 {
   struct gdbarch *gdbarch = get_frame_arch (frame);
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
 
   if (i386_fp_regnum_p (gdbarch, regnum))
     return i387_register_to_value (frame, regnum, type, to,
@@ -3318,7 +3318,7 @@ static void
 i386_value_to_register (struct frame_info *frame, int regnum,
 			struct type *type, const gdb_byte *from)
 {
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
 
   if (i386_fp_regnum_p (get_frame_arch (frame), regnum))
     {
Index: gdb-7.6.90.20140127/gdb/ia64-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/ia64-tdep.c	2014-02-06 18:20:52.986747733 +0100
+++ gdb-7.6.90.20140127/gdb/ia64-tdep.c	2014-02-06 18:20:57.304752373 +0100
@@ -3851,8 +3851,10 @@ ia64_push_dummy_call (struct gdbarch *gd
   int argno;
   struct value *arg;
   struct type *type;
-  int len, argoffset;
-  int nslots, rseslots, memslots, slotnum, nfuncargs;
+  LONGEST argoffset;
+  LONGEST len;
+  int rseslots, slotnum, nfuncargs;
+  LONGEST nslots, memslots;
   int floatreg;
   ULONGEST bsp;
   CORE_ADDR funcdescaddr, pc, global_pointer;
Index: gdb-7.6.90.20140127/gdb/iq2000-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/iq2000-tdep.c	2014-02-06 18:20:52.986747733 +0100
+++ gdb-7.6.90.20140127/gdb/iq2000-tdep.c	2014-02-06 18:20:57.304752373 +0100
@@ -654,8 +654,9 @@ iq2000_push_dummy_call (struct gdbarch *
   const bfd_byte *val;
   bfd_byte buf[4];
   struct type *type;
-  int i, argreg, typelen, slacklen;
-  int stackspace = 0;
+  int i, argreg, slacklen;
+  LONGEST typelen;
+  LONGEST stackspace = 0;
   /* Used to copy struct arguments into the stack.  */
   CORE_ADDR struct_ptr;
 
Index: gdb-7.6.90.20140127/gdb/m32r-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/m32r-tdep.c	2014-02-06 18:20:52.986747733 +0100
+++ gdb-7.6.90.20140127/gdb/m32r-tdep.c	2014-02-06 18:20:57.304752373 +0100
@@ -689,7 +689,7 @@ m32r_push_dummy_call (struct gdbarch *gd
   CORE_ADDR regval;
   gdb_byte *val;
   gdb_byte valbuf[MAX_REGISTER_SIZE];
-  int len;
+  LONGEST len;
 
   /* First force sp to a 4-byte alignment.  */
   sp = sp & ~3;
Index: gdb-7.6.90.20140127/gdb/m68k-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/m68k-tdep.c	2014-02-06 18:20:52.987747735 +0100
+++ gdb-7.6.90.20140127/gdb/m68k-tdep.c	2014-02-06 18:20:57.305752374 +0100
@@ -384,7 +384,7 @@ m68k_reg_struct_return_p (struct gdbarch
 {
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
   enum type_code code = TYPE_CODE (type);
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
 
   gdb_assert (code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION
 	      || code == TYPE_CODE_COMPLEX);
@@ -516,9 +516,9 @@ m68k_push_dummy_call (struct gdbarch *gd
   for (i = nargs - 1; i >= 0; i--)
     {
       struct type *value_type = value_enclosing_type (args[i]);
-      int len = TYPE_LENGTH (value_type);
-      int container_len = (len + 3) & ~3;
-      int offset;
+      LONGEST len = TYPE_LENGTH (value_type);
+      LONGEST container_len = (len + 3) & ~3;
+      LONGEST offset;
 
       /* Non-scalars bigger than 4 bytes are left aligned, others are
 	 right aligned.  */
Index: gdb-7.6.90.20140127/gdb/m88k-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/m88k-tdep.c	2014-02-06 18:20:52.987747735 +0100
+++ gdb-7.6.90.20140127/gdb/m88k-tdep.c	2014-02-06 18:20:57.305752374 +0100
@@ -260,13 +260,13 @@ m88k_store_arguments (struct regcache *r
 {
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   int num_register_words = 0;
-  int num_stack_words = 0;
+  LONGEST num_stack_words = 0;
   int i;
 
   for (i = 0; i < nargs; i++)
     {
       struct type *type = value_type (args[i]);
-      int len = TYPE_LENGTH (type);
+      LONGEST len = TYPE_LENGTH (type);
 
       if (m88k_integral_or_pointer_p (type) && len < 4)
 	{
@@ -308,8 +308,8 @@ m88k_store_arguments (struct regcache *r
     {
       const bfd_byte *valbuf = value_contents (args[i]);
       struct type *type = value_type (args[i]);
-      int len = TYPE_LENGTH (type);
-      int stack_word = num_stack_words;
+      LONGEST len = TYPE_LENGTH (type);
+      LONGEST stack_word = num_stack_words;
 
       if (m88k_in_register_p (type))
 	{
Index: gdb-7.6.90.20140127/gdb/mep-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/mep-tdep.c	2014-02-06 18:20:52.987747735 +0100
+++ gdb-7.6.90.20140127/gdb/mep-tdep.c	2014-02-06 18:20:57.306752375 +0100
@@ -2272,7 +2272,7 @@ push_large_arguments (CORE_ADDR sp, int
 
   for (i = 0; i < argc; i++)
     {
-      unsigned arg_len = TYPE_LENGTH (value_type (argv[i]));
+      ULONGEST arg_len = TYPE_LENGTH (value_type (argv[i]));
 
       if (arg_len > MEP_GPR_SIZE)
         {
Index: gdb-7.6.90.20140127/gdb/mips-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/mips-tdep.c	2014-02-06 18:20:52.990747738 +0100
+++ gdb-7.6.90.20140127/gdb/mips-tdep.c	2014-02-06 18:20:57.307752376 +0100
@@ -402,7 +402,7 @@ static void
 mips_xfer_register (struct gdbarch *gdbarch, struct regcache *regcache,
 		    int reg_num, int length,
 		    enum bfd_endian endian, gdb_byte *in,
-		    const gdb_byte *out, int buf_offset)
+		    const gdb_byte *out, LONGEST buf_offset)
 {
   int reg_offset = 0;
 
@@ -425,8 +425,8 @@ mips_xfer_register (struct gdbarch *gdba
     }
   if (mips_debug)
     fprintf_unfiltered (gdb_stderr,
-			"xfer $%d, reg offset %d, buf offset %d, length %d, ",
-			reg_num, reg_offset, buf_offset, length);
+			"xfer $%d, reg offset %d, buf offset %s, length %d, ",
+			reg_num, reg_offset, plongest (buf_offset), length);
   if (mips_debug && out != NULL)
     {
       int i;
@@ -4345,13 +4345,13 @@ mips_eabi_push_dummy_call (struct gdbarc
       gdb_byte valbuf[MAX_REGISTER_SIZE];
       struct value *arg = args[argnum];
       struct type *arg_type = check_typedef (value_type (arg));
-      int len = TYPE_LENGTH (arg_type);
+      LONGEST len = TYPE_LENGTH (arg_type);
       enum type_code typecode = TYPE_CODE (arg_type);
 
       if (mips_debug)
 	fprintf_unfiltered (gdb_stdlog,
-			    "mips_eabi_push_dummy_call: %d len=%d type=%d",
-			    argnum + 1, len, (int) typecode);
+			    "mips_eabi_push_dummy_call: %d len=%s type=%d",
+			    argnum + 1, plongest (len), (int) typecode);
 
       /* Function pointer arguments to mips16 code need to be made into
          mips16 pointers.  */
@@ -4636,7 +4636,7 @@ mips_eabi_return_value (struct gdbarch *
 
 static int
 mips_n32n64_fp_arg_chunk_p (struct gdbarch *gdbarch, struct type *arg_type,
-			    int offset)
+			    LONGEST offset)
 {
   int i;
 
@@ -4651,7 +4651,7 @@ mips_n32n64_fp_arg_chunk_p (struct gdbar
 
   for (i = 0; i < TYPE_NFIELDS (arg_type); i++)
     {
-      int pos;
+      LONGEST pos;
       struct type *field_type;
 
       /* We're only looking at normal fields.  */
@@ -4693,7 +4693,7 @@ mips_n32n64_push_dummy_call (struct gdba
   int argreg;
   int float_argreg;
   int argnum;
-  int len = 0;
+  LONGEST len = 0;
   int stack_offset = 0;
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   CORE_ADDR func_addr = find_function_addr (function, NULL);
@@ -5044,11 +5044,11 @@ mips_n32n64_return_value (struct gdbarch
 				: MIPS_V0_REGNUM);
 	   field < TYPE_NFIELDS (type); field++, regnum += 2)
 	{
-	  int offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field])
-			/ TARGET_CHAR_BIT);
+	  LONGEST offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field])
+			    / TARGET_CHAR_BIT);
 	  if (mips_debug)
-	    fprintf_unfiltered (gdb_stderr, "Return float struct+%d\n",
-				offset);
+	    fprintf_unfiltered (gdb_stderr, "Return float struct+%s\n",
+				plongest (offset));
 	  if (TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)) == 16)
 	    {
 	      /* A 16-byte long double field goes in two consecutive
@@ -5090,8 +5090,8 @@ mips_n32n64_return_value (struct gdbarch
 	  if (offset + xfer > TYPE_LENGTH (type))
 	    xfer = TYPE_LENGTH (type) - offset;
 	  if (mips_debug)
-	    fprintf_unfiltered (gdb_stderr, "Return struct+%d:%d in $%d\n",
-				offset, xfer, regnum);
+	    fprintf_unfiltered (gdb_stderr, "Return struct+%s:%d in $%d\n",
+				plongest (offset), xfer, regnum);
 	  mips_xfer_register (gdbarch, regcache,
 			      gdbarch_num_regs (gdbarch) + regnum,
 			      xfer, BFD_ENDIAN_UNKNOWN, readbuf, writebuf,
@@ -5149,7 +5149,7 @@ mips_o32_push_dummy_call (struct gdbarch
   int argreg;
   int float_argreg;
   int argnum;
-  int len = 0;
+  LONGEST len = 0;
   int stack_offset = 0;
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   CORE_ADDR func_addr = find_function_addr (function, NULL);
@@ -5213,13 +5213,13 @@ mips_o32_push_dummy_call (struct gdbarch
       const gdb_byte *val;
       struct value *arg = args[argnum];
       struct type *arg_type = check_typedef (value_type (arg));
-      int len = TYPE_LENGTH (arg_type);
+      LONGEST len = TYPE_LENGTH (arg_type);
       enum type_code typecode = TYPE_CODE (arg_type);
 
       if (mips_debug)
 	fprintf_unfiltered (gdb_stdlog,
-			    "mips_o32_push_dummy_call: %d len=%d type=%d",
-			    argnum + 1, len, (int) typecode);
+			    "mips_o32_push_dummy_call: %d len=%s type=%d",
+			    argnum + 1, plongest (len), (int) typecode);
 
       val = value_contents (arg);
 
@@ -5677,8 +5677,8 @@ mips_o64_push_dummy_call (struct gdbarch
   int argreg;
   int float_argreg;
   int argnum;
-  int len = 0;
-  int stack_offset = 0;
+  LONGEST len = 0;
+  LONGEST stack_offset = 0;
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   CORE_ADDR func_addr = find_function_addr (function, NULL);
 
@@ -5739,13 +5739,13 @@ mips_o64_push_dummy_call (struct gdbarch
       gdb_byte valbuf[MAX_REGISTER_SIZE];
       struct value *arg = args[argnum];
       struct type *arg_type = check_typedef (value_type (arg));
-      int len = TYPE_LENGTH (arg_type);
+      LONGEST len = TYPE_LENGTH (arg_type);
       enum type_code typecode = TYPE_CODE (arg_type);
 
       if (mips_debug)
 	fprintf_unfiltered (gdb_stdlog,
-			    "mips_o64_push_dummy_call: %d len=%d type=%d",
-			    argnum + 1, len, (int) typecode);
+			    "mips_o64_push_dummy_call: %d len=%s type=%d",
+			    argnum + 1, plongest (len), (int) typecode);
 
       val = value_contents (arg);
 
Index: gdb-7.6.90.20140127/gdb/mn10300-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/mn10300-tdep.c	2014-02-06 18:20:52.991747739 +0100
+++ gdb-7.6.90.20140127/gdb/mn10300-tdep.c	2014-02-06 18:20:57.308752377 +0100
@@ -1227,7 +1227,7 @@ mn10300_push_dummy_call (struct gdbarch
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   const int push_size = register_size (gdbarch, E_PC_REGNUM);
   int regs_used;
-  int len, arg_len; 
+  LONGEST len, arg_len; 
   int stack_offset = 0;
   int argnum;
   const gdb_byte *val;
Index: gdb-7.6.90.20140127/gdb/mt-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/mt-tdep.c	2014-02-06 18:20:52.991747739 +0100
+++ gdb-7.6.90.20140127/gdb/mt-tdep.c	2014-02-06 18:20:57.308752377 +0100
@@ -783,9 +783,9 @@ mt_push_dummy_call (struct gdbarch *gdba
   gdb_byte buf[MT_MAX_STRUCT_SIZE];
   int argreg = MT_1ST_ARGREG;
   int split_param_len = 0;
-  int stack_dest = sp;
+  LONGEST stack_dest = sp;
   int slacklen;
-  int typelen;
+  LONGEST typelen;
   int i, j;
 
   /* First handle however many args we can fit into MT_1ST_ARGREG thru
Index: gdb-7.6.90.20140127/gdb/ppc-sysv-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/ppc-sysv-tdep.c	2014-02-06 18:20:52.992747740 +0100
+++ gdb-7.6.90.20140127/gdb/ppc-sysv-tdep.c	2014-02-06 18:20:57.308752377 +0100
@@ -68,7 +68,7 @@ ppc_sysv_abi_push_dummy_call (struct gdb
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   int opencl_abi = ppc_sysv_use_opencl_abi (value_type (function));
   ULONGEST saved_sp;
-  int argspace = 0;		/* 0 is an initial wrong guess.  */
+  LONGEST argspace = 0;		/* 0 is an initial wrong guess.  */
   int write_pass;
 
   gdb_assert (tdep->wordsize == 4);
@@ -99,9 +99,9 @@ ppc_sysv_abi_push_dummy_call (struct gdb
       /* Next available vector register for vector arguments.  */
       int vreg = 2;
       /* Arguments start above the "LR save word" and "Back chain".  */
-      int argoffset = 2 * tdep->wordsize;
+      LONGEST argoffset = 2 * tdep->wordsize;
       /* Structures start after the arguments.  */
-      int structoffset = argoffset + argspace;
+      LONGEST structoffset = argoffset + argspace;
 
       /* If the function is returning a `struct', then the first word
          (which will be passed in r3) is used for struct return
@@ -120,7 +120,7 @@ ppc_sysv_abi_push_dummy_call (struct gdb
 	{
 	  struct value *arg = args[argno];
 	  struct type *type = check_typedef (value_type (arg));
-	  int len = TYPE_LENGTH (type);
+	  ssize_t len = TYPE_LENGTH (type);
 	  const bfd_byte *val = value_contents (arg);
 
 	  if (TYPE_CODE (type) == TYPE_CODE_FLT && len <= 8
@@ -1613,14 +1613,14 @@ ppc64_sysv_abi_push_dummy_call (struct g
 	    }
 	  else
 	    {
-	      int byte;
+	      ssize_t byte;
 	      for (byte = 0; byte < TYPE_LENGTH (type);
 		   byte += tdep->wordsize)
 		{
 		  if (write_pass && greg <= 10)
 		    {
 		      gdb_byte regval[MAX_REGISTER_SIZE];
-		      int len = TYPE_LENGTH (type) - byte;
+		      ssize_t len = TYPE_LENGTH (type) - byte;
 		      if (len > tdep->wordsize)
 			len = tdep->wordsize;
 		      memset (regval, 0, sizeof regval);
@@ -1648,7 +1648,7 @@ ppc64_sysv_abi_push_dummy_call (struct g
 		     register.  Work around this by always writing the
 		     value to memory.  Fortunately, doing this
 		     simplifies the code.  */
-		  int len = TYPE_LENGTH (type);
+		  ssize_t len = TYPE_LENGTH (type);
 		  if (len < tdep->wordsize)
 		    write_memory (gparam + tdep->wordsize - len, val, len);
 		  else
Index: gdb-7.6.90.20140127/gdb/rl78-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/rl78-tdep.c	2014-02-06 18:20:52.992747740 +0100
+++ gdb-7.6.90.20140127/gdb/rl78-tdep.c	2014-02-06 18:20:57.309752378 +0100
@@ -1052,8 +1052,8 @@ rl78_push_dummy_call (struct gdbarch *gd
   for (i = nargs - 1; i >= 0; i--)
     {
       struct type *value_type = value_enclosing_type (args[i]);
-      int len = TYPE_LENGTH (value_type);
-      int container_len = (len + 1) & ~1;
+      LONGEST len = TYPE_LENGTH (value_type);
+      LONGEST container_len = (len + 1) & ~1;
 
       sp -= container_len;
       write_memory (rl78_make_data_address (sp),
Index: gdb-7.6.90.20140127/gdb/rs6000-aix-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/rs6000-aix-tdep.c	2014-02-06 18:20:52.993747741 +0100
+++ gdb-7.6.90.20140127/gdb/rs6000-aix-tdep.c	2014-02-06 18:20:57.309752378 +0100
@@ -196,9 +196,9 @@ rs6000_push_dummy_call (struct gdbarch *
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   int ii;
-  int len = 0;
+  LONGEST len = 0;
   int argno;			/* current argument number */
-  int argbytes;			/* current argument byte */
+  LONGEST argbytes;		/* current argument byte */
   gdb_byte tmp_buffer[50];
   int f_argno = 0;		/* current floating point argno */
   int wordsize = gdbarch_tdep (gdbarch)->wordsize;
@@ -331,7 +331,7 @@ ran_out_of_registers_for_arguments:
 
   if ((argno < nargs) || argbytes)
     {
-      int space = 0, jj;
+      LONGEST space = 0, jj;
 
       if (argbytes)
 	{
Index: gdb-7.6.90.20140127/gdb/s390-linux-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/s390-linux-tdep.c	2014-02-06 18:20:52.993747741 +0100
+++ gdb-7.6.90.20140127/gdb/s390-linux-tdep.c	2014-02-06 18:22:17.330838389 +0100
@@ -2526,7 +2526,7 @@ is_float_like (struct type *type)
 
 
 static int
-is_power_of_two (unsigned int n)
+is_power_of_two (ULONGEST n)
 {
   return ((n & (n - 1)) == 0);
 }
@@ -2712,7 +2712,7 @@ s390_push_dummy_call (struct gdbarch *gd
       {
 	struct value *arg = args[i];
 	struct type *type = check_typedef (value_type (arg));
-	unsigned length = TYPE_LENGTH (type);
+	ULONGEST length = TYPE_LENGTH (type);
 
 	if (s390_function_arg_pass_by_reference (type))
 	  {
Index: gdb-7.6.90.20140127/gdb/score-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/score-tdep.c	2014-02-06 18:20:52.994747742 +0100
+++ gdb-7.6.90.20140127/gdb/score-tdep.c	2014-02-06 18:20:57.310752379 +0100
@@ -515,7 +515,7 @@ score_push_dummy_call (struct gdbarch *g
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   int argnum;
   int argreg;
-  int arglen = 0;
+  LONGEST arglen = 0;
   CORE_ADDR stack_offset = 0;
   CORE_ADDR addr = 0;
 
Index: gdb-7.6.90.20140127/gdb/sh-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/sh-tdep.c	2014-02-06 18:20:52.995747743 +0100
+++ gdb-7.6.90.20140127/gdb/sh-tdep.c	2014-02-06 18:20:57.310752379 +0100
@@ -807,7 +807,7 @@ sh_skip_prologue (struct gdbarch *gdbarc
 static int
 sh_use_struct_convention (int renesas_abi, struct type *type)
 {
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
   int nelem = TYPE_NFIELDS (type);
 
   /* The Renesas ABI returns aggregate types always on stack.  */
@@ -909,7 +909,7 @@ sh_frame_align (struct gdbarch *ignore,
 
 /* Helper function to justify value in register according to endianess.  */
 static const gdb_byte *
-sh_justify_value_in_reg (struct gdbarch *gdbarch, struct value *val, int len)
+sh_justify_value_in_reg (struct gdbarch *gdbarch, struct value *val, LONGEST len)
 {
   static gdb_byte valbuf[4];
 
@@ -1069,7 +1069,8 @@ sh_push_dummy_call_fpu (struct gdbarch *
   struct type *type;
   CORE_ADDR regval;
   const gdb_byte *val;
-  int len, reg_size = 0;
+  LONGEST len;
+  int reg_size = 0;
   int pass_on_stack = 0;
   int treat_as_flt;
   int last_reg_arg = INT_MAX;
@@ -1210,7 +1211,8 @@ sh_push_dummy_call_nofpu (struct gdbarch
   struct type *type;
   CORE_ADDR regval;
   const gdb_byte *val;
-  int len, reg_size = 0;
+  LONGEST len;
+  int reg_size = 0;
   int pass_on_stack = 0;
   int last_reg_arg = INT_MAX;
 
Index: gdb-7.6.90.20140127/gdb/sh64-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/sh64-tdep.c	2014-02-06 18:20:52.995747743 +0100
+++ gdb-7.6.90.20140127/gdb/sh64-tdep.c	2014-02-06 18:20:57.311752380 +0100
@@ -1058,7 +1058,7 @@ sh64_push_dummy_call (struct gdbarch *gd
 		      CORE_ADDR struct_addr)
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  int stack_offset, stack_alloc;
+  LONGEST stack_offset, stack_alloc;
   int int_argreg;
   int float_argreg;
   int double_argreg;
@@ -1069,7 +1069,7 @@ sh64_push_dummy_call (struct gdbarch *gd
   CORE_ADDR regval;
   const gdb_byte *val;
   gdb_byte valbuf[8];
-  int len;
+  LONGEST len;
   int argreg_size;
   int fp_args[12];
 
Index: gdb-7.6.90.20140127/gdb/sparc-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/sparc-tdep.c	2014-02-06 18:20:52.996747744 +0100
+++ gdb-7.6.90.20140127/gdb/sparc-tdep.c	2014-02-06 18:20:57.311752380 +0100
@@ -502,7 +502,7 @@ sparc32_store_arguments (struct regcache
   for (i = 0; i < nargs; i++)
     {
       struct type *type = value_type (args[i]);
-      int len = TYPE_LENGTH (type);
+      LONGEST len = TYPE_LENGTH (type);
 
       if (sparc_structure_or_union_p (type)
 	  || (sparc_floating_p (type) && len == 16)
Index: gdb-7.6.90.20140127/gdb/sparc64-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/sparc64-tdep.c	2014-02-06 18:20:52.996747744 +0100
+++ gdb-7.6.90.20140127/gdb/sparc64-tdep.c	2014-02-06 18:20:57.311752380 +0100
@@ -639,7 +639,8 @@ sparc64_16_byte_align_p (struct type *ty
 
 static void
 sparc64_store_floating_fields (struct regcache *regcache, struct type *type,
-			       const gdb_byte *valbuf, int element, int bitpos)
+			       const gdb_byte *valbuf, int element,
+			       LONGEST bitpos)
 {
   int len = TYPE_LENGTH (type);
 
@@ -681,7 +682,7 @@ sparc64_store_floating_fields (struct re
       for (i = 0; i < TYPE_NFIELDS (type); i++)
 	{
 	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));
-	  int subpos = bitpos + TYPE_FIELD_BITPOS (type, i);
+	  LONGEST subpos = bitpos + TYPE_FIELD_BITPOS (type, i);
 
 	  sparc64_store_floating_fields (regcache, subtype, valbuf,
 					 element, subpos);
@@ -713,7 +714,7 @@ sparc64_store_floating_fields (struct re
 
 static void
 sparc64_extract_floating_fields (struct regcache *regcache, struct type *type,
-				 gdb_byte *valbuf, int bitpos)
+				 gdb_byte *valbuf, LONGEST bitpos)
 {
   if (sparc64_floating_p (type))
     {
@@ -750,7 +751,7 @@ sparc64_extract_floating_fields (struct
       for (i = 0; i < TYPE_NFIELDS (type); i++)
 	{
 	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));
-	  int subpos = bitpos + TYPE_FIELD_BITPOS (type, i);
+	  LONGEST subpos = bitpos + TYPE_FIELD_BITPOS (type, i);
 
 	  sparc64_extract_floating_fields (regcache, subtype, valbuf, subpos);
 	}
@@ -783,7 +784,7 @@ sparc64_store_arguments (struct regcache
   for (i = 0; i < nargs; i++)
     {
       struct type *type = value_type (args[i]);
-      int len = TYPE_LENGTH (type);
+      LONGEST len = TYPE_LENGTH (type);
 
       if (sparc64_structure_or_union_p (type)
 	  || (sparc64_complex_floating_p (type) && len == 32))
@@ -883,7 +884,7 @@ sparc64_store_arguments (struct regcache
     {
       const gdb_byte *valbuf = value_contents (args[i]);
       struct type *type = value_type (args[i]);
-      int len = TYPE_LENGTH (type);
+      LONGEST len = TYPE_LENGTH (type);
       int regnum = -1;
       gdb_byte buf[16];
 
Index: gdb-7.6.90.20140127/gdb/spu-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/spu-tdep.c	2014-02-06 18:20:52.997747745 +0100
+++ gdb-7.6.90.20140127/gdb/spu-tdep.c	2014-02-06 18:20:57.312752381 +0100
@@ -1376,7 +1376,7 @@ spu_push_dummy_call (struct gdbarch *gdb
       struct value *arg = args[i];
       struct type *type = check_typedef (value_type (arg));
       const gdb_byte *contents = value_contents (arg);
-      int n_regs = align_up (TYPE_LENGTH (type), 16) / 16;
+      LONGEST n_regs = align_up (TYPE_LENGTH (type), 16) / 16;
 
       /* If the argument doesn't wholly fit into registers, it and
 	 all subsequent arguments go to the stack.  */
@@ -1408,7 +1408,7 @@ spu_push_dummy_call (struct gdbarch *gdb
 	{
 	  struct value *arg = args[i];
 	  struct type *type = check_typedef (value_type (arg));
-	  int len = TYPE_LENGTH (type);
+	  LONGEST len = TYPE_LENGTH (type);
 	  int preferred_slot;
 	  
 	  if (spu_scalar_value_p (type))
Index: gdb-7.6.90.20140127/gdb/tic6x-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/tic6x-tdep.c	2014-02-06 18:20:52.997747745 +0100
+++ gdb-7.6.90.20140127/gdb/tic6x-tdep.c	2014-02-06 18:20:57.312752381 +0100
@@ -896,7 +896,7 @@ tic6x_push_dummy_call (struct gdbarch *g
   int argreg = 0;
   int argnum;
   int stack_offset = 4;
-  int references_offset = 4;
+  LONGEST references_offset = 4;
   CORE_ADDR func_addr = find_function_addr (function, NULL);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   struct type *func_type = value_type (function);
@@ -930,7 +930,7 @@ tic6x_push_dummy_call (struct gdbarch *g
   /* Now make space on the stack for the args.  */
   for (argnum = 0; argnum < nargs; argnum++)
     {
-      int len = align_up (TYPE_LENGTH (value_type (args[argnum])), 4);
+      LONGEST len = align_up (TYPE_LENGTH (value_type (args[argnum])), 4);
       if (argnum >= 10 - argreg)
 	references_offset += len;
       stack_offset += len;
@@ -949,7 +949,7 @@ tic6x_push_dummy_call (struct gdbarch *g
       const gdb_byte *val;
       struct value *arg = args[argnum];
       struct type *arg_type = check_typedef (value_type (arg));
-      int len = TYPE_LENGTH (arg_type);
+      ssize_t len = TYPE_LENGTH (arg_type);
       enum type_code typecode = TYPE_CODE (arg_type);
 
       val = value_contents (arg);
@@ -1109,7 +1109,8 @@ tic6x_push_dummy_call (struct gdbarch *g
 	    }
 	  else
 	    internal_error (__FILE__, __LINE__,
-			    _("unexpected length %d of arg %d"), len, argnum);
+			    _("unexpected length %s of arg %d"),
+			    plongest (len), argnum);
 
 	  addr = sp + stack_offset;
 	  write_memory (addr, val, len);
Index: gdb-7.6.90.20140127/gdb/tilegx-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/tilegx-tdep.c	2014-02-06 18:20:52.998747746 +0100
+++ gdb-7.6.90.20140127/gdb/tilegx-tdep.c	2014-02-06 18:20:57.312752381 +0100
@@ -290,7 +290,7 @@ tilegx_push_dummy_call (struct gdbarch *
   CORE_ADDR stack_dest = sp;
   int argreg = TILEGX_R0_REGNUM;
   int i, j;
-  int typelen, slacklen, alignlen;
+  LONGEST typelen, slacklen, alignlen;
   static const gdb_byte four_zero_words[16] = { 0 };
 
   /* If struct_return is 1, then the struct return address will
Index: gdb-7.6.90.20140127/gdb/v850-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/v850-tdep.c	2014-02-06 18:20:52.998747746 +0100
+++ gdb-7.6.90.20140127/gdb/v850-tdep.c	2014-02-06 18:20:57.313752383 +0100
@@ -1021,7 +1021,7 @@ v850_push_dummy_call (struct gdbarch *gd
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   int argreg;
   int argnum;
-  int len = 0;
+  LONGEST len = 0;
   int stack_offset;
 
   if (gdbarch_tdep (gdbarch)->abi == V850_ABI_RH850)
@@ -1049,7 +1049,7 @@ v850_push_dummy_call (struct gdbarch *gd
      in four registers available.  Loop thru args from first to last.  */
   for (argnum = 0; argnum < nargs; argnum++)
     {
-      int len;
+      LONGEST len;
       gdb_byte *val;
       gdb_byte valbuf[v850_reg_size];
 
Index: gdb-7.6.90.20140127/gdb/vax-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/vax-tdep.c	2014-02-06 18:20:52.998747746 +0100
+++ gdb-7.6.90.20140127/gdb/vax-tdep.c	2014-02-06 18:20:57.313752383 +0100
@@ -115,7 +115,7 @@ vax_store_arguments (struct regcache *re
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   gdb_byte buf[4];
-  int count = 0;
+  LONGEST count = 0;
   int i;
 
   /* We create an argument list on the stack, and make the argument
@@ -124,7 +124,7 @@ vax_store_arguments (struct regcache *re
   /* Push arguments in reverse order.  */
   for (i = nargs - 1; i >= 0; i--)
     {
-      int len = TYPE_LENGTH (value_enclosing_type (args[i]));
+      LONGEST len = TYPE_LENGTH (value_enclosing_type (args[i]));
 
       sp -= (len + 3) & ~3;
       count += (len + 3) / 4;
Index: gdb-7.6.90.20140127/gdb/xstormy16-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/xstormy16-tdep.c	2014-02-06 18:20:52.999747748 +0100
+++ gdb-7.6.90.20140127/gdb/xstormy16-tdep.c	2014-02-06 18:20:57.313752383 +0100
@@ -235,8 +235,9 @@ xstormy16_push_dummy_call (struct gdbarc
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   CORE_ADDR stack_dest = sp;
   int argreg = E_1ST_ARG_REGNUM;
-  int i, j;
-  int typelen, slacklen;
+  int i, slacklen;
+  LONGEST j;
+  LONGEST typelen;
   const gdb_byte *val;
   gdb_byte buf[xstormy16_pc_size];
 
Index: gdb-7.6.90.20140127/gdb/xtensa-tdep.c
===================================================================
--- gdb-7.6.90.20140127.orig/gdb/xtensa-tdep.c	2014-02-06 18:20:53.000747749 +0100
+++ gdb-7.6.90.20140127/gdb/xtensa-tdep.c	2014-02-06 18:20:57.314752384 +0100
@@ -1652,8 +1652,7 @@ xtensa_store_return_value (struct type *
 
       if (len > (callsize > 8 ? 8 : 16))
 	internal_error (__FILE__, __LINE__,
-			_("unimplemented for this length: %d"),
-			TYPE_LENGTH (type));
+			_("unimplemented for this length: %d"), len);
       areg = arreg_number (gdbarch,
 			   gdbarch_tdep (gdbarch)->a0_base + 2 + callsize, wb);
 
@@ -1727,18 +1726,18 @@ xtensa_push_dummy_call (struct gdbarch *
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   int i;
-  int size, onstack_size;
+  LONGEST size, onstack_size;
   gdb_byte *buf = (gdb_byte *) alloca (16);
   CORE_ADDR ra, ps;
   struct argument_info
   {
     const bfd_byte *contents;
-    int length;
+    ssize_t length;
     int onstack;		/* onstack == 0 => in reg */
     int align;			/* alignment */
     union
     {
-      int offset;		/* stack offset if on stack.  */
+      ssize_t offset;		/* stack offset if on stack.  */
       int regno;		/* regno if in register.  */
     } u;
   };
@@ -1762,9 +1761,10 @@ xtensa_push_dummy_call (struct gdbarch *
         {
 	  struct value *arg = args[i];
 	  struct type *arg_type = check_typedef (value_type (arg));
-	  fprintf_unfiltered (gdb_stdlog, "%2d: %s %3d ", i,
-			      host_address_to_string (arg),
-			      TYPE_LENGTH (arg_type));
+	  const char *arg_type_len_s = pulongest (TYPE_LENGTH (arg_type));
+
+	  fprintf_unfiltered (gdb_stdlog, "%2d: %s %s ", i,
+			      host_address_to_string (arg), arg_type_len_s);
 	  switch (TYPE_CODE (arg_type))
 	    {
 	    case TYPE_CODE_INT:
@@ -1834,8 +1834,8 @@ xtensa_push_dummy_call (struct gdbarch *
 	  info->align = TYPE_LENGTH (builtin_type (gdbarch)->builtin_long);
 	  break;
 	}
-      info->length = TYPE_LENGTH (arg_type);
       info->contents = value_contents (arg);
+      info->length = TYPE_LENGTH (arg_type);
 
       /* Align size and onstack_size.  */
       size = (size + info->align - 1) & ~(info->align - 1);
@@ -1880,7 +1880,7 @@ xtensa_push_dummy_call (struct gdbarch *
 
       if (info->onstack)
 	{
-	  int n = info->length;
+	  ssize_t n = info->length;
 	  CORE_ADDR offset = sp + info->u.offset;
 
 	  /* Odd-sized structs are aligned to the lower side of a memory
@@ -1896,7 +1896,7 @@ xtensa_push_dummy_call (struct gdbarch *
 	}
       else
 	{
-	  int n = info->length;
+	  ssize_t n = info->length;
 	  const bfd_byte *cp = info->contents;
 	  int r = info->u.regno;
 
