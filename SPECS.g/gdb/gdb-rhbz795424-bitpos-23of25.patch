http://sourceware.org/ml/gdb-patches/2012-09/msg00630.html
Subject: [PATCH 4/4] Bitpos expansion - tdep changes


--MP_/X_WjDOvz/B_fvlsrmCwRdxe
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Hi,

This is the last part of the bitpos change.  This patch does the same
thing that patch 1/4 does, except that it does so in the *-tdep files
wherever necessary.  I separated these changes mainly because they are
related and can be reviewed independently.  Tested on Fedora 16 x86_64.

Regards,
Siddhesh

--MP_/X_WjDOvz/B_fvlsrmCwRdxe
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename=ChangeLog-tdep

gdb/ChangeLog

	* alpha-tdep.c (alpha_push_dummy_call): Expand ACCUMULATE_SIZE,
	REQUIRED_ARG_REGS, OFFSET, LEN, TLEN to ssize_t.
	(struct alpha_arg): Expand members LEN, OFFSET to ssize_t.
	* amd64-tdep.c (amd64_push_arguments): Expand NUM_ELEMENTS,
	ELEMENT and LEN to LONGEST.
	(amd64_return_value): Expand LEN to LONGEST.
	* amd64-windows-tdep.c (amd64_windows_return_value): Expand LEN
	to LONGEST.
	* arm-tdep.c (arm_vfp_cprc_sub_candidate): Return LONGEST.
	Expand COUNT, SUB_COUNT to LONGEST.
	(arm_vfp_call_candidate): Expand C to LONGEST.
	(arm_push_dummy_call): Expand LEN to LONGEST.
	* avr-tdep.c (struct stack_item): Expand member LEN to ssize_t.
	(push_stack_item): Expand parameter LEN to ssize_t.
	(avr_push_dummy_call): Expand LAST_REGNUM, J, LEN to ssize_t.
	* bfin-tdep.c (bfin_push_dummy_call): Expand TOTAL_LEN,
	CONTAINER_LEN to ssize_t.
	* cris-tdep.c (struct stack_item): Expand member LEN to ssize_t.
	(push_stack_item): Expand parameter LEN to ssize_t.
	(cris_push_dummy_call): Expand LEN, REG_DEMAND, I to ssize_t.
	* h8300-tdep.c (h8300_push_dummy_call): Expand STACK_ALLOC,
	STACK_OFFSET to LONGEST.  Expand LEN, PADDED_LEN, OFFSET to
	ssize_t.
	* hppa-tdep.c (hppa64_push_dummy_call): Expand LEN to LONGEST.
	(hppa64_return_value): Likewise.
	* i386-darwin-tdep.c (i386_darwin_push_dummy_call): Expand
	ARGS_SPACE to LONGEST.
	* i386-tdep.c (i386_push_dummy_call): Expand ARG_SPACE,
	ARG_SPACE_USED, LEN to LONGEST.
	(i386_reg_struct_return_p): Expand LEN to LONGEST.
	(i386_convert_register_p): Likewise.
	(i386_register_to_value): Likewise.
	(i386_value_to_register): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Expand ARGOFFSET, LEN,
	NSLOTS, MEMSLOTS to LONGEST.
	* iq2000-tdep.c (iq2000_push_dummy_call): Expand TYPELEN,
	STACKSPACE to LONGEST.
	* m32r-tdep.c (m32r_push_dummy_call): Expand LEN to LONGEST.
	* m68k-tdep.c (m68k_reg_struct_return_p): Expand LEN to LONGEST.
	(m68k_push_dummy_call): Expand LEN, CONTAINER_LEN, OFFSET to
	LONGEST.
	* m88k-tdep.c (m88k_store_arguments): Expand NUM_STACK_WORDS,
	LEN, STACK_WORD to LONGEST.
	* mep-tdep.c (push_large_arguments): Expand ARG_LEN to ULONGEST.
	* microblaze-tdep.c (microblaze_store_return_value): Expand LEN to
	LONGEST.
	* mips-tdep.c (mips_xfer_register): Expand parameter BUF_OFFSET to
	LONGEST.  Use plongest to format print BUF_OFFSET.
	(mips_eabi_push_dummy_call): Expand LEN to LONGEST.  Use plongest
	to format print LEN.
	(mips_n32n64_fp_arg_chunk_p): Expand parameter OFFSET to LONGEST.
	Expand POS to LONGEST.
	(mips_n32n64_push_dummy_call): Expand LEN to LONGEST.
	(mips_n32n64_return_value): Expand OFFSET to LONGEST.  Use
	plongest to format print OFFSET.
	(mips_o32_push_dummy_call): Expand LEN to LONGEST.  Use plongest
	to format print LEN.
	(mips_o64_push_dummy_call): Expand LEN, STACK_OFFSET to LONGEST.
	Use plongest to format print LEN.
	* mn10300-tdep.c (mn10300_push_dummy_call): Expand LEN to
	LONGEST.
	* mt-tdep.c (mt_push_dummy_call): Expand STACK_DEST, TYPELEN to
	LONGEST.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Expand
	ARGSPACE, ARGOFFSET, STRUCTOFFSET, LEN, to LONGEST.
	(ppc64_sysv_abi_push_dummy_call): Expand BYTE, LEN to ssize_t.
	* rl78-tdep.c (rl78_push_dummy_call): Expand LEN, CONTAINER_LEN
	to LONGEST.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call): Expand ARGBYTES,
	LEN to LONGEST.
	(ran_out_of_registers_for_arguments): Expand SPACE, JJ to
	LONGEST.
	* s390-linux-tdep.c (s390_value_from_register): Expand LEN to LONGEST.
	(is_power_of_two): Expand parameter N to ULONGEST.
	(s390_push_dummy_call): Expand LENGTH to ULONGEST.
	* score-tdep.c (score_push_dummy_call): Expand ARGLEN to
	LONGEST.
	* sh-tdep.c (sh_use_struct_convention) Expand len to LONGEST.
	(sh_justify_value_in_reg): Expand parameter LEN to LONGEST.
	(sh_push_dummy_call_fpu): Expand LEN to LONGEST.  Expand REG_SIZE
	to ssize_t.
	(sh_push_dummy_call_nofpu): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call): Expand STACK_OFFSET,
	STACK_ALLOC, LEN to LONGEST.
	* sparc-tdep.c (sparc32_store_arguments): Expand LEN to LONGEST.
	* sparc64-tdep.c (sparc64_store_floating_fields): Expand
	parameter BITPOS to LONGEST.  Expand SUBPOS to LONGEST.
	(sparc64_extract_floating_fields): Likewise.
	(sparc64_store_arguments): Expand LEN to LONGEST.
	* spu-tdep.c (spu_push_dummy_call): Expand N_REGS, LEN to LONGEST.
	(spu_value_from_register): Expand LEN to LONGEST.
	* tic6x-tdep.c (tic6x_push_dummy_call): Expand REFERENCES_OFFST,
	LEN to LONGEST.  Expand LEN to ssize_t.  Use plongest to format
	print LEN.
	* tilegx-tdep.c (tilegx_push_dummy_call): Expand TYPELEN,
	SLACKLEN, ALIGNLEN to LONGEST.
	* v850-tdep.c (v850_push_dummy_call): Expand LEN to LONGEST.
	* vax-tdep.c (vax_store_arguments): Expand COUNT, LEN to LONGEST.
	(vax_return_value): Expand LEN to LONGEST.
	* xstormy16-tdep.c (xstormy16_push_dummy_call): Expand J, TYPELEN
	to LONGEST.
	* xtensa-tdep.c (xtensa_store_return_value): Print LEN instead of
	TYPE_LENGTH..
	(struct argument_info): Expoand member LENGTH to ssize_t.
	(struct argument_info.u): Expand member OFFSET to ssize_t.
	(xtensa_push_dummy_call): Expand SIZE, ONSTACK_SIZE to LONGEST.
	Expand N to ssize_t.  Use pulongest to format print TYPE_LENGTH.

--MP_/X_WjDOvz/B_fvlsrmCwRdxe
Content-Type: text/x-patch
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment; filename=bitpos-tdep.patch

Index: gdb-7.9.50.20150520/gdb/alpha-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/alpha-tdep.c	2015-05-31 17:15:01.056868035 +0200
+++ gdb-7.9.50.20150520/gdb/alpha-tdep.c	2015-05-31 17:15:03.419882846 +0200
@@ -298,18 +298,18 @@ alpha_push_dummy_call (struct gdbarch *g
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   int i;
-  int accumulate_size = struct_return ? 8 : 0;
+  ssize_t accumulate_size = struct_return ? 8 : 0;
   struct alpha_arg
     {
       const gdb_byte *contents;
-      int len;
-      int offset;
+      ssize_t len;
+      ssize_t offset;
     };
   struct alpha_arg *alpha_args
     = (struct alpha_arg *) alloca (nargs * sizeof (struct alpha_arg));
   struct alpha_arg *m_arg;
   gdb_byte arg_reg_buffer[ALPHA_REGISTER_SIZE * ALPHA_NUM_ARG_REGS];
-  int required_arg_regs;
+  ssize_t required_arg_regs;
   CORE_ADDR func_addr = find_function_addr (function, NULL);
 
   /* The ABI places the address of the called function in T12.  */
@@ -429,8 +429,8 @@ alpha_push_dummy_call (struct gdbarch *g
   for (i = nargs; m_arg--, --i >= 0;)
     {
       const gdb_byte *contents = m_arg->contents;
-      int offset = m_arg->offset;
-      int len = m_arg->len;
+      ssize_t offset = m_arg->offset;
+      ssize_t len = m_arg->len;
 
       /* Copy the bytes destined for registers into arg_reg_buffer.  */
       if (offset < sizeof(arg_reg_buffer))
@@ -442,7 +442,7 @@ alpha_push_dummy_call (struct gdbarch *g
 	    }
 	  else
 	    {
-	      int tlen = sizeof(arg_reg_buffer) - offset;
+	      ssize_t tlen = sizeof(arg_reg_buffer) - offset;
 	      memcpy (arg_reg_buffer + offset, contents, tlen);
 	      offset += tlen;
 	      contents += tlen;
Index: gdb-7.9.50.20150520/gdb/amd64-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/amd64-tdep.c	2015-05-31 17:15:01.058868047 +0200
+++ gdb-7.9.50.20150520/gdb/amd64-tdep.c	2015-05-31 17:15:40.253113722 +0200
@@ -701,7 +701,7 @@ amd64_return_value (struct gdbarch *gdba
 		    gdb_byte *readbuf, const gdb_byte *writebuf)
 {
   enum amd64_reg_class theclass[2];
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
   static int integer_regnum[] = { AMD64_RAX_REGNUM, AMD64_RDX_REGNUM };
   static int sse_regnum[] = { AMD64_XMM0_REGNUM, AMD64_XMM1_REGNUM };
   int integer_reg = 0;
@@ -852,8 +852,8 @@ amd64_push_arguments (struct regcache *r
   };
   struct value **stack_args = alloca (nargs * sizeof (struct value *));
   int num_stack_args = 0;
-  int num_elements = 0;
-  int element = 0;
+  LONGEST num_elements = 0;
+  LONGEST element = 0;
   int integer_reg = 0;
   int sse_reg = 0;
   int i;
@@ -865,7 +865,7 @@ amd64_push_arguments (struct regcache *r
   for (i = 0; i < nargs; i++)
     {
       struct type *type = value_type (args[i]);
-      int len = TYPE_LENGTH (type);
+      LONGEST len = TYPE_LENGTH (type);
       enum amd64_reg_class theclass[2];
       int needed_integer_regs = 0;
       int needed_sse_regs = 0;
Index: gdb-7.9.50.20150520/gdb/amd64-windows-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/amd64-windows-tdep.c	2015-05-31 17:15:01.059868054 +0200
+++ gdb-7.9.50.20150520/gdb/amd64-windows-tdep.c	2015-05-31 17:15:03.421882859 +0200
@@ -288,7 +288,7 @@ amd64_windows_return_value (struct gdbar
 			    struct type *type, struct regcache *regcache,
 			    gdb_byte *readbuf, const gdb_byte *writebuf)
 {
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
   int regnum = -1;
 
   /* See if our value is returned through a register.  If it is, then
Index: gdb-7.9.50.20150520/gdb/arm-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/arm-tdep.c	2015-05-31 17:15:01.069868116 +0200
+++ gdb-7.9.50.20150520/gdb/arm-tdep.c	2015-05-31 17:15:03.425882884 +0200
@@ -3537,7 +3537,7 @@ arm_vfp_cprc_reg_char (enum arm_vfp_cprc
    array).  Vector types are not currently supported, matching the
    generic AAPCS support.  */
 
-static int
+static LONGEST
 arm_vfp_cprc_sub_candidate (struct type *t,
 			    enum arm_vfp_cprc_base_type *base_type)
 {
@@ -3600,7 +3600,7 @@ arm_vfp_cprc_sub_candidate (struct type
 
     case TYPE_CODE_ARRAY:
       {
-	int count;
+	LONGEST count;
 	unsigned unitlen;
 	count = arm_vfp_cprc_sub_candidate (TYPE_TARGET_TYPE (t), base_type);
 	if (count == -1)
@@ -3620,13 +3620,15 @@ arm_vfp_cprc_sub_candidate (struct type
 
     case TYPE_CODE_STRUCT:
       {
-	int count = 0;
+	LONGEST count = 0;
 	unsigned unitlen;
 	int i;
 	for (i = 0; i < TYPE_NFIELDS (t); i++)
 	  {
-	    int sub_count = arm_vfp_cprc_sub_candidate (TYPE_FIELD_TYPE (t, i),
-							base_type);
+	    LONGEST sub_count;
+
+	    sub_count = arm_vfp_cprc_sub_candidate (TYPE_FIELD_TYPE (t, i),
+						    base_type);
 	    if (sub_count == -1)
 	      return -1;
 	    count += sub_count;
@@ -3646,13 +3648,15 @@ arm_vfp_cprc_sub_candidate (struct type
 
     case TYPE_CODE_UNION:
       {
-	int count = 0;
+	LONGEST count = 0;
 	unsigned unitlen;
 	int i;
 	for (i = 0; i < TYPE_NFIELDS (t); i++)
 	  {
-	    int sub_count = arm_vfp_cprc_sub_candidate (TYPE_FIELD_TYPE (t, i),
-							base_type);
+	    LONGEST sub_count;
+
+	    sub_count = arm_vfp_cprc_sub_candidate (TYPE_FIELD_TYPE (t, i),
+						    base_type);
 	    if (sub_count == -1)
 	      return -1;
 	    count = (count > sub_count ? count : sub_count);
@@ -3688,7 +3692,7 @@ arm_vfp_call_candidate (struct type *t,
 			int *count)
 {
   enum arm_vfp_cprc_base_type b = VFP_CPRC_UNKNOWN;
-  int c = arm_vfp_cprc_sub_candidate (t, &b);
+  LONGEST c = arm_vfp_cprc_sub_candidate (t, &b);
   if (c <= 0 || c > 4)
     return 0;
   *base_type = b;
@@ -3769,7 +3773,7 @@ arm_push_dummy_call (struct gdbarch *gdb
 
   for (argnum = 0; argnum < nargs; argnum++)
     {
-      int len;
+      LONGEST len;
       struct type *arg_type;
       struct type *target_type;
       enum type_code typecode;
Index: gdb-7.9.50.20150520/gdb/avr-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/avr-tdep.c	2015-05-31 17:15:01.071868129 +0200
+++ gdb-7.9.50.20150520/gdb/avr-tdep.c	2015-05-31 17:15:03.425882884 +0200
@@ -1196,13 +1196,14 @@ avr_dummy_id (struct gdbarch *gdbarch, s
 
 struct stack_item
 {
-  int len;
+  ssize_t len;
   struct stack_item *prev;
   void *data;
 };
 
 static struct stack_item *
-push_stack_item (struct stack_item *prev, const bfd_byte *contents, int len)
+push_stack_item (struct stack_item *prev, const bfd_byte *contents,
+		 ssize_t len)
 {
   struct stack_item *si;
   si = xmalloc (sizeof (struct stack_item));
@@ -1291,12 +1292,12 @@ avr_push_dummy_call (struct gdbarch *gdb
 
   for (i = 0; i < nargs; i++)
     {
-      int last_regnum;
-      int j;
+      ssize_t last_regnum;
+      ssize_t j;
       struct value *arg = args[i];
       struct type *type = check_typedef (value_type (arg));
       const bfd_byte *contents = value_contents (arg);
-      int len = TYPE_LENGTH (type);
+      ssize_t len = TYPE_LENGTH (type);
 
       /* Calculate the potential last register needed.  */
       last_regnum = regnum - (len + (len & 1));
Index: gdb-7.9.50.20150520/gdb/bfin-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/bfin-tdep.c	2015-05-31 17:15:01.071868129 +0200
+++ gdb-7.9.50.20150520/gdb/bfin-tdep.c	2015-05-31 17:15:03.426882890 +0200
@@ -504,7 +504,7 @@ bfin_push_dummy_call (struct gdbarch *gd
   gdb_byte buf[4];
   int i;
   long reg_r0, reg_r1, reg_r2;
-  int total_len = 0;
+  ssize_t total_len = 0;
   enum bfin_abi abi = bfin_abi (gdbarch);
   CORE_ADDR func_addr = find_function_addr (function, NULL);
 
@@ -528,7 +528,7 @@ bfin_push_dummy_call (struct gdbarch *gd
     {
       struct type *value_type = value_enclosing_type (args[i]);
       struct type *arg_type = check_typedef (value_type);
-      int container_len = (TYPE_LENGTH (value_type) + 3) & ~3;
+      ssize_t container_len = (TYPE_LENGTH (value_type) + 3) & ~3;
 
       sp -= container_len;
       write_memory (sp, value_contents_writeable (args[i]), container_len);
Index: gdb-7.9.50.20150520/gdb/cris-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/cris-tdep.c	2015-05-31 17:15:01.073868142 +0200
+++ gdb-7.9.50.20150520/gdb/cris-tdep.c	2015-05-31 17:15:03.427882897 +0200
@@ -663,13 +663,13 @@ static CORE_ADDR cris_unwind_sp (struct
 
 struct stack_item
 {
-  int len;
+  ssize_t len;
   struct stack_item *prev;
   void *data;
 };
 
 static struct stack_item *
-push_stack_item (struct stack_item *prev, const gdb_byte *contents, int len)
+push_stack_item (struct stack_item *prev, const gdb_byte *contents, ssize_t len)
 {
   struct stack_item *si;
   si = xmalloc (sizeof (struct stack_item));
@@ -842,13 +842,13 @@ cris_push_dummy_call (struct gdbarch *gd
 
   for (argnum = 0; argnum < nargs; argnum++)
     {
-      int len;
+      ssize_t len;
       const gdb_byte *val;
-      int reg_demand;
-      int i;
+      ssize_t reg_demand;
+      ssize_t i;
       
-      len = TYPE_LENGTH (value_type (args[argnum]));
       val = value_contents (args[argnum]);
+      len = TYPE_LENGTH (value_type (args[argnum]));
       
       /* How may registers worth of storage do we need for this argument?  */
       reg_demand = (len / 4) + (len % 4 != 0 ? 1 : 0);
Index: gdb-7.9.50.20150520/gdb/h8300-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/h8300-tdep.c	2015-05-31 17:15:01.074868148 +0200
+++ gdb-7.9.50.20150520/gdb/h8300-tdep.c	2015-05-31 17:15:03.427882897 +0200
@@ -639,7 +639,7 @@ h8300_push_dummy_call (struct gdbarch *g
 		       int struct_return, CORE_ADDR struct_addr)
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  int stack_alloc = 0, stack_offset = 0;
+  LONGEST stack_alloc = 0, stack_offset = 0;
   int wordsize = BINWORD (gdbarch);
   int reg = E_ARG0_REGNUM;
   int argument;
@@ -666,11 +666,11 @@ h8300_push_dummy_call (struct gdbarch *g
     {
       struct cleanup *back_to;
       struct type *type = value_type (args[argument]);
-      int len = TYPE_LENGTH (type);
       char *contents = (char *) value_contents (args[argument]);
+      ssize_t len = TYPE_LENGTH (type);
 
       /* Pad the argument appropriately.  */
-      int padded_len = align_up (len, wordsize);
+      ssize_t padded_len = align_up (len, wordsize);
       gdb_byte *padded = xmalloc (padded_len);
       back_to = make_cleanup (xfree, padded);
 
@@ -699,7 +699,7 @@ h8300_push_dummy_call (struct gdbarch *g
 	      /* Heavens to Betsy --- it's really going in registers!
 	         Note that on the h8/300s, there are gaps between the
 	         registers in the register file.  */
-	      int offset;
+	      ssize_t offset;
 
 	      for (offset = 0; offset < padded_len; offset += wordsize)
 		{
Index: gdb-7.9.50.20150520/gdb/hppa-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/hppa-tdep.c	2015-05-31 17:15:01.076868160 +0200
+++ gdb-7.9.50.20150520/gdb/hppa-tdep.c	2015-05-31 17:15:03.428882903 +0200
@@ -991,7 +991,7 @@ hppa64_push_dummy_call (struct gdbarch *
     {
       struct value *arg = args[i];
       struct type *type = value_type (arg);
-      int len = TYPE_LENGTH (type);
+      LONGEST len = TYPE_LENGTH (type);
       const bfd_byte *valbuf;
       bfd_byte fptrbuf[8];
       int regnum;
@@ -1186,7 +1186,7 @@ hppa64_return_value (struct gdbarch *gdb
 		     struct type *type, struct regcache *regcache,
 		     gdb_byte *readbuf, const gdb_byte *writebuf)
 {
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
   int regnum, offset;
 
   if (len > 16)
Index: gdb-7.9.50.20150520/gdb/i386-darwin-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/i386-darwin-tdep.c	2015-05-31 17:15:01.076868160 +0200
+++ gdb-7.9.50.20150520/gdb/i386-darwin-tdep.c	2015-05-31 17:15:03.428882903 +0200
@@ -163,7 +163,7 @@ i386_darwin_push_dummy_call (struct gdba
 
   for (write_pass = 0; write_pass < 2; write_pass++)
     {
-      int args_space = 0;
+      LONGEST args_space = 0;
       int num_m128 = 0;
 
       if (struct_return)
Index: gdb-7.9.50.20150520/gdb/i386-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/i386-tdep.c	2015-05-31 17:15:01.082868198 +0200
+++ gdb-7.9.50.20150520/gdb/i386-tdep.c	2015-05-31 17:15:03.430882915 +0200
@@ -2651,7 +2651,7 @@ i386_push_dummy_call (struct gdbarch *gd
   gdb_byte buf[4];
   int i;
   int write_pass;
-  int args_space = 0;
+  LONGEST args_space = 0;
 
   /* Determine the total space required for arguments and struct
      return address in a first pass (allowing for 16-byte-aligned
@@ -2659,7 +2659,7 @@ i386_push_dummy_call (struct gdbarch *gd
 
   for (write_pass = 0; write_pass < 2; write_pass++)
     {
-      int args_space_used = 0;
+      LONGEST args_space_used = 0;
 
       if (struct_return)
 	{
@@ -2676,7 +2676,7 @@ i386_push_dummy_call (struct gdbarch *gd
 
       for (i = 0; i < nargs; i++)
 	{
-	  int len = TYPE_LENGTH (value_enclosing_type (args[i]));
+	  LONGEST len = TYPE_LENGTH (value_enclosing_type (args[i]));
 
 	  if (write_pass)
 	    {
@@ -2883,7 +2883,7 @@ i386_reg_struct_return_p (struct gdbarch
 {
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
   enum type_code code = TYPE_CODE (type);
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
 
   gdb_assert (code == TYPE_CODE_STRUCT
               || code == TYPE_CODE_UNION
@@ -3629,7 +3629,7 @@ static int
 i386_convert_register_p (struct gdbarch *gdbarch,
 			 int regnum, struct type *type)
 {
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
 
   /* Values may be spread across multiple registers.  Most debugging
      formats aren't expressive enough to specify the locations, so
@@ -3662,7 +3662,7 @@ i386_register_to_value (struct frame_inf
 			int *optimizedp, int *unavailablep)
 {
   struct gdbarch *gdbarch = get_frame_arch (frame);
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
 
   if (i386_fp_regnum_p (gdbarch, regnum))
     return i387_register_to_value (frame, regnum, type, to,
@@ -3698,7 +3698,7 @@ static void
 i386_value_to_register (struct frame_info *frame, int regnum,
 			struct type *type, const gdb_byte *from)
 {
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
 
   if (i386_fp_regnum_p (get_frame_arch (frame), regnum))
     {
Index: gdb-7.9.50.20150520/gdb/iq2000-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/iq2000-tdep.c	2015-05-31 17:15:01.083868204 +0200
+++ gdb-7.9.50.20150520/gdb/iq2000-tdep.c	2015-05-31 17:15:03.431882922 +0200
@@ -651,8 +651,9 @@ iq2000_push_dummy_call (struct gdbarch *
   const bfd_byte *val;
   bfd_byte buf[4];
   struct type *type;
-  int i, argreg, typelen, slacklen;
-  int stackspace = 0;
+  int i, argreg, slacklen;
+  LONGEST typelen;
+  LONGEST stackspace = 0;
   /* Used to copy struct arguments into the stack.  */
   CORE_ADDR struct_ptr;
 
Index: gdb-7.9.50.20150520/gdb/m32r-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/m32r-tdep.c	2015-05-31 17:15:01.083868204 +0200
+++ gdb-7.9.50.20150520/gdb/m32r-tdep.c	2015-05-31 17:15:03.431882922 +0200
@@ -687,7 +687,7 @@ m32r_push_dummy_call (struct gdbarch *gd
   CORE_ADDR regval;
   gdb_byte *val;
   gdb_byte valbuf[MAX_REGISTER_SIZE];
-  int len;
+  LONGEST len;
 
   /* First force sp to a 4-byte alignment.  */
   sp = sp & ~3;
Index: gdb-7.9.50.20150520/gdb/m68k-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/m68k-tdep.c	2015-05-31 17:15:01.084868210 +0200
+++ gdb-7.9.50.20150520/gdb/m68k-tdep.c	2015-05-31 17:15:03.432882928 +0200
@@ -382,7 +382,7 @@ m68k_reg_struct_return_p (struct gdbarch
 {
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
   enum type_code code = TYPE_CODE (type);
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
 
   gdb_assert (code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION
 	      || code == TYPE_CODE_COMPLEX);
@@ -514,9 +514,9 @@ m68k_push_dummy_call (struct gdbarch *gd
   for (i = nargs - 1; i >= 0; i--)
     {
       struct type *value_type = value_enclosing_type (args[i]);
-      int len = TYPE_LENGTH (value_type);
-      int container_len = (len + 3) & ~3;
-      int offset;
+      LONGEST len = TYPE_LENGTH (value_type);
+      LONGEST container_len = (len + 3) & ~3;
+      LONGEST offset;
 
       /* Non-scalars bigger than 4 bytes are left aligned, others are
 	 right aligned.  */
Index: gdb-7.9.50.20150520/gdb/m88k-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/m88k-tdep.c	2015-05-31 17:15:01.085868217 +0200
+++ gdb-7.9.50.20150520/gdb/m88k-tdep.c	2015-05-31 17:15:03.432882928 +0200
@@ -257,13 +257,13 @@ m88k_store_arguments (struct regcache *r
 {
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   int num_register_words = 0;
-  int num_stack_words = 0;
+  LONGEST num_stack_words = 0;
   int i;
 
   for (i = 0; i < nargs; i++)
     {
       struct type *type = value_type (args[i]);
-      int len = TYPE_LENGTH (type);
+      LONGEST len = TYPE_LENGTH (type);
 
       if (m88k_integral_or_pointer_p (type) && len < 4)
 	{
@@ -305,8 +305,8 @@ m88k_store_arguments (struct regcache *r
     {
       const bfd_byte *valbuf = value_contents (args[i]);
       struct type *type = value_type (args[i]);
-      int len = TYPE_LENGTH (type);
-      int stack_word = num_stack_words;
+      LONGEST len = TYPE_LENGTH (type);
+      LONGEST stack_word = num_stack_words;
 
       if (m88k_in_register_p (type))
 	{
Index: gdb-7.9.50.20150520/gdb/mep-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/mep-tdep.c	2015-05-31 17:15:01.086868223 +0200
+++ gdb-7.9.50.20150520/gdb/mep-tdep.c	2015-05-31 17:15:03.433882934 +0200
@@ -2269,7 +2269,7 @@ push_large_arguments (CORE_ADDR sp, int
 
   for (i = 0; i < argc; i++)
     {
-      unsigned arg_len = TYPE_LENGTH (value_type (argv[i]));
+      ULONGEST arg_len = TYPE_LENGTH (value_type (argv[i]));
 
       if (arg_len > MEP_GPR_SIZE)
         {
Index: gdb-7.9.50.20150520/gdb/mips-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/mips-tdep.c	2015-05-31 17:15:01.094868273 +0200
+++ gdb-7.9.50.20150520/gdb/mips-tdep.c	2015-05-31 17:15:03.435882947 +0200
@@ -455,7 +455,7 @@ static void
 mips_xfer_register (struct gdbarch *gdbarch, struct regcache *regcache,
 		    int reg_num, int length,
 		    enum bfd_endian endian, gdb_byte *in,
-		    const gdb_byte *out, int buf_offset)
+		    const gdb_byte *out, LONGEST buf_offset)
 {
   int reg_offset = 0;
 
@@ -478,8 +478,8 @@ mips_xfer_register (struct gdbarch *gdba
     }
   if (mips_debug)
     fprintf_unfiltered (gdb_stderr,
-			"xfer $%d, reg offset %d, buf offset %d, length %d, ",
-			reg_num, reg_offset, buf_offset, length);
+			"xfer $%d, reg offset %d, buf offset %s, length %d, ",
+			reg_num, reg_offset, plongest (buf_offset), length);
   if (mips_debug && out != NULL)
     {
       int i;
@@ -4551,13 +4551,13 @@ mips_eabi_push_dummy_call (struct gdbarc
       gdb_byte valbuf[MAX_REGISTER_SIZE];
       struct value *arg = args[argnum];
       struct type *arg_type = check_typedef (value_type (arg));
-      int len = TYPE_LENGTH (arg_type);
+      LONGEST len = TYPE_LENGTH (arg_type);
       enum type_code typecode = TYPE_CODE (arg_type);
 
       if (mips_debug)
 	fprintf_unfiltered (gdb_stdlog,
-			    "mips_eabi_push_dummy_call: %d len=%d type=%d",
-			    argnum + 1, len, (int) typecode);
+			    "mips_eabi_push_dummy_call: %d len=%s type=%d",
+			    argnum + 1, plongest (len), (int) typecode);
 
       /* The EABI passes structures that do not fit in a register by
          reference.  */
@@ -4826,7 +4826,7 @@ mips_eabi_return_value (struct gdbarch *
 
 static int
 mips_n32n64_fp_arg_chunk_p (struct gdbarch *gdbarch, struct type *arg_type,
-			    int offset)
+			    LONGEST offset)
 {
   int i;
 
@@ -4841,7 +4841,7 @@ mips_n32n64_fp_arg_chunk_p (struct gdbar
 
   for (i = 0; i < TYPE_NFIELDS (arg_type); i++)
     {
-      int pos;
+      LONGEST pos;
       struct type *field_type;
 
       /* We're only looking at normal fields.  */
@@ -4883,7 +4883,7 @@ mips_n32n64_push_dummy_call (struct gdba
   int argreg;
   int float_argreg;
   int argnum;
-  int len = 0;
+  LONGEST len = 0;
   int stack_offset = 0;
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   CORE_ADDR func_addr = find_function_addr (function, NULL);
@@ -5234,11 +5234,11 @@ mips_n32n64_return_value (struct gdbarch
 				: MIPS_V0_REGNUM);
 	   field < TYPE_NFIELDS (type); field++, regnum += 2)
 	{
-	  int offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field])
-			/ TARGET_CHAR_BIT);
+	  LONGEST offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field])
+			    / TARGET_CHAR_BIT);
 	  if (mips_debug)
-	    fprintf_unfiltered (gdb_stderr, "Return float struct+%d\n",
-				offset);
+	    fprintf_unfiltered (gdb_stderr, "Return float struct+%s\n",
+				plongest (offset));
 	  if (TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)) == 16)
 	    {
 	      /* A 16-byte long double field goes in two consecutive
@@ -5280,8 +5280,8 @@ mips_n32n64_return_value (struct gdbarch
 	  if (offset + xfer > TYPE_LENGTH (type))
 	    xfer = TYPE_LENGTH (type) - offset;
 	  if (mips_debug)
-	    fprintf_unfiltered (gdb_stderr, "Return struct+%d:%d in $%d\n",
-				offset, xfer, regnum);
+	    fprintf_unfiltered (gdb_stderr, "Return struct+%s:%d in $%d\n",
+				plongest (offset), xfer, regnum);
 	  mips_xfer_register (gdbarch, regcache,
 			      gdbarch_num_regs (gdbarch) + regnum,
 			      xfer, BFD_ENDIAN_UNKNOWN, readbuf, writebuf,
@@ -5339,7 +5339,7 @@ mips_o32_push_dummy_call (struct gdbarch
   int argreg;
   int float_argreg;
   int argnum;
-  int len = 0;
+  LONGEST len = 0;
   int stack_offset = 0;
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   CORE_ADDR func_addr = find_function_addr (function, NULL);
@@ -5403,13 +5403,13 @@ mips_o32_push_dummy_call (struct gdbarch
       const gdb_byte *val;
       struct value *arg = args[argnum];
       struct type *arg_type = check_typedef (value_type (arg));
-      int len = TYPE_LENGTH (arg_type);
+      LONGEST len = TYPE_LENGTH (arg_type);
       enum type_code typecode = TYPE_CODE (arg_type);
 
       if (mips_debug)
 	fprintf_unfiltered (gdb_stdlog,
-			    "mips_o32_push_dummy_call: %d len=%d type=%d",
-			    argnum + 1, len, (int) typecode);
+			    "mips_o32_push_dummy_call: %d len=%s type=%d",
+			    argnum + 1, plongest (len), (int) typecode);
 
       val = value_contents (arg);
 
@@ -5867,8 +5867,8 @@ mips_o64_push_dummy_call (struct gdbarch
   int argreg;
   int float_argreg;
   int argnum;
-  int len = 0;
-  int stack_offset = 0;
+  LONGEST len = 0;
+  LONGEST stack_offset = 0;
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   CORE_ADDR func_addr = find_function_addr (function, NULL);
 
@@ -5928,13 +5928,13 @@ mips_o64_push_dummy_call (struct gdbarch
       const gdb_byte *val;
       struct value *arg = args[argnum];
       struct type *arg_type = check_typedef (value_type (arg));
-      int len = TYPE_LENGTH (arg_type);
+      LONGEST len = TYPE_LENGTH (arg_type);
       enum type_code typecode = TYPE_CODE (arg_type);
 
       if (mips_debug)
 	fprintf_unfiltered (gdb_stdlog,
-			    "mips_o64_push_dummy_call: %d len=%d type=%d",
-			    argnum + 1, len, (int) typecode);
+			    "mips_o64_push_dummy_call: %d len=%s type=%d",
+			    argnum + 1, plongest (len), (int) typecode);
 
       val = value_contents (arg);
 
Index: gdb-7.9.50.20150520/gdb/mn10300-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/mn10300-tdep.c	2015-05-31 17:15:01.095868279 +0200
+++ gdb-7.9.50.20150520/gdb/mn10300-tdep.c	2015-05-31 17:15:03.435882947 +0200
@@ -1225,7 +1225,7 @@ mn10300_push_dummy_call (struct gdbarch
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   const int push_size = register_size (gdbarch, E_PC_REGNUM);
   int regs_used;
-  int len, arg_len; 
+  LONGEST len, arg_len; 
   int stack_offset = 0;
   int argnum;
   const gdb_byte *val;
Index: gdb-7.9.50.20150520/gdb/mt-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/mt-tdep.c	2015-05-31 17:15:01.096868286 +0200
+++ gdb-7.9.50.20150520/gdb/mt-tdep.c	2015-05-31 17:15:03.436882953 +0200
@@ -781,9 +781,9 @@ mt_push_dummy_call (struct gdbarch *gdba
   gdb_byte buf[MT_MAX_STRUCT_SIZE];
   int argreg = MT_1ST_ARGREG;
   int split_param_len = 0;
-  int stack_dest = sp;
+  LONGEST stack_dest = sp;
   int slacklen;
-  int typelen;
+  LONGEST typelen;
   int i, j;
 
   /* First handle however many args we can fit into MT_1ST_ARGREG thru
Index: gdb-7.9.50.20150520/gdb/ppc-sysv-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/ppc-sysv-tdep.c	2015-05-31 17:15:01.097868292 +0200
+++ gdb-7.9.50.20150520/gdb/ppc-sysv-tdep.c	2015-05-31 17:15:03.436882953 +0200
@@ -66,7 +66,7 @@ ppc_sysv_abi_push_dummy_call (struct gdb
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   int opencl_abi = ppc_sysv_use_opencl_abi (value_type (function));
   ULONGEST saved_sp;
-  int argspace = 0;		/* 0 is an initial wrong guess.  */
+  LONGEST argspace = 0;		/* 0 is an initial wrong guess.  */
   int write_pass;
 
   gdb_assert (tdep->wordsize == 4);
@@ -97,9 +97,9 @@ ppc_sysv_abi_push_dummy_call (struct gdb
       /* Next available vector register for vector arguments.  */
       int vreg = 2;
       /* Arguments start above the "LR save word" and "Back chain".  */
-      int argoffset = 2 * tdep->wordsize;
+      LONGEST argoffset = 2 * tdep->wordsize;
       /* Structures start after the arguments.  */
-      int structoffset = argoffset + argspace;
+      LONGEST structoffset = argoffset + argspace;
 
       /* If the function is returning a `struct', then the first word
          (which will be passed in r3) is used for struct return
@@ -118,7 +118,7 @@ ppc_sysv_abi_push_dummy_call (struct gdb
 	{
 	  struct value *arg = args[argno];
 	  struct type *type = check_typedef (value_type (arg));
-	  int len = TYPE_LENGTH (type);
+	  ssize_t len = TYPE_LENGTH (type);
 	  const bfd_byte *val = value_contents (arg);
 
 	  if (TYPE_CODE (type) == TYPE_CODE_FLT && len <= 8
@@ -1283,11 +1283,11 @@ struct ppc64_sysv_argpos
 
 static void
 ppc64_sysv_abi_push_val (struct gdbarch *gdbarch,
-			 const bfd_byte *val, int len, int align,
+			 const bfd_byte *val, ssize_t len, int align,
 			 struct ppc64_sysv_argpos *argpos)
 {
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
-  int offset = 0;
+  ssize_t offset = 0;
 
   /* Enforce alignment of stack location, if requested.  */
   if (align > tdep->wordsize)
Index: gdb-7.9.50.20150520/gdb/rl78-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/rl78-tdep.c	2015-05-31 17:15:01.097868292 +0200
+++ gdb-7.9.50.20150520/gdb/rl78-tdep.c	2015-05-31 17:15:03.437882959 +0200
@@ -1333,8 +1333,8 @@ rl78_push_dummy_call (struct gdbarch *gd
   for (i = nargs - 1; i >= 0; i--)
     {
       struct type *value_type = value_enclosing_type (args[i]);
-      int len = TYPE_LENGTH (value_type);
-      int container_len = (len + 1) & ~1;
+      LONGEST len = TYPE_LENGTH (value_type);
+      LONGEST container_len = (len + 1) & ~1;
 
       sp -= container_len;
       write_memory (rl78_make_data_address (sp),
Index: gdb-7.9.50.20150520/gdb/rs6000-aix-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/rs6000-aix-tdep.c	2015-05-31 17:15:01.098868298 +0200
+++ gdb-7.9.50.20150520/gdb/rs6000-aix-tdep.c	2015-05-31 17:15:03.437882959 +0200
@@ -186,9 +186,9 @@ rs6000_push_dummy_call (struct gdbarch *
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   int ii;
-  int len = 0;
+  LONGEST len = 0;
   int argno;			/* current argument number */
-  int argbytes;			/* current argument byte */
+  LONGEST argbytes;		/* current argument byte */
   gdb_byte tmp_buffer[50];
   int f_argno = 0;		/* current floating point argno */
   int wordsize = gdbarch_tdep (gdbarch)->wordsize;
@@ -321,7 +321,7 @@ ran_out_of_registers_for_arguments:
 
   if ((argno < nargs) || argbytes)
     {
-      int space = 0, jj;
+      LONGEST space = 0, jj;
 
       if (argbytes)
 	{
Index: gdb-7.9.50.20150520/gdb/s390-linux-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/s390-linux-tdep.c	2015-05-31 17:15:01.099868304 +0200
+++ gdb-7.9.50.20150520/gdb/s390-linux-tdep.c	2015-05-31 17:16:13.285320769 +0200
@@ -2463,7 +2463,7 @@ s390_function_arg_vector (struct type *t
 /* Determine whether N is a power of two.  */
 
 static int
-is_power_of_two (unsigned int n)
+is_power_of_two (ULONGEST n)
 {
   return n && ((n & (n - 1)) == 0);
 }
@@ -2520,7 +2520,7 @@ s390_handle_arg (struct s390_arg_state *
 		 enum bfd_endian byte_order, int is_unnamed)
 {
   struct type *type = check_typedef (value_type (arg));
-  unsigned int length = TYPE_LENGTH (type);
+  ULONGEST length = TYPE_LENGTH (type);
   int write_mode = as->regcache != NULL;
 
   if (s390_function_arg_float (type))
Index: gdb-7.9.50.20150520/gdb/score-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/score-tdep.c	2015-05-31 17:15:01.100868311 +0200
+++ gdb-7.9.50.20150520/gdb/score-tdep.c	2015-05-31 17:15:03.439882972 +0200
@@ -514,7 +514,7 @@ score_push_dummy_call (struct gdbarch *g
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   int argnum;
   int argreg;
-  int arglen = 0;
+  LONGEST arglen = 0;
   CORE_ADDR stack_offset = 0;
   CORE_ADDR addr = 0;
 
Index: gdb-7.9.50.20150520/gdb/sh-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/sh-tdep.c	2015-05-31 17:15:01.101868317 +0200
+++ gdb-7.9.50.20150520/gdb/sh-tdep.c	2015-05-31 17:15:03.439882972 +0200
@@ -805,7 +805,7 @@ sh_skip_prologue (struct gdbarch *gdbarc
 static int
 sh_use_struct_convention (int renesas_abi, struct type *type)
 {
-  int len = TYPE_LENGTH (type);
+  LONGEST len = TYPE_LENGTH (type);
   int nelem = TYPE_NFIELDS (type);
 
   /* The Renesas ABI returns aggregate types always on stack.  */
@@ -907,7 +907,7 @@ sh_frame_align (struct gdbarch *ignore,
 
 /* Helper function to justify value in register according to endianess.  */
 static const gdb_byte *
-sh_justify_value_in_reg (struct gdbarch *gdbarch, struct value *val, int len)
+sh_justify_value_in_reg (struct gdbarch *gdbarch, struct value *val, LONGEST len)
 {
   static gdb_byte valbuf[4];
 
@@ -1067,7 +1067,8 @@ sh_push_dummy_call_fpu (struct gdbarch *
   struct type *type;
   CORE_ADDR regval;
   const gdb_byte *val;
-  int len, reg_size = 0;
+  LONGEST len;
+  int reg_size = 0;
   int pass_on_stack = 0;
   int treat_as_flt;
   int last_reg_arg = INT_MAX;
@@ -1208,7 +1209,8 @@ sh_push_dummy_call_nofpu (struct gdbarch
   struct type *type;
   CORE_ADDR regval;
   const gdb_byte *val;
-  int len, reg_size = 0;
+  LONGEST len;
+  int reg_size = 0;
   int pass_on_stack = 0;
   int last_reg_arg = INT_MAX;
 
Index: gdb-7.9.50.20150520/gdb/sh64-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/sh64-tdep.c	2015-05-31 17:15:01.102868323 +0200
+++ gdb-7.9.50.20150520/gdb/sh64-tdep.c	2015-05-31 17:15:03.440882978 +0200
@@ -1056,7 +1056,7 @@ sh64_push_dummy_call (struct gdbarch *gd
 		      CORE_ADDR struct_addr)
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  int stack_offset, stack_alloc;
+  LONGEST stack_offset, stack_alloc;
   int int_argreg;
   int float_argreg;
   int double_argreg;
@@ -1067,7 +1067,7 @@ sh64_push_dummy_call (struct gdbarch *gd
   CORE_ADDR regval;
   const gdb_byte *val;
   gdb_byte valbuf[8];
-  int len;
+  LONGEST len;
   int argreg_size;
   int fp_args[12];
 
Index: gdb-7.9.50.20150520/gdb/sparc-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/sparc-tdep.c	2015-05-31 17:15:01.103868329 +0200
+++ gdb-7.9.50.20150520/gdb/sparc-tdep.c	2015-05-31 17:15:03.441882984 +0200
@@ -525,7 +525,7 @@ sparc32_store_arguments (struct regcache
   for (i = 0; i < nargs; i++)
     {
       struct type *type = value_type (args[i]);
-      int len = TYPE_LENGTH (type);
+      LONGEST len = TYPE_LENGTH (type);
 
       if (sparc_structure_or_union_p (type)
 	  || (sparc_floating_p (type) && len == 16)
Index: gdb-7.9.50.20150520/gdb/sparc64-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/sparc64-tdep.c	2015-05-31 17:15:01.104868336 +0200
+++ gdb-7.9.50.20150520/gdb/sparc64-tdep.c	2015-05-31 17:15:03.441882984 +0200
@@ -636,7 +636,8 @@ sparc64_16_byte_align_p (struct type *ty
 
 static void
 sparc64_store_floating_fields (struct regcache *regcache, struct type *type,
-			       const gdb_byte *valbuf, int element, int bitpos)
+			       const gdb_byte *valbuf, int element,
+			       LONGEST bitpos)
 {
   int len = TYPE_LENGTH (type);
 
@@ -678,7 +679,7 @@ sparc64_store_floating_fields (struct re
       for (i = 0; i < TYPE_NFIELDS (type); i++)
 	{
 	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));
-	  int subpos = bitpos + TYPE_FIELD_BITPOS (type, i);
+	  LONGEST subpos = bitpos + TYPE_FIELD_BITPOS (type, i);
 
 	  sparc64_store_floating_fields (regcache, subtype, valbuf,
 					 element, subpos);
@@ -710,7 +711,7 @@ sparc64_store_floating_fields (struct re
 
 static void
 sparc64_extract_floating_fields (struct regcache *regcache, struct type *type,
-				 gdb_byte *valbuf, int bitpos)
+				 gdb_byte *valbuf, LONGEST bitpos)
 {
   if (sparc64_floating_p (type))
     {
@@ -747,7 +748,7 @@ sparc64_extract_floating_fields (struct
       for (i = 0; i < TYPE_NFIELDS (type); i++)
 	{
 	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));
-	  int subpos = bitpos + TYPE_FIELD_BITPOS (type, i);
+	  LONGEST subpos = bitpos + TYPE_FIELD_BITPOS (type, i);
 
 	  sparc64_extract_floating_fields (regcache, subtype, valbuf, subpos);
 	}
@@ -780,7 +781,7 @@ sparc64_store_arguments (struct regcache
   for (i = 0; i < nargs; i++)
     {
       struct type *type = value_type (args[i]);
-      int len = TYPE_LENGTH (type);
+      LONGEST len = TYPE_LENGTH (type);
 
       if (sparc64_structure_or_union_p (type)
 	  || (sparc64_complex_floating_p (type) && len == 32))
@@ -880,7 +881,7 @@ sparc64_store_arguments (struct regcache
     {
       const gdb_byte *valbuf = value_contents (args[i]);
       struct type *type = value_type (args[i]);
-      int len = TYPE_LENGTH (type);
+      LONGEST len = TYPE_LENGTH (type);
       int regnum = -1;
       gdb_byte buf[16];
 
Index: gdb-7.9.50.20150520/gdb/spu-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/spu-tdep.c	2015-05-31 17:15:01.105868342 +0200
+++ gdb-7.9.50.20150520/gdb/spu-tdep.c	2015-05-31 17:15:03.442882990 +0200
@@ -1430,7 +1430,7 @@ spu_push_dummy_call (struct gdbarch *gdb
       struct value *arg = args[i];
       struct type *type = check_typedef (value_type (arg));
       const gdb_byte *contents = value_contents (arg);
-      int n_regs = align_up (TYPE_LENGTH (type), 16) / 16;
+      LONGEST n_regs = align_up (TYPE_LENGTH (type), 16) / 16;
 
       /* If the argument doesn't wholly fit into registers, it and
 	 all subsequent arguments go to the stack.  */
@@ -1462,7 +1462,7 @@ spu_push_dummy_call (struct gdbarch *gdb
 	{
 	  struct value *arg = args[i];
 	  struct type *type = check_typedef (value_type (arg));
-	  int len = TYPE_LENGTH (type);
+	  LONGEST len = TYPE_LENGTH (type);
 	  int preferred_slot;
 	  
 	  if (spu_scalar_value_p (type))
Index: gdb-7.9.50.20150520/gdb/tic6x-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/tic6x-tdep.c	2015-05-31 17:15:01.106868348 +0200
+++ gdb-7.9.50.20150520/gdb/tic6x-tdep.c	2015-05-31 17:15:03.442882990 +0200
@@ -895,7 +895,7 @@ tic6x_push_dummy_call (struct gdbarch *g
   int argreg = 0;
   int argnum;
   int stack_offset = 4;
-  int references_offset = 4;
+  LONGEST references_offset = 4;
   CORE_ADDR func_addr = find_function_addr (function, NULL);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   struct type *func_type = value_type (function);
@@ -929,7 +929,7 @@ tic6x_push_dummy_call (struct gdbarch *g
   /* Now make space on the stack for the args.  */
   for (argnum = 0; argnum < nargs; argnum++)
     {
-      int len = align_up (TYPE_LENGTH (value_type (args[argnum])), 4);
+      LONGEST len = align_up (TYPE_LENGTH (value_type (args[argnum])), 4);
       if (argnum >= 10 - argreg)
 	references_offset += len;
       stack_offset += len;
@@ -948,7 +948,7 @@ tic6x_push_dummy_call (struct gdbarch *g
       const gdb_byte *val;
       struct value *arg = args[argnum];
       struct type *arg_type = check_typedef (value_type (arg));
-      int len = TYPE_LENGTH (arg_type);
+      ssize_t len = TYPE_LENGTH (arg_type);
       enum type_code typecode = TYPE_CODE (arg_type);
 
       val = value_contents (arg);
@@ -1108,7 +1108,8 @@ tic6x_push_dummy_call (struct gdbarch *g
 	    }
 	  else
 	    internal_error (__FILE__, __LINE__,
-			    _("unexpected length %d of arg %d"), len, argnum);
+			    _("unexpected length %s of arg %d"),
+			    plongest (len), argnum);
 
 	  addr = sp + stack_offset;
 	  write_memory (addr, val, len);
Index: gdb-7.9.50.20150520/gdb/tilegx-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/tilegx-tdep.c	2015-05-31 17:15:01.107868355 +0200
+++ gdb-7.9.50.20150520/gdb/tilegx-tdep.c	2015-05-31 17:15:03.442882990 +0200
@@ -288,7 +288,7 @@ tilegx_push_dummy_call (struct gdbarch *
   CORE_ADDR stack_dest = sp;
   int argreg = TILEGX_R0_REGNUM;
   int i, j;
-  int typelen, slacklen, alignlen;
+  LONGEST typelen, slacklen, alignlen;
   static const gdb_byte four_zero_words[16] = { 0 };
 
   /* If struct_return is 1, then the struct return address will
Index: gdb-7.9.50.20150520/gdb/v850-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/v850-tdep.c	2015-05-31 17:15:01.107868355 +0200
+++ gdb-7.9.50.20150520/gdb/v850-tdep.c	2015-05-31 17:15:03.443882997 +0200
@@ -1019,7 +1019,7 @@ v850_push_dummy_call (struct gdbarch *gd
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   int argreg;
   int argnum;
-  int len = 0;
+  LONGEST len = 0;
   int stack_offset;
 
   if (gdbarch_tdep (gdbarch)->abi == V850_ABI_RH850)
@@ -1047,7 +1047,7 @@ v850_push_dummy_call (struct gdbarch *gd
      in four registers available.  Loop thru args from first to last.  */
   for (argnum = 0; argnum < nargs; argnum++)
     {
-      int len;
+      LONGEST len;
       gdb_byte *val;
       gdb_byte valbuf[v850_reg_size];
 
Index: gdb-7.9.50.20150520/gdb/vax-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/vax-tdep.c	2015-05-31 17:15:01.108868361 +0200
+++ gdb-7.9.50.20150520/gdb/vax-tdep.c	2015-05-31 17:15:03.443882997 +0200
@@ -111,7 +111,7 @@ vax_store_arguments (struct regcache *re
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   gdb_byte buf[4];
-  int count = 0;
+  LONGEST count = 0;
   int i;
 
   /* We create an argument list on the stack, and make the argument
@@ -120,7 +120,7 @@ vax_store_arguments (struct regcache *re
   /* Push arguments in reverse order.  */
   for (i = nargs - 1; i >= 0; i--)
     {
-      int len = TYPE_LENGTH (value_enclosing_type (args[i]));
+      LONGEST len = TYPE_LENGTH (value_enclosing_type (args[i]));
 
       sp -= (len + 3) & ~3;
       count += (len + 3) / 4;
Index: gdb-7.9.50.20150520/gdb/xstormy16-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/xstormy16-tdep.c	2015-05-31 17:15:01.108868361 +0200
+++ gdb-7.9.50.20150520/gdb/xstormy16-tdep.c	2015-05-31 17:15:03.443882997 +0200
@@ -233,8 +233,9 @@ xstormy16_push_dummy_call (struct gdbarc
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   CORE_ADDR stack_dest = sp;
   int argreg = E_1ST_ARG_REGNUM;
-  int i, j;
-  int typelen, slacklen;
+  int i, slacklen;
+  LONGEST j;
+  LONGEST typelen;
   const gdb_byte *val;
   gdb_byte buf[xstormy16_pc_size];
 
Index: gdb-7.9.50.20150520/gdb/xtensa-tdep.c
===================================================================
--- gdb-7.9.50.20150520.orig/gdb/xtensa-tdep.c	2015-05-31 17:15:01.110868373 +0200
+++ gdb-7.9.50.20150520/gdb/xtensa-tdep.c	2015-05-31 17:15:03.444883003 +0200
@@ -1646,8 +1646,7 @@ xtensa_store_return_value (struct type *
 
       if (len > (callsize > 8 ? 8 : 16))
 	internal_error (__FILE__, __LINE__,
-			_("unimplemented for this length: %d"),
-			TYPE_LENGTH (type));
+			_("unimplemented for this length: %d"), len);
       areg = arreg_number (gdbarch,
 			   gdbarch_tdep (gdbarch)->a0_base + 2 + callsize, wb);
 
@@ -1721,18 +1720,18 @@ xtensa_push_dummy_call (struct gdbarch *
 {
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   int i;
-  int size, onstack_size;
+  LONGEST size, onstack_size;
   gdb_byte *buf = (gdb_byte *) alloca (16);
   CORE_ADDR ra, ps;
   struct argument_info
   {
     const bfd_byte *contents;
-    int length;
+    ssize_t length;
     int onstack;		/* onstack == 0 => in reg */
     int align;			/* alignment */
     union
     {
-      int offset;		/* stack offset if on stack.  */
+      ssize_t offset;		/* stack offset if on stack.  */
       int regno;		/* regno if in register.  */
     } u;
   };
@@ -1756,9 +1755,10 @@ xtensa_push_dummy_call (struct gdbarch *
         {
 	  struct value *arg = args[i];
 	  struct type *arg_type = check_typedef (value_type (arg));
-	  fprintf_unfiltered (gdb_stdlog, "%2d: %s %3d ", i,
-			      host_address_to_string (arg),
-			      TYPE_LENGTH (arg_type));
+	  const char *arg_type_len_s = pulongest (TYPE_LENGTH (arg_type));
+
+	  fprintf_unfiltered (gdb_stdlog, "%2d: %s %s ", i,
+			      host_address_to_string (arg), arg_type_len_s);
 	  switch (TYPE_CODE (arg_type))
 	    {
 	    case TYPE_CODE_INT:
@@ -1828,8 +1828,8 @@ xtensa_push_dummy_call (struct gdbarch *
 	  info->align = TYPE_LENGTH (builtin_type (gdbarch)->builtin_long);
 	  break;
 	}
-      info->length = TYPE_LENGTH (arg_type);
       info->contents = value_contents (arg);
+      info->length = TYPE_LENGTH (arg_type);
 
       /* Align size and onstack_size.  */
       size = (size + info->align - 1) & ~(info->align - 1);
@@ -1874,7 +1874,7 @@ xtensa_push_dummy_call (struct gdbarch *
 
       if (info->onstack)
 	{
-	  int n = info->length;
+	  ssize_t n = info->length;
 	  CORE_ADDR offset = sp + info->u.offset;
 
 	  /* Odd-sized structs are aligned to the lower side of a memory
@@ -1890,7 +1890,7 @@ xtensa_push_dummy_call (struct gdbarch *
 	}
       else
 	{
-	  int n = info->length;
+	  ssize_t n = info->length;
 	  const bfd_byte *cp = info->contents;
 	  int r = info->u.regno;
 
