diff -up gdbm-1.9.1/src/bucket.c.shortread gdbm-1.9.1/src/bucket.c
--- gdbm-1.9.1/src/bucket.c.shortread	2011-08-03 21:22:23.000000000 +0200
+++ gdbm-1.9.1/src/bucket.c	2011-08-24 18:34:39.501857203 +0200
@@ -21,7 +21,7 @@
 #include "autoconf.h"
 
 #include "gdbmdefs.h"
-
+#include <errno.h>
 
 /* Initializing a new hash buckets sets all bucket entries to -1 hash value. */
 void
@@ -53,7 +53,8 @@ void
 _gdbm_get_bucket (GDBM_FILE dbf, int dir_index)
 {
   off_t bucket_adr;	/* The address of the correct hash bucket.  */
-  int   num_bytes;	/* The number of bytes read. */
+  int   num_bytes = 0; /* The total number of bytes read. */
+  int   bytes_read;    /* Number of bytes read in this syscall */
   off_t	file_pos;	/* The return address for lseek. */
   int   index;		/* Loop index. */
 
@@ -96,7 +97,12 @@ _gdbm_get_bucket (GDBM_FILE dbf, int dir
       if (file_pos != bucket_adr)
 	_gdbm_fatal (dbf, "lseek error");
 
-      num_bytes = __read (dbf, dbf->bucket, dbf->header->bucket_size);
+      do
+        {
+          bytes_read = __read (dbf, dbf->bucket+num_bytes, dbf->header->bucket_size-num_bytes);
+          if (bytes_read > 0) num_bytes += bytes_read;
+        }
+      while ((bytes_read > 0 || (bytes_read == -1 && errno == EINTR)) && num_bytes < dbf->header->bucket_size);
       if (num_bytes != dbf->header->bucket_size)
 	_gdbm_fatal (dbf, "read error");
     }
diff -up gdbm-1.9.1/src/falloc.c.shortread gdbm-1.9.1/src/falloc.c
--- gdbm-1.9.1/src/falloc.c.shortread	2011-08-24 18:23:16.876903878 +0200
+++ gdbm-1.9.1/src/falloc.c	2011-08-24 18:36:15.877850610 +0200
@@ -21,7 +21,7 @@
 #include "autoconf.h"
 
 #include "gdbmdefs.h"
-
+#include <errno.h>
 
 /* The forward definitions for this file.  See the functions for
    the definition of the function. */
@@ -158,7 +158,8 @@ _gdbm_free (GDBM_FILE dbf, off_t file_ad
 static void
 pop_avail_block (GDBM_FILE dbf)
 {
-  int  num_bytes;		/* For use with the read system call. */
+  int  num_bytes = 0;          /* For use with the read system call. */
+  int  bytes_read;             /* For use with the read system call. */
   off_t file_pos;		/* For use with the lseek system call. */
   avail_elem new_el;
   avail_block *new_blk;
@@ -183,7 +184,12 @@ pop_avail_block (GDBM_FILE dbf)
   /* Read the block. */
   file_pos = __lseek (dbf, new_el.av_adr, L_SET);
   if (file_pos != new_el.av_adr)  _gdbm_fatal (dbf, "lseek error");
-  num_bytes = __read (dbf, new_blk, new_el.av_size);
+  do
+    {
+      bytes_read = __read (dbf, new_blk+num_bytes, new_el.av_size-num_bytes);
+      if (bytes_read > 0) num_bytes += bytes_read;
+    }
+  while ((bytes_read > 0 || (bytes_read == -1 && errno == EINTR)) && num_bytes < new_el.av_size);
   if (num_bytes != new_el.av_size) _gdbm_fatal (dbf, "read error");
 
   /* Add the elements from the new block to the header. */
diff -up gdbm-1.9.1/src/findkey.c.shortread gdbm-1.9.1/src/findkey.c
--- gdbm-1.9.1/src/findkey.c.shortread	2011-08-03 21:22:23.000000000 +0200
+++ gdbm-1.9.1/src/findkey.c	2011-08-24 18:37:00.591847528 +0200
@@ -21,6 +21,7 @@
 #include "autoconf.h"
 
 #include "gdbmdefs.h"
+#include <errno.h>
 
 
 /* Read the data found in bucket entry ELEM_LOC in file DBF and
@@ -29,11 +30,12 @@
 char *
 _gdbm_read_entry (GDBM_FILE dbf, int elem_loc)
 {
-  int num_bytes;		/* For seeking and reading. */
+  int num_bytes = 0;           /* For seeking and reading. */
   int key_size;
   int data_size;
   off_t file_pos;
   data_cache_elem *data_ca;
+  int bytes_read;
 
   /* Is it already in the cache? */
   if (dbf->cache_entry->ca_data.elem_loc == elem_loc)
@@ -61,7 +63,12 @@ _gdbm_read_entry (GDBM_FILE dbf, int ele
   file_pos = __lseek (dbf, dbf->bucket->h_table[elem_loc].data_pointer, L_SET);
   if (file_pos != dbf->bucket->h_table[elem_loc].data_pointer)
     _gdbm_fatal (dbf, "lseek error");
-  num_bytes = __read (dbf, data_ca->dptr, key_size+data_size);
+  do
+    {
+      bytes_read = __read (dbf, data_ca->dptr+num_bytes, key_size+data_size-num_bytes);
+      if (bytes_read > 0) num_bytes += bytes_read;
+    }
+  while ((bytes_read > 0 || (bytes_read == -1 && errno == EINTR)) && num_bytes < key_size+data_size);
   if (num_bytes != key_size+data_size) _gdbm_fatal (dbf, "read error");
   
   return data_ca->dptr;
