diff --git a/zbar/debug.h b/zbar/debug.h
--- a/zbar/debug.h
+++ b/zbar/debug.h
@@ -27,10 +27,10 @@
 
 # ifdef __GNUC__
     /* older versions of gcc (< 2.95) require a named varargs parameter */
-#  define dprintf(args...) while(0)
+#  define debprintf(args...) while(0)
 # else
     /* unfortunately named vararg parameter is a gcc-specific extension */
-#  define dprintf(...) while(0)
+#  define debprintf(...) while(0)
 # endif
 
 #else
@@ -38,12 +38,12 @@
 # include <stdio.h>
 
 # ifdef __GNUC__
-#  define dprintf(level, args...) do {  \
+#  define debprintf(level, args...) do {  \
         if((level) <= DEBUG_LEVEL)      \
             fprintf(stderr, args);      \
     } while(0)
 # else
-#  define dprintf(level, ...) do {          \
+#  define debprintf(level, ...) do {          \
         if((level) <= DEBUG_LEVEL)          \
             fprintf(stderr, __VA_ARGS__);   \
     } while(0)
diff --git a/zbar/decoder.c b/zbar/decoder.c
--- a/zbar/decoder.c
+++ b/zbar/decoder.c
@@ -218,7 +218,7 @@ zbar_symbol_type_t zbar_decode_width (zb
     zbar_symbol_type_t tmp, sym = ZBAR_NONE;
 
     dcode->w[dcode->idx & (DECODE_WINDOW - 1)] = w;
-    dprintf(1, "    decode[%x]: w=%d (%g)\n", dcode->idx, w, (w / 32.));
+    debprintf(1, "    decode[%x]: w=%d (%g)\n", dcode->idx, w, (w / 32.));
 
     /* update shared character width */
     dcode->s6 -= get_width(dcode, 7);
diff --git a/zbar/decoder.h b/zbar/decoder.h
--- a/zbar/decoder.h
+++ b/zbar/decoder.h
@@ -188,7 +188,7 @@ static inline char acquire_lock (zbar_de
                                  zbar_symbol_type_t req)
 {
     if(dcode->lock) {
-        dprintf(2, " [locked %d]\n", dcode->lock);
+        debprintf(2, " [locked %d]\n", dcode->lock);
         return(1);
     }
     dcode->lock = req;
diff --git a/zbar/decoder/code128.c b/zbar/decoder/code128.c
--- a/zbar/decoder/code128.c
+++ b/zbar/decoder/code128.c
@@ -137,7 +137,7 @@ static inline signed char decode_lo (int
     zassert(idx <= 0x50, -1, "sig=%x offset=%x base=%x idx=%x\n",
             sig, offset, base, idx);
     c = characters[idx];
-    dprintf(2, " %02x(%x(%02x)/%x(%02x)) => %02x",
+    debprintf(2, " %02x(%x(%02x)/%x(%02x)) => %02x",
             idx, base, lo_base[base], offset, lo_offset[offset],
             (unsigned char)c);
     return(c);
@@ -152,7 +152,7 @@ static inline signed char decode_hi (int
                ((sig >>  4) & 0x00f0) |
                ((sig <<  4) & 0x0f00) |
                ((sig << 12) & 0xf000));
-    dprintf(2, " rev=%x", rev != 0);
+    debprintf(2, " rev=%x", rev != 0);
 
     switch(sig) {
     case 0x0014: idx = 0x0; break;
@@ -174,7 +174,7 @@ static inline signed char decode_hi (int
     if(rev)
         idx += 0xe;
     c = characters[0x51 + idx];
-    dprintf(2, " %02x => %02x", idx, c);
+    debprintf(2, " %02x => %02x", idx, c);
     return(c);
 }
 
@@ -199,7 +199,7 @@ static inline signed char decode6 (zbar_
     /* build edge signature of character */
     unsigned s = dcode->code128.s6;
 
-    dprintf(2, " s=%d", s);
+    debprintf(2, " s=%d", s);
     if(s < 5)
         return(-1);
     /* calculate similar edge measurements */
@@ -214,7 +214,7 @@ static inline signed char decode6 (zbar_
            (decode_e(get_width(dcode, 2) + get_width(dcode, 1), s, 11)));
     if(sig < 0)
         return(-1);
-    dprintf(2, " sig=%04x", sig);
+    debprintf(2, " sig=%04x", sig);
     /* lookup edge signature */
     c = (sig & 0x4444) ? decode_hi(sig) : decode_lo(sig);
     if(c == -1)
@@ -226,7 +226,7 @@ static inline signed char decode6 (zbar_
         : (get_width(dcode, 1) + get_width(dcode, 3) + get_width(dcode, 5));
     bars = bars * 11 * 4 / s;
     chk = calc_check(c);
-    dprintf(2, " bars=%d chk=%d", bars, chk);
+    debprintf(2, " bars=%d chk=%d", bars, chk);
     if(chk - 7 > bars || bars > chk + 7)
         return(-1);
 
@@ -268,10 +268,10 @@ static inline unsigned char validate_che
     /* and compare to check character */
     idx = (dcode128->direction) ? 1 : dcode128->character - 2;
     check = dcode->buf[idx];
-    dprintf(2, " chk=%02x(%02x)", sum, check);
+    debprintf(2, " chk=%02x(%02x)", sum, check);
     err = (sum != check);
     if(err)
-        dprintf(1, " [checksum error]\n");
+        debprintf(1, " [checksum error]\n");
     return(err);
 }
 
@@ -330,12 +330,12 @@ static inline unsigned char postprocess 
     unsigned i, j, cexp;
     unsigned char code = 0, charset;
     code128_decoder_t *dcode128 = &dcode->code128;
-    dprintf(2, "\n    postproc len=%d", dcode128->character);
+    debprintf(2, "\n    postproc len=%d", dcode128->character);
     dcode->modifiers = 0;
     dcode->direction = 1 - 2 * dcode128->direction;
     if(dcode128->direction) {
         /* reverse buffer */
-        dprintf(2, " (rev)");
+        debprintf(2, " (rev)");
         for(i = 0; i < dcode128->character / 2; i++) {
             unsigned j = dcode128->character - 1 - i;
             code = dcode->buf[i];
@@ -357,7 +357,7 @@ static inline unsigned char postprocess 
 
     charset = code - START_A;
     cexp = (code == START_C) ? 1 : 0;
-    dprintf(2, " start=%c", 'A' + charset);
+    debprintf(2, " start=%c", 'A' + charset);
 
     for(i = 1, j = 0; i < dcode128->character - 2; i++) {
         unsigned char code = dcode->buf[i];
@@ -380,7 +380,7 @@ static inline unsigned char postprocess 
                 charset &= 0x7f;
         }
         else {
-            dprintf(2, " %02x", code);
+            debprintf(2, " %02x", code);
             if(charset & 0x2) {
                 unsigned delta;
                 /* expand character set C to ASCII */
@@ -414,7 +414,7 @@ static inline unsigned char postprocess 
                 /*else drop trailing FNC1 */
             }
             else if(code >= START_A) {
-                dprintf(1, " [truncated]\n");
+                debprintf(1, " [truncated]\n");
                 return(1);
             }
             else {
@@ -465,21 +465,21 @@ zbar_symbol_type_t _zbar_decode_code128 
         return(0);
     dcode128->element = 0;
 
-    dprintf(2, "      code128[%c%02d+%x]:",
+    debprintf(2, "      code128[%c%02d+%x]:",
             (dcode128->direction) ? '<' : '>',
             dcode128->character, dcode128->element);
 
     c = decode6(dcode);
     if(dcode128->character < 0) {
         unsigned qz;
-        dprintf(2, " c=%02x", c);
+        debprintf(2, " c=%02x", c);
         if(c < START_A || c > STOP_REV || c == STOP_FWD) {
-            dprintf(2, " [invalid]\n");
+            debprintf(2, " [invalid]\n");
             return(0);
         }
         qz = get_width(dcode, 6);
         if(qz && qz < (dcode128->s6 * 3) / 4) {
-            dprintf(2, " [invalid qz %d]\n", qz);
+            debprintf(2, " [invalid qz %d]\n", qz);
             return(0);
         }
         /* decoded valid start/stop */
@@ -493,13 +493,13 @@ zbar_symbol_type_t _zbar_decode_code128 
             dcode128->direction = ZBAR_SPACE;
         dcode128->start = c;
         dcode128->width = dcode128->s6;
-        dprintf(2, " dir=%x [valid start]\n", dcode128->direction);
+        debprintf(2, " dir=%x [valid start]\n", dcode128->direction);
         return(0);
     }
     else if((c < 0) ||
             ((dcode128->character >= BUFFER_MIN) &&
              size_buf(dcode, dcode128->character + 1))) {
-        dprintf(1, (c < 0) ? " [aborted]\n" : " [overflow]\n");
+        debprintf(1, (c < 0) ? " [aborted]\n" : " [overflow]\n");
         if(dcode128->character > 1)
             release_lock(dcode, ZBAR_CODE128);
         dcode128->character = -1;
@@ -513,7 +513,7 @@ zbar_symbol_type_t _zbar_decode_code128 
             dw = dcode128->s6 - dcode128->width;
         dw *= 4;
         if(dw > dcode128->width) {
-            dprintf(1, " [width var]\n");
+            debprintf(1, " [width var]\n");
             if(dcode128->character > 1)
                 release_lock(dcode, ZBAR_CODE128);
             dcode128->character = -1;
@@ -549,17 +549,17 @@ zbar_symbol_type_t _zbar_decode_code128 
         else if(dcode128->character < CFG(*dcode128, ZBAR_CFG_MIN_LEN) ||
                 (CFG(*dcode128, ZBAR_CFG_MAX_LEN) > 0 &&
                  dcode128->character > CFG(*dcode128, ZBAR_CFG_MAX_LEN))) {
-            dprintf(2, " [invalid len]\n");
+            debprintf(2, " [invalid len]\n");
             sym = ZBAR_NONE;
         }
         else
-            dprintf(2, " [valid end]\n");
+            debprintf(2, " [valid end]\n");
         dcode128->character = -1;
         if(!sym)
             release_lock(dcode, ZBAR_CODE128);
         return(sym);
     }
 
-    dprintf(2, "\n");
+    debprintf(2, "\n");
     return(0);
 }
diff --git a/zbar/decoder/code39.c b/zbar/decoder/code39.c
--- a/zbar/decoder/code39.c
+++ b/zbar/decoder/code39.c
@@ -136,10 +136,10 @@ static inline unsigned char code39_decod
     enc <<= 1;
     if(E > 6) {
         enc |= 1;
-        dprintf(2, "1");
+        debprintf(2, "1");
     }
     else
-        dprintf(2, "0");
+        debprintf(2, "0");
     return(enc);
 }
 
@@ -180,7 +180,7 @@ static inline signed char code39_decode9
     zassert(idx < 0x2c, -1, " idx=%x enc=%x s9=%x\n", idx, enc, dcode39->s9);
 
     const char39_t *c = &code39_encodings[idx];
-    dprintf(2, " i=%02x chk=%02x c=%02x/%02x", idx, c->chk, c->fwd, c->rev);
+    debprintf(2, " i=%02x chk=%02x c=%02x/%02x", idx, c->chk, c->fwd, c->rev);
     if(enc != c->chk)
         return(-1);
 
@@ -191,11 +191,11 @@ static inline signed char code39_decode9
 static inline signed char code39_decode_start (zbar_decoder_t *dcode)
 {
     code39_decoder_t *dcode39 = &dcode->code39;
-    dprintf(2, " s=%d ", dcode39->s9);
+    debprintf(2, " s=%d ", dcode39->s9);
 
     signed char c = code39_decode9(dcode);
     if(c != 0x19 && c != 0x2b) {
-        dprintf(2, "\n");
+        debprintf(2, "\n");
         return(ZBAR_NONE);
     }
     dcode39->direction ^= (c == 0x19);
@@ -203,13 +203,13 @@ static inline signed char code39_decode_
     /* check leading quiet zone - spec is 10x */
     unsigned quiet = get_width(dcode, 9);
     if(quiet && quiet < dcode39->s9 / 2) {
-        dprintf(2, " [invalid quiet]\n");
+        debprintf(2, " [invalid quiet]\n");
         return(ZBAR_NONE);
     }
 
     dcode39->element = 9;
     dcode39->character = 0;
-    dprintf(1, " dir=%x [valid start]\n", dcode39->direction);
+    debprintf(1, " dir=%x [valid start]\n", dcode39->direction);
     return(ZBAR_PARTIAL);
 }
 
@@ -220,7 +220,7 @@ static inline void code39_postprocess (z
     int i;
     if(dcode39->direction) {
         /* reverse buffer */
-        dprintf(2, " (rev)");
+        debprintf(2, " (rev)");
         for(i = 0; i < dcode39->character / 2; i++) {
             unsigned j = dcode39->character - 1 - i;
             char code = dcode->buf[i];
@@ -258,14 +258,14 @@ zbar_symbol_type_t _zbar_decode_code39 (
     if(dcode39->character < 0) {
         if(get_color(dcode) != ZBAR_BAR)
             return(ZBAR_NONE);
-        dprintf(2, "      code39:");
+        debprintf(2, "      code39:");
         return(code39_decode_start(dcode));
     }
 
     if(++dcode39->element < 9)
         return(ZBAR_NONE);
 
-    dprintf(2, "      code39[%c%02d+%x]",
+    debprintf(2, "      code39[%c%02d+%x]",
             (dcode39->direction) ? '<' : '>',
             dcode39->character, dcode39->element);
 
@@ -279,19 +279,19 @@ zbar_symbol_type_t _zbar_decode_code39 (
 
             /* trailing quiet zone check */
             if(space && space < dcode39->width / 2) {
-                dprintf(2, " [invalid qz]\n");
+                debprintf(2, " [invalid qz]\n");
                 sym = ZBAR_NONE;
             }
             else if(dcode39->character < CFG(*dcode39, ZBAR_CFG_MIN_LEN) ||
                     (CFG(*dcode39, ZBAR_CFG_MAX_LEN) > 0 &&
                      dcode39->character > CFG(*dcode39, ZBAR_CFG_MAX_LEN))) {
-                dprintf(2, " [invalid len]\n");
+                debprintf(2, " [invalid len]\n");
                 sym = ZBAR_NONE;
             }
             else {
                 /* FIXME checksum (needs config enable) */
                 code39_postprocess(dcode);
-                dprintf(2, " [valid end]\n");
+                debprintf(2, " [valid end]\n");
             }
             dcode39->character = -1;
             if(!sym)
@@ -300,19 +300,19 @@ zbar_symbol_type_t _zbar_decode_code39 (
         }
         if(space > dcode39->width / 2) {
             /* inter-character space check failure */
-            dprintf(2, " ics>%d [invalid ics]", dcode39->width);
+            debprintf(2, " ics>%d [invalid ics]", dcode39->width);
             if(dcode39->character)
                 release_lock(dcode, ZBAR_CODE39);
             dcode39->character = -1;
         }
         dcode39->element = 0;
-        dprintf(2, "\n");
+        debprintf(2, "\n");
         return(ZBAR_NONE);
     }
 
-    dprintf(2, " s=%d ", dcode39->s9);
+    debprintf(2, " s=%d ", dcode39->s9);
     if(!check_width(dcode39->width, dcode39->s9)) {
-        dprintf(2, " [width]\n");
+        debprintf(2, " [width]\n");
         if(dcode39->character)
             release_lock(dcode, ZBAR_CODE39);
         dcode39->character = -1;
@@ -320,7 +320,7 @@ zbar_symbol_type_t _zbar_decode_code39 (
     }
 
     signed char c = code39_decode9(dcode);
-    dprintf(2, " c=%d", c);
+    debprintf(2, " c=%d", c);
 
     /* lock shared resources */
     if(!dcode39->character && acquire_lock(dcode, ZBAR_CODE39)) {
@@ -331,14 +331,14 @@ zbar_symbol_type_t _zbar_decode_code39 (
     if(c < 0 ||
        ((dcode39->character >= BUFFER_MIN) &&
         size_buf(dcode, dcode39->character + 1))) {
-        dprintf(1, (c < 0) ? " [aborted]\n" : " [overflow]\n");
+        debprintf(1, (c < 0) ? " [aborted]\n" : " [overflow]\n");
         release_lock(dcode, ZBAR_CODE39);
         dcode39->character = -1;
         return(ZBAR_NONE);
     }
     else {
         zassert(c < 0x2c, ZBAR_NONE, "c=%02x s9=%x\n", c, dcode39->s9);
-        dprintf(2, "\n");
+        debprintf(2, "\n");
     }
 
     dcode->buf[dcode39->character++] = c;
diff --git a/zbar/decoder/ean.c b/zbar/decoder/ean.c
--- a/zbar/decoder/ean.c
+++ b/zbar/decoder/ean.c
@@ -132,22 +132,22 @@ static inline signed char aux_end (zbar_
     /* check quiet zone */
     unsigned qz = get_width(dcode, 0);
     if(!fwd && qz && qz <= s * 3 / 4) {
-        dprintf(2, " [invalid quiet]");
+        debprintf(2, " [invalid quiet]");
         return(-1);
     }
 
-    dprintf(2, " (");
+    debprintf(2, " (");
     code = 0;
     for(i = 1 - fwd; i < 3 + fwd; i++) {
         unsigned e = get_width(dcode, i) + get_width(dcode, i + 1);
-        dprintf(2, " %d", e);
+        debprintf(2, " %d", e);
         code = (code << 2) | decode_e(e, s, 7);
         if(code < 0) {
-            dprintf(2, " [invalid end guard]");
+            debprintf(2, " [invalid end guard]");
             return(-1);
         }
     }
-    dprintf(2, ") s=%d aux=%x", s, code);
+    debprintf(2, ") s=%d aux=%x", s, code);
     return(code);
 }
 
@@ -162,7 +162,7 @@ static inline signed char aux_start (zba
     if(dcode->ean.s4 < 6)
         return(-1);
     if(decode_e(e2, dcode->ean.s4, 7)) {
-        dprintf(2, " [invalid any]");
+        debprintf(2, " [invalid any]");
         return(/*FIXME (get_color(dcode) == ZBAR_SPACE) ? STATE_ADDON : */-1);
     }
 
@@ -174,17 +174,17 @@ static inline signed char aux_start (zba
         unsigned qz = get_width(dcode, 7);
         if(!qz || qz > dcode->ean.s4 * 3 / 4) {
             if(!E1) {
-                dprintf(2, " [valid normal]");
+                debprintf(2, " [valid normal]");
                 return(0); /* normal symbol start */
             }
 #if 0
             else if(E1 == 1) {
-                dprintf(2, " [valid add-on]");
+                debprintf(2, " [valid add-on]");
                 return(STATE_ADDON); /* add-on symbol start */
             }
 #endif
         }
-        dprintf(2, " [invalid start]");
+        debprintf(2, " [invalid start]");
         return(-1);
     }
 
@@ -194,11 +194,11 @@ static inline signed char aux_start (zba
         unsigned e4 = get_width(dcode, 7) + get_width(dcode, 8);
         if(!decode_e(e3, dcode->ean.s4, 7) &&
            !decode_e(e4, dcode->ean.s4, 7)) {
-            dprintf(2, " [valid center]");
+            debprintf(2, " [valid center]");
             return(0); /* start after center guard */
         }
     }
-    dprintf(2, " [invalid center]");
+    debprintf(2, " [invalid center]");
     return(/*STATE_ADDON*/-1);
 }
 
@@ -212,7 +212,7 @@ static inline signed char decode4 (zbar_
                    ? get_width(dcode, 0) + get_width(dcode, 1)
                    : get_width(dcode, 2) + get_width(dcode, 3));
     unsigned e2 = get_width(dcode, 1) + get_width(dcode, 2);
-    dprintf(2, "\n        e1=%d e2=%d", e1, e2);
+    debprintf(2, "\n        e1=%d e2=%d", e1, e2);
 
     if(dcode->ean.s4 < 6)
         return(-1);
@@ -222,7 +222,7 @@ static inline signed char decode4 (zbar_
              decode_e(e2, dcode->ean.s4, 7));
     if(code < 0)
         return(-1);
-    dprintf(2, " code=%x", code);
+    debprintf(2, " code=%x", code);
 
     /* 4 combinations require additional determinant (D2)
        E1E2 == 34 (0110)
@@ -243,9 +243,9 @@ static inline signed char decode4 (zbar_
         alt = d2 > (mid * dcode->ean.s4);
         if(alt)
             code = ((code >> 1) & 3) | 0x10; /* compress code space */
-        dprintf(2, " (d2=%d(%d) alt=%d)", d2, mid * dcode->ean.s4, alt);
+        debprintf(2, " (d2=%d(%d) alt=%d)", d2, mid * dcode->ean.s4, alt);
     }
-    dprintf(2, " char=%02x", digits[(unsigned char)code]);
+    debprintf(2, " char=%02x", digits[(unsigned char)code]);
     zassert(code < 0x14, -1, "code=%02x e1=%x e2=%x s4=%x color=%x\n",
             code, e1, e2, dcode->ean.s4, get_color(dcode));
     return(code);
@@ -260,7 +260,7 @@ static inline zbar_symbol_type_t ean_par
                          (pass->raw[3] & 0x10) >> 3 |
                          (pass->raw[4] & 0x10) >> 4);
 
-    dprintf(2, " par=%x", par);
+    debprintf(2, " par=%x", par);
     if(par && par != 0xf)
         /* invalid parity combination */
         return(ZBAR_NONE);
@@ -276,8 +276,8 @@ static inline zbar_symbol_type_t ean_par
         pass->raw[3] = tmp;
     }
 
-    dprintf(2, "\n");
-    dprintf(1, "decode4=%x%x%x%x\n",
+    debprintf(2, "\n");
+    debprintf(1, "decode4=%x%x%x%x\n",
             pass->raw[1] & 0xf, pass->raw[2] & 0xf,
             pass->raw[3] & 0xf, pass->raw[4] & 0xf);
     if(!par)
@@ -309,7 +309,7 @@ static inline zbar_symbol_type_t ean_par
     if(par & 1)
         pass->raw[0] >>= 4;
     pass->raw[0] &= 0xf;
-    dprintf(2, " par=%02x(%x)", par, pass->raw[0]);
+    debprintf(2, " par=%02x(%x)", par, pass->raw[0]);
 
     if(pass->raw[0] == 0xf)
         /* invalid parity combination */
@@ -326,8 +326,8 @@ static inline zbar_symbol_type_t ean_par
         }
     }
 
-    dprintf(2, "\n");
-    dprintf(1, "decode=%x%x%x%x%x%x%x(%02x)\n",
+    debprintf(2, "\n");
+    debprintf(1, "decode=%x%x%x%x%x%x%x(%02x)\n",
             pass->raw[0] & 0xf, pass->raw[1] & 0xf,
             pass->raw[2] & 0xf, pass->raw[3] & 0xf,
             pass->raw[4] & 0xf, pass->raw[5] & 0xf,
@@ -359,7 +359,7 @@ static inline zbar_symbol_type_t decode_
        TEST_CFG(dcode->ean.ean8_config, ZBAR_CFG_ENABLE) &&
        !aux_end(dcode, fwd)) {
         zbar_symbol_type_t part;
-        dprintf(2, " fwd=%x", fwd);
+        debprintf(2, " fwd=%x", fwd);
         part = ean_part_end4(pass, fwd);
         if(part)
             dcode->ean.direction = (pass->state & STATE_REV) != 0;
@@ -389,17 +389,17 @@ static inline zbar_symbol_type_t decode_
         if(w)
             code = decode4(dcode);
         else
-            dprintf(2, " [bad width]");
+            debprintf(2, " [bad width]");
 
         if(code < 0 && idx != 0x10)
             pass->state = -1;
         else if(code < 0)
             pass->raw[5] = 0xff;
         else {
-            dprintf(2, "\n        raw[%x]=%02x =>", idx >> 2,
+            debprintf(2, "\n        raw[%x]=%02x =>", idx >> 2,
                     digits[(unsigned char)code]);
             pass->raw[(idx >> 2) + 1] = digits[(unsigned char)code];
-            dprintf(2, " raw=%d%d%d%d%d%d%d",
+            debprintf(2, " raw=%d%d%d%d%d%d%d",
                     pass->raw[0] & 0xf, pass->raw[1] & 0xf,
                     pass->raw[2] & 0xf, pass->raw[3] & 0xf,
                     pass->raw[4] & 0xf, pass->raw[5] & 0xf,
@@ -410,7 +410,7 @@ static inline zbar_symbol_type_t decode_
     if(get_color(dcode) == ZBAR_SPACE &&
        (idx == 0x18 || idx == 0x19)) {
         zbar_symbol_type_t part = ZBAR_NONE;
-        dprintf(2, " fwd=%x", fwd);
+        debprintf(2, " fwd=%x", fwd);
         if(!aux_end(dcode, fwd) && pass->raw[5] != 0xff)
             part = ean_part_end7(&dcode->ean, pass, fwd);
         if(part)
@@ -447,7 +447,7 @@ static inline signed char ean_verify_che
     zassert(d < 10, -1, "n=%x d=%x chk=%x %s\n", n, d, chk,
             _zbar_decoder_buf_dump((void*)ean->buf, 18));
     if(chk != d) {
-        dprintf(1, "\nchecksum mismatch %d != %d (%s)\n",
+        debprintf(1, "\nchecksum mismatch %d != %d (%s)\n",
                 chk, d, dsprintbuf(ean));
         return(-1);
     }
@@ -503,7 +503,7 @@ static inline zbar_symbol_type_t integra
     signed char i, j, right = !!(part & EAN_RIGHT);
     /* copy raw data into holding buffer */
     /* if same partial is not consistent, reset others */
-    dprintf(2, " integrate part=%x (%s) w=%d=>%d",
+    debprintf(2, " integrate part=%x (%s) w=%d=>%d",
             part, dsprintbuf(ean), ean->width, pass->width);
 
     if(part & ZBAR_ADDON) {
@@ -522,13 +522,13 @@ static inline zbar_symbol_type_t integra
         if((ean->left && ((part & ZBAR_SYMBOL) != ean->left)) ||
            (ean->right && ((part & ZBAR_SYMBOL) != ean->right))) {
             /* partial mismatch - reset collected parts */
-            dprintf(2, " rst(type %x %x)", ean->left, ean->right);
+            debprintf(2, " rst(type %x %x)", ean->left, ean->right);
             ean->left = ean->right = ean->addon = ZBAR_NONE;
         }
 
         if((ean->left || ean->right || ean->addon) &&
            !check_width(ean->width, pass->width)) {
-            dprintf(2, " rst(width %d)", pass->width);
+            debprintf(2, " rst(width %d)", pass->width);
             ean->left = ean->right = ean->addon = ZBAR_NONE;
         }
 
@@ -539,7 +539,7 @@ static inline zbar_symbol_type_t integra
                 unsigned char digit = pass->raw[i] & 0xf;
                 if(ean->right && ean->buf[j] != digit) {
                     /* partial mismatch - reset collected parts */
-                    dprintf(2, " rst(right)");
+                    debprintf(2, " rst(right)");
                     ean->left = ean->right = ean->addon = ZBAR_NONE;
                 }
                 ean->buf[j] = digit;
@@ -552,7 +552,7 @@ static inline zbar_symbol_type_t integra
                 unsigned char digit = pass->raw[i] & 0xf;
                 if(ean->left && ean->buf[j] != digit) {
                     /* partial mismatch - reset collected parts */
-                    dprintf(2, " rst(left)");
+                    debprintf(2, " rst(left)");
                     ean->left = ean->right = ean->addon = ZBAR_NONE;
                 }
                 ean->buf[j] = digit;
@@ -617,7 +617,7 @@ static inline zbar_symbol_type_t integra
     if(part > ZBAR_PARTIAL)
         part |= ean->addon;
 
-    dprintf(2, " dir=%d %x/%x=%x",
+    debprintf(2, " dir=%d %x/%x=%x",
             ean->direction, ean->left, ean->right, part);
     return(part);
 }
@@ -679,7 +679,7 @@ zbar_symbol_type_t _zbar_decode_ean (zba
            i == pass_idx)
         {
             zbar_symbol_type_t part;
-            dprintf(2, "      ean[%x/%x]: idx=%x st=%d s=%d",
+            debprintf(2, "      ean[%x/%x]: idx=%x st=%d s=%d",
                     pass_idx, i, dcode->idx, pass->state, dcode->ean.s4);
             part = decode_pass(dcode, pass);
             if(part) {
@@ -687,20 +687,20 @@ zbar_symbol_type_t _zbar_decode_ean (zba
                 sym = integrate_partial(&dcode->ean, pass, part);
                 if(sym) {
                     /* this pass valid => _reset_ all passes */
-                    dprintf(2, " sym=%x", sym);
+                    debprintf(2, " sym=%x", sym);
                     dcode->ean.pass[0].state = dcode->ean.pass[1].state = -1;
                     dcode->ean.pass[2].state = dcode->ean.pass[3].state = -1;
                     if(sym > ZBAR_PARTIAL) {
                         if(!acquire_lock(dcode, sym))
                             postprocess(dcode, sym);
                         else {
-                            dprintf(1, " [locked %d]", dcode->lock);
+                            debprintf(1, " [locked %d]", dcode->lock);
                             sym = ZBAR_PARTIAL;
                         }
                     }
                 }
             }
-            dprintf(2, "\n");
+            debprintf(2, "\n");
         }
     }
     return(sym);
diff --git a/zbar/decoder/i25.c b/zbar/decoder/i25.c
--- a/zbar/decoder/i25.c
+++ b/zbar/decoder/i25.c
@@ -49,7 +49,7 @@ static inline unsigned char i25_decode10
                                           unsigned char offset)
 {
     i25_decoder_t *dcode25 = &dcode->i25;
-    dprintf(2, " s=%d", dcode25->s10);
+    debprintf(2, " s=%d", dcode25->s10);
     if(dcode25->s10 < 10)
         return(0xff);
 
@@ -65,11 +65,11 @@ static inline unsigned char i25_decode10
             par++;
     }
 
-    dprintf(2, " enc=%02x par=%x", enc, par);
+    debprintf(2, " enc=%02x par=%x", enc, par);
 
     /* parity check */
     if(par != 2) {
-        dprintf(2, " [bad parity]");
+        debprintf(2, " [bad parity]");
         return(0xff);
     }
 
@@ -79,12 +79,12 @@ static inline unsigned char i25_decode10
         if(enc == 12)
             enc = 0;
         else if(--enc > 9) {
-            dprintf(2, " [invalid encoding]");
+            debprintf(2, " [invalid encoding]");
             return(0xff);
         }
     }
 
-    dprintf(2, " => %x", enc);
+    debprintf(2, " => %x", enc);
     return(enc);
 }
 
@@ -103,7 +103,7 @@ static inline signed char i25_decode_sta
     if((get_color(dcode) == ZBAR_BAR)
        ? enc != 4
        : (enc = i25_decode1(enc, get_width(dcode, i++), dcode25->s10))) {
-        dprintf(4, "      i25: s=%d enc=%x [invalid]\n", dcode25->s10, enc);
+        debprintf(4, "      i25: s=%d enc=%x [invalid]\n", dcode25->s10, enc);
         return(ZBAR_NONE);
     }
 
@@ -113,7 +113,7 @@ static inline signed char i25_decode_sta
      */
     unsigned quiet = get_width(dcode, i);
     if(quiet && quiet < dcode25->s10 * 3 / 8) {
-        dprintf(3, "      i25: s=%d enc=%x q=%d [invalid qz]\n",
+        debprintf(3, "      i25: s=%d enc=%x q=%d [invalid qz]\n",
                 dcode25->s10, enc, quiet);
         return(ZBAR_NONE);
     }
@@ -148,7 +148,7 @@ static inline signed char i25_decode_end
     if((quiet && quiet < dcode25->width * 3 / 8) ||
        decode_e(get_width(dcode, 1), dcode25->width, 45) > 2 ||
        decode_e(get_width(dcode, 2), dcode25->width, 45) > 2) {
-        dprintf(3, "      i25: s=%d q=%d [invalid qz]\n",
+        debprintf(3, "      i25: s=%d q=%d [invalid qz]\n",
                 dcode25->width, quiet);
         return(ZBAR_NONE);
     }
@@ -168,7 +168,7 @@ static inline signed char i25_decode_end
     dcode->direction = 1 - 2 * dcode25->direction;
     if(dcode25->direction) {
         /* reverse buffer */
-        dprintf(2, " (rev)");
+        debprintf(2, " (rev)");
         int i;
         for(i = 0; i < dcode25->character / 2; i++) {
             unsigned j = dcode25->character - 1 - i;
@@ -181,7 +181,7 @@ static inline signed char i25_decode_end
     if(dcode25->character < CFG(*dcode25, ZBAR_CFG_MIN_LEN) ||
        (CFG(*dcode25, ZBAR_CFG_MAX_LEN) > 0 &&
         dcode25->character > CFG(*dcode25, ZBAR_CFG_MAX_LEN))) {
-        dprintf(2, " [invalid len]\n");
+        debprintf(2, " [invalid len]\n");
         release_lock(dcode, ZBAR_I25);
         dcode25->character = -1;
         return(ZBAR_NONE);
@@ -190,7 +190,7 @@ static inline signed char i25_decode_end
     dcode->buflen = dcode25->character;
     dcode->buf[dcode25->character] = '\0';
     dcode->modifiers = 0;
-    dprintf(2, " [valid end]\n");
+    debprintf(2, " [valid end]\n");
     dcode25->character = -1;
     return(ZBAR_I25);
 }
@@ -215,7 +215,7 @@ zbar_symbol_type_t _zbar_decode_i25 (zba
     /* FIXME check current character width against previous */
     dcode25->width = dcode25->s10;
 
-    dprintf(2, "      i25[%c%02d+%x]",
+    debprintf(2, "      i25[%c%02d+%x]",
             (dcode25->direction) ? '<' : '>',
             dcode25->character, dcode25->element);
 
@@ -223,15 +223,15 @@ zbar_symbol_type_t _zbar_decode_i25 (zba
         return(ZBAR_PARTIAL);
 
     unsigned char c = i25_decode10(dcode, 1);
-    dprintf(2, " c=%x", c);
+    debprintf(2, " c=%x", c);
     if(c > 9) {
-        dprintf(2, " [aborted]\n");
+        debprintf(2, " [aborted]\n");
         goto reset;
     }
 
     if((dcode25->character >= BUFFER_MIN) &&
        size_buf(dcode, dcode25->character + 2)) {
-        dprintf(2, " [overflow]\n");
+        debprintf(2, " [overflow]\n");
         goto reset;
     }
 
@@ -243,13 +243,13 @@ zbar_symbol_type_t _zbar_decode_i25 (zba
     buf[dcode25->character++] = c + '0';
 
     c = i25_decode10(dcode, 0);
-    dprintf(2, " c=%x", c);
+    debprintf(2, " c=%x", c);
     if(c > 9) {
-        dprintf(2, " [aborted]\n");
+        debprintf(2, " [aborted]\n");
         goto reset;
     }
     else
-        dprintf(2, "\n");
+        debprintf(2, "\n");
 
     buf[dcode25->character++] = c + '0';
     dcode25->element = 10;
diff --git a/zbar/decoder/pdf417.c b/zbar/decoder/pdf417.c
--- a/zbar/decoder/pdf417.c
+++ b/zbar/decoder/pdf417.c
@@ -41,7 +41,7 @@ static inline signed short pdf417_decode
      * from similar edge measurements
      */
     unsigned s = dcode->pdf417.s8;
-    dprintf(2, " s=%d ", s);
+    debprintf(2, " s=%d ", s);
     if(s < 8)
         return(-1);
 
@@ -55,19 +55,19 @@ static inline signed short pdf417_decode
         else
             e = decode_e(get_width(dcode, 7 - i) +
                          get_width(dcode, 6 - i), s, 17);
-        dprintf(4, "%x", e);
+        debprintf(4, "%x", e);
         if(e < 0 || e > 8)
             return(-1);
         sig = (sig << 3) ^ e;
     }
-    dprintf(2, " sig=%06lx", sig);
+    debprintf(2, " sig=%06lx", sig);
 
     /* determine cluster number */
     int clst = ((sig & 7) - ((sig >> 3) & 7) +
                 ((sig >> 12) & 7) - ((sig >> 15) & 7));
     if(clst < 0)
         clst += 9;
-    dprintf(2, " k=%d", clst);
+    debprintf(2, " k=%d", clst);
     zassert(clst >= 0 && clst < 9, -1, "dir=%x sig=%lx k=%x %s\n",
             dcode->pdf417.direction, sig, clst,
             _zbar_decoder_buf_dump(dcode->buf, dcode->pdf417.character));
@@ -89,7 +89,7 @@ static inline signed short pdf417_decode
             _zbar_decoder_buf_dump(dcode->buf, dcode->pdf417.character));
 
     unsigned short c = (g[0] + g[1] + g[2]) & PDF417_HASH_MASK;
-    dprintf(2, " g0=%x g1=%x g2=%x c=%03d(%d)",
+    debprintf(2, " g0=%x g1=%x g2=%x c=%03d(%d)",
             g[0], g[1], g[2], c & 0x3ff, c >> 10);
     return(c);
 }
@@ -142,18 +142,18 @@ static inline signed char pdf417_decode_
         ei = decode_e(get_width(dcode, 8) + get_width(dcode, 9), s, 17);
     }
 
-    dprintf(2, "      pdf417[%c]: s=%d",
+    debprintf(2, "      pdf417[%c]: s=%d",
             (get_color(dcode)) ? '<' : '>', s);
 
     /* check quiet zone */
     if(ei >= 0 && ei < ex) {
-        dprintf(2, " [invalid quiet]\n");
+        debprintf(2, " [invalid quiet]\n");
         return(0);
     }
 
     /* lock shared resources */
     if(acquire_lock(dcode, ZBAR_PDF417)) {
-        dprintf(2, " [locked %d]\n", dcode->lock);
+        debprintf(2, " [locked %d]\n", dcode->lock);
         return(0);
     }
 
@@ -162,7 +162,7 @@ static inline signed char pdf417_decode_
     dcode417->element = 0;
     dcode417->character = 0;
 
-    dprintf(2, " [valid start]\n");
+    debprintf(2, " [valid start]\n");
     return(ZBAR_PARTIAL);
 }
 
@@ -176,7 +176,7 @@ zbar_symbol_type_t _zbar_decode_pdf417 (
 
     if(dcode417->character < 0) {
         pdf417_decode_start(dcode);
-        dprintf(4, "\n");
+        debprintf(4, "\n");
         return(0);
     }
 
@@ -185,7 +185,7 @@ zbar_symbol_type_t _zbar_decode_pdf417 (
         return(0);
     dcode417->element = 0;
 
-    dprintf(2, "      pdf417[%c%02d]:",
+    debprintf(2, "      pdf417[%c%02d]:",
             (dcode417->direction) ? '<' : '>', dcode417->character);
 
     if(get_color(dcode) != dcode417->direction) {
@@ -202,7 +202,7 @@ zbar_symbol_type_t _zbar_decode_pdf417 (
     if((c < 0) ||
        ((dcode417->character >= BUFFER_MIN) &&
         size_buf(dcode, dcode417->character + 1))) {
-        dprintf(1, (c < 0) ? " [aborted]\n" : " [overflow]\n");
+        debprintf(1, (c < 0) ? " [aborted]\n" : " [overflow]\n");
         release_lock(dcode, ZBAR_PDF417);
         dcode417->character = -1;
         return(0);
@@ -211,7 +211,7 @@ zbar_symbol_type_t _zbar_decode_pdf417 (
     /* FIXME TBD infer dimensions, save codewords */
 
     if(c == PDF417_STOP) {
-        dprintf(1, " [valid stop]");
+        debprintf(1, " [valid stop]");
         /* FIXME check trailing bar and qz */
         dcode->direction = 1 - 2 * dcode417->direction;
         dcode->modifiers = 0;
@@ -219,6 +219,6 @@ zbar_symbol_type_t _zbar_decode_pdf417 (
         dcode417->character = -1;
     }
 
-    dprintf(2, "\n");
+    debprintf(2, "\n");
     return(0);
 }
diff --git a/zbar/decoder/qr_finder.c b/zbar/decoder/qr_finder.c
--- a/zbar/decoder/qr_finder.c
+++ b/zbar/decoder/qr_finder.c
@@ -54,25 +54,25 @@ zbar_symbol_type_t _zbar_find_qr (zbar_d
     if(get_color(dcode) != ZBAR_SPACE || s < 7)
         return(0);
 
-    dprintf(2, "    qrf: s=%d", s);
+    debprintf(2, "    qrf: s=%d", s);
 
     ei = decode_e(pair_width(dcode, 1), s, 7);
-    dprintf(2, " %d", ei);
+    debprintf(2, " %d", ei);
     if(ei)
         goto invalid;
 
     ei = decode_e(pair_width(dcode, 2), s, 7);
-    dprintf(2, "%d", ei);
+    debprintf(2, "%d", ei);
     if(ei != 2)
         goto invalid;
 
     ei = decode_e(pair_width(dcode, 3), s, 7);
-    dprintf(2, "%d", ei);
+    debprintf(2, "%d", ei);
     if(ei != 2)
         goto invalid;
 
     ei = decode_e(pair_width(dcode, 4), s, 7);
-    dprintf(2, "%d", ei);
+    debprintf(2, "%d", ei);
     if(ei)
         goto invalid;
 
@@ -88,7 +88,7 @@ zbar_symbol_type_t _zbar_find_qr (zbar_d
     w = get_width(dcode, 5);
     qrf->line.boffs = qrf->line.pos[0] + get_width(dcode, 4) + (w + 1) / 2;
 
-    dprintf(2, " boff=%d pos=%d len=%d eoff=%d [valid]\n",
+    debprintf(2, " boff=%d pos=%d len=%d eoff=%d [valid]\n",
             qrf->line.boffs, qrf->line.pos[0], qrf->line.len,
             qrf->line.eoffs);
 
@@ -97,6 +97,6 @@ zbar_symbol_type_t _zbar_find_qr (zbar_d
     return(ZBAR_QRCODE);
 
 invalid:
-    dprintf(2, " [invalid]\n");
+    debprintf(2, " [invalid]\n");
     return(0);
 }
diff --git a/zbar/scanner.c b/zbar/scanner.c
--- a/zbar/scanner.c
+++ b/zbar/scanner.c
@@ -129,7 +129,7 @@ static inline unsigned calc_thresh (zbar
     unsigned dx, thresh = scn->y1_thresh;
     unsigned long t;
     if((thresh <= scn->y1_min_thresh) || !scn->width) {
-        dprintf(1, " tmin=%d", scn->y1_min_thresh);
+        debprintf(1, " tmin=%d", scn->y1_min_thresh);
         return(scn->y1_min_thresh);
     }
     /* slowly return threshold to min */
@@ -137,7 +137,7 @@ static inline unsigned calc_thresh (zbar
     t = thresh * dx;
     t /= scn->width;
     t /= ZBAR_SCANNER_THRESH_FADE;
-    dprintf(1, " thr=%d t=%ld x=%d last=%d.%d (%d)",
+    debprintf(1, " thr=%d t=%ld x=%d last=%d.%d (%d)",
             thresh, t, scn->x, scn->last_edge >> ZBAR_FIXED,
             scn->last_edge & ((1 << ZBAR_FIXED) - 1), dx);
     if(thresh > t) {
@@ -158,7 +158,7 @@ static inline zbar_symbol_type_t process
         scn->last_edge = scn->cur_edge;
 
     scn->width = scn->cur_edge - scn->last_edge;
-    dprintf(1, " sgn=%d cur=%d.%d w=%d (%s)\n",
+    debprintf(1, " sgn=%d cur=%d.%d w=%d (%s)\n",
             scn->y1_sign, scn->cur_edge >> ZBAR_FIXED,
             scn->cur_edge & ((1 << ZBAR_FIXED) - 1), scn->width,
             ((y1 > 0) ? "SPACE" : "BAR"));
@@ -184,7 +184,7 @@ inline zbar_symbol_type_t zbar_scanner_f
 
     if(scn->cur_edge != x || scn->y1_sign > 0) {
         zbar_symbol_type_t edge = process_edge(scn, -scn->y1_sign);
-        dprintf(1, "flush0:");
+        debprintf(1, "flush0:");
         scn->cur_edge = x;
         scn->y1_sign = -scn->y1_sign;
         return(edge);
@@ -245,7 +245,7 @@ zbar_symbol_type_t zbar_scan_y (zbar_sca
     y2_1 = y0_0 - (y0_1 * 2) + y0_2;
     y2_2 = y0_1 - (y0_2 * 2) + y0_3;
 
-    dprintf(1, "scan: x=%d y=%d y0=%d y1=%d y2=%d",
+    debprintf(1, "scan: x=%d y=%d y0=%d y1=%d y2=%d",
             x, y, y0_1, y1_1, y2_1);
 
     edge = ZBAR_NONE;
@@ -267,7 +267,7 @@ zbar_symbol_type_t zbar_scan_y (zbar_sca
             /* adaptive thresholding */
             /* start at multiple of new min/max */
             scn->y1_thresh = (abs(y1_1) * THRESH_INIT + ROUND) >> ZBAR_FIXED;
-            dprintf(1, "\tthr=%d", scn->y1_thresh);
+            debprintf(1, "\tthr=%d", scn->y1_thresh);
             if(scn->y1_thresh < scn->y1_min_thresh)
                 scn->y1_thresh = scn->y1_min_thresh;
 
@@ -280,11 +280,11 @@ zbar_symbol_type_t zbar_scan_y (zbar_sca
                 /* interpolate zero crossing */
                 scn->cur_edge -= ((y2_1 << ZBAR_FIXED) + 1) / d;
             scn->cur_edge += x << ZBAR_FIXED;
-            dprintf(1, "\n");
+            debprintf(1, "\n");
         }
     }
     else
-        dprintf(1, "\n");
+        debprintf(1, "\n");
     /* FIXME add fall-thru pass to decoder after heuristic "idle" period
        (eg, 6-8 * last width) */
     scn->x = x + 1;
@@ -313,5 +313,5 @@ void zbar_scanner_get_state (const zbar_
     /* NB not quite accurate (uses updated x) */
     mut_scn = (zbar_scanner_t*)scn;
     if(y1_thresh) *y1_thresh = calc_thresh(mut_scn);
-    dprintf(1, "\n");
+    debprintf(1, "\n");
 }
diff --git a/zbar/decoder/code93.c b/zbar/decoder/code93.c
--- a/zbar/decoder/code93.c
+++ b/zbar/decoder/code93.c
@@ -61,7 +61,7 @@ encode6 (zbar_decoder_t *dcode)
     unsigned s = dcode->s6;
     int sig = 0, i;
 
-    dprintf(2, " s=%d ", s);
+    debprintf(2, " s=%d ", s);
     if(s < 9)
         return(-1);
 
@@ -70,9 +70,9 @@ encode6 (zbar_decoder_t *dcode)
         if(c > 3)
             return(-1);
         sig = (sig << 2) | c;
-        dprintf(2, "%d", c);
+        debprintf(2, "%d", c);
     }
-    dprintf(2, " sig=%03x", sig);
+    debprintf(2, " sig=%03x", sig);
 
     return(sig);
 }
@@ -81,14 +81,14 @@ static inline int
 validate_sig (int sig)
 {
     int i, sum = 0, emin = 0, sig0 = 0, sig1 = 0;
-    dprintf(3, " sum=0");
+    debprintf(3, " sum=0");
     for(i = 3; --i >= 0; ) {
         int e = sig & 3;
         sig >>= 2;
         sum = e - sum;
         sig1 <<= 4;
         sig1 += sum;
-        dprintf(3, "%d", sum);
+        debprintf(3, "%d", sum);
         if(!i)
             break;
 
@@ -99,16 +99,16 @@ validate_sig (int sig)
         if(emin > sum)
             emin = sum;
         sig0 += sum;
-        dprintf(3, "%d", sum);
+        debprintf(3, "%d", sum);
     }
 
-    dprintf(3, " emin=%d sig=%03x/%03x", emin, sig1 & 0xfff, sig0 & 0xfff);
+    debprintf(3, " emin=%d sig=%03x/%03x", emin, sig1 & 0xfff, sig0 & 0xfff);
 
     emin = emin + (emin << 4) + (emin << 8);
     sig0 -= emin;
     sig1 += emin;
 
-    dprintf(3, "=%03x/%03x", sig1 & 0xfff, sig0 & 0xfff);
+    debprintf(3, "=%03x/%03x", sig1 & 0xfff, sig0 & 0xfff);
     return((sig0 | sig1) & 0x888);
 }
 
@@ -137,7 +137,7 @@ decode6 (zbar_decoder_t *dcode)
             _zbar_decoder_buf_dump(dcode->buf, dcode->code93.character));
 
     c = (g0 + g1) & 0x3f;
-    dprintf(2, " g0=%x g1=%x c=%02x", g0, g1, c);
+    debprintf(2, " g0=%x g1=%x c=%02x", g0, g1, c);
     return(c);
 }
 
@@ -148,7 +148,7 @@ decode_start (zbar_decoder_t *dcode)
     unsigned dir, qz, s = dcode->s6;
     int c;
 
-    dprintf(2, "      code93:");
+    debprintf(2, "      code93:");
     c = encode6(dcode);
     if(c < 0 || (c != 0x00f && c != 0x0f0))
         return(ZBAR_NONE);
@@ -163,7 +163,7 @@ decode_start (zbar_decoder_t *dcode)
 
     qz = get_width(dcode, 7);
     if(qz && qz < (s * 3) / 4) {
-        dprintf(2, " [invalid qz %d]", qz);
+        debprintf(2, " [invalid qz %d]", qz);
         return(ZBAR_NONE);
     }
 
@@ -173,7 +173,7 @@ decode_start (zbar_decoder_t *dcode)
     dcode93->character = 0;
     dcode93->width = s;
 
-    dprintf(2, " dir=%x [valid start]", dir);
+    debprintf(2, " dir=%x [valid start]", dir);
     return(ZBAR_PARTIAL);
 }
 
@@ -186,7 +186,7 @@ decode_abort (zbar_decoder_t *dcode,
         release_lock(dcode, ZBAR_CODE93);
     dcode93->character = -1;
     if(reason)
-        dprintf(1, " [%s]\n", reason);
+        debprintf(1, " [%s]\n", reason);
     return(ZBAR_NONE);
 }
 
@@ -252,14 +252,14 @@ validate_checksums (zbar_decoder_t *dcod
     }
 
     d = dcode->buf[(dcode93->direction) ? 1 : n - 2];
-    dprintf(2, " C=%02x?=%02x", d, sum_c);
+    debprintf(2, " C=%02x?=%02x", d, sum_c);
     if(d != sum_c)
         return(1);
 
     acc_k = plusmod47(acc_k, sum_c);
     sum_k = plusmod47(sum_k, acc_k);
     d = dcode->buf[(dcode93->direction) ? 0 : n - 1];
-    dprintf(2, " K=%02x?=%02x", d, sum_k);
+    debprintf(2, " K=%02x?=%02x", d, sum_k);
     if(d != sum_k)
         return(1);
 
@@ -276,11 +276,11 @@ postprocess (zbar_decoder_t *dcode)
     static const unsigned char code93_s2[] =
         "\x1b\x1c\x1d\x1e\x1f;<=>?[\\]^_{|}~\x7f\x00\x40`\x7f\x7f\x7f";
 
-    dprintf(2, "\n    postproc len=%d", n);
+    debprintf(2, "\n    postproc len=%d", n);
     dcode->direction = 1 - 2 * dcode93->direction;
     if(dcode93->direction) {
         /* reverse buffer */
-        dprintf(2, " (rev)");
+        debprintf(2, " (rev)");
         for(i = 0; i < n / 2; i++) {
             unsigned j = n - 1 - i;
             unsigned char d = dcode->buf[i];
@@ -335,7 +335,7 @@ _zbar_decode_code93 (zbar_decoder_t *dco
         if(get_color(dcode) != ZBAR_BAR)
             return(ZBAR_NONE);
         sym = decode_start(dcode);
-        dprintf(2, "\n");
+        debprintf(2, "\n");
         return(sym);
     }
 
@@ -347,7 +347,7 @@ _zbar_decode_code93 (zbar_decoder_t *dco
 
     dcode93->element = 0;
 
-    dprintf(2, "      code93[%c%02d+%x]:",
+    debprintf(2, "      code93[%c%02d+%x]:",
             (dcode93->direction) ? '<' : '>',
             dcode93->character, dcode93->element);
 
@@ -366,8 +366,8 @@ _zbar_decode_code93 (zbar_decoder_t *dco
         if(postprocess(dcode))
             return(decode_abort(dcode, "invalid encoding"));
 
-        dprintf(2, " [valid end]\n");
-        dprintf(3, "    %s\n",
+        debprintf(2, " [valid end]\n");
+        debprintf(3, "    %s\n",
                 _zbar_decoder_buf_dump(dcode->buf, dcode93->character));
 
         dcode93->character = -1;
@@ -393,6 +393,6 @@ _zbar_decode_code93 (zbar_decoder_t *dco
         dcode->buf[dcode93->character] = c;
     dcode93->character++;
 
-    dprintf(2, "\n");
+    debprintf(2, "\n");
     return(ZBAR_NONE);
 }
diff --git a/zbar/decoder/databar.c b/zbar/decoder/databar.c
--- a/zbar/decoder/databar.c
+++ b/zbar/decoder/databar.c
@@ -126,7 +126,7 @@ decode10 (unsigned char *buf,
         d = (d << 12) | (*(data++) & 0xfff); \
         i += 12;                             \
         len--;                               \
-        dprintf(2, " %03lx", d & 0xfff);     \
+        debprintf(2, " %03lx", d & 0xfff);     \
     }
 
 #define PUSH_CHAR(c) \
@@ -151,7 +151,7 @@ databar_postprocess_exp (zbar_decoder_t 
 
     /* grok encodation method */
     d = *(data++);
-    dprintf(2, "\n    len=%d %03lx", len, d & 0xfff);
+    debprintf(2, "\n    len=%d %03lx", len, d & 0xfff);
     n = (d >> 4) & 0x7f;
     if(n >= 0x40) {
         i = 10;
@@ -178,7 +178,7 @@ databar_postprocess_exp (zbar_decoder_t 
         enc = 0;
         buflen = VAR_MAX(len, 9 - 2) + 2;
     }
-    dprintf(2, " buflen=%d enc=%d", buflen, enc);
+    debprintf(2, " buflen=%d enc=%d", buflen, enc);
     zassert(buflen > 2, -1, "buflen=%d\n", buflen);
 
     if(enc < 4) {
@@ -191,7 +191,7 @@ databar_postprocess_exp (zbar_decoder_t 
             return(-1);
     }
     len -= 2;
-    dprintf(2, " [%d+%d]", i, len);
+    debprintf(2, " [%d+%d]", i, len);
 
     if(size_buf(dcode, buflen))
         return(-1);
@@ -263,7 +263,7 @@ databar_postprocess_exp (zbar_decoder_t 
         FEED_BITS(15);
         i -= 15;
         n = (d >> i) & 0x7fff;
-        dprintf(2, " v=%d", n);
+        debprintf(2, " v=%d", n);
         PUSH_CHAR4('3', '2', '0', (n >= 10000) ? '3' : '2' );
         if(n >= 10000)
             n -= 10000;
@@ -277,7 +277,7 @@ databar_postprocess_exp (zbar_decoder_t 
         FEED_BITS(20);
         i -= 20;
         n = (d >> i) & 0xfffff;
-        dprintf(2, " [%d+%d] %d", i, len, n);
+        debprintf(2, " [%d+%d] %d", i, len, n);
         if(n >= 1000000)
             return(-1);
         decode10(buf, n, 6);
@@ -313,7 +313,7 @@ databar_postprocess_exp (zbar_decoder_t 
         int scheme = SCH_NUM;
         while(i > 0 || len > 0) {
             FEED_BITS(8);
-            dprintf(2, " [%d+%d]", i, len);
+            debprintf(2, " [%d+%d]", i, len);
 
             if(scheme == SCH_NUM) {
                 int n1;
@@ -322,7 +322,7 @@ databar_postprocess_exp (zbar_decoder_t 
                     break;
                 if(!((d >> i) & 0xf)) {
                     scheme = SCH_ALNUM;
-                    dprintf(2, ">A");
+                    debprintf(2, ">A");
                     continue;
                 }
                 if(!len && i < 3) {
@@ -338,7 +338,7 @@ databar_postprocess_exp (zbar_decoder_t 
                 n = ((d >> i) & 0x7f) - 8;
                 n1 = n % 11;
                 n = n / 11;
-                dprintf(2, "N%d%d", n, n1);
+                debprintf(2, "N%d%d", n, n1);
                 *(buf++) = (n < 10) ? '0' + n : GS;
                 *(buf++) = (n1 < 10) ? '0' + n1 : GS;
             }
@@ -357,7 +357,7 @@ databar_postprocess_exp (zbar_decoder_t 
                 n = (d >> i) & 0x1f;
                 if(n == 0x04) {
                     scheme ^= 0x3;
-                    dprintf(2, ">%d", scheme);
+                    debprintf(2, ">%d", scheme);
                 }
                 else if(n == 0x0f)
                     c = GS;
@@ -394,7 +394,7 @@ databar_postprocess_exp (zbar_decoder_t 
                     if(i < 0)
                         return(-1);
                     n = ((d >> i) & 0x1f);
-                    dprintf(2, "(%02x)", n);
+                    debprintf(2, "(%02x)", n);
                     if(n < 0xa)
                         c = '!' + n - 8;
                     else if(n < 0x15)
@@ -412,7 +412,7 @@ databar_postprocess_exp (zbar_decoder_t 
                     return(-1);
 
                 if(c) {
-                    dprintf(2, "%d%c", scheme, c);
+                    debprintf(2, "%d%c", scheme, c);
                     *(buf++) = c;
                 }
             }
@@ -428,7 +428,7 @@ databar_postprocess_exp (zbar_decoder_t 
         dcode->buflen--;
     }
 
-    dprintf(2, "\n    %s", _zbar_decoder_buf_dump(dcode->buf, dcode->buflen));
+    debprintf(2, "\n    %s", _zbar_decoder_buf_dump(dcode->buf, dcode->buflen));
     return(0);
 }
 #undef FEED_BITS
@@ -450,7 +450,7 @@ databar_postprocess (zbar_decoder_t *dco
     *--buf = '\0';
     *--buf = '\0';
 
-    dprintf(2, "\n    d={%d,%d,%d,%d}", d[0], d[1], d[2], d[3]);
+    debprintf(2, "\n    d={%d,%d,%d,%d}", d[0], d[1], d[2], d[3]);
     unsigned long r = d[0] * 1597 + d[1];
     d[1] = r / 10000;
     r %= 10000;
@@ -459,7 +459,7 @@ databar_postprocess (zbar_decoder_t *dco
     r %= 10000;
     r = r * 1597 + d[3];
     d[3] = r / 10000;
-    dprintf(2, " r=%ld", r);
+    debprintf(2, " r=%ld", r);
 
     for(i = 4; --i >= 0; ) {
         c = r % 10;
@@ -471,13 +471,13 @@ databar_postprocess (zbar_decoder_t *dco
             r /= 10;
     }
 
-    dprintf(2, " d={%d,%d,%d}", d[1], d[2], d[3]);
+    debprintf(2, " d={%d,%d,%d}", d[1], d[2], d[3]);
     r = d[1] * 2841 + d[2];
     d[2] = r / 10000;
     r %= 10000;
     r = r * 1597 + d[3];
     d[3] = r / 10000;
-    dprintf(2, " r=%ld", r);
+    debprintf(2, " r=%ld", r);
 
     for(i = 4; --i >= 0; ) {
         c = r % 10;
@@ -490,7 +490,7 @@ databar_postprocess (zbar_decoder_t *dco
     }
 
     r = d[2] * 1597 + d[3];
-    dprintf(2, " d={%d,%d} r=%ld", d[2], d[3], r);
+    debprintf(2, " d={%d,%d} r=%ld", d[2], d[3], r);
 
     for(i = 5; --i >= 0; ) {
         c = r % 10;
@@ -513,7 +513,7 @@ databar_postprocess (zbar_decoder_t *dco
     else
         dcode->buflen = buf - dcode->buf + 13;
 
-    dprintf(2, "\n    %s", _zbar_decoder_buf_dump(dcode->buf, 16));
+    debprintf(2, "\n    %s", _zbar_decoder_buf_dump(dcode->buf, 16));
 }
 
 static inline int
@@ -547,7 +547,7 @@ merge_segment (databar_decoder_t *db,
             seg->partial &= s->partial;
             seg->width = (3 * seg->width + s->width + 2) / 4;
             s->finder = -1;
-            dprintf(2, " dup@%d(%d,%d)",
+            debprintf(2, " dup@%d(%d,%d)",
                     i, cnt, (db->epoch - seg->epoch) & 0xff);
         }
         else if(s->finder >= 0) {
@@ -587,7 +587,7 @@ match_segment (zbar_decoder_t *dcode,
                (s1->partial && s1->count < 4) ||
                !check_width(seg->width, s1->width, 14))
                 continue;
-            dprintf(2, "\n\t[%d,%d] f=%d(0%xx)/%d(%x%x%x)",
+            debprintf(2, "\n\t[%d,%d] f=%d(0%xx)/%d(%x%x%x)",
                     i0, i1, seg->finder, seg->color,
                     s1->finder, s1->exp, s1->color, s1->side);
 
@@ -607,7 +607,7 @@ match_segment (zbar_decoder_t *dcode,
             else
                 chk = 79 + chkf - chks;
 
-            dprintf(2, " chk=(%d,%d) => %d", chkf, chks, chk);
+            debprintf(2, " chk=(%d,%d) => %d", chkf, chks, chk);
             age1 = ((db->epoch - s0->epoch) & 0xff +
                     (db->epoch - s1->epoch) & 0xff);
 
@@ -623,7 +623,7 @@ match_segment (zbar_decoder_t *dcode,
                 age2 = (db->epoch - s2->epoch) & 0xff;
                 age = age1 + age2;
                 cnt = s0->count + s1->count + s2->count;
-                dprintf(2, " [%d] MATCH cnt=%d age=%d", i2, cnt, age);
+                debprintf(2, " [%d] MATCH cnt=%d age=%d", i2, cnt, age);
                 if(maxcnt < cnt ||
                    (maxcnt == cnt && maxage > age)) {
                     maxcnt = cnt;
@@ -670,7 +670,7 @@ lookup_sequence (databar_segment_t *seg,
     i = (n + 1) / 2 + 1;
     n += 4;
     i = (i * i) / 4;
-    dprintf(2, " {%d,%d:", i, n);
+    debprintf(2, " {%d,%d:", i, n);
     p = exp_sequences + i;
 
     fixed >>= 1;
@@ -687,11 +687,11 @@ lookup_sequence (databar_segment_t *seg,
         if(s == fixed)
             fixed = -1;
         s <<= 1;
-        dprintf(2, "%x", s);
+        debprintf(2, "%x", s);
         seq[i++] = s++;
         seq[i++] = s;
     }
-    dprintf(2, "}");
+    debprintf(2, "}");
     seq[n] = -1;
     return(fixed < 1);
 }
@@ -713,27 +713,27 @@ match_segment_exp (zbar_decoder_t *dcode
     bestsegs[0] = segs[0] = seq[1] = -1;
     seq[0] = 0;
 
-    dprintf(2, "\n    fixed=%d@%d: ", fixed, ifixed);
+    debprintf(2, "\n    fixed=%d@%d: ", fixed, ifixed);
     for(i = csegs, seg = db->segs + csegs - 1; --i >= 0; seg--) {
         if(seg->exp && seg->finder >= 0 &&
            (!seg->partial || seg->count >= 4))
             iseg[i] = IDX(seg);
         else
             iseg[i] = -1;
-        dprintf(2, " %d", iseg[i]);
+        debprintf(2, " %d", iseg[i]);
     }
 
     for(i = 0; ; i--) {
         if(!i)
-            dprintf(2, "\n   ");
+            debprintf(2, "\n   ");
         for(; i >= 0 && seq[i] >= 0; i--) {
             int j;
-            dprintf(2, " [%d]%d", i, seq[i]);
+            debprintf(2, " [%d]%d", i, seq[i]);
 
             if(seq[i] == fixed) {
                 seg = db->segs + ifixed;
                 if(segs[i] < 0 && check_width(width, seg->width, 14)) {
-                    dprintf(2, "*");
+                    debprintf(2, "*");
                     j = ifixed;
                 }
                 else
@@ -753,15 +753,15 @@ match_segment_exp (zbar_decoder_t *dcode
 
             if(!i) {
                 if(!lookup_sequence(seg, fixed, seq)) {
-                    dprintf(2, "[nf]");
+                    debprintf(2, "[nf]");
                     continue;
                 }
                 width = seg->width;
-                dprintf(2, " A00@%d", j);
+                debprintf(2, " A00@%d", j);
             }
             else {
                 width = (width + seg->width) / 2;
-                dprintf(2, " %c%x%x@%d",
+                debprintf(2, " %c%x%x@%d",
                         'A' + seg->finder, seg->color, seg->side, j);
             }
             segs[i++] = j;
@@ -783,15 +783,15 @@ match_segment_exp (zbar_decoder_t *dcode
         unsigned chk0 = data0 % 211;
         chk %= 211;
 
-        dprintf(2, " chk=%d ?= %d", chk, chk0);
+        debprintf(2, " chk=%d ?= %d", chk, chk0);
         if(chk != chk0)
             continue;
 
-        dprintf(2, " cnt=%d age=%d", cnt, age);
+        debprintf(2, " cnt=%d age=%d", cnt, age);
         if(maxcnt > cnt || (maxcnt == cnt && maxage <= age))
             continue;
 
-        dprintf(2, " !");
+        debprintf(2, " !");
         maxcnt = cnt;
         maxage = age;
         for(i = 0; segs[i] >= 0; i++)
@@ -844,7 +844,7 @@ calc_check (unsigned sig0,
         if(!(i & 1))
             chk %= mod;
     }
-    dprintf(2, " chk=%d", chk);
+    debprintf(2, " chk=%d", chk);
 
     if(side)
         chk = (chk * (6561 % mod)) % mod;
@@ -958,7 +958,7 @@ decode_char (zbar_decoder_t *dcode,
         n = 16;
     emin[1] = -n;
 
-    dprintf(2, "\n        char[%c%d]: n=%d s=%d w=%d sig=",
+    debprintf(2, "\n        char[%c%d]: n=%d s=%d w=%d sig=",
             (dir < 0) ? '>' : '<', off, n, s, seg->width);
     if(s < 13 || !check_width(seg->width, s, n))
         return(ZBAR_NONE);
@@ -967,7 +967,7 @@ decode_char (zbar_decoder_t *dcode,
         int e = decode_e(pair_width(dcode, off), s, n);
         if(e < 0)
             return(ZBAR_NONE);
-        dprintf(2, "%d", e);
+        debprintf(2, "%d", e);
         sum = e - sum;
         off += dir;
         sig1 <<= 4;
@@ -980,7 +980,7 @@ decode_char (zbar_decoder_t *dcode,
         e = decode_e(pair_width(dcode, off), s, n);
         if(e < 0)
             return(ZBAR_NONE);
-        dprintf(2, "%d", e);
+        debprintf(2, "%d", e);
         sum = e - sum;
         off += dir;
         sig0 <<= 4;
@@ -996,7 +996,7 @@ decode_char (zbar_decoder_t *dcode,
     sig0 -= diff;
     sig1 += diff;
 
-    dprintf(2, " emin=%d,%d el=%04x/%04x", emin[0], emin[1], sig0, sig1);
+    debprintf(2, " emin=%d,%d el=%04x/%04x", emin[0], emin[1], sig0, sig1);
 
     unsigned sum0 = sig0 + (sig0 >> 8);
     unsigned sum1 = sig1 + (sig1 >> 8);
@@ -1005,15 +1005,15 @@ decode_char (zbar_decoder_t *dcode,
     sum0 &= 0xf;
     sum1 &= 0xf;
 
-    dprintf(2, " sum=%d/%d", sum0, sum1);
+    debprintf(2, " sum=%d/%d", sum0, sum1);
 
     if(sum0 + sum1 + 8 != n) {
-        dprintf(2, " [SUM]");
+        debprintf(2, " [SUM]");
         return(ZBAR_NONE);
     }
 
     if(((sum0 ^ (n >> 1)) | (sum1 ^ (n >> 1) ^ n)) & 1) {
-        dprintf(2, " [ODD]");
+        debprintf(2, " [ODD]");
         return(ZBAR_NONE);
     }
 
@@ -1022,16 +1022,16 @@ decode_char (zbar_decoder_t *dcode,
             "n=%d sum=%d/%d sig=%04x/%04x g=%d",
             n, sum0, sum1, sig0, sig1, i);
     struct group_s *g = groups + i;
-    dprintf(2, "\n            g=%d(%d,%d,%d/%d)",
+    debprintf(2, "\n            g=%d(%d,%d,%d/%d)",
             i, g->sum, g->wmax, g->todd, g->teven);
 
     int vodd = calc_value4(sig0 + 0x1111, sum0 + 4, g->wmax, ~n & 1);
-    dprintf(2, " v=%d", vodd);
+    debprintf(2, " v=%d", vodd);
     if(vodd < 0 || vodd > g->todd)
         return(ZBAR_NONE);
 
     int veven = calc_value4(sig1 + 0x1111, sum1 + 4, 9 - g->wmax, n & 1);
-    dprintf(2, "/%d", veven);
+    debprintf(2, "/%d", veven);
     if(veven < 0 || veven > g->teven)
         return(ZBAR_NONE);
 
@@ -1041,7 +1041,7 @@ decode_char (zbar_decoder_t *dcode,
     else
         v += veven + vodd * g->teven;
 
-    dprintf(2, " f=%d(%x%x%x)", seg->finder, seg->exp, seg->color, seg->side);
+    debprintf(2, " f=%d(%x%x%x)", seg->finder, seg->exp, seg->color, seg->side);
 
     unsigned chk = 0;
     if(seg->exp) {
@@ -1067,7 +1067,7 @@ decode_char (zbar_decoder_t *dcode,
         if(seg->color)
             chk = (chk * 16) % 79;
     }
-    dprintf(2, " => %d val=%d", chk, v);
+    debprintf(2, " => %d val=%d", chk, v);
 
     seg->check = chk;
     seg->data = v;
@@ -1090,13 +1090,13 @@ alloc_segment (databar_decoder_t *db)
         databar_segment_t *seg = db->segs + i;
         unsigned age;
         if(seg->finder < 0) {
-            dprintf(2, " free@%d", i);
+            debprintf(2, " free@%d", i);
             return(i);
         }
         age = (db->epoch - seg->epoch) & 0xff;
         if(age >= 128 && seg->count < 2) {
             seg->finder = -1;
-            dprintf(2, " stale@%d (%d - %d = %d)",
+            debprintf(2, " stale@%d (%d - %d = %d)",
                     i, db->epoch, seg->epoch, age);
             return(i);
         }
@@ -1110,12 +1110,12 @@ alloc_segment (databar_decoder_t *db)
         if(maxage < age) {
             maxage = age;
             old = i;
-            dprintf(2, " old@%d(%u)", i, age);
+            debprintf(2, " old@%d(%u)", i, age);
         }
     }
 
     if(csegs < DATABAR_MAX_SEGMENTS) {
-        dprintf(2, " new@%d", i);
+        debprintf(2, " new@%d", i);
         i = csegs;
         csegs *= 2;
         if(csegs > DATABAR_MAX_SEGMENTS)
@@ -1153,7 +1153,7 @@ decode_finder (zbar_decoder_t *dcode)
     unsigned e2 = pair_width(dcode, 3);
     unsigned e1, e3, s, finder, dir;
     int sig, iseg;
-    dprintf(2, "      databar: e0=%d e2=%d", e0, e2);
+    debprintf(2, "      databar: e0=%d e2=%d", e0, e2);
     if(e0 < e2) {
         unsigned e = e2 * 4;
         if(e < 15 * e0 || e > 34 * e0)
@@ -1172,13 +1172,13 @@ decode_finder (zbar_decoder_t *dcode)
     e1 = pair_width(dcode, 2);
 
     s = e1 + e3;
-    dprintf(2, " e1=%d e3=%d dir=%d s=%d", e1, e3, dir, s);
+    debprintf(2, " e1=%d e3=%d dir=%d s=%d", e1, e3, dir, s);
     if(s < 12)
         return(ZBAR_NONE);
 
     sig = ((decode_e(e3, s, 14) << 8) | (decode_e(e2, s, 14) << 4) |
            decode_e(e1, s, 14));
-    dprintf(2, " sig=%04x", sig & 0xfff);
+    debprintf(2, " sig=%04x", sig & 0xfff);
     if(sig < 0 ||
        ((sig >> 4) & 0xf) < 8 ||
        ((sig >> 4) & 0xf) > 10 ||
@@ -1189,7 +1189,7 @@ decode_finder (zbar_decoder_t *dcode)
 
     finder = (finder_hash[(sig - (sig >> 5)) & 0x1f] +
               finder_hash[(sig >> 1) & 0x1f]) & 0x1f;
-    dprintf(2, " finder=%d", finder);
+    debprintf(2, " finder=%d", finder);
     if(finder == 0x1f ||
        !TEST_CFG((finder < 9) ? db->config : db->config_exp, ZBAR_CFG_ENABLE))
         return(ZBAR_NONE);
@@ -1232,7 +1232,7 @@ _zbar_decode_databar (zbar_decoder_t *dc
     int iseg, i = dcode->idx & 0xf;
 
     sym = decode_finder(dcode);
-    dprintf(2, "\n");
+    debprintf(2, "\n");
 
     iseg = db->chars[i];
     if(iseg < 0)
@@ -1240,7 +1240,7 @@ _zbar_decode_databar (zbar_decoder_t *dc
 
     db->chars[i] = -1;
     seg = db->segs + iseg;
-    dprintf(2, "        databar: i=%d part=%d f=%d(%x%x%x)",
+    debprintf(2, "        databar: i=%d part=%d f=%d(%x%x%x)",
             iseg, seg->partial, seg->finder, seg->exp, seg->color, seg->side);
     zassert(seg->finder >= 0, ZBAR_NONE, "i=%d f=%d(%x%x%x) part=%x\n",
             iseg, seg->finder, seg->exp, seg->color, seg->side, seg->partial);
@@ -1271,7 +1271,7 @@ _zbar_decode_databar (zbar_decoder_t *dc
     }
     else
         db->epoch++;
-    dprintf(2, "\n");
+    debprintf(2, "\n");
 
     return(sym);
 }
