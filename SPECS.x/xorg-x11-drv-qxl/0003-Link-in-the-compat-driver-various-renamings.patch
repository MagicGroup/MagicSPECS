diff -up xf86-video-qxl-20130514/src/compat/compat-lookup3.c.compat2 xf86-video-qxl-20130514/src/compat/compat-lookup3.c
--- xf86-video-qxl-20130514/src/compat/compat-lookup3.c.compat2	2013-07-03 14:19:39.007334520 +1000
+++ xf86-video-qxl-20130514/src/compat/compat-lookup3.c	2013-07-03 14:19:56.102748510 +1000
@@ -3,17 +3,17 @@
 lookup3.c, by Bob Jenkins, May 2006, Public Domain.
 
 These are functions for producing 32-bit hashes for hash table lookup.
-hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() 
+compat_hashword(), compat_hashlittle(), compat_hashlittle2(), compat_hashbig(), mix(), and final() 
 are externally useful functions.  Routines to test the hash are included 
 if SELF_TEST is defined.  You can use this free for any purpose.  It's in
 the public domain.  It has no warranty.
 
-You probably want to use hashlittle().  hashlittle() and hashbig()
-hash byte arrays.  hashlittle() is is faster than hashbig() on
+You probably want to use compat_hashlittle().  compat_hashlittle() and compat_hashbig()
+hash byte arrays.  compat_hashlittle() is is faster than compat_hashbig() on
 little-endian machines.  Intel and AMD are little-endian machines.
-On second thought, you probably want hashlittle2(), which is identical to
-hashlittle() except it returns two 32-bit hashes for the price of one.  
-You could implement hashbig2() if you wanted but I haven't bothered here.
+On second thought, you probably want compat_hashlittle2(), which is identical to
+compat_hashlittle() except it returns two 32-bit hashes for the price of one.  
+You could implement compat_hashbig2() if you wanted but I haven't bothered here.
 
 If you want to find a hash of, say, exactly 7 integers, do
   a = i1;  b = i2;  c = i3;
@@ -23,9 +23,9 @@ If you want to find a hash of, say, exac
   a += i7;
   final(a,b,c);
 then use c as the hash value.  If you have a variable length array of
-4-byte integers to hash, use hashword().  If you have a byte array (like
-a character string), use hashlittle().  If you have several byte arrays, or
-a mix of things, see the comments above hashlittle().  
+4-byte integers to hash, use compat_hashword().  If you have a byte array (like
+a character string), use compat_hashlittle().  If you have several byte arrays, or
+a mix of things, see the comments above compat_hashlittle().  
 
 Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, 
 then mix those integers.  This is fast (you can do a lot more thorough
@@ -161,14 +161,14 @@ and these came close:
  -- that the key be an array of uint32_t's, and
  -- that the length be the number of uint32_t's in the key
 
- The function hashword() is identical to hashlittle() on little-endian
- machines, and identical to hashbig() on big-endian machines,
+ The function compat_hashword() is identical to compat_hashlittle() on little-endian
+ machines, and identical to compat_hashbig() on big-endian machines,
  except that the length has to be measured in uint32_ts rather than in
- bytes.  hashlittle() is more complicated than hashword() only because
- hashlittle() has to dance around fitting the key bytes into registers.
+ bytes.  compat_hashlittle() is more complicated than compat_hashword() only because
+ compat_hashlittle() has to dance around fitting the key bytes into registers.
 --------------------------------------------------------------------
 */
-uint32_t hashword(
+uint32_t compat_hashword(
     const uint32_t *k,                   /* the key, an array of uint32_t values */
     size_t          length,               /* the length of the key, in uint32_ts */
     uint32_t        initval)         /* the previous hash, or an arbitrary value */
@@ -206,13 +206,13 @@ uint32_t hashword(
 
 /*
 --------------------------------------------------------------------
-hashword2() -- same as hashword(), but take two seeds and return two
+compat_hashword2() -- same as compat_hashword(), but take two seeds and return two
 32-bit values.  pc and pb must both be nonnull, and *pc and *pb must
 both be initialized with seeds.  If you pass in (*pb)==0, the output 
-(*pc) will be the same as the return value from hashword().
+(*pc) will be the same as the return value from compat_hashword().
 --------------------------------------------------------------------
 */
-void hashword2 (
+void compat_hashword2 (
 const uint32_t *k,                   /* the key, an array of uint32_t values */
 size_t          length,               /* the length of the key, in uint32_ts */
 uint32_t       *pc,                      /* IN: seed OUT: primary hash value */
@@ -252,7 +252,7 @@ uint32_t       *pb)               /* IN:
 
 /*
 -------------------------------------------------------------------------------
-hashlittle() -- hash a variable-length key into a 32-bit value
+compat_hashlittle() -- hash a variable-length key into a 32-bit value
   k       : the key (the unaligned variable-length array of bytes)
   length  : the length of the key, counting by bytes
   initval : can be any 4-byte value
@@ -267,7 +267,7 @@ use a bitmask.  For example, if you need
 In which case, the hash table should have hashsize(10) elements.
 
 If you are hashing n strings (uint8_t **)k, do it like this:
-  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);
+  for (i=0, h=0; i<n; ++i) h = compat_hashlittle( k[i], len[i], h);
 
 By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this
 code any way you wish, private, educational, or commercial.  It's free.
@@ -277,7 +277,7 @@ acceptable.  Do NOT use for cryptographi
 -------------------------------------------------------------------------------
 */
 
-uint32_t hashlittle( const void *key, size_t length, uint32_t initval)
+uint32_t compat_hashlittle( const void *key, size_t length, uint32_t initval)
 {
   uint32_t a,b,c;                                          /* internal state */
   union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */
@@ -450,16 +450,16 @@ uint32_t hashlittle( const void *key, si
 
 
 /*
- * hashlittle2: return 2 32-bit hash values
+ * compat_hashlittle2: return 2 32-bit hash values
  *
- * This is identical to hashlittle(), except it returns two 32-bit hash
+ * This is identical to compat_hashlittle(), except it returns two 32-bit hash
  * values instead of just one.  This is good enough for hash table
  * lookup with 2^^64 buckets, or if you want a second hash if you're not
  * happy with the first, or if you want a probably-unique 64-bit ID for
  * the key.  *pc is better mixed than *pb, so use *pc first.  If you want
  * a 64-bit value do something like "*pc + (((uint64_t)*pb)<<32)".
  */
-void hashlittle2( 
+void compat_hashlittle2( 
   const void *key,       /* the key to hash */
   size_t      length,    /* length of the key */
   uint32_t   *pc,        /* IN: primary initval, OUT: primary hash */
@@ -638,12 +638,12 @@ void hashlittle2(
 
 
 /*
- * hashbig():
- * This is the same as hashword() on big-endian machines.  It is different
- * from hashlittle() on all machines.  hashbig() takes advantage of
+ * compat_hashbig():
+ * This is the same as compat_hashword() on big-endian machines.  It is different
+ * from compat_hashlittle() on all machines.  compat_hashbig() takes advantage of
  * big-endian byte ordering. 
  */
-uint32_t hashbig( const void *key, size_t length, uint32_t initval)
+uint32_t compat_hashbig( const void *key, size_t length, uint32_t initval)
 {
   uint32_t a,b,c;
   union { const void *ptr; size_t i; } u; /* to cast key to (size_t) happily */
diff -up xf86-video-qxl-20130514/src/compat/compat-lookup3.h.compat2 xf86-video-qxl-20130514/src/compat/compat-lookup3.h
--- xf86-video-qxl-20130514/src/compat/compat-lookup3.h.compat2	2013-07-03 14:19:39.007334520 +1000
+++ xf86-video-qxl-20130514/src/compat/compat-lookup3.h	2013-07-03 14:19:56.102748510 +1000
@@ -21,6 +21,6 @@ typedef UINT8 uint8_t;
 
 #endif
 
-uint32_t hashlittle( const void *key, size_t length, uint32_t initval);
+uint32_t compat_hashlittle( const void *key, size_t length, uint32_t initval);
 
 #endif
diff -up xf86-video-qxl-20130514/src/compat/compat-qxl_cursor.c.compat2 xf86-video-qxl-20130514/src/compat/compat-qxl_cursor.c
--- xf86-video-qxl-20130514/src/compat/compat-qxl_cursor.c.compat2	2013-07-03 14:19:39.008334544 +1000
+++ xf86-video-qxl-20130514/src/compat/compat-qxl_cursor.c	2013-07-03 14:19:56.103748552 +1000
@@ -25,25 +25,25 @@
 #include <cursorstr.h>
 
 static void
-push_cursor (qxl_screen_t *qxl, struct qxl_cursor_cmd *cursor)
+push_cursor (compat_qxl_screen_t *compat_qxl, struct compat_qxl_cursor_cmd *cursor)
 {
-    struct qxl_command cmd;
+    struct compat_qxl_command cmd;
 
-    /* See comment on push_command() in qxl_driver.c */
-    if (qxl->rom->mode != ~0)
+    /* See comment on push_command() in compat_qxl_driver.c */
+    if (compat_qxl->rom->mode != ~0)
     {
         cmd.type = QXL_CMD_CURSOR;
-        cmd.data = physical_address (qxl, cursor);
+        cmd.data = physical_address (compat_qxl, cursor);
       
-        qxl_ring_push (qxl->cursor_ring, &cmd);
+        compat_qxl_ring_push (compat_qxl->cursor_ring, &cmd);
     }
 }
 
-static struct qxl_cursor_cmd *
-qxl_alloc_cursor_cmd(qxl_screen_t *qxl)
+static struct compat_qxl_cursor_cmd *
+compat_qxl_alloc_cursor_cmd(compat_qxl_screen_t *compat_qxl)
 {
-    struct qxl_cursor_cmd *cmd =
-	qxl_allocnf (qxl, sizeof(struct qxl_cursor_cmd));
+    struct compat_qxl_cursor_cmd *cmd =
+	compat_qxl_allocnf (compat_qxl, sizeof(struct compat_qxl_cursor_cmd));
 
     cmd->release_info.id = pointer_to_u64 (cmd) | 1;
     
@@ -51,43 +51,43 @@ qxl_alloc_cursor_cmd(qxl_screen_t *qxl)
 }
 
 static void
-qxl_set_cursor_position(ScrnInfoPtr pScrn, int x, int y)
+compat_qxl_set_cursor_position(ScrnInfoPtr pScrn, int x, int y)
 {
-    qxl_screen_t *qxl = pScrn->driverPrivate;
-    struct qxl_cursor_cmd *cmd = qxl_alloc_cursor_cmd(qxl);
+    compat_qxl_screen_t *compat_qxl = pScrn->driverPrivate;
+    struct compat_qxl_cursor_cmd *cmd = compat_qxl_alloc_cursor_cmd(compat_qxl);
 
-    qxl->cur_x = x;
-    qxl->cur_y = y;
+    compat_qxl->cur_x = x;
+    compat_qxl->cur_y = y;
     
     cmd->type = QXL_CURSOR_MOVE;
-    cmd->u.position.x = qxl->cur_x + qxl->hot_x;
-    cmd->u.position.y = qxl->cur_y + qxl->hot_y;
+    cmd->u.position.x = compat_qxl->cur_x + compat_qxl->hot_x;
+    cmd->u.position.y = compat_qxl->cur_y + compat_qxl->hot_y;
 
-    push_cursor(qxl, cmd);
+    push_cursor(compat_qxl, cmd);
 }
 
 static void
-qxl_load_cursor_image(ScrnInfoPtr pScrn, unsigned char *bits)
+compat_qxl_load_cursor_image(ScrnInfoPtr pScrn, unsigned char *bits)
 {
 }
 
 static void
-qxl_set_cursor_colors(ScrnInfoPtr pScrn, int bg, int fg)
+compat_qxl_set_cursor_colors(ScrnInfoPtr pScrn, int bg, int fg)
 {
     /* Should not be called since UseHWCursor returned FALSE */
 }
 
 static void
-qxl_load_cursor_argb (ScrnInfoPtr pScrn, CursorPtr pCurs)
+compat_qxl_load_cursor_argb (ScrnInfoPtr pScrn, CursorPtr pCurs)
 {
-    qxl_screen_t *qxl = pScrn->driverPrivate;
+    compat_qxl_screen_t *compat_qxl = pScrn->driverPrivate;
     int w = pCurs->bits->width;
     int h = pCurs->bits->height;
     int size = w * h * sizeof (CARD32);
 
-    struct qxl_cursor_cmd *cmd = qxl_alloc_cursor_cmd (qxl);
-    struct qxl_cursor *cursor =
-	qxl_allocnf(qxl, sizeof(struct qxl_cursor) + size);
+    struct compat_qxl_cursor_cmd *cmd = compat_qxl_alloc_cursor_cmd (compat_qxl);
+    struct compat_qxl_cursor *cursor =
+	compat_qxl_allocnf(compat_qxl, sizeof(struct compat_qxl_cursor) + size);
 
     cursor->header.unique = 0;
     cursor->header.type = CURSOR_TYPE_ALPHA;
@@ -121,20 +121,20 @@ qxl_load_cursor_argb (ScrnInfoPtr pScrn,
     }
 #endif
 
-    qxl->hot_x = pCurs->bits->xhot;
-    qxl->hot_y = pCurs->bits->yhot;
+    compat_qxl->hot_x = pCurs->bits->xhot;
+    compat_qxl->hot_y = pCurs->bits->yhot;
     
     cmd->type = QXL_CURSOR_SET;
-    cmd->u.set.position.x = qxl->cur_x + qxl->hot_x;
-    cmd->u.set.position.y = qxl->cur_y + qxl->hot_y;
-    cmd->u.set.shape = physical_address (qxl, cursor);
+    cmd->u.set.position.x = compat_qxl->cur_x + compat_qxl->hot_x;
+    cmd->u.set.position.y = compat_qxl->cur_y + compat_qxl->hot_y;
+    cmd->u.set.shape = physical_address (compat_qxl, cursor);
     cmd->u.set.visible = TRUE;
 
-    push_cursor(qxl, cmd);
+    push_cursor(compat_qxl, cmd);
 }    
 
 static Bool
-qxl_use_hw_cursor (ScreenPtr pScrn, CursorPtr pCurs)
+compat_qxl_use_hw_cursor (ScreenPtr pScrn, CursorPtr pCurs)
 {
     /* Old-school bitmap cursors are not
      * hardware accelerated for now.
@@ -143,36 +143,36 @@ qxl_use_hw_cursor (ScreenPtr pScrn, Curs
 }
 
 static Bool
-qxl_use_hw_cursorARGB (ScreenPtr pScrn, CursorPtr pCurs)
+compat_qxl_use_hw_cursorARGB (ScreenPtr pScrn, CursorPtr pCurs)
 {
     return TRUE;
 }
 
 static void
-qxl_hide_cursor(ScrnInfoPtr pScrn)
+compat_qxl_hide_cursor(ScrnInfoPtr pScrn)
 {
-    qxl_screen_t *qxl = pScrn->driverPrivate;
-    struct qxl_cursor_cmd *cursor = qxl_alloc_cursor_cmd(qxl);
+    compat_qxl_screen_t *compat_qxl = pScrn->driverPrivate;
+    struct compat_qxl_cursor_cmd *cursor = compat_qxl_alloc_cursor_cmd(compat_qxl);
 
     cursor->type = QXL_CURSOR_HIDE;
 
-    push_cursor(qxl, cursor);
+    push_cursor(compat_qxl, cursor);
 }
 
 static void
-qxl_show_cursor(ScrnInfoPtr pScrn)
+compat_qxl_show_cursor(ScrnInfoPtr pScrn)
 {
     /*
      * slightly hacky, but there's no QXL_CURSOR_SHOW.  Could maybe do
      * QXL_CURSOR_SET?
      */
-    qxl_screen_t *qxl = pScrn->driverPrivate;
+    compat_qxl_screen_t *compat_qxl = pScrn->driverPrivate;
 
-    qxl_set_cursor_position(pScrn, qxl->cur_x, qxl->cur_y);
+    compat_qxl_set_cursor_position(pScrn, compat_qxl->cur_x, compat_qxl->cur_y);
 }
 
 hidden void
-qxl_cursor_init(ScreenPtr pScreen)
+compat_qxl_cursor_init(ScreenPtr pScreen)
 {
     xf86CursorInfoPtr cursor;
 
@@ -182,14 +182,14 @@ qxl_cursor_init(ScreenPtr pScreen)
 
     cursor->MaxWidth = cursor->MaxHeight = 64;
     /* cursor->Flags; */
-    cursor->SetCursorPosition = qxl_set_cursor_position;
-    cursor->LoadCursorARGB = qxl_load_cursor_argb;
-    cursor->UseHWCursor = qxl_use_hw_cursor;
-    cursor->UseHWCursorARGB = qxl_use_hw_cursorARGB;
-    cursor->LoadCursorImage = qxl_load_cursor_image;
-    cursor->SetCursorColors = qxl_set_cursor_colors;
-    cursor->HideCursor = qxl_hide_cursor;
-    cursor->ShowCursor = qxl_show_cursor;
+    cursor->SetCursorPosition = compat_qxl_set_cursor_position;
+    cursor->LoadCursorARGB = compat_qxl_load_cursor_argb;
+    cursor->UseHWCursor = compat_qxl_use_hw_cursor;
+    cursor->UseHWCursorARGB = compat_qxl_use_hw_cursorARGB;
+    cursor->LoadCursorImage = compat_qxl_load_cursor_image;
+    cursor->SetCursorColors = compat_qxl_set_cursor_colors;
+    cursor->HideCursor = compat_qxl_hide_cursor;
+    cursor->ShowCursor = compat_qxl_show_cursor;
 
     if (!xf86InitCursor(pScreen, cursor))
 	xfree(cursor);
diff -up xf86-video-qxl-20130514/src/compat/compat-qxl_driver.c.compat2 xf86-video-qxl-20130514/src/compat/compat-qxl_driver.c
--- xf86-video-qxl-20130514/src/compat/compat-qxl_driver.c.compat2	2013-07-03 14:19:39.009334569 +1000
+++ xf86-video-qxl-20130514/src/compat/compat-qxl_driver.c	2013-07-03 14:19:56.103748552 +1000
@@ -20,10 +20,10 @@
  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-/** \file qxl_driver.c
+/** \file compat_qxl_driver.c
  * \author Adam Jackson <ajax@redhat.com>
  *
- * This is qxl, a driver for the Qumranet paravirtualized graphics device
+ * This is compat_qxl, a driver for the Qumranet paravirtualized graphics device
  * in qemu.
  */
 
@@ -39,12 +39,12 @@
 #define CHECK_POINT()
 
 static int
-garbage_collect (qxl_screen_t *qxl)
+garbage_collect (compat_qxl_screen_t *compat_qxl)
 {
     uint64_t id;
     int i = 0;
     
-    while (qxl_ring_pop (qxl->release_ring, &id))
+    while (compat_qxl_ring_pop (compat_qxl->release_ring, &id))
     {
 	while (id)
 	{
@@ -54,9 +54,9 @@ garbage_collect (qxl_screen_t *qxl)
 	     */
 #define POINTER_MASK ((1 << 2) - 1)
 	    
-	    union qxl_release_info *info = u64_to_pointer (id & ~POINTER_MASK);
-	    struct qxl_cursor_cmd *cmd = (struct qxl_cursor_cmd *)info;
-	    struct qxl_drawable *drawable = (struct qxl_drawable *)info;
+	    union compat_qxl_release_info *info = u64_to_pointer (id & ~POINTER_MASK);
+	    struct compat_qxl_cursor_cmd *cmd = (struct compat_qxl_cursor_cmd *)info;
+	    struct compat_qxl_drawable *drawable = (struct compat_qxl_drawable *)info;
 	    int is_cursor = FALSE;
 
 	    if ((id & POINTER_MASK) == 1)
@@ -64,22 +64,22 @@ garbage_collect (qxl_screen_t *qxl)
 
 	    if (is_cursor && cmd->type == QXL_CURSOR_SET)
 	    {
-		struct qxl_cursor *cursor = (void *)virtual_address (
-		    qxl, u64_to_pointer (cmd->u.set.shape));
+		struct compat_qxl_cursor *cursor = (void *)virtual_address (
+		    compat_qxl, u64_to_pointer (cmd->u.set.shape));
 
-		qxl_free (qxl->mem, cursor);
+		compat_qxl_free (compat_qxl->mem, cursor);
 	    }
 	    else if (!is_cursor && drawable->type == QXL_DRAW_COPY)
 	    {
-		struct qxl_image *image = virtual_address (
-		    qxl, u64_to_pointer (drawable->u.copy.src_bitmap));
+		struct compat_qxl_image *image = virtual_address (
+		    compat_qxl, u64_to_pointer (drawable->u.copy.src_bitmap));
 
-		qxl_image_destroy (qxl, image);
+		compat_qxl_image_destroy (compat_qxl, image);
 	    }
 	    
 	    id = info->next;
 	    
-	    qxl_free (qxl->mem, info);
+	    compat_qxl_free (compat_qxl->mem, info);
 	}
     }
 
@@ -87,7 +87,7 @@ garbage_collect (qxl_screen_t *qxl)
 }
 
 static void
-qxl_usleep (int useconds)
+compat_qxl_usleep (int useconds)
 {
     struct timespec t;
 
@@ -102,35 +102,35 @@ qxl_usleep (int useconds)
 
 #if 0
 static void
-push_update_area (qxl_screen_t *qxl, const struct qxl_rect *area)
+push_update_area (compat_qxl_screen_t *compat_qxl, const struct compat_qxl_rect *area)
 {
-    struct qxl_update_cmd *update = qxl_allocnf (qxl, sizeof *update);
-    struct qxl_command cmd;
+    struct compat_qxl_update_cmd *update = compat_qxl_allocnf (compat_qxl, sizeof *update);
+    struct compat_qxl_command cmd;
 
     update->release_info.id = (uint64_t)update;
     update->area = *area;
     update->update_id = 0;
 
     cmd.type = QXL_CMD_UDPATE;
-    cmd.data = physical_address (qxl, update);
+    cmd.data = physical_address (compat_qxl, update);
 
-    qxl_ring_push (qxl->command_ring, &cmd);
+    compat_qxl_ring_push (compat_qxl->command_ring, &cmd);
 }
 #endif
 
 void *
-qxl_allocnf (qxl_screen_t *qxl, unsigned long size)
+compat_qxl_allocnf (compat_qxl_screen_t *compat_qxl, unsigned long size)
 {
     void *result;
     int n_attempts = 0;
     static int nth_oom = 1;
 
-    garbage_collect (qxl);
+    garbage_collect (compat_qxl);
     
-    while (!(result = qxl_alloc (qxl->mem, size)))
+    while (!(result = compat_qxl_alloc (compat_qxl->mem, size)))
     {
-	struct qxl_ram_header *ram_header = (void *)((unsigned long)qxl->ram +
-						     qxl->rom->ram_header_offset);
+	struct compat_qxl_ram_header *ram_header = (void *)((unsigned long)compat_qxl->ram +
+						     compat_qxl->rom->ram_header_offset);
 	
 	/* Rather than go out of memory, we simply tell the
 	 * device to dump everything
@@ -140,21 +140,21 @@ qxl_allocnf (qxl_screen_t *qxl, unsigned
 	ram_header->update_area.left = 0;
 	ram_header->update_area.right = 800;
 	
-	outb (qxl->io_base + QXL_IO_UPDATE_AREA, 0);
+	outb (compat_qxl->io_base + QXL_IO_UPDATE_AREA, 0);
 	
  	ErrorF ("eliminated memory (%d)\n", nth_oom++);
 
-	outb (qxl->io_base + QXL_IO_NOTIFY_OOM, 0);
+	outb (compat_qxl->io_base + QXL_IO_NOTIFY_OOM, 0);
 
-	qxl_usleep (10000);
+	compat_qxl_usleep (10000);
 	
-	if (garbage_collect (qxl))
+	if (garbage_collect (compat_qxl))
 	{
 	    n_attempts = 0;
 	}
 	else if (++n_attempts == 1000)
 	{
-	    qxl_mem_dump_stats (qxl->mem, "Out of mem - stats\n");
+	    compat_qxl_mem_dump_stats (compat_qxl->mem, "Out of mem - stats\n");
 	    
 	    fprintf (stderr, "Out of memory\n");
 	    exit (1);
@@ -165,127 +165,127 @@ qxl_allocnf (qxl_screen_t *qxl, unsigned
 }
 
 static Bool
-qxl_blank_screen(ScreenPtr pScreen, int mode)
+compat_qxl_blank_screen(ScreenPtr pScreen, int mode)
 {
     return TRUE;
 }
 
 static void
-qxl_unmap_memory(qxl_screen_t *qxl, int scrnIndex)
+compat_qxl_unmap_memory(compat_qxl_screen_t *compat_qxl, int scrnIndex)
 {
 #ifdef XSERVER_LIBPCIACCESS
-    if (qxl->ram)
-	pci_device_unmap_range(qxl->pci, qxl->ram, qxl->pci->regions[0].size);
-    if (qxl->vram)
-	pci_device_unmap_range(qxl->pci, qxl->vram, qxl->pci->regions[1].size);
-    if (qxl->rom)
-	pci_device_unmap_range(qxl->pci, qxl->rom, qxl->pci->regions[2].size);
+    if (compat_qxl->ram)
+	pci_device_unmap_range(compat_qxl->pci, compat_qxl->ram, compat_qxl->pci->regions[0].size);
+    if (compat_qxl->vram)
+	pci_device_unmap_range(compat_qxl->pci, compat_qxl->vram, compat_qxl->pci->regions[1].size);
+    if (compat_qxl->rom)
+	pci_device_unmap_range(compat_qxl->pci, compat_qxl->rom, compat_qxl->pci->regions[2].size);
 #else
-    if (qxl->ram)
-	xf86UnMapVidMem(scrnIndex, qxl->ram, (1 << qxl->pci->size[0]));
-    if (qxl->vram)
-	xf86UnMapVidMem(scrnIndex, qxl->vram, (1 << qxl->pci->size[1]));
-    if (qxl->rom)
-	xf86UnMapVidMem(scrnIndex, qxl->rom, (1 << qxl->pci->size[2]));
+    if (compat_qxl->ram)
+	xf86UnMapVidMem(scrnIndex, compat_qxl->ram, (1 << compat_qxl->pci->size[0]));
+    if (compat_qxl->vram)
+	xf86UnMapVidMem(scrnIndex, compat_qxl->vram, (1 << compat_qxl->pci->size[1]));
+    if (compat_qxl->rom)
+	xf86UnMapVidMem(scrnIndex, compat_qxl->rom, (1 << compat_qxl->pci->size[2]));
 #endif
 
-    qxl->ram = qxl->ram_physical = qxl->vram = qxl->rom = NULL;
+    compat_qxl->ram = compat_qxl->ram_physical = compat_qxl->vram = compat_qxl->rom = NULL;
 
-    qxl->num_modes = 0;
-    qxl->modes = NULL;
+    compat_qxl->num_modes = 0;
+    compat_qxl->modes = NULL;
 }
 
 static Bool
-qxl_map_memory(qxl_screen_t *qxl, int scrnIndex)
+compat_qxl_map_memory(compat_qxl_screen_t *compat_qxl, int scrnIndex)
 {
 #ifdef XSERVER_LIBPCIACCESS
-    pci_device_map_range(qxl->pci, qxl->pci->regions[0].base_addr, 
-			 qxl->pci->regions[0].size,
+    pci_device_map_range(compat_qxl->pci, compat_qxl->pci->regions[0].base_addr, 
+			 compat_qxl->pci->regions[0].size,
 			 PCI_DEV_MAP_FLAG_WRITABLE | PCI_DEV_MAP_FLAG_WRITE_COMBINE,
-			 &qxl->ram);
-    qxl->ram_physical = u64_to_pointer (qxl->pci->regions[0].base_addr);
+			 &compat_qxl->ram);
+    compat_qxl->ram_physical = u64_to_pointer (compat_qxl->pci->regions[0].base_addr);
 
-    pci_device_map_range(qxl->pci, qxl->pci->regions[1].base_addr, 
-			 qxl->pci->regions[1].size,
+    pci_device_map_range(compat_qxl->pci, compat_qxl->pci->regions[1].base_addr, 
+			 compat_qxl->pci->regions[1].size,
 			 PCI_DEV_MAP_FLAG_WRITABLE,
-			 &qxl->vram);
+			 &compat_qxl->vram);
 
-    pci_device_map_range(qxl->pci, qxl->pci->regions[2].base_addr, 
-			 qxl->pci->regions[2].size, 0,
-			 (void **)&qxl->rom);
+    pci_device_map_range(compat_qxl->pci, compat_qxl->pci->regions[2].base_addr, 
+			 compat_qxl->pci->regions[2].size, 0,
+			 (void **)&compat_qxl->rom);
 
-    qxl->io_base = qxl->pci->regions[3].base_addr;
+    compat_qxl->io_base = compat_qxl->pci->regions[3].base_addr;
 #else
-    qxl->ram = xf86MapPciMem(scrnIndex, VIDMEM_FRAMEBUFFER,
-			     qxl->pci_tag, qxl->pci->memBase[0],
-			     (1 << qxl->pci->size[0]));
-    qxl->ram_physical = (void *)qxl->pci->memBase[0];
-    
-    qxl->vram = xf86MapPciMem(scrnIndex, VIDMEM_MMIO | VIDMEM_MMIO_32BIT,
-			      qxl->pci_tag, qxl->pci->memBase[1],
-			      (1 << qxl->pci->size[1]));
-    
-    qxl->rom = xf86MapPciMem(scrnIndex, VIDMEM_MMIO | VIDMEM_MMIO_32BIT,
-			     qxl->pci_tag, qxl->pci->memBase[2],
-			     (1 << qxl->pci->size[2]));
+    compat_qxl->ram = xf86MapPciMem(scrnIndex, VIDMEM_FRAMEBUFFER,
+			     compat_qxl->pci_tag, compat_qxl->pci->memBase[0],
+			     (1 << compat_qxl->pci->size[0]));
+    compat_qxl->ram_physical = (void *)compat_qxl->pci->memBase[0];
+    
+    compat_qxl->vram = xf86MapPciMem(scrnIndex, VIDMEM_MMIO | VIDMEM_MMIO_32BIT,
+			      compat_qxl->pci_tag, compat_qxl->pci->memBase[1],
+			      (1 << compat_qxl->pci->size[1]));
+    
+    compat_qxl->rom = xf86MapPciMem(scrnIndex, VIDMEM_MMIO | VIDMEM_MMIO_32BIT,
+			     compat_qxl->pci_tag, compat_qxl->pci->memBase[2],
+			     (1 << compat_qxl->pci->size[2]));
     
-    qxl->io_base = qxl->pci->ioBase[3];
+    compat_qxl->io_base = compat_qxl->pci->ioBase[3];
 #endif
-    if (!qxl->ram || !qxl->vram || !qxl->rom)
+    if (!compat_qxl->ram || !compat_qxl->vram || !compat_qxl->rom)
 	return FALSE;
 
     xf86DrvMsg(scrnIndex, X_INFO, "ram at %p; vram at %p; rom at %p\n",
-	       qxl->ram, qxl->vram, qxl->rom);
+	       compat_qxl->ram, compat_qxl->vram, compat_qxl->rom);
 
-    qxl->num_modes = *(uint32_t *)((uint8_t *)qxl->rom + qxl->rom->modes_offset);
-    qxl->modes = (struct qxl_mode *)(((uint8_t *)qxl->rom) + qxl->rom->modes_offset + 4);
+    compat_qxl->num_modes = *(uint32_t *)((uint8_t *)compat_qxl->rom + compat_qxl->rom->modes_offset);
+    compat_qxl->modes = (struct compat_qxl_mode *)(((uint8_t *)compat_qxl->rom) + compat_qxl->rom->modes_offset + 4);
 
     return TRUE;
 }
 
 static void
-qxl_save_state(ScrnInfoPtr pScrn)
+compat_qxl_save_state(ScrnInfoPtr pScrn)
 {
-    qxl_screen_t *qxl = pScrn->driverPrivate;
+    compat_qxl_screen_t *compat_qxl = pScrn->driverPrivate;
 
-    vgaHWSaveFonts(pScrn, &qxl->vgaRegs);
+    vgaHWSaveFonts(pScrn, &compat_qxl->vgaRegs);
 }
 
 static void
-qxl_restore_state(ScrnInfoPtr pScrn)
+compat_qxl_restore_state(ScrnInfoPtr pScrn)
 {
-    qxl_screen_t *qxl = pScrn->driverPrivate;
+    compat_qxl_screen_t *compat_qxl = pScrn->driverPrivate;
 
-    vgaHWRestoreFonts(pScrn, &qxl->vgaRegs);
+    vgaHWRestoreFonts(pScrn, &compat_qxl->vgaRegs);
 }
 
 static Bool
-qxl_close_screen(int scrnIndex, ScreenPtr pScreen)
+compat_qxl_close_screen(int scrnIndex, ScreenPtr pScreen)
 {
     ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
-    qxl_screen_t *qxl = pScrn->driverPrivate;
+    compat_qxl_screen_t *compat_qxl = pScrn->driverPrivate;
 
     if (pScrn->vtSema) {
-        qxl_restore_state(pScrn);
-	qxl_unmap_memory(qxl, scrnIndex);
+        compat_qxl_restore_state(pScrn);
+	compat_qxl_unmap_memory(compat_qxl, scrnIndex);
     }
     pScrn->vtSema = FALSE;
 
-    xfree(qxl->fb);
+    xfree(compat_qxl->fb);
 
-    pScreen->CreateScreenResources = qxl->create_screen_resources;
-    pScreen->CloseScreen = qxl->close_screen;
+    pScreen->CreateScreenResources = compat_qxl->create_screen_resources;
+    pScreen->CloseScreen = compat_qxl->close_screen;
 
     return pScreen->CloseScreen(scrnIndex, pScreen);
 }
 
 static Bool
-qxl_switch_mode(int scrnIndex, DisplayModePtr p, int flags)
+compat_qxl_switch_mode(int scrnIndex, DisplayModePtr p, int flags)
 {
-    qxl_screen_t *qxl = xf86Screens[scrnIndex]->driverPrivate;
+    compat_qxl_screen_t *compat_qxl = xf86Screens[scrnIndex]->driverPrivate;
     int mode_index = (int)(unsigned long)p->Private;
-    struct qxl_mode *m = qxl->modes + mode_index;
-    ScreenPtr pScreen = qxl->pScrn->pScreen;
+    struct compat_qxl_mode *m = compat_qxl->modes + mode_index;
+    ScreenPtr pScreen = compat_qxl->pScrn->pScreen;
 
     if (!m)
 	return FALSE;
@@ -294,11 +294,11 @@ qxl_switch_mode(int scrnIndex, DisplayMo
     xf86DrvMsg (scrnIndex, X_INFO, "Setting mode %d (%d x %d) (%d x %d) %p\n",
 		m->id, m->x_res, m->y_res, p->HDisplay, p->VDisplay, p);
 
-    outb(qxl->io_base + QXL_IO_RESET, 0);
+    outb(compat_qxl->io_base + QXL_IO_RESET, 0);
     
-    outb(qxl->io_base + QXL_IO_SET_MODE, m->id);
+    outb(compat_qxl->io_base + QXL_IO_SET_MODE, m->id);
 
-    qxl->bytes_per_pixel = (qxl->pScrn->bitsPerPixel + 7) / 8;
+    compat_qxl->bytes_per_pixel = (compat_qxl->pScrn->bitsPerPixel + 7) / 8;
 
     /* If this happens out of ScreenInit, we won't have a screen yet. In that
      * case createScreenResources will make things right.
@@ -313,15 +313,15 @@ qxl_switch_mode(int scrnIndex, DisplayMo
 		pPixmap,
 		m->x_res, m->y_res,
 		-1, -1,
-		qxl->pScrn->displayWidth * qxl->bytes_per_pixel,
+		compat_qxl->pScrn->displayWidth * compat_qxl->bytes_per_pixel,
 		NULL);
 	}
     }
     
-    if (qxl->mem)
+    if (compat_qxl->mem)
     {
-	qxl_mem_free_all (qxl->mem);
-	qxl_drop_image_cache (qxl);
+	compat_qxl_mem_free_all (compat_qxl->mem);
+	compat_qxl_drop_image_cache (compat_qxl);
     }
 
     
@@ -329,9 +329,9 @@ qxl_switch_mode(int scrnIndex, DisplayMo
 }
 
 static void
-push_drawable (qxl_screen_t *qxl, struct qxl_drawable *drawable)
+push_drawable (compat_qxl_screen_t *compat_qxl, struct compat_qxl_drawable *drawable)
 {
-    struct qxl_command cmd;
+    struct compat_qxl_command cmd;
 
     /* When someone runs "init 3", the device will be 
      * switched into VGA mode and there is nothing we
@@ -345,25 +345,25 @@ push_drawable (qxl_screen_t *qxl, struct
      * The author of the QXL device is opposed to this
      * for reasons I don't understand.
      */
-    if (qxl->rom->mode != ~0)
+    if (compat_qxl->rom->mode != ~0)
     {
 	cmd.type = QXL_CMD_DRAW;
-	cmd.data = physical_address (qxl, drawable);
+	cmd.data = physical_address (compat_qxl, drawable);
 	    
-	qxl_ring_push (qxl->command_ring, &cmd);
+	compat_qxl_ring_push (compat_qxl->command_ring, &cmd);
     }
 }
 
-static struct qxl_drawable *
-make_drawable (qxl_screen_t *qxl, uint8_t type,
-	       const struct qxl_rect *rect
+static struct compat_qxl_drawable *
+make_drawable (compat_qxl_screen_t *compat_qxl, uint8_t type,
+	       const struct compat_qxl_rect *rect
 	       /* , pRegion clip */)
 {
-    struct qxl_drawable *drawable;
+    struct compat_qxl_drawable *drawable;
 
     CHECK_POINT();
     
-    drawable = qxl_allocnf (qxl, sizeof *drawable);
+    drawable = compat_qxl_allocnf (compat_qxl, sizeof *drawable);
 
     CHECK_POINT();
 
@@ -383,7 +383,7 @@ make_drawable (qxl_screen_t *qxl, uint8_
     if (rect)
 	drawable->bbox = *rect;
 
-    drawable->mm_time = qxl->rom->mm_clock;
+    drawable->mm_time = compat_qxl->rom->mm_clock;
 
     CHECK_POINT();
     
@@ -405,7 +405,7 @@ enum ROPDescriptor {
 };
 
 static void
-undamage_box (qxl_screen_t *qxl, const struct qxl_rect *rect)
+undamage_box (compat_qxl_screen_t *compat_qxl, const struct compat_qxl_rect *rect)
 {
     RegionRec region;
     BoxRec box;
@@ -415,27 +415,27 @@ undamage_box (qxl_screen_t *qxl, const s
     box.x2 = rect->right;
     box.y2 = rect->bottom;
 
-    REGION_INIT (qxl->pScrn->pScreen, &region, &box, 0);
+    REGION_INIT (compat_qxl->pScrn->pScreen, &region, &box, 0);
 
-    REGION_SUBTRACT (qxl->pScrn->pScreen, &(qxl->pending_copy), &(qxl->pending_copy), &region);
+    REGION_SUBTRACT (compat_qxl->pScrn->pScreen, &(compat_qxl->pending_copy), &(compat_qxl->pending_copy), &region);
 
-    REGION_EMPTY (qxl->pScrn->pScreen, &(qxl->pending_copy));
+    REGION_EMPTY (compat_qxl->pScrn->pScreen, &(compat_qxl->pending_copy));
 }
 
 static void
-clear_pending_damage (qxl_screen_t *qxl)
+clear_pending_damage (compat_qxl_screen_t *compat_qxl)
 {
-    REGION_EMPTY (qxl->pScrn->pScreen, &(qxl->pending_copy));
+    REGION_EMPTY (compat_qxl->pScrn->pScreen, &(compat_qxl->pending_copy));
 }
 
 static void
-submit_fill (qxl_screen_t *qxl, const struct qxl_rect *rect, uint32_t color)
+submit_fill (compat_qxl_screen_t *compat_qxl, const struct compat_qxl_rect *rect, uint32_t color)
 {
-    struct qxl_drawable *drawable;
+    struct compat_qxl_drawable *drawable;
 
     CHECK_POINT();
     
-    drawable = make_drawable (qxl, QXL_DRAW_FILL, rect);
+    drawable = make_drawable (compat_qxl, QXL_DRAW_FILL, rect);
 
     CHECK_POINT();
 
@@ -447,13 +447,13 @@ submit_fill (qxl_screen_t *qxl, const st
     drawable->u.fill.mask.pos.y = 0;
     drawable->u.fill.mask.bitmap = 0;
 
-    push_drawable (qxl, drawable);
+    push_drawable (compat_qxl, drawable);
 
-    undamage_box (qxl, rect);
+    undamage_box (compat_qxl, rect);
 }
 
 static void
-translate_rect (struct qxl_rect *rect)
+translate_rect (struct compat_qxl_rect *rect)
 {
     rect->right -= rect->left;
     rect->bottom -= rect->top;
@@ -461,10 +461,10 @@ translate_rect (struct qxl_rect *rect)
 }
 
 static void
-submit_copy (qxl_screen_t *qxl, const struct qxl_rect *rect)
+submit_copy (compat_qxl_screen_t *compat_qxl, const struct compat_qxl_rect *rect)
 {
-    struct qxl_drawable *drawable;
-    ScrnInfoPtr pScrn = qxl->pScrn;
+    struct compat_qxl_drawable *drawable;
+    ScrnInfoPtr pScrn = compat_qxl->pScrn;
 
     if (rect->left == rect->right ||
 	rect->top == rect->bottom)
@@ -473,13 +473,13 @@ submit_copy (qxl_screen_t *qxl, const st
 	return ;
     }
     
-    drawable = make_drawable (qxl, QXL_DRAW_COPY, rect);
+    drawable = make_drawable (compat_qxl, QXL_DRAW_COPY, rect);
 
     drawable->u.copy.src_bitmap = physical_address (
-	qxl, qxl_image_create (qxl, qxl->fb, rect->left, rect->top,
+	compat_qxl, compat_qxl_image_create (compat_qxl, compat_qxl->fb, rect->left, rect->top,
 			       rect->right - rect->left,
 			       rect->bottom - rect->top,
-			       pScrn->displayWidth * qxl->bytes_per_pixel));
+			       pScrn->displayWidth * compat_qxl->bytes_per_pixel));
     drawable->u.copy.src_area = *rect;
     translate_rect (&drawable->u.copy.src_area);
     drawable->u.copy.rop_descriptor = ROPD_OP_PUT;
@@ -489,7 +489,7 @@ submit_copy (qxl_screen_t *qxl, const st
     drawable->u.copy.mask.pos.y = 0;
     drawable->u.copy.mask.bitmap = 0;
 
-    push_drawable (qxl, drawable);
+    push_drawable (compat_qxl, drawable);
 }
 
 static void
@@ -511,87 +511,87 @@ print_region (const char *header, Region
 }
 
 static void
-accept_damage (qxl_screen_t *qxl)
+accept_damage (compat_qxl_screen_t *compat_qxl)
 {
-    REGION_UNION (qxl->pScrn->pScreen, &(qxl->to_be_sent), &(qxl->to_be_sent), 
-		  &(qxl->pending_copy));
+    REGION_UNION (compat_qxl->pScrn->pScreen, &(compat_qxl->to_be_sent), &(compat_qxl->to_be_sent), 
+		  &(compat_qxl->pending_copy));
 
-    REGION_EMPTY (qxl->pScrn->pScreen, &(qxl->pending_copy));
+    REGION_EMPTY (compat_qxl->pScrn->pScreen, &(compat_qxl->pending_copy));
 }
 
 static void
-qxl_send_copies (qxl_screen_t *qxl)
+compat_qxl_send_copies (compat_qxl_screen_t *compat_qxl)
 {
     BoxPtr pBox;
     int nbox;
 
-    nbox = REGION_NUM_RECTS (&qxl->to_be_sent);
-    pBox = REGION_RECTS (&qxl->to_be_sent);
+    nbox = REGION_NUM_RECTS (&compat_qxl->to_be_sent);
+    pBox = REGION_RECTS (&compat_qxl->to_be_sent);
 
-/*      if (REGION_NUM_RECTS (&qxl->to_be_sent) > 0)  */
-/*        	print_region ("send bits", &qxl->to_be_sent); */
+/*      if (REGION_NUM_RECTS (&compat_qxl->to_be_sent) > 0)  */
+/*        	print_region ("send bits", &compat_qxl->to_be_sent); */
     
     while (nbox--)
     {
-	struct qxl_rect qrect;
+	struct compat_qxl_rect qrect;
 
 	qrect.top = pBox->y1;
 	qrect.left = pBox->x1;
 	qrect.bottom = pBox->y2;
 	qrect.right = pBox->x2;
 	
-	submit_copy (qxl, &qrect);
+	submit_copy (compat_qxl, &qrect);
 
 	pBox++;
     }
 
-    REGION_EMPTY(qxl->pScrn->pScreen, &qxl->to_be_sent);
+    REGION_EMPTY(compat_qxl->pScrn->pScreen, &compat_qxl->to_be_sent);
 }
 
 static void
-paint_shadow (qxl_screen_t *qxl)
+paint_shadow (compat_qxl_screen_t *compat_qxl)
 {
-    struct qxl_rect qrect;
+    struct compat_qxl_rect qrect;
 
     qrect.top = 0;
     qrect.bottom = 1200;
     qrect.left = 0;
     qrect.right = 1600;
 
-    submit_copy (qxl, &qrect);
+    submit_copy (compat_qxl, &qrect);
 }
 
 static void
-qxl_sanity_check (qxl_screen_t *qxl)
+compat_qxl_sanity_check (compat_qxl_screen_t *compat_qxl)
 {
     /* read the mode back from the rom */
-    if (!qxl->rom || !qxl->pScrn)
+    if (!compat_qxl->rom || !compat_qxl->pScrn)
 	return;
 
-    if (qxl->rom->mode == ~0) 
+    if (compat_qxl->rom->mode == ~0) 
     {
  	ErrorF("QXL device jumped back to VGA mode - resetting mode\n");
- 	qxl_switch_mode(qxl->pScrn->scrnIndex, qxl->pScrn->currentMode, 0);
+ 	compat_qxl_switch_mode(compat_qxl->pScrn->scrnIndex, compat_qxl->pScrn->currentMode, 0);
     }
 }
 
 static void
-qxl_block_handler (pointer data, OSTimePtr pTimeout, pointer pRead)
+compat_qxl_block_handler (pointer data, OSTimePtr pTimeout, pointer pRead)
 {
-    qxl_screen_t *qxl = (qxl_screen_t *) data;
+    compat_qxl_screen_t *compat_qxl = (compat_qxl_screen_t *) data;
 
-    if (!qxl->pScrn->vtSema)
+    if (!compat_qxl->pScrn->vtSema)
         return;
 
-    qxl_sanity_check(qxl);
+    compat_qxl_sanity_check(compat_qxl);
 
-    accept_damage (qxl);
+    accept_damage (compat_qxl);
 
-    qxl_send_copies (qxl);
+    compat_qxl_send_copies (compat_qxl);
 }
 
 static void
-qxl_wakeup_handler (pointer data, int i, pointer LastSelectMask)
+compat_qxl_wakeup_handler (pointer data, int i, pointer LastSelectMask)
 {
 }
 
@@ -612,59 +612,59 @@ qxl_wakeup_handler (pointer data, int i,
  * damage, that must first be unioned onto to_be_sent, and then the new
  * damage must be stored in pending_copy.
  * 
- * The qxl_screen_t struct contains two regions, "pending_copy" and 
+ * The compat_qxl_screen_t struct contains two regions, "pending_copy" and 
  * "to_be_sent". 
  *
  * Pending copy is 
  * 
  */
 static void
-qxl_on_damage (DamagePtr pDamage, RegionPtr pRegion, pointer closure)
+compat_qxl_on_damage (DamagePtr pDamage, RegionPtr pRegion, pointer closure)
 {
-    qxl_screen_t *qxl = closure;
+    compat_qxl_screen_t *compat_qxl = closure;
 
 /*     print_region ("damage", pRegion); */
     
 /*     print_region ("on_damage ", pRegion); */
 
-    accept_damage (qxl);
+    accept_damage (compat_qxl);
 
-/*     print_region ("accepting, qxl->to_be_sent is now", &qxl->to_be_sent); */
+/*     print_region ("accepting, compat_qxl->to_be_sent is now", &compat_qxl->to_be_sent); */
 
-    REGION_COPY (qxl->pScrn->pScreen, &(qxl->pending_copy), pRegion);
+    REGION_COPY (compat_qxl->pScrn->pScreen, &(compat_qxl->pending_copy), pRegion);
 }
 
 
 static Bool
-qxl_create_screen_resources(ScreenPtr pScreen)
+compat_qxl_create_screen_resources(ScreenPtr pScreen)
 {
     ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-    qxl_screen_t *qxl = pScrn->driverPrivate;
+    compat_qxl_screen_t *compat_qxl = pScrn->driverPrivate;
     Bool ret;
     PixmapPtr pPixmap;
 
-    pScreen->CreateScreenResources = qxl->create_screen_resources;
+    pScreen->CreateScreenResources = compat_qxl->create_screen_resources;
     ret = pScreen->CreateScreenResources (pScreen);
-    pScreen->CreateScreenResources = qxl_create_screen_resources;
+    pScreen->CreateScreenResources = compat_qxl_create_screen_resources;
 
     if (!ret)
 	return FALSE;
 
-    qxl->damage = DamageCreate (qxl_on_damage, NULL,
+    compat_qxl->damage = DamageCreate (compat_qxl_on_damage, NULL,
 			        DamageReportRawRegion,
-				TRUE, pScreen, qxl);
+				TRUE, pScreen, compat_qxl);
 
 
     pPixmap = pScreen->GetScreenPixmap(pScreen);
 
-    if (!RegisterBlockAndWakeupHandlers(qxl_block_handler, qxl_wakeup_handler, qxl))
+    if (!RegisterBlockAndWakeupHandlers(compat_qxl_block_handler, compat_qxl_wakeup_handler, compat_qxl))
 	return FALSE;
 
-    REGION_INIT (pScreen, &(qxl->pending_copy), NullBox, 0);
+    REGION_INIT (pScreen, &(compat_qxl->pending_copy), NullBox, 0);
 
-    REGION_INIT (pScreen, &(qxl->to_be_sent), NullBox, 0);
+    REGION_INIT (pScreen, &(compat_qxl->to_be_sent), NullBox, 0);
  
-    DamageRegister (&pPixmap->drawable, qxl->damage);
+    DamageRegister (&pPixmap->drawable, compat_qxl->damage);
     return TRUE;
 }
 
@@ -686,13 +686,13 @@ get_window_pixmap (DrawablePtr pDrawable
 }
 
 static void
-qxl_poly_fill_rect (DrawablePtr pDrawable,
+compat_qxl_poly_fill_rect (DrawablePtr pDrawable,
 		 GCPtr	     pGC,
 		 int	     nrect,
 		 xRectangle *prect)
 {
     ScrnInfoPtr pScrn = xf86Screens[pDrawable->pScreen->myNum];
-    qxl_screen_t *qxl = pScrn->driverPrivate;
+    compat_qxl_screen_t *compat_qxl = pScrn->driverPrivate;
     PixmapPtr pPixmap;
     int xoff, yoff;
 
@@ -714,14 +714,14 @@ qxl_poly_fill_rect (DrawablePtr pDrawabl
 
 	while (nbox--)
 	{
-	    struct qxl_rect qrect;
+	    struct compat_qxl_rect qrect;
 
 	    qrect.left = pBox->x1;
 	    qrect.right = pBox->x2;
 	    qrect.top = pBox->y1;
 	    qrect.bottom = pBox->y2;
 
-	    submit_fill (qxl, &qrect, pGC->fgPixel);
+	    submit_fill (compat_qxl, &qrect, pGC->fgPixel);
 
 	    pBox++;
 	}
@@ -733,7 +733,7 @@ qxl_poly_fill_rect (DrawablePtr pDrawabl
 }
 
 static void
-qxl_copy_n_to_n (DrawablePtr    pSrcDrawable,
+compat_qxl_copy_n_to_n (DrawablePtr    pSrcDrawable,
 		 DrawablePtr    pDstDrawable,
 		 GCPtr	        pGC,
 		 BoxPtr	        pbox,
@@ -747,7 +747,7 @@ qxl_copy_n_to_n (DrawablePtr    pSrcDraw
 {
     ScreenPtr pScreen = pSrcDrawable->pScreen;
     ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-    qxl_screen_t *qxl = pScrn->driverPrivate;
+    compat_qxl_screen_t *compat_qxl = pScrn->driverPrivate;
     int src_xoff, src_yoff;
     int dst_xoff, dst_yoff;
     PixmapPtr pSrcPixmap, pDstPixmap;
@@ -776,7 +776,7 @@ qxl_copy_n_to_n (DrawablePtr    pSrcDraw
 	if (n)
 	{
 /* 	    ErrorF ("Clearing pending damage\n"); */
-	    clear_pending_damage (qxl);
+	    clear_pending_damage (compat_qxl);
 	    
 	    /* We have to do this because the copy will cause the damage
 	     * to be sent to move.
@@ -786,13 +786,13 @@ qxl_copy_n_to_n (DrawablePtr    pSrcDraw
 	     * complex, and the performance win is unlikely to be
 	     * very big.
 	     */
-	    qxl_send_copies (qxl);
+	    compat_qxl_send_copies (compat_qxl);
 	}
     
 	while (n--)
 	{
-	    struct qxl_drawable *drawable;
-	    struct qxl_rect qrect;
+	    struct compat_qxl_drawable *drawable;
+	    struct compat_qxl_rect qrect;
 	    
 	    qrect.top = b->y1;
 	    qrect.bottom = b->y2;
@@ -803,19 +803,19 @@ qxl_copy_n_to_n (DrawablePtr    pSrcDraw
 /* 		    b->x1, b->y1, b->x2, b->y2, */
 /* 		    dx, dy, dst_xoff, dst_yoff); */
 	    
-	    drawable = make_drawable (qxl, QXL_COPY_BITS, &qrect);
+	    drawable = make_drawable (compat_qxl, QXL_COPY_BITS, &qrect);
 	    drawable->u.copy_bits.src_pos.x = b->x1 + dx;
 	    drawable->u.copy_bits.src_pos.y = b->y1 + dy;
 
-	    push_drawable (qxl, drawable);
+	    push_drawable (compat_qxl, drawable);
 
 #if 0
 	    if (closure)
-		qxl_usleep (1000000);
+		compat_qxl_usleep (1000000);
 #endif
 	    
 #if 0
-	    submit_fill (qxl, &qrect, rand());
+	    submit_fill (compat_qxl, &qrect, rand());
 #endif
 
 	    b++;
@@ -828,7 +828,7 @@ qxl_copy_n_to_n (DrawablePtr    pSrcDraw
 }
 
 static RegionPtr
-qxl_copy_area(DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable, GCPtr pGC,
+compat_qxl_copy_area(DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable, GCPtr pGC,
 	    int srcx, int srcy, int width, int height, int dstx, int dsty)
 {
     if (pSrcDrawable->type == DRAWABLE_WINDOW &&
@@ -841,7 +841,7 @@ qxl_copy_area(DrawablePtr pSrcDrawable,
 
 	res = fbDoCopy (pSrcDrawable, pDstDrawable, pGC,
 			srcx, srcy, width, height, dstx, dsty,
-			qxl_copy_n_to_n, 0, NULL);
+			compat_qxl_copy_n_to_n, 0, NULL);
 
 	return res;
     }
@@ -856,11 +856,11 @@ qxl_copy_area(DrawablePtr pSrcDrawable,
 }
 
 static void
-qxl_fill_region_solid (DrawablePtr pDrawable, RegionPtr pRegion, Pixel pixel)
+compat_qxl_fill_region_solid (DrawablePtr pDrawable, RegionPtr pRegion, Pixel pixel)
 {
     ScreenPtr pScreen = pDrawable->pScreen;
     ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-    qxl_screen_t *qxl = pScrn->driverPrivate;
+    compat_qxl_screen_t *compat_qxl = pScrn->driverPrivate;
     PixmapPtr pPixmap;
     int xoff, yoff;
 
@@ -871,14 +871,14 @@ qxl_fill_region_solid (DrawablePtr pDraw
 
 	while (nbox--)
 	{
-	    struct qxl_rect qrect;
+	    struct compat_qxl_rect qrect;
 
 	    qrect.left = pBox->x1;
 	    qrect.right = pBox->x2;
 	    qrect.top = pBox->y1;
 	    qrect.bottom = pBox->y2;
 
-	    submit_fill (qxl, &qrect, pixel);
+	    submit_fill (compat_qxl, &qrect, pixel);
 
 	    pBox++;
 	}
@@ -889,7 +889,7 @@ qxl_fill_region_solid (DrawablePtr pDraw
 }
 
 static void
-qxl_copy_window (WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
+compat_qxl_copy_window (WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
 {
     RegionRec rgnDst;
     int dx, dy;
@@ -905,7 +905,7 @@ qxl_copy_window (WindowPtr pWin, DDXPoin
 
     fbCopyRegion (&pWin->drawable, &pWin->drawable,
 		  NULL, 
-		  &rgnDst, dx, dy, qxl_copy_n_to_n, 0, NULL);
+		  &rgnDst, dx, dy, compat_qxl_copy_n_to_n, 0, NULL);
 
     REGION_UNINIT (pScreen, &rgnDst);
 
@@ -915,7 +915,7 @@ qxl_copy_window (WindowPtr pWin, DDXPoin
 }
 
 static int
-qxl_create_gc (GCPtr pGC)
+compat_qxl_create_gc (GCPtr pGC)
 {
     static GCOps ops;
     static int initialized;
@@ -926,8 +926,8 @@ qxl_create_gc (GCPtr pGC)
     if (!initialized)
     {
 	ops = *pGC->ops;
-	ops.PolyFillRect = qxl_poly_fill_rect;
-	ops.CopyArea = qxl_copy_area;
+	ops.PolyFillRect = compat_qxl_poly_fill_rect;
+	ops.CopyArea = compat_qxl_copy_area;
 
 	initialized = TRUE;
     }
@@ -937,26 +937,26 @@ qxl_create_gc (GCPtr pGC)
 }
 
 static Bool
-qxl_screen_init(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
+compat_qxl_screen_init(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 {
     ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
-    qxl_screen_t *qxl = pScrn->driverPrivate;
-    struct qxl_rom *rom;
-    struct qxl_ram_header *ram_header;
+    compat_qxl_screen_t *compat_qxl = pScrn->driverPrivate;
+    struct compat_qxl_rom *rom;
+    struct compat_qxl_ram_header *ram_header;
     VisualPtr visual;
 
     CHECK_POINT();
 
-    qxl->pScrn = pScrn;
+    compat_qxl->pScrn = pScrn;
     
-    if (!qxl_map_memory(qxl, scrnIndex))
+    if (!compat_qxl_map_memory(compat_qxl, scrnIndex))
 	return FALSE;
 
-    rom = qxl->rom;
-    ram_header = (void *)((unsigned long)qxl->ram + (unsigned long)qxl->rom->ram_header_offset);
+    rom = compat_qxl->rom;
+    ram_header = (void *)((unsigned long)compat_qxl->ram + (unsigned long)compat_qxl->rom->ram_header_offset);
 
-    qxl_save_state(pScrn);
-    qxl_blank_screen(pScreen, SCREEN_SAVER_ON);
+    compat_qxl_save_state(pScrn);
+    compat_qxl_blank_screen(pScreen, SCREEN_SAVER_ON);
     
     miClearVisualTypes();
     if (!miSetVisualTypes(pScrn->depth, miGetDefaultVisualMask(pScrn->depth),
@@ -968,14 +968,14 @@ qxl_screen_init(int scrnIndex, ScreenPtr
     /* Note we do this before setting pScrn->virtualY to match our current
        mode, so as to allocate a buffer large enough for the largest mode.
        FIXME: add support for resizing the framebuffer on modeset. */
-    qxl->fb = xcalloc(pScrn->virtualY * pScrn->displayWidth, 4);
-    if (!qxl->fb)
+    compat_qxl->fb = xcalloc(pScrn->virtualY * pScrn->displayWidth, 4);
+    if (!compat_qxl->fb)
 	goto out;
 
     pScrn->virtualX = pScrn->currentMode->HDisplay;
     pScrn->virtualY = pScrn->currentMode->VDisplay;
     
-    if (!fbScreenInit(pScreen, qxl->fb,
+    if (!fbScreenInit(pScreen, compat_qxl->fb,
 		      pScrn->currentMode->HDisplay,
 		      pScrn->currentMode->VDisplay,
 		      pScrn->xDpi, pScrn->yDpi, pScrn->displayWidth,
@@ -1001,59 +1001,59 @@ qxl_screen_init(int scrnIndex, ScreenPtr
     
     fbPictureInit(pScreen, 0, 0);
 
-    qxl->create_screen_resources = pScreen->CreateScreenResources;
-    pScreen->CreateScreenResources = qxl_create_screen_resources;
+    compat_qxl->create_screen_resources = pScreen->CreateScreenResources;
+    pScreen->CreateScreenResources = compat_qxl_create_screen_resources;
 
     /* Set up resources */
-    qxl->mem = qxl_mem_create ((void *)((unsigned long)qxl->ram + (unsigned long)rom->pages_offset),
+    compat_qxl->mem = compat_qxl_mem_create ((void *)((unsigned long)compat_qxl->ram + (unsigned long)rom->pages_offset),
 			       rom->num_io_pages * getpagesize());
-    qxl->io_pages = (void *)((unsigned long)qxl->ram + (unsigned long)rom->pages_offset);
-    qxl->io_pages_physical = (void *)((unsigned long)qxl->ram_physical + (unsigned long)rom->pages_offset);
+    compat_qxl->io_pages = (void *)((unsigned long)compat_qxl->ram + (unsigned long)rom->pages_offset);
+    compat_qxl->io_pages_physical = (void *)((unsigned long)compat_qxl->ram_physical + (unsigned long)rom->pages_offset);
 
-    qxl->command_ring = qxl_ring_create (&(ram_header->cmd_ring_hdr),
-					 sizeof (struct qxl_command),
-					 32, qxl->io_base + QXL_IO_NOTIFY_CMD);
-    qxl->cursor_ring = qxl_ring_create (&(ram_header->cursor_ring_hdr),
-					sizeof (struct qxl_command),
-					32, qxl->io_base + QXL_IO_NOTIFY_CURSOR);
-    qxl->release_ring = qxl_ring_create (&(ram_header->release_ring_hdr),
+    compat_qxl->command_ring = compat_qxl_ring_create (&(ram_header->cmd_ring_hdr),
+					 sizeof (struct compat_qxl_command),
+					 32, compat_qxl->io_base + QXL_IO_NOTIFY_CMD);
+    compat_qxl->cursor_ring = compat_qxl_ring_create (&(ram_header->cursor_ring_hdr),
+					sizeof (struct compat_qxl_command),
+					32, compat_qxl->io_base + QXL_IO_NOTIFY_CURSOR);
+    compat_qxl->release_ring = compat_qxl_ring_create (&(ram_header->release_ring_hdr),
 					 sizeof (uint64_t),
 					 8, 0);
 					 
     /* xf86DPMSInit(pScreen, xf86DPMSSet, 0); */
 
 #if 0 /* XV accel */
-    qxlInitVideo(pScreen);
+    compat_qxlInitVideo(pScreen);
 #endif
 
-    pScreen->SaveScreen = qxl_blank_screen;
-    qxl->close_screen = pScreen->CloseScreen;
-    pScreen->CloseScreen = qxl_close_screen;
+    pScreen->SaveScreen = compat_qxl_blank_screen;
+    compat_qxl->close_screen = pScreen->CloseScreen;
+    pScreen->CloseScreen = compat_qxl_close_screen;
 
-    qxl->create_gc = pScreen->CreateGC;
-    pScreen->CreateGC = qxl_create_gc;
+    compat_qxl->create_gc = pScreen->CreateGC;
+    pScreen->CreateGC = compat_qxl_create_gc;
 
 #if 0
-    qxl->paint_window_background = pScreen->PaintWindowBackground;
-    qxl->paint_window_border = pScreen->PaintWindowBorder;
+    compat_qxl->paint_window_background = pScreen->PaintWindowBackground;
+    compat_qxl->paint_window_border = pScreen->PaintWindowBorder;
 #endif
-    qxl->copy_window = pScreen->CopyWindow;
+    compat_qxl->copy_window = pScreen->CopyWindow;
 #if 0
-    pScreen->PaintWindowBackground = qxl_paint_window;
-    pScreen->PaintWindowBorder = qxl_paint_window;
+    pScreen->PaintWindowBackground = compat_qxl_paint_window;
+    pScreen->PaintWindowBorder = compat_qxl_paint_window;
 #endif
-    pScreen->CopyWindow = qxl_copy_window;
+    pScreen->CopyWindow = compat_qxl_copy_window;
 
     miDCInitialize(pScreen, xf86GetPointerScreenFuncs());
 
     if (!miCreateDefColormap(pScreen))
 	goto out;
 
-    qxl_cursor_init (pScreen);
+    compat_qxl_cursor_init (pScreen);
     
     CHECK_POINT();
 
-    qxl_switch_mode(scrnIndex, pScrn->currentMode, 0);
+    compat_qxl_switch_mode(scrnIndex, pScrn->currentMode, 0);
 
     CHECK_POINT();
     
@@ -1064,26 +1064,26 @@ out:
 }
 
 static Bool
-qxl_enter_vt(int scrnIndex, int flags)
+compat_qxl_enter_vt(int scrnIndex, int flags)
 {
     ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
 
-    qxl_save_state(pScrn);
-    qxl_switch_mode(scrnIndex, pScrn->currentMode, 0);
+    compat_qxl_save_state(pScrn);
+    compat_qxl_switch_mode(scrnIndex, pScrn->currentMode, 0);
 
     return TRUE;
 }
 
 static void
-qxl_leave_vt(int scrnIndex, int flags)
+compat_qxl_leave_vt(int scrnIndex, int flags)
 {
     ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
 
-    qxl_restore_state(pScrn);
+    compat_qxl_restore_state(pScrn);
 }
 
 static Bool
-qxl_color_setup(ScrnInfoPtr pScrn)
+compat_qxl_color_setup(ScrnInfoPtr pScrn)
 {
     int scrnIndex = pScrn->scrnIndex;
     Gamma gzeros = { 0.0, 0.0, 0.0 };
@@ -1113,13 +1113,13 @@ qxl_color_setup(ScrnInfoPtr pScrn)
 }
 
 static void
-print_modes (qxl_screen_t *qxl, int scrnIndex)
+print_modes (compat_qxl_screen_t *compat_qxl, int scrnIndex)
 {
     int i;
 
-    for (i = 0; i < qxl->num_modes; ++i)
+    for (i = 0; i < compat_qxl->num_modes; ++i)
     {
-	struct qxl_mode *m = qxl->modes + i;
+	struct compat_qxl_mode *m = compat_qxl->modes + i;
 
 	xf86DrvMsg (scrnIndex, X_INFO,
 		    "%d: %dx%d, %d bits, stride %d, %dmm x %dmm, orientation %d\n",
@@ -1129,11 +1129,11 @@ print_modes (qxl_screen_t *qxl, int scrn
 }
 
 static Bool
-qxl_check_device(ScrnInfoPtr pScrn, qxl_screen_t *qxl)
+compat_qxl_check_device(ScrnInfoPtr pScrn, compat_qxl_screen_t *compat_qxl)
 {
     int scrnIndex = pScrn->scrnIndex;
-    struct qxl_rom *rom = qxl->rom;
-    struct qxl_ram_header *ram_header = (void *)((unsigned long)qxl->ram + rom->ram_header_offset);
+    struct compat_qxl_rom *rom = compat_qxl->rom;
+    struct compat_qxl_ram_header *ram_header = (void *)((unsigned long)compat_qxl->ram + rom->ram_header_offset);
 
     CHECK_POINT();
     
@@ -1170,24 +1170,24 @@ qxl_check_device(ScrnInfoPtr pScrn, qxl_
     xf86DrvMsg(scrnIndex, X_INFO, "Correct RAM signature %x\n", 
 	       ram_header->magic);
 
-    qxl->draw_area_offset = rom->draw_area_offset;
-    qxl->draw_area_size = rom->draw_area_size;
+    compat_qxl->draw_area_offset = rom->draw_area_offset;
+    compat_qxl->draw_area_size = rom->draw_area_size;
     pScrn->videoRam = rom->draw_area_size / 1024;
     
     return TRUE;
 }
 
 static int
-qxl_find_native_mode(ScrnInfoPtr pScrn, DisplayModePtr p)
+compat_qxl_find_native_mode(ScrnInfoPtr pScrn, DisplayModePtr p)
 {
     int i;
-    qxl_screen_t *qxl = pScrn->driverPrivate;
+    compat_qxl_screen_t *compat_qxl = pScrn->driverPrivate;
 
     CHECK_POINT();
     
-    for (i = 0; i < qxl->num_modes; i++) 
+    for (i = 0; i < compat_qxl->num_modes; i++) 
     {
-	struct qxl_mode *m = qxl->modes + i;
+	struct compat_qxl_mode *m = compat_qxl->modes + i;
 
 	if (m->x_res == p->HDisplay &&
 	    m->y_res == p->VDisplay &&
@@ -1212,20 +1212,20 @@ qxl_find_native_mode(ScrnInfoPtr pScrn,
 }
 
 static ModeStatus
-qxl_valid_mode(int scrn, DisplayModePtr p, Bool flag, int pass)
+compat_qxl_valid_mode(int scrn, DisplayModePtr p, Bool flag, int pass)
 {
     ScrnInfoPtr pScrn = xf86Screens[scrn];
-    qxl_screen_t *qxl = pScrn->driverPrivate;
+    compat_qxl_screen_t *compat_qxl = pScrn->driverPrivate;
     int bpp = pScrn->bitsPerPixel;
     int mode_idx;
 
     /* FIXME: I don't think this is necessary now that we report the
      * correct amount of video ram?
      */
-    if (p->HDisplay * p->VDisplay * (bpp/8) > qxl->draw_area_size)
+    if (p->HDisplay * p->VDisplay * (bpp/8) > compat_qxl->draw_area_size)
 	return MODE_MEM;
 
-    mode_idx = qxl_find_native_mode (pScrn, p);
+    mode_idx = compat_qxl_find_native_mode (pScrn, p);
     if (mode_idx == -1)
 	return MODE_NOMODE;
 
@@ -1234,7 +1234,7 @@ qxl_valid_mode(int scrn, DisplayModePtr
     return MODE_OK;
 }
 
-static void qxl_add_mode(ScrnInfoPtr pScrn, int width, int height, int type)
+static void compat_qxl_add_mode(ScrnInfoPtr pScrn, int width, int height, int type)
 {
     DisplayModePtr mode;
 
@@ -1263,10 +1263,10 @@ static void qxl_add_mode(ScrnInfoPtr pSc
 }
 
 static Bool
-qxl_pre_init(ScrnInfoPtr pScrn, int flags)
+compat_qxl_pre_init(ScrnInfoPtr pScrn, int flags)
 {
     int i, scrnIndex = pScrn->scrnIndex;
-    qxl_screen_t *qxl = NULL;
+    compat_qxl_screen_t *compat_qxl = NULL;
     ClockRangePtr clockRanges = NULL;
     int *linePitches = NULL;
     DisplayModePtr mode;
@@ -1281,27 +1281,27 @@ qxl_pre_init(ScrnInfoPtr pScrn, int flag
     }
 
     if (!pScrn->driverPrivate)
-	pScrn->driverPrivate = xnfcalloc(sizeof(qxl_screen_t), 1);
-    qxl = pScrn->driverPrivate;
+	pScrn->driverPrivate = xnfcalloc(sizeof(compat_qxl_screen_t), 1);
+    compat_qxl = pScrn->driverPrivate;
     
-    qxl->entity = xf86GetEntityInfo(pScrn->entityList[0]);
-    qxl->pci = xf86GetPciInfoForEntity(qxl->entity->index);
+    compat_qxl->entity = xf86GetEntityInfo(pScrn->entityList[0]);
+    compat_qxl->pci = xf86GetPciInfoForEntity(compat_qxl->entity->index);
 #ifndef XSERVER_LIBPCIACCESS
-    qxl->pci_tag = pciTag(qxl->pci->bus, qxl->pci->device, qxl->pci->func);
+    compat_qxl->pci_tag = pciTag(compat_qxl->pci->bus, compat_qxl->pci->device, compat_qxl->pci->func);
 #endif
 
     pScrn->monitor = pScrn->confScreen->monitor;
 
-    if (!qxl_color_setup(pScrn))
+    if (!compat_qxl_color_setup(pScrn))
 	goto out;
 
     /* option parsing and card differentiation */
     xf86CollectOptions(pScrn, NULL);
     
-    if (!qxl_map_memory(qxl, scrnIndex))
+    if (!compat_qxl_map_memory(compat_qxl, scrnIndex))
 	goto out;
 
-    if (!qxl_check_device(pScrn, qxl))
+    if (!compat_qxl_check_device(pScrn, compat_qxl))
 	goto out;
 
     /* ddc stuff here */
@@ -1328,22 +1328,22 @@ qxl_pre_init(ScrnInfoPtr pScrn, int flag
     }
 
     /* Add any modes not in xorg's default mode list */
-    for (i = 0; i < qxl->num_modes; i++)
-        if (qxl->modes[i].orientation == 0) {
-            qxl_add_mode(pScrn, qxl->modes[i].x_res, qxl->modes[i].y_res,
+    for (i = 0; i < compat_qxl->num_modes; i++)
+        if (compat_qxl->modes[i].orientation == 0) {
+            compat_qxl_add_mode(pScrn, compat_qxl->modes[i].x_res, compat_qxl->modes[i].y_res,
                          M_T_DRIVER);
-            if (qxl->modes[i].x_res > max_x)
-                max_x = qxl->modes[i].x_res;
-            if (qxl->modes[i].y_res > max_y)
-                max_y = qxl->modes[i].y_res;
+            if (compat_qxl->modes[i].x_res > max_x)
+                max_x = compat_qxl->modes[i].x_res;
+            if (compat_qxl->modes[i].y_res > max_y)
+                max_y = compat_qxl->modes[i].y_res;
         }
 
     if (pScrn->display->virtualX == 0 && pScrn->display->virtualY == 0) {
         /* It is possible for the largest x + largest y size combined leading
            to a virtual size which will not fit into the framebuffer when this
            happens we prefer max width and make height as large as possible */
-        if (max_x * max_y * (pScrn->bitsPerPixel / 8) > qxl->draw_area_size)
-            pScrn->display->virtualY = qxl->draw_area_size /
+        if (max_x * max_y * (pScrn->bitsPerPixel / 8) > compat_qxl->draw_area_size)
+            pScrn->display->virtualY = compat_qxl->draw_area_size /
                                        (max_x * (pScrn->bitsPerPixel / 8));
         else
             pScrn->display->virtualY = max_y;
@@ -1381,14 +1381,14 @@ qxl_pre_init(ScrnInfoPtr pScrn, int flag
 	goto out;
     }
 
-    print_modes (qxl, scrnIndex);
+    print_modes (compat_qxl, scrnIndex);
 
     /* VGA hardware initialisation */
     if (!vgaHWGetHWRec(pScrn))
         return FALSE;
 
     /* hate */
-    qxl_unmap_memory(qxl, scrnIndex);
+    compat_qxl_unmap_memory(compat_qxl, scrnIndex);
 
     CHECK_POINT();
     
@@ -1398,19 +1398,19 @@ qxl_pre_init(ScrnInfoPtr pScrn, int flag
 out:
     if (clockRanges)
 	xfree(clockRanges);
-    if (qxl)
-	xfree(qxl);
+    if (compat_qxl)
+	xfree(compat_qxl);
 
     return FALSE;
 }
 
 #ifdef XSERVER_LIBPCIACCESS
-enum qxl_class
+enum compat_qxl_class
 {
     CHIP_QXL_1,
 };
 
-static const struct pci_id_match qxl_device_match[] = {
+static const struct pci_id_match compat_qxl_device_match[] = {
     {
 	PCI_VENDOR_RED_HAT, PCI_CHIP_QXL_0100, PCI_MATCH_ANY, PCI_MATCH_ANY,
 	0x00030000, 0x00ffffff, CHIP_QXL_1
@@ -1420,14 +1420,14 @@ static const struct pci_id_match qxl_dev
 };
 #endif
 
-static SymTabRec qxlChips[] =
+static SymTabRec compat_qxlChips[] =
 {
     { PCI_CHIP_QXL_0100,	"QXL 1", },
     { -1, NULL }
 };
 
 #ifndef XSERVER_LIBPCIACCESS
-static PciChipsets qxlPciChips[] =
+static PciChipsets compat_qxlPciChips[] =
 {
     { PCI_CHIP_QXL_0100,    PCI_CHIP_QXL_0100,	RES_SHARED_VGA },
     { -1, -1, RES_UNDEFINED }
@@ -1435,20 +1435,20 @@ static PciChipsets qxlPciChips[] =
 #endif
 
 static void
-qxl_identify(int flags)
+compat_qxl_identify(int flags)
 {
-    xf86PrintChipsets("qxl", "Driver for QXL virtual graphics", qxlChips);
+    xf86PrintChipsets("compat_qxl", "Driver for QXL virtual graphics", compat_qxlChips);
 }
 
-static void
-qxl_init_scrn(ScrnInfoPtr pScrn)
+void
+compat_init_scrn(ScrnInfoPtr pScrn)
 {
     pScrn->driverVersion    = 0;
-    pScrn->driverName	    = pScrn->name = "qxl";
-    pScrn->PreInit	    = qxl_pre_init;
-    pScrn->ScreenInit	    = qxl_screen_init;
-    pScrn->SwitchMode	    = qxl_switch_mode;
-    pScrn->ValidMode	    = qxl_valid_mode;
-    pScrn->EnterVT	    = qxl_enter_vt;
-    pScrn->LeaveVT	    = qxl_leave_vt;
+    pScrn->driverName	    = pScrn->name = "compat_qxl";
+    pScrn->PreInit	    = compat_qxl_pre_init;
+    pScrn->ScreenInit	    = compat_qxl_screen_init;
+    pScrn->SwitchMode	    = compat_qxl_switch_mode;
+    pScrn->ValidMode	    = compat_qxl_valid_mode;
+    pScrn->EnterVT	    = compat_qxl_enter_vt;
+    pScrn->LeaveVT	    = compat_qxl_leave_vt;
 }
diff -up xf86-video-qxl-20130514/src/compat/compat-qxl.h.compat2 xf86-video-qxl-20130514/src/compat/compat-qxl.h
--- xf86-video-qxl-20130514/src/compat/compat-qxl.h.compat2	2013-07-03 14:19:39.009334569 +1000
+++ xf86-video-qxl-20130514/src/compat/compat-qxl.h	2013-07-03 14:19:56.102748510 +1000
@@ -43,8 +43,8 @@
 
 #define hidden _X_HIDDEN
 
-#define QXL_NAME		"qxl"
-#define QXL_DRIVER_NAME		"qxl"
+#define QXL_NAME		"compat_qxl"
+#define QXL_DRIVER_NAME		"compat_qxl"
 #define PCI_VENDOR_RED_HAT	0x1b36
 
 #define PCI_CHIP_QXL_0100	0x0100
@@ -63,7 +63,7 @@ enum {
     QXL_IO_LOG,
 };
 
-struct qxl_mode {
+struct compat_qxl_mode {
     uint32_t id;
     uint32_t x_res;
     uint32_t y_res;
@@ -81,39 +81,39 @@ typedef enum
     QXL_CMD_UPDATE,
     QXL_CMD_CURSOR,
     QXL_CMD_MESSAGE
-} qxl_command_type;
+} compat_qxl_command_type;
 
-struct qxl_command {
+struct compat_qxl_command {
     uint64_t data;
     uint32_t type;
     uint32_t pad;
 };
 
-struct qxl_rect {
+struct compat_qxl_rect {
     uint32_t top;
     uint32_t left;
     uint32_t bottom;
     uint32_t right;
 };
 
-union qxl_release_info {
+union compat_qxl_release_info {
     uint64_t id;
     uint64_t next;
 };
 
-struct qxl_clip {
+struct compat_qxl_clip {
     uint32_t type;
     uint64_t address;
 };
 
-struct qxl_point {
+struct compat_qxl_point {
     int x;
     int y;
 };
 
-struct qxl_pattern {
+struct compat_qxl_pattern {
     uint64_t pat;
-    struct qxl_point pos;
+    struct compat_qxl_point pos;
 };
 
 typedef enum
@@ -121,19 +121,19 @@ typedef enum
     QXL_BRUSH_TYPE_NONE,
     QXL_BRUSH_TYPE_SOLID,
     QXL_BRUSH_TYPE_PATTERN
-} qxl_brush_type;
+} compat_qxl_brush_type;
 
-struct qxl_brush {
+struct compat_qxl_brush {
     uint32_t type;
     union {
 	uint32_t color;
-	struct qxl_pattern pattern;
+	struct compat_qxl_pattern pattern;
     } u;
 };
 
-struct qxl_mask {
+struct compat_qxl_mask {
     unsigned char flags;
-    struct qxl_point pos;
+    struct compat_qxl_point pos;
     uint64_t bitmap;
 };
 
@@ -145,13 +145,13 @@ typedef enum {
     QXL_IMAGE_TYPE_LZ_RGB,
     QXL_IMAGE_TYPE_GLZ_RGB,
     QXL_IMAGE_TYPE_FROM_CACHE,
-} qxl_image_type;
+} compat_qxl_image_type;
 
 typedef enum {
     QXL_IMAGE_CACHE = (1 << 0)
-} qxl_image_flags;
+} compat_qxl_image_flags;
 
-struct qxl_image_descriptor
+struct compat_qxl_image_descriptor
 {
     uint64_t id;
     uint8_t type;
@@ -160,7 +160,7 @@ struct qxl_image_descriptor
     uint32_t height;
 };
 
-struct qxl_data_chunk {
+struct compat_qxl_data_chunk {
     uint32_t data_size;
     uint64_t prev_chunk;
     uint64_t next_chunk;
@@ -179,90 +179,90 @@ typedef enum
     QXL_BITMAP_FMT_24BIT,
     QXL_BITMAP_FMT_32BIT,
     QXL_BITMAP_FMT_RGBA,
-} qxl_bitmap_format;
+} compat_qxl_bitmap_format;
 
 typedef enum {
     QXL_BITMAP_PAL_CACHE_ME = (1 << 0),
     QXL_BITMAP_PAL_FROM_CACHE = (1 << 1),
     QXL_BITMAP_TOP_DOWN = (1 << 2),
-} qxl_bitmap_flags;
+} compat_qxl_bitmap_flags;
 
-struct qxl_bitmap {
+struct compat_qxl_bitmap {
     uint8_t format;
     uint8_t flags;		
     uint32_t x;			/* actually width */
     uint32_t y;			/* actually height */
     uint32_t stride;		/* in bytes */
     uint64_t palette;		/* Can be NULL */
-    uint64_t data;		/* A qxl_data_chunk that actually contains the data */
+    uint64_t data;		/* A compat_qxl_data_chunk that actually contains the data */
 };
 
-struct qxl_image {
-    struct qxl_image_descriptor descriptor;
+struct compat_qxl_image {
+    struct compat_qxl_image_descriptor descriptor;
     union
     {
-	struct qxl_bitmap bitmap;
+	struct compat_qxl_bitmap bitmap;
     } u;
 };
 
-struct qxl_fill {
-    struct qxl_brush brush;
+struct compat_qxl_fill {
+    struct compat_qxl_brush brush;
     unsigned short rop_descriptor;
-    struct qxl_mask mask;
+    struct compat_qxl_mask mask;
 };
 
-struct qxl_opaque {
+struct compat_qxl_opaque {
     uint64_t src_bitmap;
-    struct qxl_rect src_area;
-    struct qxl_brush brush;
+    struct compat_qxl_rect src_area;
+    struct compat_qxl_brush brush;
     unsigned short rop_descriptor;
     unsigned char scale_mode;
-    struct qxl_mask mask;
+    struct compat_qxl_mask mask;
 };
 
-struct qxl_copy {
+struct compat_qxl_copy {
     uint64_t src_bitmap;
-    struct qxl_rect src_area;
+    struct compat_qxl_rect src_area;
     unsigned short rop_descriptor;
     unsigned char scale_mode;
-    struct qxl_mask mask;
+    struct compat_qxl_mask mask;
 };
 
-struct qxl_transparent {
+struct compat_qxl_transparent {
     uint64_t src_bitmap;
-    struct qxl_rect src_area;
+    struct compat_qxl_rect src_area;
     uint32_t src_color;
     uint32_t true_color;
 };
 
-struct qxl_alpha_blend {
+struct compat_qxl_alpha_blend {
     unsigned char alpha;
     uint64_t src_bitmap;
-    struct qxl_rect src_area;
+    struct compat_qxl_rect src_area;
 };
 
-struct qxl_copy_bits {
-    struct qxl_point src_pos;
+struct compat_qxl_copy_bits {
+    struct compat_qxl_point src_pos;
 };
 
-struct qxl_blend { /* same as copy */
+struct compat_qxl_blend { /* same as copy */
     uint64_t src_bitmap;
-    struct qxl_rect src_area;
+    struct compat_qxl_rect src_area;
     unsigned short rop_descriptor;
     unsigned char scale_mode;
-    struct qxl_mask mask;
+    struct compat_qxl_mask mask;
 };
 
-struct qxl_rop3 {
+struct compat_qxl_rop3 {
     uint64_t src_bitmap;
-    struct qxl_rect src_area;
-    struct qxl_brush brush;
+    struct compat_qxl_rect src_area;
+    struct compat_qxl_brush brush;
     unsigned char rop3;
     unsigned char scale_mode;
-    struct qxl_mask mask;
+    struct compat_qxl_mask mask;
 };
 
-struct qxl_line_attr {
+struct compat_qxl_line_attr {
     unsigned char flags;
     unsigned char join_style;
     unsigned char end_style;
@@ -272,33 +272,33 @@ struct qxl_line_attr {
     uint64_t style;
 };
 
-struct qxl_stroke {
+struct compat_qxl_stroke {
     uint64_t path;
-    struct qxl_line_attr attr;
-    struct qxl_brush brush;
+    struct compat_qxl_line_attr attr;
+    struct compat_qxl_brush brush;
     unsigned short fore_mode;
     unsigned short back_mode;
 };
 
-struct qxl_text {
+struct compat_qxl_text {
     uint64_t str;
-    struct qxl_rect back_area;
-    struct qxl_brush fore_brush;
-    struct qxl_brush back_brush;
+    struct compat_qxl_rect back_area;
+    struct compat_qxl_brush fore_brush;
+    struct compat_qxl_brush back_brush;
     unsigned short fore_mode;
     unsigned short back_mode;
 };
 
-struct qxl_blackness {
-    struct qxl_mask mask;
+struct compat_qxl_blackness {
+    struct compat_qxl_mask mask;
 };
 
-struct qxl_inverse {
-    struct qxl_mask mask;
+struct compat_qxl_inverse {
+    struct compat_qxl_mask mask;
 };
 
-struct qxl_whiteness {
-    struct qxl_mask mask;
+struct compat_qxl_whiteness {
+    struct compat_qxl_mask mask;
 };
 
 /* Effects */
@@ -312,14 +312,14 @@ typedef enum
     QXL_EFFECT_NOP_ON_DUP,
     QXL_EFFECT_NOP,
     QXL_EFFECT_OPAQUE_BRUSH
-} qxl_effect_type;
+} compat_qxl_effect_type;
 
 typedef enum
 {
     QXL_CLIP_TYPE_NONE,
     QXL_CLIP_TYPE_RECTS,
     QXL_CLIP_TYPE_PATH,
-} qxl_clip_type;
+} compat_qxl_clip_type;
 
 typedef enum {
     QXL_DRAW_NOP,
@@ -336,41 +336,41 @@ typedef enum {
     QXL_DRAW_TEXT,
     QXL_DRAW_TRANSPARENT,
     QXL_DRAW_ALPHA_BLEND,
-} qxl_draw_type;
+} compat_qxl_draw_type;
 
-struct qxl_drawable {
-    union qxl_release_info release_info;
+struct compat_qxl_drawable {
+    union compat_qxl_release_info release_info;
     unsigned char effect;
     unsigned char type;
     unsigned short bitmap_offset;
-    struct qxl_rect bitmap_area;
-    struct qxl_rect bbox;
-    struct qxl_clip clip;
+    struct compat_qxl_rect bitmap_area;
+    struct compat_qxl_rect bbox;
+    struct compat_qxl_clip clip;
     uint32_t mm_time;
     union {
-	struct qxl_fill fill;
-	struct qxl_opaque opaque;
-	struct qxl_copy copy;
-	struct qxl_transparent transparent;
-	struct qxl_alpha_blend alpha_blend;
-	struct qxl_copy_bits copy_bits;
-	struct qxl_blend blend;
-	struct qxl_rop3 rop3;
-	struct qxl_stroke stroke;
-	struct qxl_text text;
-	struct qxl_blackness blackness;
-	struct qxl_inverse inverse;
-	struct qxl_whiteness whiteness;
+	struct compat_qxl_fill fill;
+	struct compat_qxl_opaque opaque;
+	struct compat_qxl_copy copy;
+	struct compat_qxl_transparent transparent;
+	struct compat_qxl_alpha_blend alpha_blend;
+	struct compat_qxl_copy_bits copy_bits;
+	struct compat_qxl_blend blend;
+	struct compat_qxl_rop3 rop3;
+	struct compat_qxl_stroke stroke;
+	struct compat_qxl_text text;
+	struct compat_qxl_blackness blackness;
+	struct compat_qxl_inverse inverse;
+	struct compat_qxl_whiteness whiteness;
     } u;
 };
 
-struct qxl_update_cmd {
-    union qxl_release_info release_info;
-    struct qxl_rect area;
+struct compat_qxl_update_cmd {
+    union compat_qxl_release_info release_info;
+    struct compat_qxl_rect area;
     uint32_t update_id;
 };
 
-struct qxl_point16 {
+struct compat_qxl_point16 {
     int16_t x;
     int16_t y;
 };
@@ -394,7 +394,7 @@ enum {
     CURSOR_TYPE_COLOR32,
 };
 
-struct qxl_cursor_header {
+struct compat_qxl_cursor_header {
     uint64_t unique;
     uint16_t type;
     uint16_t width;
@@ -403,19 +403,19 @@ struct qxl_cursor_header {
     uint16_t hot_spot_y;
 };
 
-struct qxl_cursor
+struct compat_qxl_cursor
 {
-    struct qxl_cursor_header header;
+    struct compat_qxl_cursor_header header;
     uint32_t data_size;
-    struct qxl_data_chunk chunk;
+    struct compat_qxl_data_chunk chunk;
 };
 
-struct qxl_cursor_cmd {
-    union qxl_release_info release_info;
+struct compat_qxl_cursor_cmd {
+    union compat_qxl_release_info release_info;
     uint8_t type;
     union {
 	struct {
-	    struct qxl_point16 position;
+	    struct compat_qxl_point16 position;
 	    unsigned char visible;
 	    uint64_t shape;
 	} set;
@@ -423,12 +423,12 @@ struct qxl_cursor_cmd {
 	    uint16_t length;
 	    uint16_t frequency;
 	} trail;
-	struct qxl_point16 position;
+	struct compat_qxl_point16 position;
     } u;
     uint8_t device_data[QXL_CURSOR_DEVICE_DATA_SIZE];
 };
 
-struct qxl_rom {
+struct compat_qxl_rom {
     uint32_t magic;
     uint32_t id;
     uint32_t update_id;
@@ -444,7 +444,7 @@ struct qxl_rom {
     uint32_t mm_clock;
 };
 
-struct qxl_ring_header {
+struct compat_qxl_ring_header {
     uint32_t num_items;
     uint32_t prod;
     uint32_t notify_on_prod;
@@ -454,38 +454,38 @@ struct qxl_ring_header {
 
 #define QXL_LOG_BUF_SIZE 4096
 
-struct qxl_ram_header {
+struct compat_qxl_ram_header {
     uint32_t magic;
     uint32_t int_pending;
     uint32_t int_mask;
     unsigned char log_buf[QXL_LOG_BUF_SIZE];
-    struct qxl_ring_header  cmd_ring_hdr;
-    struct qxl_command	    cmd_ring[32];
-    struct qxl_ring_header  cursor_ring_hdr;
-    struct qxl_command	    cursor_ring[32];
-    struct qxl_ring_header  release_ring_hdr;
+    struct compat_qxl_ring_header  cmd_ring_hdr;
+    struct compat_qxl_command	    cmd_ring[32];
+    struct compat_qxl_ring_header  cursor_ring_hdr;
+    struct compat_qxl_command	    cursor_ring[32];
+    struct compat_qxl_ring_header  release_ring_hdr;
     uint64_t		    release_ring[8];
-    struct qxl_rect	    update_area;
+    struct compat_qxl_rect	    update_area;
 };
 
 #pragma pack(pop)
 
-typedef struct _qxl_screen_t qxl_screen_t;
+typedef struct _compat_qxl_screen_t compat_qxl_screen_t;
 
-struct _qxl_screen_t
+struct _compat_qxl_screen_t
 {
     /* These are the names QXL uses */
     void *			ram;	/* Video RAM */
     void *			ram_physical;
     void *			vram;	/* Command RAM */
-    struct qxl_rom *		rom;    /* Parameter RAM */
+    struct compat_qxl_rom *		rom;    /* Parameter RAM */
     
-    struct qxl_ring *		command_ring;
-    struct qxl_ring *		cursor_ring;
-    struct qxl_ring *		release_ring;
+    struct compat_qxl_ring *		command_ring;
+    struct compat_qxl_ring *		cursor_ring;
+    struct compat_qxl_ring *		release_ring;
     
     int				num_modes;
-    struct qxl_mode *		modes;
+    struct compat_qxl_mode *		modes;
     int				io_base;
     int				draw_area_offset;
     int				draw_area_size;
@@ -493,7 +493,7 @@ struct _qxl_screen_t
     void *			fb;
     int				bytes_per_pixel;
 
-    struct qxl_mem *		mem;	/* Context for qxl_alloc/free */
+    struct compat_qxl_mem *		mem;	/* Context for compat_qxl_alloc/free */
     
     EntityInfoPtr		entity;
 
@@ -530,15 +530,15 @@ struct _qxl_screen_t
 };
 
 static inline uint64_t
-physical_address (qxl_screen_t *qxl, void *virtual)
+physical_address (compat_qxl_screen_t *compat_qxl, void *virtual)
 {
-    return (uint64_t) ((unsigned long)virtual + (((unsigned long)qxl->ram_physical - (unsigned long)qxl->ram)));
+    return (uint64_t) ((unsigned long)virtual + (((unsigned long)compat_qxl->ram_physical - (unsigned long)compat_qxl->ram)));
 }
 
 static inline void *
-virtual_address (qxl_screen_t *qxl, void *physical)
+virtual_address (compat_qxl_screen_t *compat_qxl, void *physical)
 {
-    return (void *) ((unsigned long)physical + ((unsigned long)qxl->ram - (unsigned long)qxl->ram_physical));
+    return (void *) ((unsigned long)physical + ((unsigned long)compat_qxl->ram - (unsigned long)compat_qxl->ram_physical));
 }
 
 static inline void *
@@ -553,58 +553,58 @@ pointer_to_u64 (void *p)
     return (uint64_t)(unsigned long)p;
 }
 
-struct qxl_ring;
+struct compat_qxl_ring;
 
 /*
  * HW cursor
  */
-void              qxl_cursor_init        (ScreenPtr               pScreen);
+void              compat_qxl_cursor_init        (ScreenPtr               pScreen);
 
 
 
 /*
  * Rings
  */
-struct qxl_ring * qxl_ring_create      (struct qxl_ring_header *header,
+struct compat_qxl_ring * compat_qxl_ring_create      (struct compat_qxl_ring_header *header,
 					int                     element_size,
 					int                     n_elements,
 					int                     prod_notify);
-void              qxl_ring_push        (struct qxl_ring        *ring,
+void              compat_qxl_ring_push        (struct compat_qxl_ring        *ring,
 					const void             *element);
-Bool              qxl_ring_pop         (struct qxl_ring        *ring,
+Bool              compat_qxl_ring_pop         (struct compat_qxl_ring        *ring,
 					void                   *element);
-void              qxl_ring_wait_idle   (struct qxl_ring        *ring);
+void              compat_qxl_ring_wait_idle   (struct compat_qxl_ring        *ring);
 
 
 
 /*
  * Images
  */
-struct qxl_image *qxl_image_create     (qxl_screen_t           *qxl,
+struct compat_qxl_image *compat_qxl_image_create     (compat_qxl_screen_t           *compat_qxl,
 					const uint8_t          *data,
 					int                     x,
 					int                     y,
 					int                     width,
 					int                     height,
 					int                     stride);
-void              qxl_image_destroy    (qxl_screen_t           *qxl,
-					struct qxl_image       *image);
-void		  qxl_drop_image_cache (qxl_screen_t	       *qxl);
+void              compat_qxl_image_destroy    (compat_qxl_screen_t           *compat_qxl,
+					struct compat_qxl_image       *image);
+void		  compat_qxl_drop_image_cache (compat_qxl_screen_t	       *compat_qxl);
 
 
 /*
  * Malloc
  */
-struct qxl_mem *  qxl_mem_create       (void                   *base,
+struct compat_qxl_mem *  compat_qxl_mem_create       (void                   *base,
 					unsigned long           n_bytes);
-void              qxl_mem_dump_stats   (struct qxl_mem         *mem,
+void              compat_qxl_mem_dump_stats   (struct compat_qxl_mem         *mem,
 					const char             *header);
-void *            qxl_alloc            (struct qxl_mem         *mem,
+void *            compat_qxl_alloc            (struct compat_qxl_mem         *mem,
 					unsigned long           n_bytes);
-void              qxl_free             (struct qxl_mem         *mem,
+void              compat_qxl_free             (struct compat_qxl_mem         *mem,
 					void                   *d);
-void              qxl_mem_free_all     (struct qxl_mem         *mem);
-void *            qxl_allocnf          (qxl_screen_t           *qxl,
+void              compat_qxl_mem_free_all     (struct compat_qxl_mem         *mem);
+void *            compat_qxl_allocnf          (compat_qxl_screen_t           *compat_qxl,
 					unsigned long           size);
 
 
diff -up xf86-video-qxl-20130514/src/compat/compat-qxl_image.c.compat2 xf86-video-qxl-20130514/src/compat/compat-qxl_image.c
--- xf86-video-qxl-20130514/src/compat/compat-qxl_image.c.compat2	2013-07-03 14:19:39.010334593 +1000
+++ xf86-video-qxl-20130514/src/compat/compat-qxl_image.c	2013-07-03 14:19:56.103748552 +1000
@@ -8,7 +8,7 @@ typedef struct image_info_t image_info_t
 
 struct image_info_t
 {
-    struct qxl_image *image;
+    struct compat_qxl_image *image;
     int ref_count;
     image_info_t *next;
 };
@@ -33,7 +33,7 @@ hash_and_copy (const uint8_t *src, int s
 	if (dest)
 	    memcpy (dest_line, src_line, n_bytes);
 
-	hash = hashlittle (src_line, n_bytes, hash);
+	hash = compat_hashlittle (src_line, n_bytes, hash);
     }
 
     return hash;
@@ -48,7 +48,7 @@ lookup_image_info (unsigned int hash,
 
     while (info)
     {
-	struct qxl_image *image = info->image;
+	struct compat_qxl_image *image = info->image;
 
 	if (image->descriptor.id == hash		&&
 	    image->descriptor.width == width		&&
@@ -95,17 +95,17 @@ remove_image_info (image_info_t *info)
     free (info);
 }
 
-struct qxl_image *
-qxl_image_create (qxl_screen_t *qxl, const uint8_t *data,
+struct compat_qxl_image *
+compat_qxl_image_create (compat_qxl_screen_t *compat_qxl, const uint8_t *data,
 		  int x, int y, int width, int height,
 		  int stride)
 {
     unsigned int hash;
     image_info_t *info;
 
-    data += y * stride + x * qxl->bytes_per_pixel;
+    data += y * stride + x * compat_qxl->bytes_per_pixel;
 
-    hash = hash_and_copy (data, stride, NULL, -1, qxl->bytes_per_pixel, width, height);
+    hash = hash_and_copy (data, stride, NULL, -1, compat_qxl->bytes_per_pixel, width, height);
 
     info = lookup_image_info (hash, width, height);
     if (info)
@@ -120,11 +120,11 @@ qxl_image_create (qxl_screen_t *qxl, con
 
 	for (i = 0; i < height; ++i)
 	{
-	    struct qxl_data_chunk *chunk;
+	    struct compat_qxl_data_chunk *chunk;
 	    const uint8_t *src_line = data + i * stride;
 	    uint32_t *dest_line;
 		
-	    chunk = virtual_address (qxl, u64_to_pointer (info->image->u.bitmap.data));
+	    chunk = virtual_address (compat_qxl, u64_to_pointer (info->image->u.bitmap.data));
 	    
 	    dest_line = (uint32_t *)chunk->data + width * i;
 
@@ -147,9 +147,9 @@ qxl_image_create (qxl_screen_t *qxl, con
     }
     else
     {
-	struct qxl_image *image;
-	struct qxl_data_chunk *chunk;
-	int dest_stride = width * qxl->bytes_per_pixel;
+	struct compat_qxl_image *image;
+	struct compat_qxl_data_chunk *chunk;
+	int dest_stride = width * compat_qxl->bytes_per_pixel;
 	image_info_t *info;
 
 #if 0
@@ -159,7 +159,7 @@ qxl_image_create (qxl_screen_t *qxl, con
 	/* Chunk */
 	
 	/* FIXME: Check integer overflow */
-	chunk = qxl_allocnf (qxl, sizeof *chunk + height * dest_stride);
+	chunk = compat_qxl_allocnf (compat_qxl, sizeof *chunk + height * dest_stride);
 	
 	chunk->data_size = height * dest_stride;
 	chunk->prev_chunk = 0;
@@ -167,10 +167,10 @@ qxl_image_create (qxl_screen_t *qxl, con
 	
 	hash_and_copy (data, stride,
 		       chunk->data, dest_stride,
-		       qxl->bytes_per_pixel, width, height);
+		       compat_qxl->bytes_per_pixel, width, height);
 
 	/* Image */
-	image = qxl_allocnf (qxl, sizeof *image);
+	image = compat_qxl_allocnf (compat_qxl, sizeof *image);
 
 	image->descriptor.id = 0;
 	image->descriptor.type = QXL_IMAGE_TYPE_BITMAP;
@@ -179,7 +179,7 @@ qxl_image_create (qxl_screen_t *qxl, con
 	image->descriptor.width = width;
 	image->descriptor.height = height;
 
-	if (qxl->bytes_per_pixel == 2)
+	if (compat_qxl->bytes_per_pixel == 2)
 	{
 	    image->u.bitmap.format = QXL_BITMAP_FMT_16BIT;
 	}
@@ -191,9 +191,9 @@ qxl_image_create (qxl_screen_t *qxl, con
 	image->u.bitmap.flags = QXL_BITMAP_TOP_DOWN;
 	image->u.bitmap.x = width;
 	image->u.bitmap.y = height;
-	image->u.bitmap.stride = width * qxl->bytes_per_pixel;
+	image->u.bitmap.stride = width * compat_qxl->bytes_per_pixel;
 	image->u.bitmap.palette = 0;
-	image->u.bitmap.data = physical_address (qxl, chunk);
+	image->u.bitmap.data = physical_address (compat_qxl, chunk);
 
 #if 0
 	ErrorF ("%p has size %d %d\n", image, width, height);
@@ -218,13 +218,13 @@ qxl_image_create (qxl_screen_t *qxl, con
 }
 
 void
-qxl_image_destroy (qxl_screen_t *qxl,
-		   struct qxl_image *image)
+compat_qxl_image_destroy (compat_qxl_screen_t *compat_qxl,
+		   struct compat_qxl_image *image)
 {
-    struct qxl_data_chunk *chunk;
+    struct compat_qxl_data_chunk *chunk;
     image_info_t *info;
 
-    chunk = virtual_address (qxl, u64_to_pointer (image->u.bitmap.data));
+    chunk = virtual_address (compat_qxl, u64_to_pointer (image->u.bitmap.data));
     
     info = lookup_image_info (image->descriptor.id,
 			      image->descriptor.width,
@@ -244,12 +244,12 @@ qxl_image_destroy (qxl_screen_t *qxl,
 	remove_image_info (info);
     }
 
-    qxl_free (qxl->mem, chunk);
-    qxl_free (qxl->mem, image);
+    compat_qxl_free (compat_qxl->mem, chunk);
+    compat_qxl_free (compat_qxl->mem, image);
 }
 
 void
-qxl_drop_image_cache (qxl_screen_t *qxl)
+compat_qxl_drop_image_cache (compat_qxl_screen_t *compat_qxl)
 {
     memset (image_table, 0, HASH_SIZE * sizeof (image_info_t *));
 }
diff -up xf86-video-qxl-20130514/src/compat/compat-qxl_mem.c.compat2 xf86-video-qxl-20130514/src/compat/compat-qxl_mem.c
--- xf86-video-qxl-20130514/src/compat/compat-qxl_mem.c.compat2	2013-07-03 14:19:39.010334593 +1000
+++ xf86-video-qxl-20130514/src/compat/compat-qxl_mem.c	2013-07-03 14:19:56.104748592 +1000
@@ -22,7 +22,7 @@ struct block
     } u;
 };
 
-struct qxl_mem
+struct compat_qxl_mem
 {
     void *		base;
     unsigned long	n_bytes;
@@ -35,7 +35,7 @@ struct qxl_mem
 };
 
 static void
-initialize (struct qxl_mem *mem)
+initialize (struct compat_qxl_mem *mem)
 {
     mem->unused = (struct block *)mem->base;
     mem->unused->n_bytes = mem->n_bytes;
@@ -47,10 +47,10 @@ initialize (struct qxl_mem *mem)
     mem->n_freed_blocks = 0;
 }
 
-struct qxl_mem *
-qxl_mem_create (void *base, unsigned long n_bytes)
+struct compat_qxl_mem *
+compat_qxl_mem_create (void *base, unsigned long n_bytes)
 {
-    struct qxl_mem *mem = NULL;
+    struct compat_qxl_mem *mem = NULL;
 
     mem = calloc (sizeof (*mem), 1);
     if (!mem)
@@ -66,13 +66,13 @@ out:
 }
 
 void
-qxl_mem_free_all (struct qxl_mem *mem)
+compat_qxl_mem_free_all (struct compat_qxl_mem *mem)
 {
     initialize (mem);
 }
 
 void
-qxl_mem_dump_stats (struct qxl_mem *mem, const char *header)
+compat_qxl_mem_dump_stats (struct compat_qxl_mem *mem, const char *header)
 {
     struct block *b;
     int n_blocks;
@@ -122,7 +122,7 @@ qxl_mem_dump_stats (struct qxl_mem *mem,
 }
 
 void *
-qxl_alloc (struct qxl_mem *mem, unsigned long n_bytes)
+compat_qxl_alloc (struct compat_qxl_mem *mem, unsigned long n_bytes)
 {
     struct block *b, *prev;
 
@@ -202,7 +202,7 @@ qxl_alloc (struct qxl_mem *mem, unsigned
     /* If we get here, we are out of memory, so print some stats */
 #if 0
     fprintf (stderr, "Failing to allocate %lu bytes\n", n_bytes);
-    qxl_mem_dump_stats (mem, "out of memory");
+    compat_qxl_mem_dump_stats (mem, "out of memory");
 #endif
     
     return NULL;
@@ -213,7 +213,7 @@ qxl_alloc (struct qxl_mem *mem, unsigned
  * last unused block.
  */
 static void
-find_neighbours (struct qxl_mem *mem, void *data,
+find_neighbours (struct compat_qxl_mem *mem, void *data,
 		 struct block **before, struct block **after)
 {
     struct block *b;
@@ -237,7 +237,7 @@ find_neighbours (struct qxl_mem *mem, vo
 }
 
 void
-qxl_free (struct qxl_mem *mem, void *d)
+compat_qxl_free (struct compat_qxl_mem *mem, void *d)
 {
     struct block *b = d - sizeof (unsigned long);
     struct block *before, *after;
@@ -248,7 +248,7 @@ qxl_free (struct qxl_mem *mem, void *d)
 #if 0
     printf ("freeing %p (%d bytes)\n", b, b->n_bytes);
     
-    qxl_mem_dump_stats (mem, "before free");
+    compat_qxl_mem_dump_stats (mem, "before free");
 #endif
     
     find_neighbours (mem, (void *)b, &before, &after);
@@ -316,6 +316,6 @@ qxl_free (struct qxl_mem *mem, void *d)
     }
 
 #if 0
-    qxl_mem_dump_stats (mem, "after free");
+    compat_qxl_mem_dump_stats (mem, "after free");
 #endif
 }
diff -up xf86-video-qxl-20130514/src/compat/compat-qxl_ring.c.compat2 xf86-video-qxl-20130514/src/compat/compat-qxl_ring.c
--- xf86-video-qxl-20130514/src/compat/compat-qxl_ring.c.compat2	2013-07-03 14:19:39.010334593 +1000
+++ xf86-video-qxl-20130514/src/compat/compat-qxl_ring.c	2013-07-03 14:19:56.104748592 +1000
@@ -5,11 +5,11 @@
 
 struct ring
 {
-    struct qxl_ring_header	header;
+    struct compat_qxl_ring_header	header;
     uint8_t			elements[0];
 };
 
-struct qxl_ring
+struct compat_qxl_ring
 {
     volatile struct ring *ring;
     int			element_size;
@@ -17,13 +17,13 @@ struct qxl_ring
     int			prod_notify;
 };
 
-struct qxl_ring *
-qxl_ring_create (struct qxl_ring_header *header,
+struct compat_qxl_ring *
+compat_qxl_ring_create (struct compat_qxl_ring_header *header,
 		 int                     element_size,
 		 int                     n_elements,
 		 int			 prod_notify)
 {
-    struct qxl_ring *ring;
+    struct compat_qxl_ring *ring;
 
     ring = malloc (sizeof *ring);
     if (!ring)
@@ -38,10 +38,10 @@ qxl_ring_create (struct qxl_ring_header
 }
 
 void
-qxl_ring_push (struct qxl_ring *ring,
+compat_qxl_ring_push (struct compat_qxl_ring *ring,
 	       const void      *new_elt)
 {
-    volatile struct qxl_ring_header *header = &(ring->ring->header);
+    volatile struct compat_qxl_ring_header *header = &(ring->ring->header);
     volatile uint8_t *elt;
     int idx;
 
@@ -66,10 +66,10 @@ qxl_ring_push (struct qxl_ring *ring,
 }
 
 Bool
-qxl_ring_pop (struct qxl_ring *ring,
+compat_qxl_ring_pop (struct compat_qxl_ring *ring,
 	      void            *element)
 {
-    volatile struct qxl_ring_header *header = &(ring->ring->header);
+    volatile struct compat_qxl_ring_header *header = &(ring->ring->header);
     volatile uint8_t *ring_elt;
     int idx;
 
@@ -87,7 +87,7 @@ qxl_ring_pop (struct qxl_ring *ring,
 }
 
 void
-qxl_ring_wait_idle (struct qxl_ring *ring)
+compat_qxl_ring_wait_idle (struct compat_qxl_ring *ring)
 {
     while (ring->ring->header.cons != ring->ring->header.prod)
     {
diff -up xf86-video-qxl-20130514/src/compat/Makefile.am.compat2 xf86-video-qxl-20130514/src/compat/Makefile.am
--- xf86-video-qxl-20130514/src/compat/Makefile.am.compat2	2013-07-03 14:19:39.010334593 +1000
+++ xf86-video-qxl-20130514/src/compat/Makefile.am	2013-07-03 14:19:56.102748510 +1000
@@ -24,13 +24,13 @@
 # -avoid-version prevents gratuitous .0.0.0 version numbers on the end
 # _ladir passes a dummy rpath to libtool so the thing will actually link
 # TODO: -nostdlib/-Bstatic/-lgcc platform magic, not installing the .a, etc.
-qxl_drv_la_LTLIBRARIES = qxl_drv.la
-qxl_drv_la_LDFLAGS = -module -avoid-version
-qxl_drv_ladir = @moduledir@/drivers
-AM_CFLAGS = -g
+
+noinst_LTLIBRARIES = compatdriver.la
+compatdriver_la_LDFLAGS = -module -avoid-version
+
 AM_CFLAGS = $(XORG_CFLAGS) $(PCIACCESS_CFLAGS) $(CWARNFLAGS)
 
-qxl_drv_la_SOURCES =				\
+compatdriver_la_SOURCES =				\
 	compat-qxl.h					\
 	compat-qxl_driver.c				\
 	compat-qxl_image.c				\
diff -up xf86-video-qxl-20130514/src/Makefile.am.compat2 xf86-video-qxl-20130514/src/Makefile.am
--- xf86-video-qxl-20130514/src/Makefile.am.compat2	2013-07-03 14:19:56.102748510 +1000
+++ xf86-video-qxl-20130514/src/Makefile.am	2013-07-03 14:20:10.365094118 +1000
@@ -34,7 +34,7 @@ qxl_drv_la_LTLIBRARIES = qxl_drv.la
 qxl_drv_la_LDFLAGS = -module -avoid-version
 qxl_drv_ladir = @moduledir@/drivers
 
-qxl_drv_la_LIBADD = uxa/libuxa.la
+qxl_drv_la_LIBADD = uxa/libuxa.la compat/compatdriver.la
 if LIBUDEV
 qxl_drv_la_LIBADD += $(LIBUDEV_LIBS)
 endif
diff -up xf86-video-qxl-20130514/src/qxl_driver.c.compat2 xf86-video-qxl-20130514/src/qxl_driver.c
--- xf86-video-qxl-20130514/src/qxl_driver.c.compat2	2013-05-14 11:13:00.000000000 +1000
+++ xf86-video-qxl-20130514/src/qxl_driver.c	2013-07-03 14:19:56.104748592 +1000
@@ -1365,7 +1365,11 @@ qxl_pci_probe (DriverPtr drv, int entity
     qxl = pScrn->driverPrivate;
     qxl->pci = dev;
     
-    qxl_init_scrn (pScrn, kms);
+    if (!kms && qxl->pci->revision == 0x01)
+    {
+	compat_init_scrn (pScrn);
+    } else
+        qxl_init_scrn (pScrn, kms);
     
     return TRUE;
 }
