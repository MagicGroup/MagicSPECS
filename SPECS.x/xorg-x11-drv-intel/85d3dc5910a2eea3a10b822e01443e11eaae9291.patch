commit 85d3dc5910a2eea3a10b822e01443e11eaae9291
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Dec 2 10:22:51 2011 +0000

    uxa: Reset size limits based on AGP size
    
    The basis for the constraints are what we can map into the aperture for
    direct writing with the CPU, so use the size of the mappable region as
    opposed to the size of the total GTT.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/src/intel.h b/src/intel.h
index 1f004a8..28f049e 100644
--- a/src/intel.h
+++ b/src/intel.h
@@ -542,7 +542,6 @@ int intel_crtc_to_pipe(xf86CrtcPtr crtc);
 unsigned long intel_get_fence_size(intel_screen_private *intel, unsigned long size);
 unsigned long intel_get_fence_pitch(intel_screen_private *intel, unsigned long pitch,
 				   uint32_t tiling_mode);
-void intel_set_gem_max_sizes(ScrnInfoPtr scrn);
 
 drm_intel_bo *intel_allocate_framebuffer(ScrnInfoPtr scrn,
 					int w, int h, int cpp,
diff --git a/src/intel_memory.c b/src/intel_memory.c
index 763a6ad..7e0a6dd 100644
--- a/src/intel_memory.c
+++ b/src/intel_memory.c
@@ -169,6 +169,35 @@ static inline int intel_pad_drawable_width(int width)
 	return ALIGN(width, 64);
 }
 
+
+static size_t
+agp_aperture_size(struct pci_device *dev, int gen)
+{
+	return dev->regions[gen < 30 ? 0 : 2].size;
+}
+
+static void intel_set_gem_max_sizes(ScrnInfoPtr scrn)
+{
+	intel_screen_private *intel = intel_get_screen_private(scrn);
+	size_t agp_size = agp_aperture_size(intel->PciInfo,
+					    INTEL_INFO(intel)->gen);
+
+	/* The chances of being able to mmap an object larger than this
+	 * are slim, so don't try. */
+	intel->max_gtt_map_size = agp_size / 2;
+
+	/* Let objects be tiled up to the size where only 4 would fit in
+	 * the aperture, presuming best case alignment.  */
+	intel->max_tiling_size = agp_size / 4;
+
+	/* Large BOs will tend to hit SW fallbacks frequently, and also will
+	 * tend to fail to successfully map when doing SW fallbacks because we
+	 * overcommit address space for BO access, or worse cause aperture
+	 * thrashing.
+	 */
+	intel->max_bo_size = intel->max_gtt_map_size;
+}
+
 /**
  * Allocates a framebuffer for a screen.
  *
@@ -249,56 +278,3 @@ retry:
 
 	return front_buffer;
 }
-
-static void intel_set_max_bo_size(intel_screen_private *intel,
-				 const struct drm_i915_gem_get_aperture *aperture)
-{
-	if (aperture->aper_available_size)
-		/* Large BOs will tend to hit SW fallbacks frequently, and also will
-		 * tend to fail to successfully map when doing SW fallbacks because we
-		 * overcommit address space for BO access, or worse cause aperture
-		 * thrashing.
-		 */
-		intel->max_bo_size = aperture->aper_available_size / 2;
-	else
-		intel->max_bo_size = 64 * 1024 * 1024;
-}
-
-static void intel_set_max_gtt_map_size(intel_screen_private *intel,
-				      const struct drm_i915_gem_get_aperture *aperture)
-{
-	if (aperture->aper_available_size)
-		/* Let objects up get bound up to the size where only 2 would fit in
-		 * the aperture, but then leave slop to account for alignment like
-		 * libdrm does.
-		 */
-		intel->max_gtt_map_size =
-			aperture->aper_available_size * 3 / 4 / 2;
-	else
-		intel->max_gtt_map_size = 16 * 1024 * 1024;
-}
-
-static void intel_set_max_tiling_size(intel_screen_private *intel,
-				     const struct drm_i915_gem_get_aperture *aperture)
-{
-	if (aperture->aper_available_size)
-		/* Let objects be tiled up to the size where only 4 would fit in
-		 * the aperture, presuming worst case alignment.
-		 */
-		intel->max_tiling_size = aperture->aper_available_size / 4;
-	else
-		intel->max_tiling_size = 4 * 1024 * 1024;
-}
-
-void intel_set_gem_max_sizes(ScrnInfoPtr scrn)
-{
-	intel_screen_private *intel = intel_get_screen_private(scrn);
-	struct drm_i915_gem_get_aperture aperture;
-
-	aperture.aper_available_size = 0;
-	drmIoctl(intel->drmSubFD, DRM_IOCTL_I915_GEM_GET_APERTURE, &aperture);
-
-	intel_set_max_bo_size(intel, &aperture);
-	intel_set_max_gtt_map_size(intel, &aperture);
-	intel_set_max_tiling_size(intel, &aperture);
-}
