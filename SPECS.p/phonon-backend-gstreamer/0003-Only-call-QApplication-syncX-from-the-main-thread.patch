From 2cafb9db34ed1079eca22c913a48011b67ff9c70 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Dan=20Vr=C3=A1til?= <dvratil@redhat.com>
Date: Tue, 8 Apr 2014 19:46:25 +0200
Subject: [PATCH 3/3] Only call QApplication::syncX() from the main thread

This fixes a regression introduced in 2db4c4. In order to pass WID to gstreamer
synchronously, a Qt::DirectConnection between Pipeline signal and a VideoWidget
slot must be created. However the signal from Pipeline can be emitted from an
arbitrary thread, so we can't call QApplication::syncX() directly from the slot
callchain. This patch moves the call to VideoWidget::syncX() slot that is called
from X11Renderer via queued invocation to make sure it's always executed from the
main thread.

FIXED-IN: 4.7.3
BUG: 327367
BUG: 332977
CCBUG: 305333
---
 gstreamer/videowidget.cpp | 13 +++++++++++++
 gstreamer/videowidget.h   |  1 +
 gstreamer/x11renderer.cpp | 19 +++++--------------
 3 files changed, 19 insertions(+), 14 deletions(-)

diff --git a/gstreamer/videowidget.cpp b/gstreamer/videowidget.cpp
index a3948ba..51b088f 100644
--- a/gstreamer/videowidget.cpp
+++ b/gstreamer/videowidget.cpp
@@ -18,6 +18,7 @@
 
 #include "videowidget.h"
 #include <QtCore/QEvent>
+#include <QtCore/QThread>
 #include <QtGui/QResizeEvent>
 #include <QtGui/QPalette>
 #include <QtGui/QImage>
@@ -81,6 +82,18 @@ void VideoWidget::updateWindowID()
         render->setOverlay();
 }
 
+void Gstreamer::VideoWidget::syncX()
+{
+    Q_ASSERT(QThread::currentThread() == QApplication::instance()->thread());
+
+#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)
+#warning syncx
+//    QApplication::syncX();
+#else
+    QApplication::syncX();
+#endif
+}
+
 void VideoWidget::finalizeLink()
 {
     connect(root()->pipeline(), SIGNAL(mouseOverActive(bool)), this, SLOT(mouseOverActive(bool)));
diff --git a/gstreamer/videowidget.h b/gstreamer/videowidget.h
index d2bac6a..f36f327 100644
--- a/gstreamer/videowidget.h
+++ b/gstreamer/videowidget.h
@@ -87,6 +87,7 @@ public:
 public slots:
     void setMovieSize(const QSize &size);
     void mouseOverActive(bool active);
+    void syncX();
 
 protected:
     virtual void keyPressEvent(QKeyEvent *event);
diff --git a/gstreamer/x11renderer.cpp b/gstreamer/x11renderer.cpp
index a8e922b..8b1d9ef 100644
--- a/gstreamer/x11renderer.cpp
+++ b/gstreamer/x11renderer.cpp
@@ -162,14 +162,6 @@ void X11Renderer::setOverlay()
 {
     if (m_videoSink && GST_IS_X_OVERLAY(m_videoSink)) {
         WId windowId = m_renderWidget->winId();
-        // Even if we have created a winId at this point, other X applications
-        // need to be aware of it.
-#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)
-#warning syncx
-//         QApplication::syncX();
-#else
-        QApplication::syncX();
-#endif
 #if GST_VERSION >= GST_VERSION_CHECK(0,10,31,0)
         gst_x_overlay_set_window_handle(GST_X_OVERLAY(m_videoSink), windowId);
 #else
@@ -182,12 +174,11 @@ void X11Renderer::setOverlay()
 
 void X11Renderer::windowExposed()
 {
-#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)
-#warning syncx
-//     QApplication::syncX();
-#else
-    QApplication::syncX();
-#endif
+    // This can be invoked within a callchain in an arbitrary thread, so make
+    // sure we call syncX() from the main thread
+    QMetaObject::invokeMethod(m_videoWidget, "syncX",
+                              Qt::QueuedConnection);
+
     if (m_videoSink && GST_IS_X_OVERLAY(m_videoSink))
         gst_x_overlay_expose(GST_X_OVERLAY(m_videoSink));
 }
-- 
1.9.0

