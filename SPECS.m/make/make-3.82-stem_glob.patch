diff -up make-3.82/default.c~ make-3.82/default.c
--- make-3.82/default.c~	2010-07-13 03:20:39.000000000 +0200
+++ make-3.82/default.c	2013-07-26 19:28:27.372056421 +0200
@@ -542,9 +542,8 @@ set_default_suffixes (void)
   else
     {
       char *p = default_suffixes;
-      suffix_file->deps = enter_prereqs(PARSE_FILE_SEQ (&p, struct dep, '\0',
-                                                        NULL, 0),
-                                        NULL);
+      suffix_file->deps = enter_prereqs (PARSE_SIMPLE_SEQ (&p, struct dep),
+                                         NULL);
       define_variable_cname ("SUFFIXES", default_suffixes, o_default, 0);
     }
 }
diff -up make-3.82/dep.h~ make-3.82/dep.h
--- make-3.82/dep.h~	2010-07-13 03:20:39.000000000 +0200
+++ make-3.82/dep.h	2013-07-26 19:40:03.121285291 +0200
@@ -65,6 +65,8 @@ struct nameseq
 
 #define PARSE_FILE_SEQ(_s,_t,_c,_p,_f) \
             (_t *)parse_file_seq ((_s),sizeof (_t),(_c),(_p),(_f))
+#define PARSE_SIMPLE_SEQ(_s,_t) \
+            (_t *)parse_file_seq ((_s),sizeof (_t),'\0',NULL,PARSEFS_NONE)
 
 #ifdef VMS
 void *parse_file_seq ();
diff -up make-3.82/file.c~ make-3.82/file.c
--- make-3.82/file.c~	2010-07-13 03:20:39.000000000 +0200
+++ make-3.82/file.c	2013-07-26 19:40:47.067541216 +0200
@@ -426,7 +426,7 @@ remove_intermediates (int sig)
 struct dep *
 split_prereqs (char *p)
 {
-  struct dep *new = PARSE_FILE_SEQ (&p, struct dep, '|', NULL, 0);
+  struct dep *new = PARSE_FILE_SEQ (&p, struct dep, '|', NULL, PARSEFS_NONE);
 
   if (*p)
     {
@@ -435,7 +435,7 @@ split_prereqs (char *p)
       struct dep *ood;
 
       ++p;
-      ood = PARSE_FILE_SEQ (&p, struct dep, '\0', NULL, 0);
+      ood = PARSE_SIMPLE_SEQ (&p, struct dep);
 
       if (! new)
         new = ood;
diff -up make-3.82/implicit.c~ make-3.82/implicit.c
--- make-3.82/implicit.c~	2010-07-13 03:20:40.000000000 +0200
+++ make-3.82/implicit.c	2013-07-26 19:42:33.650161869 +0200
@@ -254,8 +254,6 @@ pattern_search (struct file *file, int a
      that is not just `%'.  */
   int specific_rule_matched = 0;
 
-  struct dep dep_simple;
-
   unsigned int ri;  /* uninit checks OK */
   struct rule *rule;
 
@@ -530,11 +528,9 @@ pattern_search (struct file *file, int a
               /* If we don't need a second expansion, just replace the %.  */
               if (! dep->need_2nd_expansion)
                 {
-                  dep_simple = *dep;
-                  dep_simple.next = 0;
                   p = strchr (nptr, '%');
                   if (p == 0)
-                    dep_simple.name = nptr;
+                    strcpy (depname, nptr);
                   else
                     {
                       char *o = depname;
@@ -548,13 +544,19 @@ pattern_search (struct file *file, int a
                       memcpy (o, stem_str, stemlen);
                       o += stemlen;
                       strcpy (o, p + 1);
-                      dep_simple.name = strcache_add (depname);
                     }
-                  dl = &dep_simple;
+
+                  /* Parse the expanded string.  It might have wildcards.  */
+                  p = depname;
+                  dl = PARSE_SIMPLE_SEQ (&p, struct dep);
+                  for (d = dl; d != NULL; d = d->next)
+                    {
+                      ++deps_found;
+                      d->ignore_mtime = dep->ignore_mtime;
+                    }
 
                   /* We've used up this dep, so next time get a new one.  */
                   nptr = 0;
-                  ++deps_found;
                 }
 
               /* We have to perform second expansion on this prereq.  In an
@@ -633,7 +635,7 @@ pattern_search (struct file *file, int a
 
                   /* Parse the expanded string. */
                   dl = PARSE_FILE_SEQ (&p, struct dep, order_only ? '\0' : '|',
-                                       add_dir ? dir : NULL, 0);
+                                       add_dir ? dir : NULL, PARSEFS_NONE);
 
                   for (d = dl; d != NULL; d = d->next)
                     {
@@ -777,8 +779,7 @@ pattern_search (struct file *file, int a
                 }
 
               /* Free the ns chain.  */
-              if (dl != &dep_simple)
-                free_dep_chain (dl);
+	      free_dep_chain (dl);
 
               if (failed)
                 break;
diff -up make-3.82/main.c~ make-3.82/main.c
--- make-3.82/main.c~	2013-07-26 19:27:26.076702728 +0200
+++ make-3.82/main.c	2013-07-26 19:42:57.476300585 +0200
@@ -2276,7 +2276,7 @@ main (int argc, char **argv, char **envp
             {
               struct nameseq *ns;
 
-              ns = PARSE_FILE_SEQ (&p, struct nameseq, '\0', NULL, 0);
+              ns = PARSE_SIMPLE_SEQ (&p, struct nameseq);
               if (ns)
                 {
                   /* .DEFAULT_GOAL should contain one target. */
diff -up make-3.82/read.c~ make-3.82/read.c
--- make-3.82/read.c~	2013-07-26 19:27:26.122702993 +0200
+++ make-3.82/read.c	2013-07-26 19:43:42.004559875 +0200
@@ -1033,7 +1033,7 @@ eval (struct ebuffer *ebuf, int set_defa
         /* Make the colon the end-of-string so we know where to stop
            looking for targets.  */
         *colonp = '\0';
-        filenames = PARSE_FILE_SEQ (&p2, struct nameseq, '\0', NULL, 0);
+        filenames = PARSE_SIMPLE_SEQ (&p2, struct nameseq);
         *p2 = ':';
 
         if (!filenames)
diff -up make-3.82/rule.c~ make-3.82/rule.c
--- make-3.82/rule.c~	2010-07-19 09:10:54.000000000 +0200
+++ make-3.82/rule.c	2013-07-26 19:44:03.956687696 +0200
@@ -377,7 +377,7 @@ install_pattern_rule (struct pspec *p, i
   ++r->suffixes[0];
 
   ptr = p->dep;
-  r->deps = PARSE_FILE_SEQ (&ptr, struct dep, '\0', NULL, 0);
+  r->deps = PARSE_SIMPLE_SEQ (&ptr, struct dep);
 
   if (new_pattern_rule (r, 0))
     {
diff --git a/tests/scripts/features/rule_glob b/tests/scripts/features/rule_glob
new file mode 100644
index 0000000..2d377e7
--- /dev/null
+++ b/tests/scripts/features/rule_glob
@@ -0,0 +1,37 @@
+#                                                                    -*-perl-*-
+
+$description = "Test globbing in targets and prerequisites.";
+
+$details = "";
+
+touch(qw(a.one a.two a.three));
+
+# Test wildcards in regular targets and prerequisites
+run_make_test(q{
+.PHONY: all a.one a.two a.three
+all: a.one* a.t[a-z0-9]o a.th[!q]ee
+a.o[Nn][Ee] a.t*: ; @echo $@
+},
+              '', "a.one\na.two\na.three");
+
+# Test wildcards in pattern targets and prerequisites
+run_make_test(q{
+.PHONY: all
+all: a.four
+%.four : %.t* ; @echo $@: $(sort $^)
+},
+              '', "a.four: a.three a.two");
+
+# Test wildcards in second expansion targets and prerequisites
+run_make_test(q{
+.PHONY: all
+all: a.four
+.SECONDEXPANSION:
+%.four : $$(sort %.t*) ; @echo $@: $(sort $^)
+},
+              '', "a.four: a.three a.two");
+
+unlink(qw(a.one a.two a.three));
+
+# This tells the test driver that the perl test script executed properly.
+1;
