From 66d9f120e26d49329667e4b9f5a84076c4f66a6e Mon Sep 17 00:00:00 2001
From: Harish Zunjarrao <harish.zunjarrao@qlogic.com>
Date: Fri, 18 Oct 2013 09:29:24 -0400
Subject: [PATCH] iscsi tools: Additional parameters for network settings

Signed-off-by: Harish Zunjarrao <harish.zunjarrao@qlogic.com>
Signed-off-by: Adheer Chandravanshi <adheer.chandravanshi@qlogic.com>
Signed-off-by: Vikas Chaudhary <vikas.chaudhary@qlogic.com>
---
 usr/config.h      |  50 +++-
 usr/idbm.c        |  76 +++++
 usr/idbm_fields.h |  49 ++++
 usr/iface.c       | 847 ++++++++++++++++++++++++++++++++++++++++++++++++------
 usr/iscsi_sysfs.c | 200 +++++++++++++
 5 files changed, 1132 insertions(+), 90 deletions(-)

diff --git a/usr/config.h b/usr/config.h
index d457bdd..fd31a54 100644
--- a/usr/config.h
+++ b/usr/config.h
@@ -232,11 +232,59 @@ typedef struct iface_rec {
 							   * 1 = enable */
 	uint16_t		mtu;
 	uint16_t		port;
+	char			delayed_ack[ISCSI_MAX_STR_LEN];
+	char			nagle[ISCSI_MAX_STR_LEN];
+	char			tcp_wsf_state[ISCSI_MAX_STR_LEN];
+	uint8_t			tcp_wsf;
+	uint8_t			tcp_timer_scale;
+	char			tcp_timestamp[ISCSI_MAX_STR_LEN];
+	char			dhcp_dns[ISCSI_MAX_STR_LEN];
+	char			dhcp_slp_da[ISCSI_MAX_STR_LEN];
+	char			tos_state[ISCSI_MAX_STR_LEN];
+	uint8_t			tos;
+	char			gratuitous_arp[ISCSI_MAX_STR_LEN];
+	char			dhcp_alt_client_id_state[ISCSI_MAX_STR_LEN];
+	char			dhcp_alt_client_id[ISCSI_MAX_STR_LEN];
+	char			dhcp_req_vendor_id_state[ISCSI_MAX_STR_LEN];
+	char			dhcp_vendor_id_state[ISCSI_MAX_STR_LEN];
+	char			dhcp_vendor_id[ISCSI_MAX_STR_LEN];
+	char			dhcp_learn_iqn[ISCSI_MAX_STR_LEN];
+	char			fragmentation[ISCSI_MAX_STR_LEN];
+	char			incoming_forwarding[ISCSI_MAX_STR_LEN];
+	uint8_t			ttl;
+	char			gratuitous_neighbor_adv[ISCSI_MAX_STR_LEN];
+	char			redirect[ISCSI_MAX_STR_LEN];
+	char			mld[ISCSI_MAX_STR_LEN];
+	uint32_t		flow_label;
+	uint32_t		traffic_class;
+	uint8_t			hop_limit;
+	uint32_t		nd_reachable_tmo;
+	uint32_t		nd_rexmit_time;
+	uint32_t		nd_stale_tmo;
+	uint8_t			dup_addr_detect_cnt;
+	uint32_t		router_adv_link_mtu;
+	uint16_t		def_task_mgmt_tmo;
+	char			header_digest[ISCSI_MAX_STR_LEN];
+	char			data_digest[ISCSI_MAX_STR_LEN];
+	char			immediate_data[ISCSI_MAX_STR_LEN];
+	char			initial_r2t[ISCSI_MAX_STR_LEN];
+	char			data_seq_inorder[ISCSI_MAX_STR_LEN];
+	char			data_pdu_inorder[ISCSI_MAX_STR_LEN];
+	uint8_t			erl;
+	uint32_t		max_recv_dlength;
+	uint32_t		first_burst_len;
+	uint16_t		max_out_r2t;
+	uint32_t		max_burst_len;
+	char			chap_auth[ISCSI_MAX_STR_LEN];
+	char			bidi_chap[ISCSI_MAX_STR_LEN];
+	char			strict_login_comp[ISCSI_MAX_STR_LEN];
+	char			discovery_auth[ISCSI_MAX_STR_LEN];
+	char			discovery_logout[ISCSI_MAX_STR_LEN];
 	char			port_state[ISCSI_MAX_STR_LEN];
 	char			port_speed[ISCSI_MAX_STR_LEN];
 	/*
 	 * TODO: we may have to make this bigger and interconnect
-	 * specific for infinniband 
+	 * specific for infiniband
 	 */
 	char			hwaddress[ISCSI_HWADDRESS_BUF_SIZE];
 	char			transport_name[ISCSI_TRANSPORT_NAME_MAXLEN];
diff --git a/usr/idbm.c b/usr/idbm.c
index 6b6f57c..4428ebe 100644
--- a/usr/idbm.c
+++ b/usr/idbm.c
@@ -454,6 +454,82 @@ void idbm_recinfo_iface(iface_rec_t *r, recinfo_t *ri)
 	__recinfo_int(IFACE_NUM, ri, r, iface_num, IDBM_SHOW, num, 1);
 	__recinfo_uint16(IFACE_MTU, ri, r, mtu, IDBM_SHOW, num, 1);
 	__recinfo_uint16(IFACE_PORT, ri, r, port, IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_DHCP_ALT_CID, ri, r, dhcp_alt_client_id_state,
+		      IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_DHCP_ALT_CID_STR, ri, r, dhcp_alt_client_id,
+		      IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_DHCP_DNS, ri, r, dhcp_dns, IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_DHCP_LEARN_IQN, ri, r, dhcp_learn_iqn, IDBM_SHOW,
+		      num, 1);
+	__recinfo_str(IFACE_DHCP_REQ_VID, ri, r, dhcp_req_vendor_id_state,
+		      IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_DHCP_VID, ri, r, dhcp_vendor_id_state, IDBM_SHOW,
+		      num, 1);
+	__recinfo_str(IFACE_DHCP_VID_STR, ri, r, dhcp_vendor_id, IDBM_SHOW,
+		      num, 1);
+	__recinfo_str(IFACE_DHCP_SLP_DA, ri, r, dhcp_slp_da, IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_FRAGMENTATION, ri, r, fragmentation, IDBM_SHOW,
+		      num, 1);
+	__recinfo_str(IFACE_GRAT_ARP, ri, r, gratuitous_arp, IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_IN_FORWARD, ri, r, incoming_forwarding, IDBM_SHOW,
+		      num, 1);
+	__recinfo_str(IFACE_TOS_STATE, ri, r, tos_state, IDBM_SHOW, num, 1);
+	__recinfo_uint8(IFACE_TOS, ri, r, tos, IDBM_SHOW, num, 1);
+	__recinfo_uint8(IFACE_TTL, ri, r, ttl, IDBM_SHOW, num, 1);
+	__recinfo_uint8(IFACE_DUP_ADDR_DETECT_CNT, ri, r, dup_addr_detect_cnt,
+			IDBM_SHOW, num, 1);
+	__recinfo_uint32(IFACE_FLOW_LABEL, ri, r, flow_label, IDBM_SHOW,
+			 num, 1);
+	__recinfo_str(IFACE_GRAT_NEIGHBOR_ADV, ri, r, gratuitous_neighbor_adv,
+		      IDBM_SHOW, num, 1);
+	__recinfo_uint8(IFACE_HOP_LIMIT, ri, r, hop_limit, IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_MLD, ri, r, mld, IDBM_SHOW, num, 1);
+	__recinfo_uint32(IFACE_ND_REACHABLE_TMO, ri, r, nd_reachable_tmo,
+			 IDBM_SHOW, num, 1);
+	__recinfo_uint32(IFACE_ND_REXMIT_TIME, ri, r, nd_rexmit_time, IDBM_SHOW,
+			 num, 1);
+	__recinfo_uint32(IFACE_ND_STALE_TMO, ri, r, nd_stale_tmo, IDBM_SHOW,
+			 num, 1);
+	__recinfo_uint32(IFACE_RTR_ADV_LINK_MTU, ri, r, router_adv_link_mtu,
+			 IDBM_SHOW, num, 1);
+	__recinfo_uint8(IFACE_TRAFFIC_CLASS, ri, r, traffic_class, IDBM_SHOW,
+			num, 1);
+	__recinfo_str(IFACE_DELAYED_ACK, ri, r, delayed_ack, IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_TCP_NAGLE, ri, r, nagle, IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_TCP_WSF_STATE, ri, r, tcp_wsf_state, IDBM_SHOW,
+		      num, 1);
+	__recinfo_uint8(IFACE_TCP_WSF, ri, r, tcp_wsf, IDBM_SHOW, num, 1);
+	__recinfo_uint8(IFACE_TCP_TIMER_SCALE, ri, r, tcp_timer_scale,
+			IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_TCP_TIMESTAMP, ri, r, tcp_timestamp, IDBM_SHOW,
+		      num, 1);
+	__recinfo_str(IFACE_REDIRECT, ri, r, redirect, IDBM_SHOW, num, 1);
+	__recinfo_uint16(IFACE_DEF_TMF_TMO, ri, r, def_task_mgmt_tmo, IDBM_SHOW,
+			 num, 1);
+	__recinfo_str(IFACE_HDRDGST, ri, r, header_digest, IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_DATADGST, ri, r, data_digest, IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_IMM_DATA, ri, r, immediate_data, IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_INITIAL_R2T, ri, r, initial_r2t, IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_DSEQ_INORDER, ri, r, data_seq_inorder, IDBM_SHOW,
+		      num, 1);
+	__recinfo_str(IFACE_DPDU_INORDER, ri, r, data_pdu_inorder, IDBM_SHOW,
+		      num, 1);
+	__recinfo_uint8(IFACE_ERL, ri, r, erl, IDBM_SHOW, num, 1);
+	__recinfo_uint32(IFACE_MAX_RECV_DLEN, ri, r, max_recv_dlength,
+			 IDBM_SHOW, num, 1);
+	__recinfo_uint32(IFACE_FIRST_BURST, ri, r, first_burst_len, IDBM_SHOW,
+			 num, 1);
+	__recinfo_uint16(IFACE_MAX_R2T, ri, r, max_out_r2t, IDBM_SHOW, num, 1);
+	__recinfo_uint32(IFACE_MAX_BURST, ri, r, max_burst_len, IDBM_SHOW,
+			 num, 1);
+	__recinfo_str(IFACE_CHAP_AUTH, ri, r, chap_auth, IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_BIDI_CHAP, ri, r, bidi_chap, IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_STRICT_LOGIN_COMP, ri, r, strict_login_comp,
+		      IDBM_SHOW, num, 1);
+	__recinfo_str(IFACE_DISCOVERY_AUTH, ri, r, discovery_auth, IDBM_SHOW,
+		      num, 1);
+	__recinfo_str(IFACE_DISCOVERY_LOGOUT, ri, r, discovery_logout,
+		      IDBM_SHOW, num, 1);
 }
 
 void idbm_recinfo_host_chap(struct iscsi_chap_rec *r, recinfo_t *ri)
diff --git a/usr/idbm_fields.h b/usr/idbm_fields.h
index 179dda8..5790a03 100644
--- a/usr/idbm_fields.h
+++ b/usr/idbm_fields.h
@@ -89,6 +89,55 @@
 #define IFACE_NUM		"iface.iface_num"
 #define IFACE_MTU		"iface.mtu"
 #define IFACE_PORT		"iface.port"
+#define IFACE_DELAYED_ACK	"iface.delayed_ack"
+#define IFACE_TCP_NAGLE		"iface.tcp_nagle"
+#define IFACE_TCP_WSF_STATE	"iface.tcp_wsf_state"
+#define IFACE_TCP_WSF		"iface.tcp_wsf"
+#define IFACE_TCP_TIMER_SCALE	"iface.tcp_timer_scale"
+#define IFACE_TCP_TIMESTAMP	"iface.tcp_timestamp"
+#define IFACE_DHCP_DNS		"iface.dhcp_dns"
+#define IFACE_DHCP_SLP_DA	"iface.dhcp_slp_da"
+#define IFACE_TOS_STATE		"iface.tos_state"
+#define IFACE_TOS		"iface.tos"
+#define IFACE_GRAT_ARP		"iface.gratuitous_arp"
+#define IFACE_DHCP_ALT_CID	"iface.dhcp_alt_client_id_state"
+#define IFACE_DHCP_ALT_CID_STR	"iface.dhcp_alt_client_id"
+#define IFACE_DHCP_REQ_VID	"iface.dhcp_req_vendor_id_state"
+#define IFACE_DHCP_VID		"iface.dhcp_vendor_id_state"
+#define IFACE_DHCP_VID_STR	"iface.dhcp_vendor_id"
+#define IFACE_DHCP_LEARN_IQN	"iface.dhcp_learn_iqn"
+#define IFACE_FRAGMENTATION	"iface.fragmentation"
+#define IFACE_IN_FORWARD	"iface.incoming_forwarding"
+#define IFACE_TTL		"iface.ttl"
+#define IFACE_GRAT_NEIGHBOR_ADV	"iface.gratuitous_neighbor_adv"
+#define IFACE_REDIRECT		"iface.redirect"
+#define IFACE_IGNORE_ICMP_ECHO_REQ	"iface.ignore_icmp_echo_request"
+#define IFACE_MLD		"iface.mld"
+#define IFACE_FLOW_LABEL	"iface.flow_label"
+#define IFACE_TRAFFIC_CLASS	"iface.traffic_class"
+#define IFACE_HOP_LIMIT		"iface.hop_limit"
+#define IFACE_ND_REACHABLE_TMO	"iface.nd_reachable_tmo"
+#define IFACE_ND_REXMIT_TIME	"iface.nd_rexmit_time"
+#define IFACE_ND_STALE_TMO	"iface.nd_stale_tmo"
+#define IFACE_DUP_ADDR_DETECT_CNT	"iface.dup_addr_detect_cnt"
+#define IFACE_RTR_ADV_LINK_MTU	"iface.router_adv_link_mtu"
+#define IFACE_DEF_TMF_TMO	"iface.def_task_mgmt_timeout"
+#define IFACE_HDRDGST		"iface.header_digest"
+#define IFACE_DATADGST		"iface.data_digest"
+#define IFACE_IMM_DATA		"iface.immediate_data"
+#define IFACE_INITIAL_R2T	"iface.initial_r2t"
+#define IFACE_DSEQ_INORDER	"iface.data_seq_inorder"
+#define IFACE_DPDU_INORDER	"iface.data_pdu_inorder"
+#define IFACE_ERL		"iface.erl"
+#define IFACE_MAX_RECV_DLEN	"iface.max_receive_data_len"
+#define IFACE_FIRST_BURST	"iface.first_burst_len"
+#define IFACE_MAX_R2T		"iface.max_outstanding_r2t"
+#define IFACE_MAX_BURST		"iface.max_burst_len"
+#define IFACE_CHAP_AUTH		"iface.chap_auth"
+#define IFACE_BIDI_CHAP		"iface.bidi_chap"
+#define IFACE_STRICT_LOGIN_COMP	"iface.strict_login_compliance"
+#define IFACE_DISCOVERY_AUTH	"iface.discovery_auth"
+#define IFACE_DISCOVERY_LOGOUT	"iface.discovery_logout"
 
 /* discovery fields */
 #define DISC_STARTUP		"discovery.startup"
diff --git a/usr/iface.c b/usr/iface.c
index 55b0dd4..87ac875 100644
--- a/usr/iface.c
+++ b/usr/iface.c
@@ -601,6 +601,105 @@ void iface_copy(struct iface_rec *dst, struct iface_rec *src)
 		dst->mtu = src->mtu;
 	if (src->port)
 		dst->port = src->port;
+	if (strlen(src->delayed_ack))
+		strcpy(dst->delayed_ack, src->delayed_ack);
+	if (strlen(src->nagle))
+		strcpy(dst->nagle, src->nagle);
+	if (strlen(src->tcp_wsf_state))
+		strcpy(dst->tcp_wsf_state, src->tcp_wsf_state);
+	if (src->tcp_wsf)
+		dst->tcp_wsf = src->tcp_wsf;
+	if (src->tcp_timer_scale)
+		dst->tcp_timer_scale = src->tcp_timer_scale;
+	if (strlen(src->tcp_timestamp))
+		strcpy(dst->tcp_timestamp, src->tcp_timestamp);
+	if (strlen(src->dhcp_dns))
+		strcpy(dst->dhcp_dns, src->dhcp_dns);
+	if (strlen(src->dhcp_slp_da))
+		strcpy(dst->dhcp_slp_da, src->dhcp_slp_da);
+	if (strlen(src->tos_state))
+		strcpy(dst->tos_state, src->tos_state);
+	if (src->tos)
+		dst->tos = src->tos;
+	if (strlen(src->gratuitous_arp))
+		strcpy(dst->gratuitous_arp, src->gratuitous_arp);
+	if (strlen(src->dhcp_alt_client_id_state))
+		strcpy(dst->dhcp_alt_client_id_state,
+		       src->dhcp_alt_client_id_state);
+	if (strlen(src->dhcp_alt_client_id))
+		strcpy(dst->dhcp_alt_client_id, src->dhcp_alt_client_id);
+	if (strlen(src->dhcp_req_vendor_id_state))
+		strcpy(dst->dhcp_req_vendor_id_state,
+		       src->dhcp_req_vendor_id_state);
+	if (strlen(src->dhcp_vendor_id_state))
+		strcpy(dst->dhcp_vendor_id_state, src->dhcp_vendor_id_state);
+	if (strlen(src->dhcp_vendor_id))
+		strcpy(dst->dhcp_vendor_id, src->dhcp_vendor_id);
+	if (strlen(src->dhcp_learn_iqn))
+		strcpy(dst->dhcp_learn_iqn, src->dhcp_learn_iqn);
+	if (strlen(src->fragmentation))
+		strcpy(dst->fragmentation, src->fragmentation);
+	if (strlen(src->incoming_forwarding))
+		strcpy(dst->incoming_forwarding, src->incoming_forwarding);
+	if (src->ttl)
+		dst->ttl = src->ttl;
+	if (strlen(src->gratuitous_neighbor_adv))
+		strcpy(dst->gratuitous_neighbor_adv,
+		       src->gratuitous_neighbor_adv);
+	if (strlen(src->redirect))
+		strcpy(dst->redirect, src->redirect);
+	if (strlen(src->mld))
+		strcpy(dst->mld, src->mld);
+	if (src->flow_label)
+		dst->flow_label = src->flow_label;
+	if (src->traffic_class)
+		dst->traffic_class = src->traffic_class;
+	if (src->hop_limit)
+		dst->hop_limit = src->hop_limit;
+	if (src->nd_reachable_tmo)
+		dst->nd_reachable_tmo = src->nd_reachable_tmo;
+	if (src->nd_rexmit_time)
+		dst->nd_rexmit_time = src->nd_rexmit_time;
+	if (src->nd_stale_tmo)
+		dst->nd_stale_tmo = src->nd_stale_tmo;
+	if (src->dup_addr_detect_cnt)
+		dst->dup_addr_detect_cnt = src->dup_addr_detect_cnt;
+	if (src->router_adv_link_mtu)
+		dst->router_adv_link_mtu = src->router_adv_link_mtu;
+	if (src->def_task_mgmt_tmo)
+		dst->def_task_mgmt_tmo = src->def_task_mgmt_tmo;
+	if (strlen(src->header_digest))
+		strcpy(dst->header_digest, src->header_digest);
+	if (strlen(src->data_digest))
+		strcpy(dst->data_digest, src->data_digest);
+	if (strlen(src->immediate_data))
+		strcpy(dst->immediate_data, src->immediate_data);
+	if (strlen(src->initial_r2t))
+		strcpy(dst->initial_r2t, src->initial_r2t);
+	if (strlen(src->data_seq_inorder))
+		strcpy(dst->data_seq_inorder, src->data_seq_inorder);
+	if (strlen(src->data_pdu_inorder))
+		strcpy(dst->data_pdu_inorder, src->data_pdu_inorder);
+	if (src->erl)
+		dst->erl = src->erl;
+	if (src->max_recv_dlength)
+		dst->max_recv_dlength = src->max_recv_dlength;
+	if (src->first_burst_len)
+		dst->first_burst_len = src->first_burst_len;
+	if (src->max_out_r2t)
+		dst->max_out_r2t = src->max_out_r2t;
+	if (src->max_burst_len)
+		dst->max_burst_len = src->max_burst_len;
+	if (strlen(src->chap_auth))
+		strcpy(dst->chap_auth, src->chap_auth);
+	if (strlen(src->bidi_chap))
+		strcpy(dst->bidi_chap, src->bidi_chap);
+	if (strlen(src->strict_login_comp))
+		strcpy(dst->strict_login_comp, src->strict_login_comp);
+	if (strlen(src->discovery_auth))
+		strcpy(dst->discovery_auth, src->discovery_auth);
+	if (strlen(src->discovery_logout))
+		strcpy(dst->discovery_logout, src->discovery_logout);
 	if (strlen(src->hwaddress))
 		strcpy(dst->hwaddress, src->hwaddress);
 	if (strlen(src->transport_name))
@@ -1026,6 +1125,79 @@ struct iface_param_count {
 	int count;
 };
 
+#define IFACE_NET_PARAM_EN_CNT(param_val, cnt) {	\
+	if (!strcmp(param_val, "disable") ||		\
+	    !strcmp(param_val, "enable"))		\
+		(*cnt)++;				\
+}
+
+/**
+ * iface_get_common_param_count - Gets common parameters count for given iface
+ * @iface: iface to setup
+ * @count: number of parameters to set
+ */
+static void iface_get_common_param_count(struct iface_rec *iface, int *count)
+{
+	if (strcmp(iface->vlan_state, "disable")) {
+		/* vlan_state enabled */
+		(*count)++;
+
+		if (iface->vlan_id)
+			/* For vlan value */
+			(*count)++;
+	} else {
+		/* vlan_state disabled */
+		(*count)++;
+	}
+
+	if (iface->mtu)
+		(*count)++;
+
+	if (iface->port)
+		(*count)++;
+
+	IFACE_NET_PARAM_EN_CNT(iface->delayed_ack, count);
+	IFACE_NET_PARAM_EN_CNT(iface->nagle, count);
+	IFACE_NET_PARAM_EN_CNT(iface->tcp_wsf_state, count);
+	IFACE_NET_PARAM_EN_CNT(iface->tcp_timestamp, count);
+	IFACE_NET_PARAM_EN_CNT(iface->redirect, count);
+	IFACE_NET_PARAM_EN_CNT(iface->header_digest, count);
+	IFACE_NET_PARAM_EN_CNT(iface->data_digest, count);
+	IFACE_NET_PARAM_EN_CNT(iface->immediate_data, count);
+	IFACE_NET_PARAM_EN_CNT(iface->initial_r2t, count);
+	IFACE_NET_PARAM_EN_CNT(iface->data_seq_inorder, count);
+	IFACE_NET_PARAM_EN_CNT(iface->data_pdu_inorder, count);
+	IFACE_NET_PARAM_EN_CNT(iface->chap_auth, count);
+	IFACE_NET_PARAM_EN_CNT(iface->bidi_chap, count);
+	IFACE_NET_PARAM_EN_CNT(iface->strict_login_comp, count);
+	IFACE_NET_PARAM_EN_CNT(iface->discovery_auth, count);
+	IFACE_NET_PARAM_EN_CNT(iface->discovery_logout, count);
+
+	if (iface->tcp_wsf)
+		(*count)++;
+
+	if (iface->tcp_timer_scale)
+		(*count)++;
+
+	if (iface->def_task_mgmt_tmo)
+		(*count)++;
+
+	if (iface->erl)
+		(*count)++;
+
+	if (iface->max_recv_dlength)
+		(*count)++;
+
+	if (iface->first_burst_len)
+		(*count)++;
+
+	if (iface->max_burst_len)
+		(*count)++;
+
+	if (iface->max_out_r2t)
+		(*count)++;
+}
+
 /**
  * __iface_get_param_count - Gets netconfig parameter count for given iface
  * @data: iface_param_count structure
@@ -1044,10 +1216,10 @@ static int __iface_get_param_count(void *data, struct iface_rec *iface)
 	if (iptype == ISCSI_IFACE_TYPE_IPV4) {
 
 		if (strcmp(iface->state, "disable")) {
-			if (strstr(iface->bootproto, "dhcp"))
+			if (strstr(iface->bootproto, "dhcp")) {
 				/* DHCP enabled */
 				count++;
-			else {
+			} else {
 				/* DHCP disabled */
 				count++;
 
@@ -1062,12 +1234,13 @@ static int __iface_get_param_count(void *data, struct iface_rec *iface)
 					if (strstr(iface->gateway, "."))
 						/* User configured Gateway */
 						count++;
-				} else
+				} else {
 					/*
 					 * IPv4 Address not valid, decrement
 					 * count of DHCP
 					 */
 					count--;
+				}
 			}
 
 			/*
@@ -1078,37 +1251,68 @@ static int __iface_get_param_count(void *data, struct iface_rec *iface)
 				/* iface state */
 				count++;
 
-				if (strcmp(iface->vlan_state, "disable")) {
-					/* vlan_state enabled */
+				IFACE_NET_PARAM_EN_CNT(iface->dhcp_dns,
+						       &count);
+
+				IFACE_NET_PARAM_EN_CNT(iface->dhcp_slp_da,
+						       &count);
+
+				IFACE_NET_PARAM_EN_CNT(iface->tos_state,
+						       &count);
+
+				IFACE_NET_PARAM_EN_CNT(iface->gratuitous_arp,
+						       &count);
+
+				IFACE_NET_PARAM_EN_CNT(
+						iface->dhcp_alt_client_id_state,
+						&count);
+
+				if (iface->dhcp_alt_client_id[0])
 					count++;
 
-					if (iface->vlan_id)
-						/* For vlan value */
-						count++;
-				} else
-					/* vlan_state disabled */
+				IFACE_NET_PARAM_EN_CNT(
+						iface->dhcp_req_vendor_id_state,
+						&count);
+
+				IFACE_NET_PARAM_EN_CNT(
+						iface->dhcp_vendor_id_state,
+						&count);
+
+				if (iface->dhcp_vendor_id[0])
 					count++;
 
-				if (iface->mtu)
+				IFACE_NET_PARAM_EN_CNT(iface->dhcp_learn_iqn,
+						       &count);
+
+				IFACE_NET_PARAM_EN_CNT(iface->fragmentation,
+						       &count);
+
+				IFACE_NET_PARAM_EN_CNT(
+						     iface->incoming_forwarding,
+						     &count);
+
+				if (iface->tos)
 					count++;
 
-				if (iface->port)
+				if (iface->ttl)
 					count++;
+
+				iface_get_common_param_count(iface, &count);
 			}
-		} else
+		} else {
 			/* IPv4 is disabled, iface state */
 			count++;
-
+		}
 	} else if (iptype == ISCSI_IFACE_TYPE_IPV6) {
 
 		if (strcmp(iface->state, "disable")) {
 
 			/* IPv6 Address */
 			if (strstr(iface->ipv6_autocfg, "nd") ||
-			    strstr(iface->ipv6_autocfg, "dhcpv6"))
+			    strstr(iface->ipv6_autocfg, "dhcpv6")) {
 				/* Autocfg enabled */
 				count++;
-			else {
+			} else {
 				/* Autocfg disabled */
 				count++;
 
@@ -1169,26 +1373,42 @@ static int __iface_get_param_count(void *data, struct iface_rec *iface)
 				/* iface state */
 				count++;
 
-				if (strcmp(iface->vlan_state, "disable")) {
-					/* vlan_state enabled */
+				IFACE_NET_PARAM_EN_CNT(
+						 iface->gratuitous_neighbor_adv,
+						 &count);
+
+				IFACE_NET_PARAM_EN_CNT(iface->mld, &count);
+
+				if (iface->flow_label)
+					count++;
+
+				if (iface->traffic_class)
+					count++;
+
+				if (iface->hop_limit)
 					count++;
 
-					if (iface->vlan_id)
-						/* For vlan value */
-						count++;
-				} else
-					/* vlan_state disabled */
+				if (iface->nd_reachable_tmo)
 					count++;
 
-				if (iface->mtu)
+				if (iface->nd_rexmit_time)
 					count++;
 
-				if (iface->port)
+				if (iface->nd_stale_tmo)
 					count++;
+
+				if (iface->dup_addr_detect_cnt)
+					count++;
+
+				if (iface->router_adv_link_mtu)
+					count++;
+
+				iface_get_common_param_count(iface, &count);
 			}
-		} else
+		} else {
 			/* IPv6 is disabled, iface state */
 			count++;
+		}
 	}
 
 	iface_params->count += count;
@@ -1578,6 +1798,44 @@ free:
 	}								\
 }
 
+/* write string parameter value */
+static int iface_fill_str_param_val(struct iovec *iov, uint32_t iface_num,
+				    uint8_t iface_type, uint16_t param,
+				    uint32_t param_len, char *param_val)
+{
+	int len;
+	struct iscsi_iface_param_info *net_param;
+	struct nlattr *attr;
+
+	if (!param_val[0])
+		return 1;
+
+	len = sizeof(struct iscsi_iface_param_info) + param_len;
+	iov->iov_base = iscsi_nla_alloc(param, len);
+	if (!(iov->iov_base))
+		return 1;
+
+	attr = iov->iov_base;
+	iov->iov_len = NLA_ALIGN(attr->nla_len);
+	net_param = (struct iscsi_iface_param_info *)ISCSI_NLA_DATA(attr);
+	net_param->iface_num = iface_num;
+	net_param->len = param_len;
+	net_param->param = param;
+	net_param->iface_type = iface_type;
+	net_param->param_type = ISCSI_NET_PARAM;
+	memcpy(net_param->value, param_val, param_len);
+	return 0;
+}
+
+#define IFACE_SET_NET_PARAM_STRVAL(iov, inum, itype, param, plen,	\
+				   ival, gcnt, lcnt) {			\
+	if (!iface_fill_str_param_val(iov, inum, itype, param, plen,	\
+				      ival)) {				\
+		(*gcnt)++;						\
+		(*lcnt)++;						\
+	}								\
+}
+
 struct iface_net_config {
 	struct iface_rec *primary;
 	struct iovec *iovs;
@@ -1597,8 +1855,12 @@ static int __iface_build_net_config(void *data, struct iface_rec *iface)
 	/* start at 2, because 0 is for nlmsghdr and 1 for event */
 	iov = net_config->iovs + 2;
 
+	if (!iface->port)
+		iface->port = 3260;
+
 	iptype = iface_get_iptype(iface);
-	if (iptype == ISCSI_IFACE_TYPE_IPV4) {
+	switch (iptype) {
+	case ISCSI_IFACE_TYPE_IPV4:
 		if (!strcmp(iface->state, "disable")) {
 			IFACE_SET_PARAM_STATE(&iov[net_config->count],
 					      iface->iface_num,
@@ -1652,53 +1914,136 @@ static int __iface_build_net_config(void *data, struct iface_rec *iface)
 		 */
 		if (count) {
 			IFACE_SET_PARAM_STATE(&iov[net_config->count],
+					  iface->iface_num,
+					  ISCSI_IFACE_TYPE_IPV4,
+					  ISCSI_NET_PARAM_IPV4_DHCP_DNS_ADDR_EN,
+					  ISCSI_NET_PARAM,
+					  iface->dhcp_dns,
+					  &net_config->count,
+					  &count);
+
+			IFACE_SET_PARAM_STATE(&iov[net_config->count],
+					    iface->iface_num,
+					    ISCSI_IFACE_TYPE_IPV4,
+					    ISCSI_NET_PARAM_IPV4_DHCP_SLP_DA_EN,
+					    ISCSI_NET_PARAM,
+					    iface->dhcp_slp_da,
+					    &net_config->count,
+					    &count);
+
+			IFACE_SET_PARAM_STATE(&iov[net_config->count],
+					      iface->iface_num,
+					      ISCSI_IFACE_TYPE_IPV4,
+					      ISCSI_NET_PARAM_IPV4_TOS_EN,
+					      ISCSI_NET_PARAM,
+					      iface->tos_state,
+					      &net_config->count,
+					      &count);
+
+			IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
 					      iface->iface_num,
 					      ISCSI_IFACE_TYPE_IPV4,
-					      ISCSI_NET_PARAM_IFACE_ENABLE,
+					      ISCSI_NET_PARAM_IPV4_TOS,
 					      ISCSI_NET_PARAM,
-					      iface->state,
+					      1,
+					      iface->tos,
 					      &net_config->count,
 					      &count);
 
 			IFACE_SET_PARAM_STATE(&iov[net_config->count],
 					      iface->iface_num,
 					      ISCSI_IFACE_TYPE_IPV4,
-					      ISCSI_NET_PARAM_VLAN_ENABLED,
+					      ISCSI_NET_PARAM_IPV4_GRAT_ARP_EN,
 					      ISCSI_NET_PARAM,
-					      iface->vlan_state,
+					      iface->gratuitous_arp,
 					      &net_config->count,
 					      &count);
 
-			if (strcmp(iface->vlan_state, "disable") &&
-			    iface->vlan_id) {
-				if (!iface_fill_vlan_id(&iov[net_config->count],
-						iface, ISCSI_IFACE_TYPE_IPV4)) {
-					net_config->count++;
-					count++;
-				}
-			}
+			IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				     iface->iface_num,
+				     ISCSI_IFACE_TYPE_IPV4,
+				     ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID_EN,
+				     ISCSI_NET_PARAM,
+				     iface->dhcp_alt_client_id_state,
+				     &net_config->count,
+				     &count);
 
-			IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
-					       iface->iface_num,
-					       ISCSI_IFACE_TYPE_IPV4,
-					       ISCSI_NET_PARAM_MTU,
-					       ISCSI_NET_PARAM,
-					       2,
-					       iface->mtu,
-					       &net_config->count,
-					       &count);
+			IFACE_SET_NET_PARAM_STRVAL(&iov[net_config->count],
+					iface->iface_num,
+					ISCSI_IFACE_TYPE_IPV4,
+					ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID,
+					 strlen(iface->dhcp_alt_client_id),
+					iface->dhcp_alt_client_id,
+					&net_config->count,
+					&count);
+
+			IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				     iface->iface_num,
+				     ISCSI_IFACE_TYPE_IPV4,
+				     ISCSI_NET_PARAM_IPV4_DHCP_REQ_VENDOR_ID_EN,
+				     ISCSI_NET_PARAM,
+				     iface->dhcp_req_vendor_id_state,
+				     &net_config->count,
+				     &count);
+
+			IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				     iface->iface_num,
+				     ISCSI_IFACE_TYPE_IPV4,
+				     ISCSI_NET_PARAM_IPV4_DHCP_USE_VENDOR_ID_EN,
+				     ISCSI_NET_PARAM,
+				     iface->dhcp_vendor_id_state,
+				     &net_config->count,
+				     &count);
+
+			IFACE_SET_NET_PARAM_STRVAL(&iov[net_config->count],
+					iface->iface_num,
+					ISCSI_IFACE_TYPE_IPV4,
+					ISCSI_NET_PARAM_IPV4_DHCP_VENDOR_ID,
+					strlen(iface->dhcp_vendor_id),
+					iface->dhcp_vendor_id,
+					&net_config->count,
+					&count);
+
+			IFACE_SET_PARAM_STATE(&iov[net_config->count],
+					 iface->iface_num,
+					 ISCSI_IFACE_TYPE_IPV4,
+					 ISCSI_NET_PARAM_IPV4_DHCP_LEARN_IQN_EN,
+					 ISCSI_NET_PARAM,
+					 iface->dhcp_learn_iqn,
+					 &net_config->count,
+					 &count);
+
+			IFACE_SET_PARAM_STATE(&iov[net_config->count],
+					  iface->iface_num,
+					  ISCSI_IFACE_TYPE_IPV4,
+					  ISCSI_NET_PARAM_IPV4_FRAGMENT_DISABLE,
+					  ISCSI_NET_PARAM,
+					  iface->fragmentation,
+					  &net_config->count,
+					  &count);
+
+			IFACE_SET_PARAM_STATE(&iov[net_config->count],
+					     iface->iface_num,
+					     ISCSI_IFACE_TYPE_IPV4,
+					     ISCSI_NET_PARAM_IPV4_IN_FORWARD_EN,
+					     ISCSI_NET_PARAM,
+					     iface->incoming_forwarding,
+					     &net_config->count,
+					     &count);
 
 			IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
 					       iface->iface_num,
 					       ISCSI_IFACE_TYPE_IPV4,
-					       ISCSI_NET_PARAM_PORT,
+					       ISCSI_NET_PARAM_IPV4_TTL,
 					       ISCSI_NET_PARAM,
-					       2,
-					       iface->port,
+					       1,
+					       iface->ttl,
 					       &net_config->count,
 					       &count);
 		}
-	} else if (iptype == ISCSI_IFACE_TYPE_IPV6) {
+		break;
+
+	case ISCSI_IFACE_TYPE_IPV6:
 		if (!strcmp(iface->state, "disable")) {
 			IFACE_SET_PARAM_STATE(&iov[net_config->count],
 					      iface->iface_num,
@@ -1786,53 +2131,377 @@ static int __iface_build_net_config(void *data, struct iface_rec *iface)
 		 */
 		if (count) {
 			IFACE_SET_PARAM_STATE(&iov[net_config->count],
-					      iface->iface_num,
-					      ISCSI_IFACE_TYPE_IPV6,
-					      ISCSI_NET_PARAM_IFACE_ENABLE,
-					      ISCSI_NET_PARAM,
-					      iface->state,
-					      &net_config->count,
-					      &count);
+				      iface->iface_num,
+				      ISCSI_IFACE_TYPE_IPV6,
+				      ISCSI_NET_PARAM_IPV6_GRAT_NEIGHBOR_ADV_EN,
+				      ISCSI_NET_PARAM,
+				      iface->gratuitous_neighbor_adv,
+				      &net_config->count,
+				      &count);
 
 			IFACE_SET_PARAM_STATE(&iov[net_config->count],
 					      iface->iface_num,
 					      ISCSI_IFACE_TYPE_IPV6,
-					      ISCSI_NET_PARAM_VLAN_ENABLED,
+					      ISCSI_NET_PARAM_IPV6_MLD_EN,
 					      ISCSI_NET_PARAM,
-					      iface->vlan_state,
+					      iface->mld,
 					      &net_config->count,
 					      &count);
 
-			if (strcmp(iface->vlan_state, "disable") &&
-			    iface->vlan_id) {
-				if (!iface_fill_vlan_id(&iov[net_config->count],
-						iface,
-						ISCSI_IFACE_TYPE_IPV6)) {
-					net_config->count++;
-					count++;
-				}
+			IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+					       iface->iface_num,
+					       ISCSI_IFACE_TYPE_IPV6,
+					       ISCSI_NET_PARAM_IPV6_FLOW_LABEL,
+					       ISCSI_NET_PARAM,
+					       4,
+					       iface->flow_label,
+					       &net_config->count,
+					       &count);
+
+			IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+					     iface->iface_num,
+					     ISCSI_IFACE_TYPE_IPV6,
+					     ISCSI_NET_PARAM_IPV6_TRAFFIC_CLASS,
+					     ISCSI_NET_PARAM,
+					     1,
+					     iface->traffic_class,
+					     &net_config->count,
+					     &count);
+
+			IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+					       iface->iface_num,
+					       ISCSI_IFACE_TYPE_IPV6,
+					       ISCSI_NET_PARAM_IPV6_HOP_LIMIT,
+					       ISCSI_NET_PARAM,
+					       1,
+					       iface->hop_limit,
+					       &net_config->count,
+					       &count);
+
+			IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+					  iface->iface_num,
+					  ISCSI_IFACE_TYPE_IPV6,
+					  ISCSI_NET_PARAM_IPV6_ND_REACHABLE_TMO,
+					  ISCSI_NET_PARAM,
+					  4,
+					  iface->nd_reachable_tmo,
+					  &net_config->count,
+					  &count);
+
+			IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+					    iface->iface_num,
+					    ISCSI_IFACE_TYPE_IPV6,
+					    ISCSI_NET_PARAM_IPV6_ND_REXMIT_TIME,
+					    ISCSI_NET_PARAM,
+					    4,
+					    iface->nd_rexmit_time,
+					    &net_config->count,
+					    &count);
+
+			IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+					      iface->iface_num,
+					      ISCSI_IFACE_TYPE_IPV6,
+					      ISCSI_NET_PARAM_IPV6_ND_STALE_TMO,
+					      ISCSI_NET_PARAM,
+					      4,
+					      iface->nd_stale_tmo,
+					      &net_config->count,
+					      &count);
+
+			IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+				       iface->iface_num,
+				       ISCSI_IFACE_TYPE_IPV6,
+				       ISCSI_NET_PARAM_IPV6_DUP_ADDR_DETECT_CNT,
+				       ISCSI_NET_PARAM,
+				       1,
+				       iface->dup_addr_detect_cnt,
+				       &net_config->count,
+				       &count);
+
+			IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+					  iface->iface_num,
+					  ISCSI_IFACE_TYPE_IPV6,
+					  ISCSI_NET_PARAM_IPV6_RTR_ADV_LINK_MTU,
+					  ISCSI_NET_PARAM,
+					  4,
+					  iface->router_adv_link_mtu,
+					  &net_config->count,
+					  &count);
+		}
+		break;
+	}
+
+	/* Fill parameters common to IPv4 and IPv6 ifaces */
+	if (count) {
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_NET_PARAM_IFACE_ENABLE,
+				      ISCSI_NET_PARAM,
+				      iface->state,
+				      &net_config->count,
+				      &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_NET_PARAM_VLAN_ENABLED,
+				      ISCSI_NET_PARAM,
+				      iface->vlan_state,
+				      &net_config->count,
+				      &count);
+
+		if (strcmp(iface->vlan_state, "disable") && iface->vlan_id) {
+			if (!iface_fill_vlan_id(&iov[net_config->count], iface,
+						iptype)) {
+				net_config->count++;
+				count++;
 			}
-
-			IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
-					       iface->iface_num,
-					       ISCSI_IFACE_TYPE_IPV6,
-					       ISCSI_NET_PARAM_MTU,
-					       ISCSI_NET_PARAM,
-					       2,
-					       iface->mtu,
-					       &net_config->count,
-					       &count);
-
-			IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
-					       iface->iface_num,
-					       ISCSI_IFACE_TYPE_IPV6,
-					       ISCSI_NET_PARAM_PORT,
-					       ISCSI_NET_PARAM,
-					       2,
-					       iface->port,
-					       &net_config->count,
-					       &count);
 		}
+
+		IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+				       iface->iface_num,
+				       iptype,
+				       ISCSI_NET_PARAM_MTU,
+				       ISCSI_NET_PARAM,
+				       2,
+				       iface->mtu,
+				       &net_config->count,
+				       &count);
+
+		IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+				       iface->iface_num,
+				       iptype,
+				       ISCSI_NET_PARAM_PORT,
+				       ISCSI_NET_PARAM,
+				       2,
+				       iface->port,
+				       &net_config->count,
+				       &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_NET_PARAM_DELAYED_ACK_EN,
+				      ISCSI_NET_PARAM,
+				      iface->delayed_ack,
+				      &net_config->count,
+				      &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_NET_PARAM_TCP_NAGLE_DISABLE,
+				      ISCSI_NET_PARAM,
+				      iface->nagle,
+				      &net_config->count,
+				      &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_NET_PARAM_TCP_WSF_DISABLE,
+				      ISCSI_NET_PARAM,
+				      iface->tcp_wsf_state,
+				      &net_config->count,
+				      &count);
+
+		IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+				       iface->iface_num,
+				       iptype,
+				       ISCSI_NET_PARAM_TCP_WSF,
+				       ISCSI_NET_PARAM,
+				       1,
+				       iface->tcp_wsf,
+				       &net_config->count,
+				       &count);
+
+		IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+				       iface->iface_num,
+				       iptype,
+				       ISCSI_NET_PARAM_TCP_TIMER_SCALE,
+				       ISCSI_NET_PARAM,
+				       1,
+				       iface->tcp_timer_scale,
+				       &net_config->count,
+				       &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_NET_PARAM_TCP_TIMESTAMP_EN,
+				      ISCSI_NET_PARAM,
+				      iface->tcp_timestamp,
+				      &net_config->count,
+				      &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_NET_PARAM_REDIRECT_EN,
+				      ISCSI_NET_PARAM,
+				      iface->redirect,
+				      &net_config->count,
+				      &count);
+
+		IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+				     iface->iface_num,
+				     iptype,
+				     ISCSI_IFACE_PARAM_DEF_TASKMGMT_TMO,
+				     ISCSI_IFACE_PARAM,
+				     2,
+				     iface->def_task_mgmt_tmo,
+				     &net_config->count,
+				     &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_IFACE_PARAM_HDRDGST_EN,
+				      ISCSI_IFACE_PARAM,
+				      iface->header_digest,
+				      &net_config->count,
+				      &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_IFACE_PARAM_DATADGST_EN,
+				      ISCSI_IFACE_PARAM,
+				      iface->data_digest,
+				      &net_config->count,
+				      &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_IFACE_PARAM_IMM_DATA_EN,
+				      ISCSI_IFACE_PARAM,
+				      iface->immediate_data,
+				      &net_config->count,
+				      &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_IFACE_PARAM_INITIAL_R2T_EN,
+				      ISCSI_IFACE_PARAM,
+				      iface->initial_r2t,
+				      &net_config->count,
+				      &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_IFACE_PARAM_DATASEQ_INORDER_EN,
+				      ISCSI_IFACE_PARAM,
+				      iface->data_seq_inorder,
+				      &net_config->count,
+				      &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_IFACE_PARAM_PDU_INORDER_EN,
+				      ISCSI_IFACE_PARAM,
+				      iface->data_pdu_inorder,
+				      &net_config->count,
+				      &count);
+
+		IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+				       iface->iface_num,
+				       iptype,
+				       ISCSI_IFACE_PARAM_ERL,
+				       ISCSI_IFACE_PARAM,
+				       1,
+				       iface->erl,
+				       &net_config->count,
+				       &count);
+
+		IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+				       iface->iface_num,
+				       iptype,
+				       ISCSI_IFACE_PARAM_MAX_RECV_DLENGTH,
+				       ISCSI_IFACE_PARAM,
+				       4,
+				       iface->max_recv_dlength,
+				       &net_config->count,
+				       &count);
+
+		IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+				       iface->iface_num,
+				       iptype,
+				       ISCSI_IFACE_PARAM_FIRST_BURST,
+				       ISCSI_IFACE_PARAM,
+				       4,
+				       iface->first_burst_len,
+				       &net_config->count,
+				       &count);
+
+		IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+				       iface->iface_num,
+				       iptype,
+				       ISCSI_IFACE_PARAM_MAX_R2T,
+				       ISCSI_IFACE_PARAM,
+				       2,
+				       iface->max_out_r2t,
+				       &net_config->count,
+				       &count);
+
+		IFACE_SET_PARAM_INTVAL(&iov[net_config->count],
+				       iface->iface_num,
+				       iptype,
+				       ISCSI_IFACE_PARAM_MAX_BURST,
+				       ISCSI_IFACE_PARAM,
+				       4,
+				       iface->max_burst_len,
+				       &net_config->count,
+				       &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_IFACE_PARAM_CHAP_AUTH_EN,
+				      ISCSI_IFACE_PARAM,
+				      iface->chap_auth,
+				      &net_config->count,
+				      &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_IFACE_PARAM_BIDI_CHAP_EN,
+				      ISCSI_IFACE_PARAM,
+				      iface->bidi_chap,
+				      &net_config->count,
+				      &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_IFACE_PARAM_STRICT_LOGIN_COMP_EN,
+				      ISCSI_IFACE_PARAM,
+				      iface->strict_login_comp,
+				      &net_config->count,
+				      &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_IFACE_PARAM_DISCOVERY_AUTH_OPTIONAL,
+				      ISCSI_IFACE_PARAM,
+				      iface->discovery_auth,
+				      &net_config->count,
+				      &count);
+
+		IFACE_SET_PARAM_STATE(&iov[net_config->count],
+				      iface->iface_num,
+				      iptype,
+				      ISCSI_IFACE_PARAM_DISCOVERY_LOGOUT_EN,
+				      ISCSI_IFACE_PARAM,
+				      iface->discovery_logout,
+				      &net_config->count,
+				      &count);
 	}
 	return 0;
 }
diff --git a/usr/iscsi_sysfs.c b/usr/iscsi_sysfs.c
index 04c3673..c916ed8 100644
--- a/usr/iscsi_sysfs.c
+++ b/usr/iscsi_sysfs.c
@@ -856,6 +856,71 @@ static int iscsi_sysfs_read_iface(struct iface_rec *iface, int host_no,
 
 		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "subnet",
 			      iface->subnet_mask, sizeof(iface->subnet_mask));
+
+		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			      "dhcp_alt_client_id_en",
+			      iface->dhcp_alt_client_id_state,
+			      sizeof(iface->dhcp_alt_client_id_state));
+
+		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			      "dhcp_alt_client_id",
+			      iface->dhcp_alt_client_id,
+			      sizeof(iface->dhcp_alt_client_id));
+
+		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			      "dhcp_dns_address_en",
+			      iface->dhcp_dns, sizeof(iface->dhcp_dns));
+
+		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			      "dhcp_learn_iqn_en",
+			      iface->dhcp_learn_iqn,
+			      sizeof(iface->dhcp_learn_iqn));
+
+		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			      "dhcp_req_vendor_id_en",
+			      iface->dhcp_req_vendor_id_state,
+			      sizeof(iface->dhcp_req_vendor_id_state));
+
+		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			      "dhcp_use_vendor_id_en",
+			      iface->dhcp_vendor_id_state,
+			      sizeof(iface->dhcp_vendor_id_state));
+
+		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			      "dhcp_vendor_id",
+			      iface->dhcp_vendor_id,
+			      sizeof(iface->dhcp_vendor_id));
+
+		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			      "dhcp_slp_da_info_en",
+			      iface->dhcp_slp_da, sizeof(iface->dhcp_slp_da));
+
+		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			      "fragment_disable",
+			      iface->fragmentation,
+			      sizeof(iface->fragmentation));
+
+		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			      "grat_arp_en",
+			      iface->gratuitous_arp,
+			      sizeof(iface->gratuitous_arp));
+
+		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			      "incoming_forwarding_en",
+			      iface->incoming_forwarding,
+			      sizeof(iface->incoming_forwarding));
+
+		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			      "tos_en",
+			      iface->tos_state, sizeof(iface->tos_state));
+
+		if (sysfs_get_uint8(iface_kern_id, ISCSI_IFACE_SUBSYS,
+				    "tos", &iface->tos))
+			iface->tos = 0;
+
+		if (sysfs_get_uint8(iface_kern_id, ISCSI_IFACE_SUBSYS,
+				    "ttl", &iface->ttl))
+			iface->ttl = 0;
 	} else {
 		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS,
 			      "ipaddr_autocfg",
@@ -872,6 +937,53 @@ static int iscsi_sysfs_read_iface(struct iface_rec *iface, int host_no,
 		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "router_addr",
 			      iface->ipv6_router,
 			      sizeof(iface->ipv6_router));
+
+		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "router_state",
+			      iface->router_autocfg,
+			      sizeof(iface->router_autocfg));
+
+		if (sysfs_get_uint8(iface_kern_id, ISCSI_IFACE_SUBSYS,
+				    "dup_addr_detect_cnt",
+				    &iface->dup_addr_detect_cnt))
+			iface->dup_addr_detect_cnt = 0;
+
+		if (sysfs_get_uint(iface_kern_id, ISCSI_IFACE_SUBSYS,
+				   "flow_label", &iface->flow_label))
+			iface->flow_label = 0;
+
+		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			      "grat_neighbor_adv_en",
+			      iface->gratuitous_neighbor_adv,
+			      sizeof(iface->gratuitous_neighbor_adv));
+
+		if (sysfs_get_uint8(iface_kern_id, ISCSI_IFACE_SUBSYS,
+				    "hop_limit", &iface->hop_limit))
+			iface->hop_limit = 0;
+
+		sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "mld_en",
+			      iface->mld, sizeof(iface->mld));
+
+		if (sysfs_get_uint(iface_kern_id, ISCSI_IFACE_SUBSYS,
+				   "nd_reachable_tmo",
+				   &iface->nd_reachable_tmo))
+			iface->nd_reachable_tmo = 0;
+
+		if (sysfs_get_uint(iface_kern_id, ISCSI_IFACE_SUBSYS,
+				   "nd_rexmit_time", &iface->nd_rexmit_time))
+			iface->nd_rexmit_time = 0;
+
+		if (sysfs_get_uint(iface_kern_id, ISCSI_IFACE_SUBSYS,
+				   "nd_stale_tmo", &iface->nd_stale_tmo))
+			iface->nd_stale_tmo = 0;
+
+		if (sysfs_get_uint(iface_kern_id, ISCSI_IFACE_SUBSYS,
+				   "router_adv_link_mtu",
+				   &iface->router_adv_link_mtu))
+			iface->router_adv_link_mtu = 0;
+
+		if (sysfs_get_uint(iface_kern_id, ISCSI_IFACE_SUBSYS,
+				   "traffic_class", &iface->traffic_class))
+			iface->traffic_class = 0;
 	}
 
 	if (sysfs_get_uint16(iface_kern_id, ISCSI_IFACE_SUBSYS, "port",
@@ -888,6 +1000,94 @@ static int iscsi_sysfs_read_iface(struct iface_rec *iface, int host_no,
 			    &iface->vlan_priority))
 		iface->vlan_priority = UINT8_MAX;
 
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "vlan_enabled",
+		      iface->vlan_state, sizeof(iface->vlan_state));
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "enabled",
+		      iface->state, sizeof(iface->state));
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "delayed_ack_en",
+		      iface->delayed_ack, sizeof(iface->delayed_ack));
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "tcp_nagle_disable",
+		      iface->nagle, sizeof(iface->nagle));
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "tcp_wsf_disable",
+		      iface->tcp_wsf_state, sizeof(iface->tcp_wsf_state));
+
+	if (sysfs_get_uint8(iface_kern_id, ISCSI_IFACE_SUBSYS, "tcp_wsf",
+			    &iface->tcp_wsf))
+		iface->tcp_wsf = 0;
+
+	if (sysfs_get_uint8(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			    "tcp_timer_scale", &iface->tcp_timer_scale))
+		iface->tcp_timer_scale = 0;
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "tcp_timestamp_en",
+		      iface->tcp_timestamp, sizeof(iface->tcp_timestamp));
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "redirect_en",
+		      iface->redirect, sizeof(iface->redirect));
+
+	if (sysfs_get_uint16(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			     "def_taskmgmt_tmo", &iface->def_task_mgmt_tmo))
+		iface->def_task_mgmt_tmo = 0;
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "header_digest",
+		      iface->header_digest, sizeof(iface->header_digest));
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "data_digest",
+		      iface->data_digest, sizeof(iface->data_digest));
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "immediate_data",
+		      iface->immediate_data, sizeof(iface->immediate_data));
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "initial_r2t",
+		      iface->initial_r2t, sizeof(iface->initial_r2t));
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "data_seq_in_order",
+		      iface->data_seq_inorder, sizeof(iface->data_seq_inorder));
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "data_pdu_in_order",
+		      iface->data_pdu_inorder, sizeof(iface->data_pdu_inorder));
+
+	if (sysfs_get_uint8(iface_kern_id, ISCSI_IFACE_SUBSYS, "erl",
+			    &iface->erl))
+		iface->erl = 0;
+
+	if (sysfs_get_uint(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			   "max_recv_dlength", &iface->max_recv_dlength))
+		iface->max_recv_dlength = 0;
+
+	if (sysfs_get_uint(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			   "first_burst_len", &iface->first_burst_len))
+		iface->first_burst_len = 0;
+
+	if (sysfs_get_uint16(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			     "max_outstanding_r2t", &iface->max_out_r2t))
+		iface->max_out_r2t = 0;
+
+	if (sysfs_get_uint(iface_kern_id, ISCSI_IFACE_SUBSYS,
+			   "max_burst_len", &iface->max_burst_len))
+		iface->max_burst_len = 0;
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "chap_auth",
+		      iface->chap_auth, sizeof(iface->chap_auth));
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "bidi_chap",
+		      iface->bidi_chap, sizeof(iface->bidi_chap));
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "strict_login_comp_en",
+		      iface->strict_login_comp,
+		      sizeof(iface->strict_login_comp));
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS,
+		      "discovery_auth_optional",
+		      iface->discovery_auth, sizeof(iface->discovery_auth));
+
+	sysfs_get_str(iface_kern_id, ISCSI_IFACE_SUBSYS, "discovery_logout",
+		      iface->discovery_logout, sizeof(iface->discovery_logout));
+
 	if (sscanf(iface_kern_id, "ipv%d-iface-%u-%u", &iface_type,
 		   &tmp_host_no, &iface_num) == 3)
 		iface->iface_num = iface_num;
-- 
1.8.3.1

