diff -up isdn4k-utils-CVS-2010-05-01-patched/eurofile/src/wuauth/Makefile.legal isdn4k-utils-CVS-2010-05-01-patched/eurofile/src/wuauth/Makefile
--- isdn4k-utils-CVS-2010-05-01-patched/eurofile/src/wuauth/Makefile.legal	2013-01-04 14:52:27.580092162 -0500
+++ isdn4k-utils-CVS-2010-05-01-patched/eurofile/src/wuauth/Makefile	2013-01-04 14:52:56.890097375 -0500
@@ -12,10 +12,10 @@ LFLAGS =
 MYCFLAGS = -O6 -fomit-frame-pointer -fno-strength-reduce -pipe ${IFLAGS} ${LFLAGS}
 CFLAGS = -g
 
-SRCS   = strcasestr.c access.c divfunc.c private.c acl.c main.c sigfix.c  \
+SRCS   = strcasestr.c access.c divfunc.c private.c acl.c main.c \
 #	extensions.c
 
-OBJS   = strcasestr.o access.o divfunc.o private.o acl.o main.o sigfix.o \
+OBJS   = strcasestr.o access.o divfunc.o private.o acl.o main.o \
 #	extensions.o
  
 libwuauth.a: $(OBJS)
diff -up isdn4k-utils-CVS-2010-05-01-patched/pcbit/convhexbin.c.legal isdn4k-utils-CVS-2010-05-01-patched/pcbit/convhexbin.c
--- isdn4k-utils-CVS-2010-05-01-patched/pcbit/convhexbin.c.legal	2013-01-04 14:57:31.916181837 -0500
+++ isdn4k-utils-CVS-2010-05-01-patched/pcbit/convhexbin.c	2013-01-04 14:57:27.245180568 -0500
@@ -0,0 +1,187 @@
+/*
+ * Parser/loader for IHEX formatted data.
+ * Derived from Linux's ihex2fw.c.
+ *
+ * Copyright Â© 2008 David Woodhouse <dwmw2@infradead.org>
+ * Copyright Â© 2005 Jan Harkes <jaharkes@cs.cmu.edu>
+ * Copyright 2010 Ben Hutchings
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <stdint.h>
+#include <stdio.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdlib.h>
+
+
+struct ihex_binrec {
+	struct ihex_binrec *next; /* not part of the real data structure */
+        uint32_t addr;
+        uint16_t len;
+        uint8_t data[];
+};
+
+/**
+ * nybble/hex are little helpers to parse hexadecimal numbers to a byte value
+ **/
+static uint8_t nybble(const uint8_t n)
+{
+       if      (n >= '0' && n <= '9') return n - '0';
+       else if (n >= 'A' && n <= 'F') return n - ('A' - 10);
+       else if (n >= 'a' && n <= 'f') return n - ('a' - 10);
+       return 0;
+}
+
+static uint8_t hex(const uint8_t *data, uint8_t *crc)
+{
+       uint8_t val = (nybble(data[0]) << 4) | nybble(data[1]);
+       *crc += val;
+       return val;
+}
+
+static int process_ihex(uint8_t *buf, size_t buf_start, size_t buf_end,
+			const uint8_t *data, ssize_t size);
+
+int convhexbin(char *filename, unsigned char *buf, int size)
+{
+	struct stat st;
+	uint8_t *data;
+	int infd;
+
+	infd = open(filename, O_RDONLY);
+	if (infd == -1) {
+		fprintf(stderr, "Failed to open source file: %s",
+			strerror(errno));
+		return -1;
+	}
+	if (fstat(infd, &st)) {
+		perror("stat");
+		return -1;
+	}
+	data = mmap(NULL, st.st_size, PROT_READ, MAP_SHARED, infd, 0);
+	if (data == MAP_FAILED) {
+		perror("mmap");
+		return -1;
+	}
+
+	return process_ihex(buf, 0x100000 - size, 0x100000, data, st.st_size);
+}
+
+static int process_ihex(uint8_t *buf, size_t buf_start, size_t buf_end,
+			const uint8_t *data, ssize_t size)
+{
+	struct ihex_binrec *record = NULL;
+	uint32_t offset = 0;
+	uint8_t type, crc = 0, crcbyte = 0;
+	int i, j;
+	int line = 1;
+	int len;
+
+	i = 0;
+next_record:
+	/* search for the start of record character */
+	while (i < size) {
+		if (data[i] == '\n') line++;
+		if (data[i++] == ':') break;
+	}
+
+	/* Minimum record length would be about 10 characters */
+	if (i + 10 > size) {
+		fprintf(stderr, "Can't find valid record at line %d\n", line);
+		return -EINVAL;
+	}
+
+	len = hex(data + i, &crc); i += 2;
+	free(record);
+	record = malloc((sizeof (*record) + len + 3) & ~3);
+	if (!record) {
+		fprintf(stderr, "out of memory for records\n");
+		return -ENOMEM;
+	}
+	memset(record, 0, (sizeof(*record) + len + 3) & ~3);
+	record->len = len;
+
+	/* now check if we have enough data to read everything */
+	if (i + 8 + (record->len * 2) > size) {
+		fprintf(stderr, "Not enough data to read complete record at line %d\n",
+			line);
+		return -EINVAL;
+	}
+
+	record->addr  = hex(data + i, &crc) << 8; i += 2;
+	record->addr |= hex(data + i, &crc); i += 2;
+	type = hex(data + i, &crc); i += 2;
+
+	for (j = 0; j < record->len; j++, i += 2)
+		record->data[j] = hex(data + i, &crc);
+
+	/* check CRC */
+	crcbyte = hex(data + i, &crc); i += 2;
+	if (crc != 0) {
+		fprintf(stderr, "CRC failure at line %d: got 0x%X, expected 0x%X\n",
+			line, crcbyte, (unsigned char)(crcbyte-crc));
+		return -EINVAL;
+	}
+
+	/* Done reading the record */
+	switch (type) {
+	case 0:
+		/* old style EOF record? */
+		if (!record->len)
+			break;
+
+		record->addr += offset;
+		if (record->addr < buf_start ||
+		    record->addr + record->len > buf_end) {
+			fprintf(stderr, "HEX record address/size out of range "
+				"at line %d\n",
+				line);
+			return -EINVAL;
+		}
+		memcpy(buf + (record->addr - buf_start),
+		       record->data, record->len);
+		goto next_record;
+
+	case 1: /* End-Of-File Record */
+		if (record->len) {
+			fprintf(stderr, "Bad EOF record (type 01) format at line %d\n",
+				line);
+			return -EINVAL;
+		}
+		break;
+
+	case 2: /* Extended Segment Address Record (HEX86) */
+		if (record->addr || record->len != 2) {
+			fprintf(stderr, "Bad HEX86/HEX386 record (type %02X) at line %d\n",
+				type, line);
+			return -EINVAL;
+		}
+
+		/* We shouldn't really be using the offset for HEX86 because
+		 * the wraparound case is specified quite differently. */
+		offset = record->data[0] << 8 | record->data[1];
+		offset <<= (type == 2 ? 4 : 16);
+		goto next_record;
+
+	case 3: /* Start Segment Address Record */
+		/* These records contain the CS/IP or EIP where execution
+		 * starts. Don't really know what to do with them. */
+		goto next_record;
+
+	default:
+		fprintf(stderr, "Unknown record (type %02X)\n", type);
+		return -EINVAL;
+	}
+
+	free(record);
+	return 0;
+}
