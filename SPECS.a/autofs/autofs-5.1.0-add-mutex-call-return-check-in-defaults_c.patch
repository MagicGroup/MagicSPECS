autofs-5.1.0 - add mutex call return check in defaults.c

From: Ian Kent <ikent@redhat.com>

Even though pthread_mutex_lock() and pthread_mutex_unlock() should
never fail checking their return has very occassionally been useful
and isn't consistent with the usage elsewhere.
---
 CHANGELOG      |    1 +
 lib/defaults.c |   55 ++++++++++++++++++++++++++++++++++---------------------
 2 files changed, 35 insertions(+), 21 deletions(-)

diff --git a/CHANGELOG b/CHANGELOG
index 9cbccce..31a804d 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -20,6 +20,7 @@
 - fix some out of order evaluations in parse_amd.c.
 - fix copy and paste error in dup_defaults_entry().
 - fix leak in parse_mount().
+- add mutex call return check in defaults.c.
 
 04/06/2014 autofs-5.1.0
 =======================
diff --git a/lib/defaults.c b/lib/defaults.c
index 4e09c19..83f6ac7 100644
--- a/lib/defaults.c
+++ b/lib/defaults.c
@@ -172,6 +172,19 @@ static int conf_update(const char *, const char *, const char *, unsigned long);
 static void conf_delete(const char *, const char *);
 static struct conf_option *conf_lookup(const char *, const char *);
 
+static void defaults_mutex_lock(void)
+{
+	int status = pthread_mutex_lock(&conf_mutex);
+	if (status)
+		fatal(status);
+}
+
+static void defaults_mutex_unlock(void)
+{
+	int status = pthread_mutex_unlock(&conf_mutex);
+	if (status)
+		fatal(status);
+}
 
 static void message(unsigned int to_syslog, const char *msg, ...)
 {
@@ -254,9 +267,9 @@ static void __conf_release(void)
 
 void defaults_conf_release(void)
 {
-	pthread_mutex_lock(&conf_mutex);
+	defaults_mutex_lock();
 	__conf_release();
-	pthread_mutex_unlock(&conf_mutex);
+	defaults_mutex_unlock();
 	return;
 }
 
@@ -728,11 +741,11 @@ static unsigned int conf_section_exists(const char *section)
 		return 0;
 
 	ret = 0;
-	pthread_mutex_lock(&conf_mutex);
+	defaults_mutex_lock();
 	co = conf_lookup(section, section);
 	if (co)
 		ret = 1;
-	pthread_mutex_unlock(&conf_mutex);
+	defaults_mutex_unlock();
 
 	return ret;
 }
@@ -1058,7 +1071,7 @@ unsigned int defaults_read_config(unsigned int to_syslog)
 
 	conf = oldconf = NULL;
 
-	pthread_mutex_lock(&conf_mutex);
+	defaults_mutex_lock();
 	if (!config) {
 		if (conf_init()) {
 			message(to_syslog, "failed to init config");
@@ -1150,7 +1163,7 @@ out:
 		fclose(conf);
 	if (oldconf)
 		fclose(oldconf);
-	pthread_mutex_unlock(&conf_mutex);
+	defaults_mutex_unlock();
 	return ret;
 }
 
@@ -1159,11 +1172,11 @@ static char *conf_get_string(const char *section, const char *name)
 	struct conf_option *co;
 	char *val = NULL;
 
-	pthread_mutex_lock(&conf_mutex);
+	defaults_mutex_lock();
 	co = conf_lookup(section, name);
 	if (co && co->value)
 		val = strdup(co->value);
-	pthread_mutex_unlock(&conf_mutex);
+	defaults_mutex_unlock();
 	return val;
 }
 
@@ -1172,11 +1185,11 @@ static long conf_get_number(const char *section, const char *name)
 	struct conf_option *co;
 	long val = -1;
 
-	pthread_mutex_lock(&conf_mutex);
+	defaults_mutex_lock();
 	co = conf_lookup(section, name);
 	if (co && co->value)
 		val = atol(co->value);
-	pthread_mutex_unlock(&conf_mutex);
+	defaults_mutex_unlock();
 	return val;
 }
 
@@ -1185,7 +1198,7 @@ static int conf_get_yesno(const char *section, const char *name)
 	struct conf_option *co;
 	int val = -1;
 
-	pthread_mutex_lock(&conf_mutex);
+	defaults_mutex_lock();
 	co = conf_lookup(section, name);
 	if (co && co->value) {
 		if (isdigit(*co->value))
@@ -1195,7 +1208,7 @@ static int conf_get_yesno(const char *section, const char *name)
 		else if (!strcasecmp(co->value, "no"))
 			val = 0;
 	}
-	pthread_mutex_unlock(&conf_mutex);
+	defaults_mutex_unlock();
 	return val;
 }
 
@@ -1272,10 +1285,10 @@ struct list_head *defaults_get_uris(void)
 		return NULL;
 	}
 
-	pthread_mutex_lock(&conf_mutex);
+	defaults_mutex_lock();
 	co = conf_lookup(autofs_gbl_sec, NAME_LDAP_URI);
 	if (!co) {
-		pthread_mutex_unlock(&conf_mutex);
+		defaults_mutex_unlock();
 		free(list);
 		return NULL;
 	}
@@ -1286,7 +1299,7 @@ struct list_head *defaults_get_uris(void)
 				add_uris(co->value, list);
 		co = co->next;
 	}
-	pthread_mutex_unlock(&conf_mutex);
+	defaults_mutex_unlock();
 
 	if (list_empty(list)) {
 		free(list);
@@ -1398,10 +1411,10 @@ struct ldap_searchdn *defaults_get_searchdns(void)
 	if (!defaults_read_config(0))
 		return NULL;
 
-	pthread_mutex_lock(&conf_mutex);
+	defaults_mutex_lock();
 	co = conf_lookup(autofs_gbl_sec, NAME_SEARCH_BASE);
 	if (!co) {
-		pthread_mutex_unlock(&conf_mutex);
+		defaults_mutex_unlock();
 		return NULL;
 	}
 
@@ -1417,7 +1430,7 @@ struct ldap_searchdn *defaults_get_searchdns(void)
 
 		new = alloc_searchdn(co->value);
 		if (!new) {
-			pthread_mutex_unlock(&conf_mutex);
+			defaults_mutex_unlock();
 			defaults_free_searchdns(sdn);
 			return NULL;
 		}
@@ -1434,7 +1447,7 @@ struct ldap_searchdn *defaults_get_searchdns(void)
 
 		co = co->next;
 	}
-	pthread_mutex_unlock(&conf_mutex);
+	defaults_mutex_unlock();
 
 	return sdn;
 }
@@ -1512,9 +1525,9 @@ int defaults_master_set(void)
 {
 	struct conf_option *co;
 
-	pthread_mutex_lock(&conf_mutex);
+	defaults_mutex_lock();
 	co = conf_lookup(autofs_gbl_sec, NAME_MASTER_MAP);
-	pthread_mutex_unlock(&conf_mutex);
+	defaults_mutex_unlock();
 	if (co)
 		return 1;
 	return 0;
