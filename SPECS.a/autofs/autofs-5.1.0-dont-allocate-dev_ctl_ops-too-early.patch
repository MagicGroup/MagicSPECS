autofs-5.1.0 - dont allocate dev_ctl_ops too early

From: Ian Kent <raven@themaw.net>

If the standard io file descriptors have been closed by the cloning
process the file handle for autofs device control can correspond to
a descriptor number of one of the standard io descriptors which will
be closed when the process is daemonized.

Avoid this by closing the device control descriptor opened when
performing sanity checks at startup so that it can be opened
on a higher numbered file descriptor after the process has switched
to daemon mode.
---
 CHANGELOG    |    1 +
 lib/mounts.c |   14 +++++++++++++-
 2 files changed, 14 insertions(+), 1 deletion(-)

diff --git a/CHANGELOG b/CHANGELOG
index 92ee83b..ece8c5c 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -2,6 +2,7 @@
 =======================
 - fix compile error in defaults.c.
 - add serialization to sasl init.
+- dont allocate dev_ctl_ops too early.
 
 04/06/2014 autofs-5.1.0
 =======================
diff --git a/lib/mounts.c b/lib/mounts.c
index c9e1237..f635371 100644
--- a/lib/mounts.c
+++ b/lib/mounts.c
@@ -90,7 +90,7 @@ unsigned int linux_version_code(void)
 
 unsigned int query_kproto_ver(void)
 {
-	struct ioctl_ops *ops = get_ioctl_ops();
+	struct ioctl_ops *ops;
 	char dir[] = "/tmp/autoXXXXXX", *t_dir;
 	char options[MAX_OPTIONS_LEN + 1];
 	pid_t pgrp = getpgrp();
@@ -131,10 +131,19 @@ unsigned int query_kproto_ver(void)
 		return 0;
 	}
 
+	ops = get_ioctl_ops();
+	if (!ops) {
+		umount(t_dir);
+		close(pipefd[0]);
+		rmdir(t_dir);
+		return 0;
+	}
+
 	ops->open(LOGOPT_NONE, &ioctlfd, st.st_dev, t_dir);
 	if (ioctlfd == -1) {
 		umount(t_dir);
 		close(pipefd[0]);
+		close_ioctl_ctl();
 		rmdir(t_dir);
 		return 0;
 	}
@@ -146,6 +155,7 @@ unsigned int query_kproto_ver(void)
 		ops->close(LOGOPT_NONE, ioctlfd);
 		umount(t_dir);
 		close(pipefd[0]);
+		close_ioctl_ctl();
 		rmdir(t_dir);
 		return 0;
 	}
@@ -155,6 +165,7 @@ unsigned int query_kproto_ver(void)
 		ops->close(LOGOPT_NONE, ioctlfd);
 		umount(t_dir);
 		close(pipefd[0]);
+		close_ioctl_ctl();
 		rmdir(t_dir);
 		return 0;
 	}
@@ -162,6 +173,7 @@ unsigned int query_kproto_ver(void)
 	ops->close(LOGOPT_NONE, ioctlfd);
 	umount(t_dir);
 	close(pipefd[0]);
+	close_ioctl_ctl();
 	rmdir(t_dir);
 
 	return 1;
